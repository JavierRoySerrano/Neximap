<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Diagram Builder (Nodes/Links/Country Boxes) ‚Üí CSV + NDG</title>
  <style>
    :root { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif; }
    body { margin: 0; background:#ffffff; color:#333; }
    header {
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      padding:0; border-bottom:1px solid #e0e0e0;
      position: sticky; top: 0; background:#fafafa; z-index: 10;
    }
    
    /* Menu Bar Items */
    .menu-item {
      background: transparent;
      border: none;
      color: #444;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 13px;
      border-radius: 4px;
    }
    .menu-item:hover { background: #e8e8e8; }
    
    /* Tool Buttons */
    .tool-btn {
      background: transparent;
      border: 1px solid transparent;
      color: #555;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 16px;
      border-radius: 4px;
      min-width: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .tool-btn:hover { background: #e8e8e8; border-color: #d0d0d0; }
    .tool-btn.active, .tool-btn.primary { background: #0096D6; color: #fff; border-color: #0096D6; }
    .tool-btn.shape-tool.active { background: #0096D6; color: #fff; }
    
    .tool-sep { width: 1px; height: 24px; background: #d0d0d0; margin: 0 6px; }
    
    /* Toggle items in menu */
    .toggle-item { display: flex; align-items: center; gap: 8px; }
    .toggle-item input { accent-color: #0096D6; }
    
    .btn {
      background:#fff; border:1px solid #d0d0d0; color:#333;
      padding:6px 10px; border-radius:6px; cursor:pointer; font-weight:500; font-size: 12px;
    }
    .btn:hover { background:#f5f5f5; border-color:#bbb; }
    .btn.primary { background:#0096D6; border-color:#0096D6; color:#fff; }
    .btn.primary:hover { background:#0080b8; }
    .mini-btn { padding:4px 8px; font-size:11px; }
    .hint { opacity:.7; font-size: 12px; color:#666; }
    input[type="file"]{ display:none; }

    #layout { display: flex; height: calc(100vh - 72px); position: relative; }
    #wrap { flex: 1; position: relative; overflow: auto; background: #f0f0f0; }
    #inspector {
      position: absolute;
      right: 20px;
      top: 20px;
      width: 340px;
      max-height: calc(100vh - 120px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 100;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      resize: horizontal;
      min-width: 280px;
      max-width: 500px;
    }
    #inspector.minimized {
      height: 40px !important;
      max-height: 40px;
      resize: none;
    }
    #inspectorHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: #f8f8f8;
      border-bottom: 1px solid #e0e0e0;
      cursor: move;
      user-select: none;
    }
    #inspectorHeader h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }
    #inspectorControls {
      display: flex;
      gap: 4px;
    }
    #inspectorControls button {
      background: transparent;
      border: 1px solid #d0d0d0;
      color: #666;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    #inspectorControls button:hover {
      background: #e8e8e8;
      border-color: #bbb;
    }
    #inspectorContent {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 12px;
      background: #fff;
    }
    #inspector.minimized #inspectorContent {
      display: none;
    }
    #inspector h3 { margin:0 0 10px; font-size:14px; color:#333; }
    #inspector .muted { opacity:.8; font-size:11px; line-height:1.4; margin-bottom:10px; color:#666; }
    #inspector .row { margin:10px 0; }
    #inspector label { display:block; font-size:11px; color:#555; margin:0 0 4px; }
    #inspector input, #inspector textarea, #inspector select {
      width:100%; box-sizing:border-box;
      padding:8px 10px; border-radius:6px; border:1px solid #d0d0d0;
      background:#fff; color:#333; font-size: 13px;
    }
    #inspector input:focus, #inspector select:focus, #inspector textarea:focus {
      outline: none;
      border-color: #0096D6;
      box-shadow: 0 0 0 2px rgba(0,150,214,0.15);
    }
    #inspector textarea { min-height: 60px; resize: vertical; }
    #inspector .inline { display:flex; gap:8px; }
    #inspector .inline > * { flex:1; }
    #inspector h4 { color:#333; margin:16px 0 8px; font-size:11px; font-weight:600; text-transform:uppercase; letter-spacing:0.5px; }
    #inspector input[type="color"] { padding:2px; height:32px; }
    #inspector input[type="checkbox"] { width:auto; accent-color:#0096D6; }
    .muted kbd { background:#f0f0f0; padding:2px 5px; border-radius:3px; font-size:10px; border:1px solid #d0d0d0; }

    svg { display:block; user-select:none; background:#fff; }
    #svgContainer { display: inline-block; }
    .grid { stroke:#e8e8e8; stroke-width:1; }

    .group-rect { rx:8; ry:8; }
    .group-selected .group-rect { 
      stroke: #0096D6 !important; 
      stroke-width: 2 !important; 
      filter: drop-shadow(0 0 3px rgba(0,150,214,0.4));
    }
    .group-label { font-weight:600; user-select:none; cursor: default; }
    .group-handle { fill:#888; opacity:.7; cursor:nwse-resize; }

    .edge { fill:none; }
    .edge.selected { stroke:#0096D6 !important; stroke-width: 3 !important; filter: drop-shadow(0 0 3px rgba(0,150,214,0.5)); }
    .edge-label {
      fill:#333;
      paint-order: stroke; stroke:#ffffff; stroke-width:3px;
      cursor: default; user-select:none;
    }

    .node { cursor: grab; }
    .node:active { cursor: grabbing; }
    .node-circle { }
    .node.selected .node-circle { 
      stroke: #0096D6 !important; 
      stroke-width: 3 !important; 
      filter: drop-shadow(0 0 4px rgba(0,150,214,0.5));
    }
    .node.link-source .node-circle {
      stroke: #ff9800 !important;
      stroke-width: 4 !important;
      filter: drop-shadow(0 0 6px rgba(255,152,0,0.6));
      animation: pulse 1s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .node-text, .tag-text { text-anchor: middle; user-select:none; cursor: default; }
    .node-text { dominant-baseline: middle; }
    .tag-text { dominant-baseline: hanging; opacity:.8; }

    .toast {
      position:absolute; right:14px; bottom:14px; background:#333; border:1px solid #222;
      color:#fff; padding:10px 16px; border-radius:8px; max-width: 520px; font-size: 13px; opacity:0;
      transform: translateY(8px); transition: all .2s ease; z-index: 20;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .toast.show { opacity:1; transform: translateY(0); }
    kbd{ padding:1px 6px; border:1px solid #d0d0d0; border-bottom-width:2px; border-radius:4px; background:#f5f5f5; font-size:11px; color:#333; }

    header { position: sticky; top: 0; }
    .menu {
      position:absolute;
      top: 28px;
      left: 0;
      background:#ffffff;
      border:1px solid #d0d0d0;
      border-radius:6px;
      padding:4px 0;
      min-width: 200px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.12);
      z-index: 30;
    }
    .menu[hidden]{ display:none; }
    .menu .item{
      display:flex; align-items:center; gap:10px;
      padding:8px 14px;
      cursor:pointer;
      user-select:none;
      font-size: 13px;
      color:#333;
    }
    .menu .item:hover{ background:#f5f5f5; }
    .menu .item.active { background:#e8f4fc; color:#0096D6; }
    .menu .sep{ height:1px; background:#e0e0e0; margin:4px 0; }

    .toggle{ display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:4px; font-size:12px; color:#555; }
    .toggle input{ accent-color:#0096D6; }

    /* Tag filter styles */
    .tag-filter-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 12px;
    }
    .tag-filter-item:hover { background: #f5f5f5; }
    .tag-filter-item input { accent-color: #0096D6; }
    .tag-filter-item .tag-name { flex: 1; }
    .tag-filter-item .tag-count { 
      color: #999; 
      font-size: 11px;
      background: #f0f0f0;
      padding: 1px 6px;
      border-radius: 10px;
    }
    #btnTagFilter.filtering { 
      background: #e8f4fc; 
      color: #0096D6;
      border-color: #0096D6;
    }

    .marquee { fill: rgba(0,150,214,0.1); stroke:#0096D6; stroke-width:1; stroke-dasharray:4 2; }
  
    /* Color Palette Picker */
    .color-picker-wrap { position: relative; }
    .color-swatch {
      width: 100%;
      height: 32px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      padding: 0 8px;
      gap: 8px;
    }
    .color-swatch:hover { border-color: #0096D6; }
    .color-swatch-preview {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.1);
    }
    .color-swatch-label { font-size: 11px; color: #666; }
    .color-palette {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #fff;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      padding: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 50;
      display: none;
    }
    .color-palette.show { display: block; }
    .color-palette-row {
      display: flex;
      gap: 4px;
      margin-bottom: 4px;
    }
    .color-palette-row:last-child { margin-bottom: 0; }
    .color-palette-item {
      width: 24px;
      height: 24px;
      border-radius: 3px;
      cursor: pointer;
      border: 1px solid rgba(0,0,0,0.1);
      transition: transform 0.1s;
    }
    .color-palette-item:hover { transform: scale(1.15); border-color: #0096D6; }
    .color-palette-item.selected { outline: 2px solid #0096D6; outline-offset: 1px; }
    .color-palette-custom {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e0e0e0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .color-palette-custom input[type="color"] {
      width: 32px;
      height: 24px;
      padding: 0;
      border: 1px solid #d0d0d0;
      border-radius: 3px;
      cursor: pointer;
    }
    .color-palette-custom span { font-size: 11px; color: #666; }

    .shape-bar{ display:flex; gap:4px; align-items:center; padding:4px 6px; border:1px solid #d0d0d0; border-radius:6px; background:#fff; }
    .shape-btn{ 
      background:transparent; 
      border:1px solid transparent; 
      color:#555; 
      padding:6px 10px; 
      border-radius:4px; 
      cursor:pointer; 
      font-size:14px;
      min-width:36px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .shape-btn:hover{ background:#f0f0f0; }
    .shape-btn.active{ background:#0096D6; border-color:#0096D6; color:#fff; }

  
    @media print{
      body{ background:#ffffff !important; color:#000000 !important; }
      header, .toast{ display:none !important; }
      svg{ background:#ffffff !important; }
      .edge{ stroke:#000000 !important; }
      .edge-label, .node-label, .group-title{ fill:#000000 !important; }
      .node-circle{ stroke:#000000 !important; fill:#ffffff !important; }
      .group-rect{ stroke:#000000 !important; fill:rgba(0,0,0,0.04) !important; }
    }
  </style>
</head>
<body>

<header style="background:#fafafa; border-bottom:1px solid #e0e0e0;">
  <!-- Menu Bar (text menus) -->
  <div style="display:flex; align-items:center; gap:0; padding:4px 12px; background:#fff; border-bottom:1px solid #e8e8e8;">
    <span style="font-weight:600; color:#7b5eac; font-size:15px; margin-right:16px;">‚¨° Diagram Builder</span>
    <button class="menu-item" id="btnFile" type="button">File</button>
    <button class="menu-item" id="btnEditMenu" type="button">Edit</button>
    <button class="menu-item" id="btnViewMenu" type="button">View</button>
    <div class="menu" id="fileMenu" hidden>
      <div class="item" id="miSave">Save <span style="opacity:0.5;float:right">Ctrl+S</span></div>
      <div class="item" id="miSaveAs">Save As‚Ä¶</div>
      <div class="sep"></div>
      <div class="item" id="miOpen">Open‚Ä¶ <span style="opacity:0.5;float:right">Ctrl+O</span></div>
      <div class="sep"></div>
      <div class="item" id="miRecover">Recover Autosave</div>
      <div class="item" id="miClearAutosave">Clear Autosave</div>
      <div class="sep"></div>
      <div class="item" id="miClearDiagram">Clear Diagram</div>
      <div class="sep"></div>
      <div class="item" id="miExportSVG">Export as SVG‚Ä¶</div>
      <div class="item" id="miExportPNG">Export as PNG‚Ä¶</div>
      <div class="item" id="miExportJPG">Export as JPG‚Ä¶</div>
      <div class="sep"></div>
      <div class="item" id="btnExportLinks">Export Links CSV</div>
      <div class="item" id="btnExportNodes">Export Nodes CSV</div>
    </div>
    <div class="menu" id="editMenu" hidden>
      <div class="item" id="miUndo">Undo <span style="opacity:0.5;float:right">Ctrl+Z</span></div>
      <div class="item" id="miRedo">Redo <span style="opacity:0.5;float:right">Ctrl+Shift+Z</span></div>
      <div class="sep"></div>
      <div class="item" id="miCopy">Copy <span style="opacity:0.5;float:right">Ctrl+C</span></div>
      <div class="item" id="miCut">Cut <span style="opacity:0.5;float:right">Ctrl+X</span></div>
      <div class="item" id="miPaste">Paste <span style="opacity:0.5;float:right">Ctrl+V</span></div>
      <div class="sep"></div>
      <div class="item" id="miDelete">Delete <span style="opacity:0.5;float:right">Del</span></div>
    </div>
    <div class="menu" id="viewMenu" hidden>
      <div class="item" id="miZoomIn">Zoom In <span style="opacity:0.5;float:right">Ctrl++</span></div>
      <div class="item" id="miZoomOut">Zoom Out <span style="opacity:0.5;float:right">Ctrl+-</span></div>
      <div class="item" id="miFitView">Fit to View</div>
      <div class="sep"></div>
      <div class="item" id="miToggleInspector">Toggle Inspector <span style="opacity:0.5;float:right">I</span></div>
      <div class="item" id="miTagFilter">Tag Filter‚Ä¶ <span style="opacity:0.5;float:right">F</span></div>
      <div class="sep"></div>
      <label class="item toggle-item"><input type="checkbox" id="tglShowLatency" checked /> Show Latency</label>
      <label class="item toggle-item"><input type="checkbox" id="tglShowNodeCode" checked /> Show Node Codes</label>
      <label class="item toggle-item"><input type="checkbox" id="tglShowLinkCode" checked /> Show Link Codes</label>
      <label class="item toggle-item"><input type="checkbox" id="tglShowNodeTags" /> Show Node Tags</label>
      <label class="item toggle-item"><input type="checkbox" id="tglShowExtraTags" /> Show Additional Tags</label>
    </div>
    <input type="file" id="fileLoad" accept=".ndg,application/json" style="display:none;" />
  </div>
  
  <!-- Icon Toolbar -->
  <div style="display:flex; align-items:center; gap:2px; padding:4px 12px; background:#fafafa;">
    <!-- Zoom Controls -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnZoomLevel" type="button" style="min-width:60px; font-size:12px; gap:4px;" title="Click for zoom options">
        <span id="zoomLevel">100%</span> <span style="font-size:10px;">‚ñæ</span>
      </button>
      <div class="menu" id="zoomMenu" hidden style="min-width:180px;">
        <div class="item" id="zoomFitView">Fit to View <span style="opacity:0.5;float:right">Enter</span></div>
        <div class="sep"></div>
        <div class="item zoom-preset" data-zoom="0.25">25%</div>
        <div class="item zoom-preset" data-zoom="0.50">50%</div>
        <div class="item zoom-preset" data-zoom="0.75">75%</div>
        <div class="item zoom-preset" data-zoom="1.00">100%</div>
        <div class="item zoom-preset" data-zoom="1.25">125%</div>
        <div class="item zoom-preset" data-zoom="1.50">150%</div>
        <div class="item zoom-preset" data-zoom="2.00">200%</div>
        <div class="item zoom-preset" data-zoom="3.00">300%</div>
        <div class="item zoom-preset" data-zoom="4.00">400%</div>
        <div class="sep"></div>
        <div class="item" id="zoomReset">Reset to 100% <span style="opacity:0.5;float:right">Ctrl+0</span></div>
      </div>
    </div>
    <button class="tool-btn" id="btnZoomIn" type="button" title="Zoom In">‚äï</button>
    <button class="tool-btn" id="btnZoomOut" type="button" title="Zoom Out">‚äñ</button>
    <button class="tool-btn" id="btnZoomFit" type="button" title="Fit to View">‚ä°</button>
    <div style="position:relative;">
      <button class="tool-btn" id="btnGridToggle" type="button" title="Toggle Grid">‚ñ¶</button>
      <div class="menu" id="gridMenu" hidden style="min-width:150px;">
        <label class="item toggle-item"><input type="checkbox" id="gridEnabled" checked /> Show Grid</label>
        <div class="sep"></div>
        <div class="item grid-size" data-size="10">Fine (10px)</div>
        <div class="item grid-size" data-size="20">Small (20px)</div>
        <div class="item grid-size active" data-size="40">Medium (40px)</div>
        <div class="item grid-size" data-size="60">Large (60px)</div>
        <div class="item grid-size" data-size="100">Extra Large (100px)</div>
      </div>
    </div>
    
    <div class="tool-sep"></div>
    
    <!-- Undo/Redo -->
    <button class="tool-btn" id="btnUndo" type="button" title="Undo (Ctrl+Z)">‚Ü∂</button>
    <button class="tool-btn" id="btnRedo" type="button" title="Redo (Ctrl+Shift+Z)">‚Ü∑</button>
    
    <div class="tool-sep"></div>
    
    <!-- Delete -->
    <button class="tool-btn" id="btnDelete" type="button" title="Delete Selected">‚å´</button>
    
    <div class="tool-sep"></div>
    
    <!-- Containers -->
    <button class="tool-btn" id="btnAddGroup" type="button" title="Add Country/Organization Box">‚ñ¢</button>
    <button class="tool-btn" id="btnAddRegion" type="button" title="Add Region Container">‚äû</button>
    
    <div class="tool-sep"></div>
    
    <!-- Shape Tools -->
    <button class="tool-btn shape-tool active" data-shape="circle" type="button" title="Circle">‚óã</button>
    <button class="tool-btn shape-tool" data-shape="square" type="button" title="Square">‚ñ°</button>
    <button class="tool-btn shape-tool" data-shape="triangle" type="button" title="Triangle">‚ñ≥</button>
    <button class="tool-btn shape-tool" data-shape="rectangle" type="button" title="Rectangle">‚ñ≠</button>
    <button class="tool-btn shape-tool" data-shape="ellipse" type="button" title="Ellipse">‚¨≠</button>
    <button class="tool-btn shape-tool" data-shape="hexagon" type="button" title="Hexagon">‚éî</button>
    
    <div class="tool-sep"></div>
    
    <!-- Link Tool -->
    <button class="tool-btn" id="btnCreateLink" type="button" title="Create Link (click two nodes)">‚Üó</button>
    
    <div class="tool-sep"></div>
    
    <!-- Brush (Format Painter) -->
    <button class="tool-btn" id="btnBrush" type="button" title="Brush - Copy and apply formatting">‚åò</button>
    
    <div class="tool-sep"></div>
    
    <!-- Tag Filter -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnTagFilter" type="button" title="Filter by Tags">üè∑</button>
      <div class="menu" id="tagFilterMenu" hidden style="min-width:220px; max-height:400px; overflow-y:auto;">
        <div style="padding:8px 12px; font-weight:600; border-bottom:1px solid #e0e0e0;">Filter by Tags</div>
        <label class="item toggle-item"><input type="radio" name="filterMode" value="all" checked /> Show All (no filter)</label>
        <label class="item toggle-item"><input type="radio" name="filterMode" value="include" /> Show only selected tags</label>
        <label class="item toggle-item"><input type="radio" name="filterMode" value="exclude" /> Hide selected tags</label>
        <div class="sep"></div>
        <div style="padding:4px 12px; font-size:11px; color:#666;">Tags:</div>
        <div id="tagFilterList" style="max-height:200px; overflow-y:auto;"></div>
        <div class="sep"></div>
        <div style="display:flex; gap:8px; padding:8px 12px;">
          <button class="mini-btn" id="btnTagSelectAll" type="button">Select All</button>
          <button class="mini-btn" id="btnTagClearAll" type="button">Clear All</button>
        </div>
      </div>
    </div>
    
    <div class="tool-sep"></div>
    
    <!-- Inspector Toggle -->
    <button class="tool-btn" id="btnToggleInspector" type="button" title="Toggle Inspector (I)">‚ò∞</button>
    
    <div style="flex:1;"></div>
    
    <!-- Compact Help -->
    <span style="font-size:10px; color:#888; padding:0 8px;">
      Dbl-click: add node ‚Ä¢ Alt+drag: select ‚Ä¢ Drag: pan ‚Ä¢ Ctrl+wheel: zoom
    </span>
  </div>
</header>


<div id="layout">
  <div id="wrap">
    <div id="svgContainer" style="transform-origin: 0 0;">
      <svg id="svg" viewBox="0 0 1600 900" preserveAspectRatio="none"></svg>
    </div>
    <div class="toast" id="toast"></div>
  </div>

  <aside id="inspector">
    <div id="inspectorHeader">
      <h3>Inspector</h3>
      <div id="inspectorControls">
        <button id="btnMinimizeInspector" title="Minimize/Maximize">‚àí</button>
        <button id="btnCloseInspector" title="Hide Inspector">‚úï</button>
      </div>
    </div>
    <div id="inspectorContent">
      <div class="muted" id="inspectorHelp">
        Select a node, link, or country box to edit it. Use Delete/Backspace to remove selected.
        <br/>Move any label only with <kbd>Ctrl</kbd>+drag (so normal dragging moves nodes/boxes).
      </div>

      <div id="canvasSettings">
        <h4 style="margin: 12px 0 10px; font-size: 13px; opacity: 0.9;">Canvas Settings</h4>
        <div class="row inline">
          <div>
            <label>Canvas Width</label>
            <input id="canvasWidth" type="number" min="400" step="100" />
        </div>
        <div>
          <label>Canvas Height</label>
          <input id="canvasHeight" type="number" min="300" step="100" />
        </div>
      </div>
      <label class="toggle"><input type="checkbox" id="tglCanvasBorder" checked />Show Canvas Border</label>
      <div class="muted" style="margin-top: 8px;">Drag objects beyond the border to expand the workspace.</div>
    </div>

    <div id="noSelection" class="muted">Nothing selected.</div>

<div id="nodeInspector" style="display:none;">
  <div class="row">
    <label>Unique ID</label>
    <input id="nodeUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:11px;" />
  </div>

  <div class="row">
    <label>Node Style Preset</label>
    <div class="inline">
      <select id="nodePreset"></select>
      <button class="mini-btn" id="btnNodePresetSave">Save</button>
      <button class="mini-btn" id="btnNodePresetApply">Apply</button>
      <button class="mini-btn" id="btnNodePresetDelete">Delete</button>
    </div>
  </div>

  <div class="row">
    <label>Node Name (label)</label>
    <input id="nodeName" />
  </div>
  <div class="row">
    <label>Node Tag(s) (comma-separated)</label>
    <textarea id="nodeTags"></textarea>
  </div>
  <div class="row">
    <label>Additional Tags (free text)</label>
    <input id="nodeExtraTags" placeholder="e.g. role=core, owner=teamA" />
  </div>

  <div class="row inline">
    <div>
      <label>Node Code</label>
      <input id="nodeCode" placeholder="e.g. N-001" />
    </div>
    <div>
      <label>Show Code</label>
      <select id="nodeShowCode">
        <option value="1">Yes</option>
        <option value="0">No</option>
      </select>
    </div>
  </div>

  <div class="row">
    <label>Address</label>
    <input id="nodeAddress" placeholder="e.g. 123 Main Street" />
  </div>

  <div class="row inline">
    <div>
      <label>City</label>
      <input id="nodeCity" placeholder="e.g. New York" />
    </div>
    <div>
      <label>Country</label>
      <input id="nodeCountry" placeholder="e.g. USA" />
    </div>
  </div>

  <div class="row inline">
    <div>
      <label>Name Font</label>
      <input id="nodeNameFont" type="number" min="6" max="72" step="1" />
    </div>
    <div>
      <label>Tags Font</label>
      <input id="nodeTagFont" type="number" min="6" max="72" step="1" />
    </div>
  </div>

  <div class="row inline">
    <div>
      <label>Name Color</label>
      <input id="nodeNameColor" type="color" />
    </div>
    <div>
      <label>Tags Color</label>
      <input id="nodeTagColor" type="color" />
    </div>
  </div>

  <div class="row inline">
    <div>
      <label>Node Fill</label>
      <input id="nodeFill" type="color" />
    </div>
    <div>
      <label>Node Stroke</label>
      <input id="nodeStroke" type="color" />
    </div>
  </div>

  <div class="row">
    <label>Line Width</label>
    <input id="nodeStrokeW" type="number" min="0.5" max="12" step="0.5" />
  </div>

  <div class="row">
    <label>Node Size</label>
    <input id="nodeSize" type="number" min="10" max="80" step="1" />
  </div>

  <div class="row">
    <label>Assigned Country Box (auto if inside)</label>
    <input id="nodeGroup" disabled />
  </div>
</div>

    <div id="edgeInspector" style="display:none;">
      <div class="row">
        <label>Unique ID</label>
        <input id="edgeUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:11px;" />
      </div>
      
      <div class="row inline">
        <div>
          <label>Source Node UUID</label>
          <input id="edgeSourceUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:10px;" />
        </div>
        <div>
          <label>Target Node UUID</label>
          <input id="edgeTargetUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:10px;" />
        </div>
      </div>

      <div class="row">
        <label>Link Style Preset</label>
        <div class="inline">
          <select id="edgePreset"></select>
          <button class="mini-btn" id="btnEdgePresetSave">Save</button>
          <button class="mini-btn" id="btnEdgePresetApply">Apply</button>
          <button class="mini-btn" id="btnEdgePresetDelete">Delete</button>
        </div>
      </div>

      <div class="row">
        <label>Link Tag</label>
        <input id="edgeTag" />
      </div>
      
      <div class="row">
        <label>Filter Tags (comma-separated)</label>
        <textarea id="edgeFilterTags" placeholder="default, onnet, Asia" style="height:40px;"></textarea>
      </div>

      <div class="row">
        <label>Latency value (ms)</label>
        <input id="edgeLatency" type="text" inputmode="decimal" placeholder="e.g. 1.234" />
        <div class="muted">This field only accepts a number. The diagram shows it as ‚ÄúX ms‚Äù.</div>
      </div>
      
      <div class="row">
        <label>Capacity Options</label>
        <input id="edgeCapacity" placeholder="e.g. Up to 100G" />
      </div>
      
      <div class="row">
        <label>Additional Tags (free text)</label>
        <input id="edgeExtraTags" placeholder="e.g. provider=ISP1, circuit=ABC123" />
      </div>

      <div class="row inline">
        <div>
          <label>Link Code</label>
          <input id="edgeCode" placeholder="e.g. L-010" />
        </div>
        <div>
          <label>Show Code</label>
          <select id="edgeShowCode">
            <option value="1">Yes</option>
            <option value="0">No</option>
          </select>
        </div>
      </div>

      <div class="row inline">
        <div>
          <label>Label Font</label>
          <input id="edgeLabelFont" type="number" min="6" max="72" step="1" />
        </div>
        <div>
          <label>Label Color</label>
          <input id="edgeLabelColor" type="color" />
        </div>
      </div>

      <div class="row inline">
        <div>
          <label>Style</label>
          <select id="edgeStyle">
            <option value="straight">Straight</option>
            <option value="orthogonal">90¬∞ Orthogonal</option>
            <option value="curve">Curve (Bezier)</option>
          </select>
        </div>
        <div>
          <label>Routing</label>
          <select id="edgeRoute">
            <option value="hv">Horizontal then Vertical</option>
            <option value="vh">Vertical then Horizontal</option>
          </select>
        </div>
      </div>

      <div class="row" id="curveArchControl" style="display:none;">
         <label>Curve Bend (drag handle on curve or adjust slider)</label>
         <input id="edgeCurveArch" type="range" min="-0.6" max="0.6" step="0.05" />
         <span id="curveArchValue">0.30</span>
      </div>

      <div class="row">
         <label>Line Width</label>
  	 <input id="edgeStrokeW" type="number" min="0.5" max="12" step="0.5" />
      </div>

      <div class="row">
         <label>Line Color</label>
         <input id="edgeStrokeColor" type="color" />
      </div>
    </div>
     
    <div id="groupInspector" style="display:none;">
      <div class="row">
        <label>Unique ID</label>
        <input id="groupUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:11px;" />
      </div>

      <div class="row">
        <label>Box Style Preset</label>
        <div class="inline">
          <select id="groupPreset"></select>
          <button class="mini-btn" id="btnGroupPresetSave">Save</button>
          <button class="mini-btn" id="btnGroupPresetApply">Apply</button>
          <button class="mini-btn" id="btnGroupPresetDelete">Delete</button>
        </div>
      </div>

      <div class="row">
        <label>Box Title</label>
        <input id="groupTitle" />
      </div>
      
      <div class="row">
        <label>Filter Tags (comma-separated)</label>
        <textarea id="groupFilterTags" placeholder="default, APAC, production" style="height:40px;"></textarea>
      </div>

      <div class="row inline">
        <div>
          <label>Box Type</label>
          <select id="groupType">
            <option value="country">Country</option>
            <option value="region">Region</option>
          </select>
        </div>
        <div>
          <label>Parent Region</label>
          <select id="groupParent"></select>
        </div>
      </div>

      <div class="row">
        <label>Additional Tags (free text)</label>
        <input id="groupExtraTags" placeholder="e.g. region=APAC" />
      </div>

      <div class="row inline">
        <div>
          <label>Title Font</label>
          <input id="groupTitleFont" type="number" min="6" max="72" step="1" />
        </div>
        <div>
          <label>Title Color</label>
          <input id="groupTitleColor" type="color" />
        </div>
      </div>

      <div class="row inline">
        <div>
          <label>Box Fill (CSS color)</label>
          <input id="groupFill" type="text" placeholder="e.g. rgba(54,76,140,0.12) or #112233" />
        </div>
        <div>
          <label>Box Stroke</label>
          <input id="groupStroke" type="color" />
        </div>
      </div>

      <div class="row inline">
        <div>
          <label>Width</label>
          <input id="groupW" type="number" min="120" />
        </div>
        <div>
          <label>Height</label>
          <input id="groupH" type="number" min="90" />
        </div>
      </div>

      <div class="row">
  	 <label>Border Width</label>
  	 <input id="groupStrokeW" type="number" min="0.5" max="12" step="0.5" />
      </div>
    </div>
    </div><!-- end inspectorContent -->
  </aside>
</div>

<script>
(() => {
  const svg = document.getElementById('svg');
  const toastEl = document.getElementById('toast');

  // UUID generation for unique identifiers
  function generateUUID() {
    // Use crypto.randomUUID if available (modern browsers), fallback to manual generation
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    // Fallback UUID v4 generation
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  // Color Palette System
  const colorPalette = {
    // Row 1: White, Light grays, Soft colors
    row1: ['#ffffff', '#f5f5f5', '#e8e8e8', '#dae8fc', '#d5e8d4', '#fff2cc', '#f8cecc', '#e1d5e7'],
    // Row 2: Pastel colors
    row2: ['#eeeeee', '#dae8fc', '#d5e8d4', '#fff2cc', '#f8cecc', '#e1d5e7', '#fce5cd', '#cce5ff'],
    // Row 3: Medium colors  
    row3: ['#b3b3b3', '#6c8ebf', '#82b366', '#d6b656', '#b85450', '#9673a6', '#d79b00', '#36a2eb'],
    // Row 4: Darker/saturated colors
    row4: ['#666666', '#1a5276', '#196f3d', '#b7950b', '#922b21', '#6c3483', '#a04000', '#1f618d']
  };

  function createColorPicker(inputElement, onChange) {
    const wrapper = document.createElement('div');
    wrapper.className = 'color-picker-wrap';
    
    const swatch = document.createElement('div');
    swatch.className = 'color-swatch';
    
    const preview = document.createElement('div');
    preview.className = 'color-swatch-preview';
    preview.style.backgroundColor = inputElement.value || '#ffffff';
    
    const label = document.createElement('span');
    label.className = 'color-swatch-label';
    label.textContent = inputElement.value || '#ffffff';
    
    swatch.appendChild(preview);
    swatch.appendChild(label);
    
    const palette = document.createElement('div');
    palette.className = 'color-palette';
    
    // Add color rows
    [colorPalette.row1, colorPalette.row2, colorPalette.row3, colorPalette.row4].forEach(row => {
      const rowDiv = document.createElement('div');
      rowDiv.className = 'color-palette-row';
      row.forEach(color => {
        const item = document.createElement('div');
        item.className = 'color-palette-item';
        item.style.backgroundColor = color;
        item.dataset.color = color;
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          selectColor(color);
        });
        rowDiv.appendChild(item);
      });
      palette.appendChild(rowDiv);
    });
    
    // Custom color picker
    const customDiv = document.createElement('div');
    customDiv.className = 'color-palette-custom';
    const customInput = document.createElement('input');
    customInput.type = 'color';
    customInput.value = inputElement.value || '#ffffff';
    customInput.addEventListener('input', (e) => {
      selectColor(e.target.value);
    });
    const customLabel = document.createElement('span');
    customLabel.textContent = 'Custom color';
    customDiv.appendChild(customInput);
    customDiv.appendChild(customLabel);
    palette.appendChild(customDiv);
    
    wrapper.appendChild(swatch);
    wrapper.appendChild(palette);
    
    // Replace original input
    inputElement.style.display = 'none';
    inputElement.parentNode.insertBefore(wrapper, inputElement);
    
    function selectColor(color) {
      inputElement.value = color;
      preview.style.backgroundColor = color;
      label.textContent = color;
      customInput.value = color;
      palette.classList.remove('show');
      if (onChange) onChange(color);
      // Trigger change event on original input
      inputElement.dispatchEvent(new Event('input', { bubbles: true }));
    }
    
    function updateFromInput() {
      const color = inputElement.value || '#ffffff';
      preview.style.backgroundColor = color;
      label.textContent = color;
      customInput.value = color;
    }
    
    swatch.addEventListener('click', (e) => {
      e.stopPropagation();
      // Close other palettes
      document.querySelectorAll('.color-palette.show').forEach(p => {
        if (p !== palette) p.classList.remove('show');
      });
      palette.classList.toggle('show');
    });
    
    // Close palette when clicking outside
    document.addEventListener('click', () => {
      palette.classList.remove('show');
    });
    
    palette.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    return { update: updateFromInput };
  }

  // Global visibility toggles
  const tglShowLatency = document.getElementById('tglShowLatency');
  const tglShowNodeCode = document.getElementById('tglShowNodeCode');
  const tglShowLinkCode = document.getElementById('tglShowLinkCode');
  const tglShowNodeTags = document.getElementById('tglShowNodeTags');
  const tglShowExtraTags = document.getElementById('tglShowExtraTags');
  const canvasWidth = document.getElementById('canvasWidth');
  const canvasHeight = document.getElementById('canvasHeight');
  const tglCanvasBorder = document.getElementById('tglCanvasBorder');

  function syncGlobalToggles() {
    if (tglShowLatency) tglShowLatency.checked = !!state.ui.showLatency;
    if (tglShowNodeCode) tglShowNodeCode.checked = !!state.ui.showNodeCode;
    if (tglShowLinkCode) tglShowLinkCode.checked = !!state.ui.showLinkCode;
    if (tglShowNodeTags) tglShowNodeTags.checked = !!state.ui.showNodeTags;
    if (tglShowExtraTags) tglShowExtraTags.checked = !!state.ui.showExtraTags;
    if (canvasWidth) canvasWidth.value = state.canvasWidth;
    if (canvasHeight) canvasHeight.value = state.canvasHeight;
    if (tglCanvasBorder) tglCanvasBorder.checked = !!state.showCanvasBorder;
  }

  [tglShowLatency, tglShowNodeCode, tglShowLinkCode, tglShowNodeTags, tglShowExtraTags].forEach(el => {
    if (!el) return;
    el.addEventListener('change', () => {
      state.ui.showLatency = !!tglShowLatency?.checked;
      state.ui.showNodeCode = !!tglShowNodeCode?.checked;
      state.ui.showLinkCode = !!tglShowLinkCode?.checked;
      state.ui.showNodeTags = !!tglShowNodeTags?.checked;
      state.ui.showExtraTags = !!tglShowExtraTags?.checked;
      render();
    });
  });

  if (canvasWidth) {
    canvasWidth.addEventListener('input', () => {
      const val = parseInt(canvasWidth.value, 10);
      if (val >= 400) {
        state.canvasWidth = val;
        svg.setAttribute('viewBox', `0 0 ${state.canvasWidth} ${state.canvasHeight}`);
        render();
      }
    });
  }

  if (canvasHeight) {
    canvasHeight.addEventListener('input', () => {
      const val = parseInt(canvasHeight.value, 10);
      if (val >= 300) {
        state.canvasHeight = val;
        svg.setAttribute('viewBox', `0 0 ${state.canvasWidth} ${state.canvasHeight}`);
        render();
      }
    });
  }

  if (tglCanvasBorder) {
    tglCanvasBorder.addEventListener('change', () => {
      state.showCanvasBorder = !!tglCanvasBorder.checked;
      render();
    });
  }




  const state = {
    nodes: [],
    edges: [],
    groups: [],
    nextNode: 1,
    nextEdge: 1,
    nextGroup: 1,
    selected: null,
    connectFrom: null,
    dragging: null,
    resizingGroup: null,
    placingGroup: false,
    defaultNodeShape: 'circle',
    placingGroupType: 'country',

    // Canvas dimensions (now customizable)
    canvasWidth: 1600,
    canvasHeight: 900,
    showCanvasBorder: true,

    // Grid settings
    gridEnabled: true,
    gridSize: 40,

    // Tag filter settings
    tagFilter: {
      mode: 'all',  // 'all', 'include', 'exclude'
      selectedTags: new Set()
    },

    // Zoom level (CSS transform based)
    zoom: 1,

    // UI/global toggles
    ui: { showLatency: true, showNodeCode: true, showLinkCode: true, showNodeTags: false, showExtraTags: false },

    // Named style presets (saved inside .ndg)
    stylePresets: { node: {}, edge: {}, group: {} },

    // Format painter (session-only)
    styleBrush: null,

    // Multi-selection (ids)
    selection: { nodes: new Set(), edges: new Set(), groups: new Set() },
    marquee: null,
    lastMouse: { x: 0, y: 0 }
  };

  const history = { stack: [], index: -1, max: 120 };
  let dirty = false;

  // Pan and Zoom functionality using CSS transform and scrollbars
  function updateViewBox() {
    // Keep the viewBox matching canvas dimensions
    svg.setAttribute('viewBox', `0 0 ${state.canvasWidth} ${state.canvasHeight}`);
    
    // Update SVG size and container transform for zoom
    const svgContainer = document.getElementById('svgContainer');
    const scaledWidth = state.canvasWidth * state.zoom;
    const scaledHeight = state.canvasHeight * state.zoom;
    
    svg.setAttribute('width', scaledWidth);
    svg.setAttribute('height', scaledHeight);
    
    // Update zoom level display
    const zoomPct = Math.round(state.zoom * 100);
    const zoomLevelEl = document.getElementById('zoomLevel');
    if (zoomLevelEl) zoomLevelEl.textContent = `${zoomPct}%`;
  }

  function setZoom(newZoom, centerOnMouse = false, mouseX = 0, mouseY = 0) {
    newZoom = Math.max(0.1, Math.min(5, newZoom)); // Clamp between 10% and 500%
    
    const wrap = document.getElementById('wrap');
    const oldZoom = state.zoom;
    
    if (centerOnMouse && wrap) {
      // Calculate the point under the mouse in canvas coordinates before zoom
      const scrollLeft = wrap.scrollLeft;
      const scrollTop = wrap.scrollTop;
      const pointX = (scrollLeft + mouseX) / oldZoom;
      const pointY = (scrollTop + mouseY) / oldZoom;
      
      state.zoom = newZoom;
      updateViewBox();
      
      // After zoom, scroll to keep the same point under the mouse
      wrap.scrollLeft = pointX * newZoom - mouseX;
      wrap.scrollTop = pointY * newZoom - mouseY;
    } else {
      state.zoom = newZoom;
      updateViewBox();
    }
  }

  function fitToView() {
    if (state.nodes.length === 0 && state.groups.length === 0) {
      // Nothing to fit - reset to 100%
      state.zoom = 1;
      updateViewBox();
      const wrap = document.getElementById('wrap');
      if (wrap) {
        wrap.scrollLeft = 0;
        wrap.scrollTop = 0;
      }
      return;
    }

    // Calculate bounding box of all content
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    state.nodes.forEach(n => {
      const r = n.r || 24;
      minX = Math.min(minX, n.x - r - 50);
      minY = Math.min(minY, n.y - r - 50);
      maxX = Math.max(maxX, n.x + r + 50);
      maxY = Math.max(maxY, n.y + r + 50);
    });
    
    state.groups.forEach(g => {
      minX = Math.min(minX, g.x - 20);
      minY = Math.min(minY, g.y - 20);
      maxX = Math.max(maxX, g.x + g.w + 20);
      maxY = Math.max(maxY, g.y + g.h + 20);
    });

    const contentWidth = maxX - minX;
    const contentHeight = maxY - minY;
    
    const wrap = document.getElementById('wrap');
    const wrapWidth = wrap.clientWidth;
    const wrapHeight = wrap.clientHeight;
    
    const scaleX = wrapWidth / contentWidth;
    const scaleY = wrapHeight / contentHeight;
    const scale = Math.min(scaleX, scaleY) * 0.9; // 90% to add padding
    
    state.zoom = Math.max(0.1, Math.min(5, scale));
    updateViewBox();
    
    // Scroll to show the content
    if (wrap) {
      wrap.scrollLeft = minX * state.zoom;
      wrap.scrollTop = minY * state.zoom;
    }
  }

  // In-app clipboard (for copy/paste)
  let clipboard = null; // { nodes:[], groups:[], edges:[], bbox:{minX,minY} }

  function selectionToClipboard() {
    const nodeIds = new Set(state.selection.nodes);
    const groupIds = new Set(state.selection.groups);

    // Include edges where both endpoints are selected (plus any explicitly selected)
    const edgeIds = new Set(state.selection.edges);
    state.edges.forEach(e => { if (nodeIds.has(e.a) && nodeIds.has(e.b)) edgeIds.add(e.id); });

    const nodes = state.nodes.filter(n => nodeIds.has(n.id)).map(n => ({...n}));
    const groups = state.groups.filter(g => groupIds.has(g.id)).map(g => ({...g}));
    const edges = state.edges.filter(e => edgeIds.has(e.id)).map(e => ({...e}));

    if (nodes.length===0 && groups.length===0 && edges.length===0) return null;

    // bbox of nodes + groups (for paste offset)
    const xs = [], ys = [];
    nodes.forEach(n => { xs.push(n.x); ys.push(n.y); });
    groups.forEach(g => { xs.push(g.x, g.x+g.w); ys.push(g.y, g.y+g.h); });
    const minX = xs.length ? Math.min(...xs) : 0;
    const minY = ys.length ? Math.min(...ys) : 0;

    return { nodes, groups, edges, bbox: { minX, minY } };
  }

  function copySelection() {
    const clip = selectionToClipboard();
    if (!clip) { showToast('Nothing selected to copy.'); return; }
    clipboard = clip;
    showToast(`Copied ${clip.nodes.length} node(s), ${clip.edges.length} link(s), ${clip.groups.length} box(es).`);
  }

  function cutSelection() {
    copySelection();
    // If nothing copied, don't delete.
    if (!clipboard) return;
    deleteSelection();
  }

  function pasteSelection() {
    if (!clipboard) { showToast('Clipboard is empty.'); return; }

    const offset = 24;
    const targetX = state.lastMouse?.x ?? 200;
    const targetY = state.lastMouse?.y ?? 200;

    // Paste near last mouse position (or just offset)
    const dx = (targetX - clipboard.bbox.minX) + offset;
    const dy = (targetY - clipboard.bbox.minY) + offset;

    const nodeIdMap = new Map();
    const groupIdMap = new Map();

    // Duplicate groups first (so nodes can reference them)
    const newGroupIds = [];
    for (const g of clipboard.groups) {
      const id = state.nextGroup++;
      const ng = { ...g, id, x: g.x + dx, y: g.y + dy };
      // remap parentId if parent was also copied
      if (ng.parentId && groupIdMap.has(ng.parentId)) ng.parentId = groupIdMap.get(ng.parentId);
      state.groups.push(ng);
      groupIdMap.set(g.id, id);
      newGroupIds.push(id);
    }

    const newNodeIds = [];
    for (const n of clipboard.nodes) {
      const id = state.nextNode++;
      const nn = { ...n, id, x: n.x + dx, y: n.y + dy };
      if (nn.groupId && groupIdMap.has(nn.groupId)) nn.groupId = groupIdMap.get(nn.groupId);
      state.nodes.push(nn);
      nodeIdMap.set(n.id, id);
      newNodeIds.push(id);
    }

    const newEdgeIds = [];
    for (const e of clipboard.edges) {
      // only recreate edges whose endpoints were included in clipboard (typical copy behavior)
      if (!nodeIdMap.has(e.a) || !nodeIdMap.has(e.b)) continue;
      const id = state.nextEdge++;
      const ne = { ...e, id, a: nodeIdMap.get(e.a), b: nodeIdMap.get(e.b) };
      state.edges.push(ne);
      newEdgeIds.push(id);
    }

    refreshAllMemberships();
    commit();

    setMultiSelection({ nodes: newNodeIds, edges: newEdgeIds, groups: newGroupIds });
    render();
    showToast('Pasted selection.');
  }

  function cloneSelectionForDrag() {
    const clip = selectionToClipboard();
    if (!clip) return false;
    clipboard = clip;
    pasteSelection();
    return true;
  }



  const showToast = (msg) => {
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toastEl.classList.remove('show'), 2400);
  };

  // Ribbon tabs (File/Home). This does not change any existing handlers.
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  // Node shape tool (sets default for NEW nodes only)
  const shapeButtons = document.querySelectorAll('.shape-tool');
  function setActiveShape(shape){
    state.defaultNodeShape = shape;
    shapeButtons.forEach(b=>{
      b.classList.toggle('active', b.dataset.shape === shape);
    });
  }
  
  shapeButtons.forEach(btn => {
    btn.addEventListener('click', (ev) => {
      const shape = btn.dataset.shape;
      setActiveShape(shape);

      // If a node is selected, update ONLY that node
      if (state.selected?.type === 'node'){
        const n = findNode(state.selected.id);
        if (n){
          n.shape = shape;
          commit(); render();
          showToast('Changed node shape to ' + shape + '.');
          return;
        }
      }
      showToast('New nodes will be ' + shape + '.');
    });
  });

  // --- File menu UI ---
  const fileBtn = document.getElementById('btnFile');
  const fileMenu = document.getElementById('fileMenu');
  const editBtn = document.getElementById('btnEditMenu');
  const editMenu = document.getElementById('editMenu');
  const viewBtn = document.getElementById('btnViewMenu');
  const viewMenu = document.getElementById('viewMenu');
  
  function closeAllMenus(){ 
    fileMenu.hidden = true; 
    if (editMenu) editMenu.hidden = true;
    if (viewMenu) viewMenu.hidden = true;
    const zoomMenu = document.getElementById('zoomMenu');
    if (zoomMenu) zoomMenu.hidden = true;
    const gridMenu = document.getElementById('gridMenu');
    if (gridMenu) gridMenu.hidden = true;
  }
  
  function toggleMenu(btn, menu) {
    closeAllMenus();
    menu.hidden = !menu.hidden;
    if (!menu.hidden) {
      const r = btn.getBoundingClientRect();
      menu.style.left = r.left + "px";
      menu.style.top = r.bottom + "px";
    }
  }
  
  fileBtn.addEventListener('click', (ev) => { ev.stopPropagation(); toggleMenu(fileBtn, fileMenu); });
  if (editBtn && editMenu) editBtn.addEventListener('click', (ev) => { ev.stopPropagation(); toggleMenu(editBtn, editMenu); });
  if (viewBtn && viewMenu) viewBtn.addEventListener('click', (ev) => { ev.stopPropagation(); toggleMenu(viewBtn, viewMenu); });
  
  document.addEventListener('click', () => closeAllMenus());
  window.addEventListener('keydown', (ev) => { if (ev.key === 'Escape') closeAllMenus(); });

  // Edit menu actions
  if (document.getElementById('miUndo')) document.getElementById('miUndo').addEventListener('click', () => { undo(); closeAllMenus(); });
  if (document.getElementById('miRedo')) document.getElementById('miRedo').addEventListener('click', () => { redo(); closeAllMenus(); });
  if (document.getElementById('miCopy')) document.getElementById('miCopy').addEventListener('click', () => { copySelection(); closeAllMenus(); });
  if (document.getElementById('miCut')) document.getElementById('miCut').addEventListener('click', () => { copySelection(); deleteSelected(); closeAllMenus(); });
  if (document.getElementById('miPaste')) document.getElementById('miPaste').addEventListener('click', () => { pasteSelection(); closeAllMenus(); });
  if (document.getElementById('miDelete')) document.getElementById('miDelete').addEventListener('click', () => { deleteSelected(); closeAllMenus(); });

  // View menu actions
  if (document.getElementById('miZoomIn')) document.getElementById('miZoomIn').addEventListener('click', () => { setZoom(state.zoom * 1.2); closeAllMenus(); });
  if (document.getElementById('miZoomOut')) document.getElementById('miZoomOut').addEventListener('click', () => { setZoom(state.zoom / 1.2); closeAllMenus(); });
  if (document.getElementById('miFitView')) document.getElementById('miFitView').addEventListener('click', () => { fitToView(); closeAllMenus(); });
  if (document.getElementById('miToggleInspector')) document.getElementById('miToggleInspector').addEventListener('click', () => {
    const inspector = document.getElementById('inspector');
    inspector.style.display = inspector.style.display === 'none' ? 'flex' : 'none';
    closeAllMenus();
  });

  // Toolbar button actions
  if (document.getElementById('btnUndo')) document.getElementById('btnUndo').addEventListener('click', () => undo());
  if (document.getElementById('btnRedo')) document.getElementById('btnRedo').addEventListener('click', () => redo());
  if (document.getElementById('btnDelete')) document.getElementById('btnDelete').addEventListener('click', () => deleteSelected());


  
  // --- Export helpers (SVG/PNG/JPG) ---
  function downloadBlob(blob, filename){
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 800);
  }

  function getSvgCloneForExport(){
    const svg = document.getElementById('svg');
    const clone = svg.cloneNode(true);

    clone.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');

    const style = document.createElementNS('http://www.w3.org/2000/svg','style');
    style.textContent = `
      .edge{ fill:none; stroke-linecap:round; }
      .edge-label{ font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
      .node-label{ font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
      .group-title{ font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    `;
    clone.insertBefore(style, clone.firstChild);

    const vb = clone.getAttribute('viewBox');
    let w=1600,h=900;
    if (vb){
      const p = vb.split(/\s+/).map(Number);
      if (p.length===4 && p.every(n=>isFinite(n))) { w=p[2]; h=p[3]; }
    }
    const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
    bg.setAttribute('x','0'); bg.setAttribute('y','0');
    bg.setAttribute('width', String(w)); bg.setAttribute('height', String(h));
    bg.setAttribute('fill', '#ffffff');
    clone.insertBefore(bg, style.nextSibling);

    clone.querySelectorAll('.edge-label').forEach(el => el.setAttribute('fill', '#000000'));
    clone.querySelectorAll('.node-label').forEach(el => el.setAttribute('fill', '#000000'));
    clone.querySelectorAll('.group-title').forEach(el => el.setAttribute('fill', '#000000'));

    return clone;
  }

  function exportSVG(){
    const clone = getSvgCloneForExport();
    const text = new XMLSerializer().serializeToString(clone);
    const blob = new Blob([text], {type:'image/svg+xml;charset=utf-8'});
    const name = (sanitizeBaseName(state.projectName || 'diagram') || 'diagram') + '.svg';
    downloadBlob(blob, name);
  }

  async function exportRaster(kind){
    const clone = getSvgCloneForExport();
    // Use viewBox for sizing if present
    const vb = clone.getAttribute('viewBox');
    let w = 1600, h = 900;
    if (vb){
      const p = vb.split(/\s+/).map(Number);
      if (p.length===4 && p.every(n=>isFinite(n))) { w = p[2]; h = p[3]; }
    } else {
      const ww = Number(clone.getAttribute('width')); const hh = Number(clone.getAttribute('height'));
      if (isFinite(ww)) w = ww;
      if (isFinite(hh)) h = hh;
    }

    const svgText = new XMLSerializer().serializeToString(clone);
    const svgBlob = new Blob([svgText], {type:'image/svg+xml;charset=utf-8'});
    const url = URL.createObjectURL(svgBlob);

    const img = new Image();
    await new Promise((res, rej)=>{ img.onload=res; img.onerror=rej; img.src=url; });

    const scale = 2; // sharper output
    const canvas = document.createElement('canvas');
    canvas.width = Math.round(w*scale);
    canvas.height = Math.round(h*scale);
    const ctx = canvas.getContext('2d');

    // Background (match page background)
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.scale(scale, scale);
    ctx.drawImage(img, 0, 0, w, h);
    URL.revokeObjectURL(url);

    const mime = (kind==='png') ? 'image/png' : 'image/jpeg';
    const ext = (kind==='png') ? '.png' : '.jpg';
    const quality = (kind==='png') ? undefined : 0.92;
    const dataUrl = canvas.toDataURL(mime, quality);

    const bin = atob(dataUrl.split(',')[1]);
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    const outBlob = new Blob([bytes], {type:mime});
    const name = (sanitizeBaseName(state.projectName || 'diagram') || 'diagram') + ext;
    downloadBlob(outBlob, name);
  }

document.getElementById('miSave').addEventListener('click', () => { closeAllMenus(); saveProject(false); });
  document.getElementById('miSaveAs').addEventListener('click', () => { closeAllMenus(); saveProject(true); });
  document.getElementById('miOpen').addEventListener('click', () => { closeAllMenus(); document.getElementById('fileLoad').click(); });
  document.getElementById('miRecover').addEventListener('click', () => { closeAllMenus(); recoverAutosave(); });
  document.getElementById('miClearAutosave').addEventListener('click', () => { closeAllMenus(); clearAutosave(); });
  document.getElementById('miClearDiagram').addEventListener('click', () => { closeAllMenus(); clearDiagram(); });

  document.getElementById('miExportSVG').addEventListener('click', () => { closeAllMenus(); exportSVG(); showToast('Exported SVG.'); });
  document.getElementById('miExportPNG').addEventListener('click', () => { closeAllMenus(); exportRaster('png'); showToast('Exported PNG.'); });
  document.getElementById('miExportJPG').addEventListener('click', () => { closeAllMenus(); exportRaster('jpg'); showToast('Exported JPG.'); });

  // --- Style presets helpers ---
  const STYLE_FIELDS = {
    node: ["fill","stroke","nameColor","tagColor","nameFont","tagFont","showCode","nameDx","nameDy","tagDx","tagDy"],
    edge: ["labelFont","labelColor","style","route","showCode","labelDx","labelDy","strokeW","strokeColor"],
    group:["fill","stroke","titleColor","titleFont","titleDx","titleDy"]
  };
  function pickStyle(type, obj){
    const s = {};
    (STYLE_FIELDS[type]||[]).forEach(k => { if (k in obj) s[k] = obj[k]; });
    return s;
  }
  function applyStyle(type, obj, style){
    if (!style) return;
    (STYLE_FIELDS[type]||[]).forEach(k => { if (k in style) obj[k] = style[k]; });
  }

  // Preset UI elements
  const nodePresetSel = document.getElementById('nodePreset');
  const edgePresetSel = document.getElementById('edgePreset');
  const groupPresetSel = document.getElementById('groupPreset');

  function refreshPresetSelects(){
    const fill = (sel, map) => {
      if (!sel) return;
      const cur = sel.value;
      sel.innerHTML = "";
      const opt0 = document.createElement('option');
      opt0.value = ""; opt0.textContent = "(none)";
      sel.appendChild(opt0);
      Object.keys(map||{}).sort((a,b)=>a.localeCompare(b)).forEach(name=>{
        const o = document.createElement('option');
        o.value = name; o.textContent = name;
        sel.appendChild(o);
      });
      sel.value = cur && (map||{})[cur] ? cur : "";
    };
    fill(nodePresetSel, state.stylePresets.node);
    fill(edgePresetSel, state.stylePresets.edge);
    fill(groupPresetSel, state.stylePresets.group);
  }

  function savePreset(type, obj){
    console.log(`[SAVE PRESET] Function called - type: ${type}, obj:`, obj);
    const name = sanitizeBaseName(prompt(`Save ${type} style as:`, "")) || "";
    console.log(`[SAVE PRESET] Prompt returned name: "${name}"`);
    if (!name) { showToast("Preset save cancelled."); return; }
    state.stylePresets[type][name] = pickStyle(type, obj);
    commit(); // persist in history and autosave
    refreshPresetSelects();
    showToast(`Saved preset: ${name}`);
  }
  function applyPreset(type, obj, name){
    const style = state.stylePresets[type][name];
    if (!style) { showToast("No preset selected."); return; }
    applyStyle(type, obj, style);
    commit(); render();
    showToast(`Applied preset: ${name}`);
  }
  function deletePreset(type, name){
    if (!name) { showToast("No preset selected."); return; }
    if (!confirm(`Delete preset "${name}"?`)) return;
    delete state.stylePresets[type][name];
    commit();
    refreshPresetSelects();
    showToast("Preset deleted.");
  }

  // --- Format painter (brush) ---
  const btnBrush = document.getElementById('btnBrush');
  function setBrushFromSelected(){
    const sel = state.selected;
    if (!sel) { showToast("Select an object first."); return; }
    if (sel.type === 'node') {
      const n = findNode(sel.id); if (!n) return;
      state.styleBrush = { type:'node', style: pickStyle('node', n) };
    } else if (sel.type === 'edge') {
      const e = findEdge(sel.id); if (!e) return;
      state.styleBrush = { type:'edge', style: pickStyle('edge', e) };
    } else if (sel.type === 'group') {
      const g = findGroup(sel.id); if (!g) return;
      state.styleBrush = { type:'group', style: pickStyle('group', g) };
    } else return;
    btnBrush.classList.add('primary');
    showToast("Format painter armed ‚Äî click targets to apply (Esc cancels).");
  }
  function clearBrush(){
    state.styleBrush = null;
    btnBrush.classList.remove('primary');
  }
  btnBrush.addEventListener('click', (ev) => {
    ev.stopPropagation();
    if (state.styleBrush) { clearBrush(); showToast("Format painter off."); return; }
    setBrushFromSelected();
  });

  const btnCreateLink = document.getElementById('btnCreateLink');
  
  let linkMode = false;
  let linkSourceNode = null;  // Track the source node ID
  
  function clearLinkMode() {
    linkMode = false;
    linkSourceNode = null;
    state.connectFrom = null;
    btnCreateLink.classList.remove('primary');
  }
  
  btnCreateLink.addEventListener('click', (ev) => {
    ev.stopPropagation();
    linkMode = !linkMode;
    linkSourceNode = null;
    state.connectFrom = null;
    btnCreateLink.classList.toggle('primary', linkMode);
    console.log(`[LINK MODE] ${linkMode ? 'ACTIVATED' : 'DEACTIVATED'} - linkMode=${linkMode}, linkSourceNode=${linkSourceNode}`);
    if (linkMode) {
      // Check if a node is already selected
      if (state.selected && state.selected.type === 'node') {
        linkSourceNode = state.selected.id;
        const node = findNode(linkSourceNode);
        console.log(`[LINK MODE] Node ${linkSourceNode} already selected - using as source`);
        showToast(`Link source: ${node?.name || `N${linkSourceNode}`} ‚Üí Click target node`);
      } else {
        console.log(`[LINK MODE] No node selected - waiting for first click`);
        showToast('Link mode ON - Click first node');
      }
    } else {
      showToast('Link mode OFF');
    }
    render();
  });

  // Zoom controls
  const btnZoomIn = document.getElementById('btnZoomIn');
  const btnZoomOut = document.getElementById('btnZoomOut');
  const btnZoomFit = document.getElementById('btnZoomFit');
  const btnZoomLevel = document.getElementById('btnZoomLevel');
  const zoomMenu = document.getElementById('zoomMenu');

  if (btnZoomIn) {
    btnZoomIn.addEventListener('click', () => {
      setZoom(state.zoom * 1.2);
    });
  }

  if (btnZoomOut) {
    btnZoomOut.addEventListener('click', () => {
      setZoom(state.zoom / 1.2);
    });
  }

  if (btnZoomFit) {
    btnZoomFit.addEventListener('click', () => {
      fitToView();
    });
  }

  // Zoom dropdown menu
  if (btnZoomLevel && zoomMenu) {
    btnZoomLevel.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      zoomMenu.hidden = !zoomMenu.hidden;
      if (!zoomMenu.hidden) {
        const r = btnZoomLevel.getBoundingClientRect();
        zoomMenu.style.left = '0';
        zoomMenu.style.top = '100%';
      }
    });

    // Zoom preset items
    zoomMenu.querySelectorAll('.zoom-preset').forEach(item => {
      item.addEventListener('click', () => {
        const zoom = parseFloat(item.dataset.zoom);
        if (zoom) setZoom(zoom);
        zoomMenu.hidden = true;
      });
    });

    // Fit to view
    const zoomFitView = document.getElementById('zoomFitView');
    if (zoomFitView) {
      zoomFitView.addEventListener('click', () => {
        fitToView();
        zoomMenu.hidden = true;
      });
    }

    // Reset to 100%
    const zoomReset = document.getElementById('zoomReset');
    if (zoomReset) {
      zoomReset.addEventListener('click', () => {
        setZoom(1.0);
        zoomMenu.hidden = true;
      });
    }

    // Close menu when clicking outside
    document.addEventListener('click', () => {
      zoomMenu.hidden = true;
    });
    
    zoomMenu.addEventListener('click', (ev) => {
      ev.stopPropagation();
    });
  }

  // Keyboard shortcut for reset zoom
  window.addEventListener('keydown', (ev) => {
    if ((ev.ctrlKey || ev.metaKey) && ev.key === '0') {
      ev.preventDefault();
      setZoom(1.0);
    }
  });

  // Grid toggle and settings
  const btnGridToggle = document.getElementById('btnGridToggle');
  const gridMenu = document.getElementById('gridMenu');
  const gridEnabledCheckbox = document.getElementById('gridEnabled');

  if (btnGridToggle && gridMenu) {
    btnGridToggle.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      gridMenu.hidden = !gridMenu.hidden;
    });

    // Grid enable/disable checkbox
    if (gridEnabledCheckbox) {
      gridEnabledCheckbox.addEventListener('change', () => {
        state.gridEnabled = gridEnabledCheckbox.checked;
        btnGridToggle.classList.toggle('active', state.gridEnabled);
        render();
      });
    }

    // Grid size options
    gridMenu.querySelectorAll('.grid-size').forEach(item => {
      item.addEventListener('click', () => {
        const size = parseInt(item.dataset.size);
        if (size) {
          state.gridSize = size;
          // Update active state
          gridMenu.querySelectorAll('.grid-size').forEach(i => i.classList.remove('active'));
          item.classList.add('active');
          render();
        }
      });
    });

    // Close menu when clicking outside
    document.addEventListener('click', () => {
      gridMenu.hidden = true;
    });
    
    gridMenu.addEventListener('click', (ev) => {
      ev.stopPropagation();
    });

    // Initialize button state
    btnGridToggle.classList.toggle('active', state.gridEnabled);
  }

  // ============== TAG FILTER SYSTEM ==============
  const btnTagFilter = document.getElementById('btnTagFilter');
  const tagFilterMenu = document.getElementById('tagFilterMenu');
  const tagFilterList = document.getElementById('tagFilterList');
  const btnTagSelectAll = document.getElementById('btnTagSelectAll');
  const btnTagClearAll = document.getElementById('btnTagClearAll');
  const miTagFilter = document.getElementById('miTagFilter');

  // Collect all unique tags from nodes, edges, and groups - returns separate counts
  function collectAllTags() {
    const nodeTags = new Map();
    const edgeTags = new Map();
    const groupTags = new Map();
    const allTags = new Set();
    
    // Count from nodes
    for (const node of state.nodes) {
      const tags = getNodeTags(node);
      for (const tag of tags) {
        nodeTags.set(tag, (nodeTags.get(tag) || 0) + 1);
        allTags.add(tag);
      }
    }
    // Count from edges
    for (const edge of state.edges) {
      const tags = getEdgeTags(edge);
      for (const tag of tags) {
        edgeTags.set(tag, (edgeTags.get(tag) || 0) + 1);
        allTags.add(tag);
      }
    }
    // Count from groups
    for (const group of state.groups) {
      const tags = getGroupTags(group);
      for (const tag of tags) {
        groupTags.set(tag, (groupTags.get(tag) || 0) + 1);
        allTags.add(tag);
      }
    }
    return { nodeTags, edgeTags, groupTags, allTags };
  }

  // Get all tags for a node (from tags array + extraTags)
  function getNodeTags(node) {
    const tags = new Set();
    // Always add 'default' tag
    tags.add('default');
    // Add from tags array
    if (Array.isArray(node.tags)) {
      node.tags.forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    // Add from extraTags (comma-separated)
    if (node.extraTags) {
      node.extraTags.split(',').forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    return tags;
  }

  // Get all tags for an edge (from filterTags array + extraTags)
  function getEdgeTags(edge) {
    const tags = new Set();
    // Always add 'default' tag
    tags.add('default');
    // Add from filterTags array
    if (Array.isArray(edge.filterTags)) {
      edge.filterTags.forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    // Add from extraTags (comma-separated)
    if (edge.extraTags) {
      edge.extraTags.split(',').forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    return tags;
  }

  // Get all tags for a group (from filterTags array + extraTags)
  function getGroupTags(group) {
    const tags = new Set();
    // Always add 'default' tag
    tags.add('default');
    // Add from filterTags array
    if (Array.isArray(group.filterTags)) {
      group.filterTags.forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    // Add from extraTags (comma-separated)
    if (group.extraTags) {
      group.extraTags.split(',').forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    return tags;
  }

  // Check if a node should be visible based on current filter
  function isNodeVisible(node) {
    if (state.tagFilter.mode === 'all') return true;
    
    const nodeTags = getNodeTags(node);
    const selectedTags = state.tagFilter.selectedTags;
    
    if (selectedTags.size === 0) return true; // No tags selected = show all
    
    // Check if node has ANY of the selected tags
    let hasSelectedTag = false;
    for (const tag of nodeTags) {
      if (selectedTags.has(tag)) {
        hasSelectedTag = true;
        break;
      }
    }
    
    if (state.tagFilter.mode === 'include') {
      return hasSelectedTag;
    } else if (state.tagFilter.mode === 'exclude') {
      return !hasSelectedTag;
    }
    
    return true;
  }

  // Check if an edge should be visible
  // Hierarchy: First check if both connected nodes are visible, then apply edge's own tag filter
  function isEdgeVisible(edge) {
    const nodeA = findNode(edge.a);
    const nodeB = findNode(edge.b);
    if (!nodeA || !nodeB) return false;
    
    // FIRST: Both nodes must be visible (node filtering takes priority)
    if (!isNodeVisible(nodeA) || !isNodeVisible(nodeB)) return false;
    
    // THEN: Apply edge's own tag filter (only if nodes are visible)
    if (state.tagFilter.mode === 'all') return true;
    
    const edgeTags = getEdgeTags(edge);
    const selectedTags = state.tagFilter.selectedTags;
    
    if (selectedTags.size === 0) return true;
    
    let hasSelectedTag = false;
    for (const tag of edgeTags) {
      if (selectedTags.has(tag)) {
        hasSelectedTag = true;
        break;
      }
    }
    
    if (state.tagFilter.mode === 'include') {
      return hasSelectedTag;
    } else if (state.tagFilter.mode === 'exclude') {
      return !hasSelectedTag;
    }
    
    return true;
  }

  // Check if a group contains any visible nodes
  function groupHasVisibleNodes(group) {
    return state.nodes.some(n => n.groupId === group.id && isNodeVisible(n));
  }

  // Check if a group should be visible based on current filter
  // Hierarchy: First check if group contains visible nodes, then apply group's own tag filter
  function isGroupVisible(group) {
    // FIRST: Group must contain at least one visible node to be considered
    // (unless it's a region that contains visible country boxes)
    if (group.type === 'region') {
      // Region is visible if it contains any visible country box
      const hasVisibleCountry = state.groups.some(g => 
        g.type === 'country' && g.parentId === group.id && isCountryBoxVisible(g)
      );
      if (!hasVisibleCountry) return false;
    } else {
      // Country box must have visible nodes
      if (!groupHasVisibleNodes(group)) return false;
    }
    
    // THEN: Apply group's own tag filter (only if it has visible content)
    if (state.tagFilter.mode === 'all') return true;
    
    const groupTags = getGroupTags(group);
    const selectedTags = state.tagFilter.selectedTags;
    
    if (selectedTags.size === 0) return true;
    
    let hasSelectedTag = false;
    for (const tag of groupTags) {
      if (selectedTags.has(tag)) {
        hasSelectedTag = true;
        break;
      }
    }
    
    if (state.tagFilter.mode === 'include') {
      return hasSelectedTag;
    } else if (state.tagFilter.mode === 'exclude') {
      return !hasSelectedTag;
    }
    
    return true;
  }

  // Helper for country boxes specifically (checks if it has visible nodes)
  function isCountryBoxVisible(group) {
    if (group.type !== 'country') return isGroupVisible(group);
    
    // Must have visible nodes
    if (!groupHasVisibleNodes(group)) return false;
    
    // Then apply tag filter
    if (state.tagFilter.mode === 'all') return true;
    
    const groupTags = getGroupTags(group);
    const selectedTags = state.tagFilter.selectedTags;
    
    if (selectedTags.size === 0) return true;
    
    let hasSelectedTag = false;
    for (const tag of groupTags) {
      if (selectedTags.has(tag)) {
        hasSelectedTag = true;
        break;
      }
    }
    
    if (state.tagFilter.mode === 'include') {
      return hasSelectedTag;
    } else if (state.tagFilter.mode === 'exclude') {
      return !hasSelectedTag;
    }
    
    return true;
  }

  // Update the tag filter list UI
  function updateTagFilterList() {
    if (!tagFilterList) return;
    
    const { nodeTags, edgeTags, groupTags, allTags } = collectAllTags();
    tagFilterList.innerHTML = '';
    
    // Helper function to sort tags (default first, then alphabetically)
    const sortTags = (tagsMap) => {
      return Array.from(tagsMap.keys()).sort((a, b) => {
        if (a === 'default') return -1;
        if (b === 'default') return 1;
        return a.localeCompare(b);
      });
    };
    
    // Helper function to create a tag item
    const createTagItem = (tag, count) => {
      const label = document.createElement('label');
      label.className = 'tag-filter-item';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = state.tagFilter.selectedTags.has(tag);
      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          state.tagFilter.selectedTags.add(tag);
        } else {
          state.tagFilter.selectedTags.delete(tag);
        }
        updateFilterButtonState();
        render();
      });
      
      const nameSpan = document.createElement('span');
      nameSpan.className = 'tag-name';
      nameSpan.textContent = tag;
      
      const countSpan = document.createElement('span');
      countSpan.className = 'tag-count';
      countSpan.textContent = count;
      
      label.appendChild(checkbox);
      label.appendChild(nameSpan);
      label.appendChild(countSpan);
      return label;
    };
    
    // Helper function to create section header
    const createSectionHeader = (title, icon) => {
      const header = document.createElement('div');
      header.style.cssText = 'padding:6px 12px; font-size:11px; font-weight:600; color:#666; background:#f5f5f5; border-top:1px solid #e0e0e0; border-bottom:1px solid #e0e0e0;';
      header.textContent = `${icon} ${title}`;
      return header;
    };
    
    // Node Tags Section
    if (nodeTags.size > 0) {
      tagFilterList.appendChild(createSectionHeader('Node Tags', '‚óã'));
      const sortedNodeTags = sortTags(nodeTags);
      for (const tag of sortedNodeTags) {
        tagFilterList.appendChild(createTagItem(tag, nodeTags.get(tag)));
      }
    }
    
    // Link Tags Section
    if (edgeTags.size > 0) {
      tagFilterList.appendChild(createSectionHeader('Link Tags', '‚Üó'));
      const sortedEdgeTags = sortTags(edgeTags);
      for (const tag of sortedEdgeTags) {
        tagFilterList.appendChild(createTagItem(tag, edgeTags.get(tag)));
      }
    }
    
    // Box Tags Section
    if (groupTags.size > 0) {
      tagFilterList.appendChild(createSectionHeader('Box Tags', '‚ñ¢'));
      const sortedGroupTags = sortTags(groupTags);
      for (const tag of sortedGroupTags) {
        tagFilterList.appendChild(createTagItem(tag, groupTags.get(tag)));
      }
    }
  }

  // Update filter button state (highlight if filtering)
  function updateFilterButtonState() {
    if (!btnTagFilter) return;
    const isFiltering = state.tagFilter.mode !== 'all' && state.tagFilter.selectedTags.size > 0;
    btnTagFilter.classList.toggle('filtering', isFiltering);
  }

  // Tag filter menu handling
  if (btnTagFilter && tagFilterMenu) {
    btnTagFilter.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateTagFilterList();
      tagFilterMenu.hidden = !tagFilterMenu.hidden;
    });

    // Filter mode radio buttons
    tagFilterMenu.querySelectorAll('input[name="filterMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        state.tagFilter.mode = radio.value;
        updateFilterButtonState();
        render();
      });
    });

    // Select All button
    if (btnTagSelectAll) {
      btnTagSelectAll.addEventListener('click', () => {
        const tagCounts = collectAllTags();
        state.tagFilter.selectedTags = new Set(tagCounts.keys());
        updateTagFilterList();
        updateFilterButtonState();
        render();
      });
    }

    // Clear All button
    if (btnTagClearAll) {
      btnTagClearAll.addEventListener('click', () => {
        state.tagFilter.selectedTags.clear();
        updateTagFilterList();
        updateFilterButtonState();
        render();
      });
    }

    // Close menu when clicking outside
    document.addEventListener('click', () => {
      tagFilterMenu.hidden = true;
    });
    
    tagFilterMenu.addEventListener('click', (ev) => {
      ev.stopPropagation();
    });
  }

  // View menu - Tag Filter option
  if (miTagFilter) {
    miTagFilter.addEventListener('click', (ev) => {
      ev.stopPropagation();
      // Close other menus but not tagFilterMenu
      fileMenu.hidden = true;
      if (editMenu) editMenu.hidden = true;
      if (viewMenu) viewMenu.hidden = true;
      const zoomMenu = document.getElementById('zoomMenu');
      if (zoomMenu) zoomMenu.hidden = true;
      const gridMenu = document.getElementById('gridMenu');
      if (gridMenu) gridMenu.hidden = true;
      
      // Get elements directly to ensure they're found
      const tagFilterBtn = document.getElementById('btnTagFilter');
      const tagFilterPanel = document.getElementById('tagFilterMenu');
      
      if (tagFilterBtn && tagFilterPanel) {
        updateTagFilterList();
        tagFilterPanel.hidden = false;
        // Position near the button
        const rect = tagFilterBtn.getBoundingClientRect();
        tagFilterPanel.style.position = 'fixed';
        tagFilterPanel.style.left = rect.left + 'px';
        tagFilterPanel.style.top = rect.bottom + 'px';
      }
    });
  }

  // Keyboard shortcut for tag filter (F key)
  window.addEventListener('keydown', (ev) => {
    if (ev.key === 'f' || ev.key === 'F') {
      if (ev.target.tagName === 'INPUT' || ev.target.tagName === 'TEXTAREA') return;
      ev.preventDefault();
      if (btnTagFilter && tagFilterMenu) {
        closeAllMenus();
        updateTagFilterList();
        tagFilterMenu.hidden = !tagFilterMenu.hidden;
      }
    }
  });

  // Add tagFilterMenu to closeAllMenus
  const originalCloseAllMenus = closeAllMenus;
  closeAllMenus = function() {
    originalCloseAllMenus();
    if (tagFilterMenu) tagFilterMenu.hidden = true;
  };

  // Mouse wheel zoom (centered on mouse position)
  svg.addEventListener('wheel', (ev) => {
    if (ev.ctrlKey || ev.metaKey) {
      ev.preventDefault();
      const delta = ev.deltaY > 0 ? 0.9 : 1.1;
      const rect = svg.getBoundingClientRect();
      const mouseX = ev.clientX - rect.left;
      const mouseY = ev.clientY - rect.top;
      setZoom(state.zoom * delta, true, mouseX, mouseY);
    }
  }, { passive: false });


  const downloadText = (filename, text, mime="text/plain") => {
    const blob = new Blob([text], {type: mime});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(a.href), 500);
  };

  const escapeCSV = (v) => {
    const s = String(v ?? "");
    if (/[,"\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  };

  function getMouse(ev) {
    const pt = svg.createSVGPoint();
    pt.x = ev.clientX; pt.y = ev.clientY;
    const m = pt.matrixTransform(svg.getScreenCTM().inverse());
    return { x: m.x, y: m.y };
  }

  const findNode = (id) => state.nodes.find(n => n.id === id);
  const findEdge = (id) => state.edges.find(e => e.id === id);
  const findGroup = (id) => state.groups.find(g => g.id === id);

  function pointInGroup(x,y,g){
    return x >= g.x && x <= g.x+g.w && y >= g.y && y <= g.y+g.h;
  }
  function updateNodeGroupMembership(node) {
    let gid = null;
    // Nodes belong to the top-most *country* box they are inside (regions don't directly own nodes)
    for (let i = state.groups.length - 1; i >= 0; i--) {
      const g = state.groups[i];
      if (g.type !== 'country') continue;
      if (pointInGroup(node.x, node.y, g)) { gid = g.id; break; }
    }
    node.groupId = gid;
  }
  function updateCountryRegionMembership(country) {
    if (!country || country.type !== 'country') return;
    let rid = null;
    const cx = country.x + country.w / 2;
    const cy = country.y + country.h / 2;
    for (let i = state.groups.length - 1; i >= 0; i--) {
      const g = state.groups[i];
      if (g.type !== 'region') continue;
      if (pointInGroup(cx, cy, g)) { rid = g.id; break; }
    }
    country.parentId = rid;
  }

  function refreshAllMemberships() {
    state.groups.forEach(g => { if (g.type === 'country') updateCountryRegionMembership(g); });
    state.nodes.forEach(updateNodeGroupMembership);
  }

  function projectSnapshot() {
    return JSON.parse(JSON.stringify({
      nodes: state.nodes, edges: state.edges, groups: state.groups,
      nextNode: state.nextNode, nextEdge: state.nextEdge, nextGroup: state.nextGroup,
      stylePresets: state.stylePresets,
      canvasWidth: state.canvasWidth,
      canvasHeight: state.canvasHeight,
      showCanvasBorder: state.showCanvasBorder
    }));
  }
  function applySnapshot(snap) {
    state.nodes = snap.nodes || [];
    state.edges = snap.edges || [];
    state.groups = snap.groups || [];
    state.nextNode = snap.nextNode || (Math.max(0, ...state.nodes.map(n=>n.id)) + 1);
    state.nextEdge = snap.nextEdge || (Math.max(0, ...state.edges.map(e=>e.id)) + 1);
    state.nextGroup = snap.nextGroup || (Math.max(0, ...state.groups.map(g=>g.id)) + 1);

    // Restore presets if snapshot carries them; otherwise keep current
    state.stylePresets = snap.stylePresets || state.stylePresets || { node: {}, edge: {}, group: {} };
    state.styleBrush = null;

    // Restore canvas dimensions
    if (typeof snap.canvasWidth === 'number') state.canvasWidth = snap.canvasWidth;
    if (typeof snap.canvasHeight === 'number') state.canvasHeight = snap.canvasHeight;
    if (typeof snap.showCanvasBorder === 'boolean') state.showCanvasBorder = snap.showCanvasBorder;
    svg.setAttribute('viewBox', `0 0 ${state.canvasWidth} ${state.canvasHeight}`);
    syncGlobalToggles();

    // Clear transient UI state
    state.selected = null;
    state.connectFrom = null;
    state.dragging = null;
    state.resizingGroup = null;
    state.placingGroup = false;
    state.placingGroupType = 'country';

    refreshAllMemberships();
    render();
    updateInspector();
  }
  function pushHistory() {
    const snap = projectSnapshot();
    if (history.index < history.stack.length - 1) {
      history.stack = history.stack.slice(0, history.index + 1);
    }
    history.stack.push(snap);
    if (history.stack.length > history.max) history.stack.shift();
    else history.index++;
  }
  function commit() { dirty = true; pushHistory(); }
  function undo() {
    if (history.index <= 0) { showToast("Nothing to undo."); return; }
    history.index--;
    applySnapshot(history.stack[history.index]);
    dirty = true;
    showToast("Undo");
  }
  function redo() {
    if (history.index >= history.stack.length - 1) { showToast("Nothing to redo."); return; }
    history.index++;
    applySnapshot(history.stack[history.index]);
    dirty = true;
    showToast("Redo");
  }

  function svgLine(x1,y1,x2,y2,cls){
    const l = document.createElementNS('http://www.w3.org/2000/svg','line');
    l.setAttribute('x1', x1); l.setAttribute('y1', y1);
    l.setAttribute('x2', x2); l.setAttribute('y2', y2);
    l.setAttribute('class', cls);
    return l;
  }
  
  function drawCanvasBorder() {
    if (!state.showCanvasBorder) return;
    const border = document.createElementNS('http://www.w3.org/2000/svg','rect');
    border.setAttribute('x', 0);
    border.setAttribute('y', 0);
    border.setAttribute('width', state.canvasWidth);
    border.setAttribute('height', state.canvasHeight);
    border.setAttribute('fill', 'none');
    border.setAttribute('stroke', '#444');
    border.setAttribute('stroke-width', 2);
    border.setAttribute('stroke-dasharray', '8 4');
    border.style.pointerEvents = 'none';
    svg.appendChild(border);
  }
  
  function drawGrid() {
    const w = state.canvasWidth, h = state.canvasHeight;
    // Only draw grid if enabled
    if (state.gridEnabled) {
      const step = state.gridSize || 40;
      for (let x=0; x<=w; x+=step) svg.appendChild(svgLine(x,0,x,h,'grid'));
      for (let y=0; y<=h; y+=step) svg.appendChild(svgLine(0,y,w,y,'grid'));
    }
    drawCanvasBorder();
  }


  function polygonPoints(cx, cy, r, sides, rotationRad=0){
    const pts = [];
    for (let i=0;i<sides;i++){
      const a = rotationRad + (i * 2*Math.PI / sides);
      pts.push([cx + r*Math.cos(a), cy + r*Math.sin(a)]);
    }
    return pts.map(p=>p[0].toFixed(2)+","+p[1].toFixed(2)).join(" ");
  }
  function setMultilineText(textEl, lines, fontSizePx) {
    while (textEl.firstChild) textEl.removeChild(textEl.firstChild);
    const fs = fontSizePx ?? 12;
    lines.forEach((line, i) => {
      const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      tspan.setAttribute('x', textEl.getAttribute('x'));
      if (i === 0) tspan.setAttribute('dy', '0');
      else tspan.setAttribute('dy', (fs * 1.2).toString());
      tspan.textContent = line;
      textEl.appendChild(tspan);
    });
  }

  function render() {
    svg.innerHTML = '';
    drawGrid();
    
    // Filter groups (regions first, then countries) based on tag filter
    state.groups.filter(g=>g.type==='region').forEach(g => {
      if (isGroupVisible(g)) drawGroup(g);
    });
    state.groups.filter(g=>g.type!=='region').forEach(g => {
      if (isGroupVisible(g)) drawGroup(g);
    });
    
    // Filter edges based on node visibility and edge tags
    state.edges.forEach(e => {
      if (isEdgeVisible(e)) {
        drawEdge(e);
      }
    });
    
    // Filter nodes based on tag filter
    state.nodes.forEach(n => {
      if (isNodeVisible(n)) {
        drawNode(n);
      }
    });

    if (state.connectFrom) {
      const n = findNode(state.connectFrom);
      if (n && isNodeVisible(n)) {
        const hint = document.createElementNS('http://www.w3.org/2000/svg','text');
        hint.setAttribute('x', n.x);
        hint.setAttribute('y', n.y - 40);
        hint.setAttribute('class', 'edge-label');
        hint.style.fontSize = "12px";
        hint.textContent = "Select target node‚Ä¶";
        svg.appendChild(hint);
      }
    }
    if (state.marquee) {
      const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
      r.setAttribute('class','marquee');
      r.setAttribute('x', state.marquee.x);
      r.setAttribute('y', state.marquee.y);
      r.setAttribute('width', state.marquee.w);
      r.setAttribute('height', state.marquee.h);
      svg.appendChild(r);
    }
    updateInspector();
  }

  function drawGroup(g) {
    const grp = document.createElementNS('http://www.w3.org/2000/svg','g');
    const isSel = (state.selected?.type==='group' && state.selected?.id===g.id) || state.selection.groups.has(g.id);
    if (isSel) grp.classList.add('group-selected');

    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x', g.x);
    rect.setAttribute('y', g.y);
    rect.setAttribute('width', g.w);
    rect.setAttribute('height', g.h);
    rect.setAttribute('class', 'group-rect');
    rect.setAttribute('fill', g.fill || "rgba(54, 76, 140, 0.12)");
    rect.setAttribute('stroke', g.stroke || "#6073b8");
    rect.setAttribute('stroke-width', (g.strokeW ?? 2));
    rect.style.pointerEvents = "auto";  // Make clickable for selection and dragging
    rect.style.cursor = "grab";  // Show hand cursor

    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('x', g.x + 14 + (g.titleDx || 0));
    label.setAttribute('y', g.y + 22 + (g.titleDy || 0));
    label.setAttribute('class', 'group-label');
    label.setAttribute('fill', g.titleColor || "#eaeaea");
    label.style.fontSize = (g.titleFont || 14) + "px";
    label.textContent = g.title || (g.type==='region' ? `Region${g.id}` : `Country${g.id}`);
    label.style.pointerEvents = "auto";

    const handle = document.createElementNS('http://www.w3.org/2000/svg','rect');
    handle.setAttribute('x', g.x + g.w - 10);
    handle.setAttribute('y', g.y + g.h - 10);
    handle.setAttribute('width', 10);
    handle.setAttribute('height', 10);
    handle.setAttribute('class', 'group-handle');

    rect.addEventListener('mousedown', (ev) => {
      ev.stopPropagation();
      const m = getMouse(ev);
      
      // In link mode, don't allow group dragging
      if (linkMode) {
        return;
      }
      
      // Shift+click without Ctrl - let mouseup/click handle multi-selection, don't set up dragging
      if (ev.shiftKey && !(ev.ctrlKey || ev.metaKey)) {
        console.log(`[GROUP MOUSEDOWN] Group ${g.id} - Shift+click, letting click handler handle multi-select`);
        return;
      }
      
      // Check BEFORE calling select() to preserve multi-selection if dragging
      // If the clicked group is part of a multi-selection, drag entire selection
      if (state.selection.groups.has(g.id) && (state.selection.groups.size > 1 || state.selection.nodes.size > 0)) {
        console.log(`[MULTI-DRAG] Group ${g.id} is part of multi-selection (${state.selection.nodes.size} nodes, ${state.selection.groups.size} groups) - setting up multi-drag`);
        const origNodes = [...state.selection.nodes].map(id => {
          const nn = findNode(id); return nn ? {id, x: nn.x, y: nn.y} : null;
        }).filter(Boolean);
        const origGroups = [...state.selection.groups].map(id => {
          const gg = findGroup(id); return gg ? {id, x: gg.x, y: gg.y} : null;
        }).filter(Boolean);
        state.dragging = { type:'selection', mx0: m.x, my0: m.y, origNodes, origGroups };
        state.selected = null; // Clear single selection when dragging multiple
        console.log(`[MULTI-DRAG] Dragging ${origNodes.length} nodes and ${origGroups.length} groups`);
      } else {
        console.log(`[SINGLE-DRAG] Group ${g.id} - single selection drag setup`);
        // Don't call select() here - it may trigger render() which recreates DOM
        if (!state.selection.groups.has(g.id)) {
          setSingleSelection({type:'group', id:g.id});
        }
        state.dragging = { type:'group', id:g.id, dx: g.x - m.x, dy: g.y - m.y };
      }
      rect.style.cursor = "grabbing";
      state.connectFrom = null;
    });

    label.addEventListener('mousedown', (ev) => {
      if (!(ev.ctrlKey || ev.metaKey)) return;
      ev.stopPropagation();
      const m = getMouse(ev);
      state.dragging = { type:'groupTitleLabel', id:g.id,
        dx: (g.x + 14 + (g.titleDx||0)) - m.x,
        dy: (g.y + 22 + (g.titleDy||0)) - m.y
      };
      select({type:'group', id:g.id});
      state.connectFrom = null;
      render();
    });

    handle.addEventListener('mousedown', (ev) => {
      ev.stopPropagation();
      const m = getMouse(ev);
      select({type:'group', id:g.id});
      state.resizingGroup = { id: g.id, startW: g.w, startH: g.h, mx0: m.x, my0: m.y };
      state.connectFrom = null;
      render();
    });

    rect.addEventListener('mouseup', (ev) => {
      // Don't stop propagation - let global handler clear dragging state
      // Just restore cursor
      rect.style.cursor = "grab";
    });

    rect.addEventListener('click', (ev) => { 
      ev.stopPropagation(); 
      if (ev.shiftKey) {
        // Shift+click toggles multi-selection for this group
        if (state.selection.groups.has(g.id)) {
          state.selection.groups.delete(g.id);
          state.selected = null;
        } else {
          state.selection.groups.add(g.id);
          state.selected = null;
        }
        render();
        return;
      }
      select({type:'group', id:g.id}); 
      state.connectFrom=null; 
      render(); 
    });
    label.addEventListener('click', (ev) => { 
      ev.stopPropagation(); 
      if (ev.shiftKey) {
        // Shift+click toggles multi-selection for this group
        if (state.selection.groups.has(g.id)) {
          state.selection.groups.delete(g.id);
          state.selected = null;
        } else {
          state.selection.groups.add(g.id);
          state.selected = null;
        }
        render();
        return;
      }
      select({type:'group', id:g.id}); 
      state.connectFrom=null; 
      render(); 
    });

    grp.appendChild(rect);
    grp.appendChild(label);
    grp.appendChild(handle);
    svg.appendChild(grp);
  }

  function orthogonalPath(x1,y1,x2,y2, route){
    if (route === 'vh') return `M ${x1} ${y1} L ${x1} ${y2} L ${x2} ${y2}`;
    return `M ${x1} ${y1} L ${x2} ${y1} L ${x2} ${y2}`;
  }
  function orthogonalBaseLabelPoint(x1,y1,x2,y2, route){
    if (route === 'vh') return { x: x1 + 8, y: y2 - 8 };
    return { x: x2 + 8, y: y1 - 8 };
  }
  function getEdgeLabelLines(e) {
    const lines = [];
    if (state.ui.showLinkCode && e.showCode && e.code && e.code.trim()) lines.push(e.code.trim());
    lines.push((e.tag && e.tag.trim()) ? e.tag.trim() : "‚Äî");
    if (state.ui.showLatency && typeof e.latencyMs === "number" && isFinite(e.latencyMs)) lines.push(`${e.latencyMs} ms`);
    if (e.extraTags && e.extraTags.trim()) lines.push(e.extraTags.trim());
    return lines;
  }

  function quadraticCurvePath(x1, y1, x2, y2, arch) {
    // Create bezier curve path
    // arch controls how much the curve bends (0.3 = moderate, 0 = straight, 0.6 = extreme)
    const mx = (x1 + x2) / 2;
    const my = (y1 + y2) / 2;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const offset = dist * arch * 0.5;
    const cpx = mx - dy/dist * offset;
    const cpy = my + dx/dist * offset;
    return `M ${x1} ${y1} Q ${cpx} ${cpy} ${x2} ${y2}`;
  }

  function curveBaseLabelPoint(x1, y1, x2, y2, arch) {
    // Label position on curve (midpoint adjusted)
    const mx = (x1 + x2) / 2;
    const my = (y1 + y2) / 2;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const offset = dist * arch * 0.25;
    return { x: mx - dy/dist * offset + 8, y: my + dx/dist * offset - 8 };
  }

  function getCurveControlPoint(x1, y1, x2, y2, arch) {
    // Returns the bezier control point (used for draggable handle position)
    const mx = (x1 + x2) / 2;
    const my = (y1 + y2) / 2;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const offset = dist * arch * 0.5;
    const cpx = mx - dy/dist * offset;
    const cpy = my + dx/dist * offset;
    return { x: cpx, y: cpy };
  }

  function drawEdge(e) {
    const a = findNode(e.a), b = findNode(e.b);
    if (!a || !b) {
      console.log(`[DRAW EDGE] Edge ${e.id} NOT drawn - missing nodes: a=${!!a}, b=${!!b}`);
      return;
    }
    console.log(`[DRAW EDGE] Drawing edge ${e.id} from node ${e.a} to node ${e.b}, style=${e.style}`);
    const isSel = (state.selected?.type==='edge' && state.selected?.id===e.id) || state.selection.edges.has(e.id);

    // Calculate offset for parallel edges between same nodes
    // Normalize node pair to ensure consistent ordering (smaller id first)
    const nodeA = Math.min(e.a, e.b);
    const nodeB = Math.max(e.a, e.b);
    const isReversed = e.a > e.b; // Track if this edge is in reverse direction
    
    const parallelEdges = state.edges.filter(edge => {
      const edgeNodeA = Math.min(edge.a, edge.b);
      const edgeNodeB = Math.max(edge.a, edge.b);
      return edgeNodeA === nodeA && edgeNodeB === nodeB;
    });
    
    // Sort parallel edges by id for consistent ordering
    parallelEdges.sort((x, y) => x.id - y.id);
    
    const edgeIndex = parallelEdges.findIndex(edge => edge.id === e.id);
    const totalParallel = parallelEdges.length;
    
    console.log(`[PARALLEL] Edge ${e.id}: index=${edgeIndex}, total=${totalParallel}`);
    
    // Calculate perpendicular offset
    let offsetX = 0, offsetY = 0;
    if (totalParallel > 1) {
      // Always calculate direction from lower node id to higher node id for consistency
      const lowNode = findNode(nodeA);
      const highNode = findNode(nodeB);
      const dx = highNode.x - lowNode.x;
      const dy = highNode.y - lowNode.y;
      const len = Math.sqrt(dx*dx + dy*dy) || 1;
      // Perpendicular unit vector
      const perpX = -dy / len;
      const perpY = dx / len;
      // Spread edges evenly: offset from center
      const spacing = 15; // pixels between parallel edges
      const offsetAmount = (edgeIndex - (totalParallel - 1) / 2) * spacing;
      offsetX = perpX * offsetAmount;
      offsetY = perpY * offsetAmount;
      
      console.log(`[PARALLEL] Edge ${e.id}: offsetAmount=${offsetAmount}, offsetX=${offsetX.toFixed(2)}, offsetY=${offsetY.toFixed(2)}`);
    }

    // Offset node positions for this edge
    const ax = a.x + offsetX;
    const ay = a.y + offsetY;
    const bx = b.x + offsetX;
    const by = b.y + offsetY;

    let baseLabel = null;
    if (e.style === 'orthogonal') {
      // Draw the visible edge
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', orthogonalPath(ax,ay,bx,by, e.route || 'hv'));
      p.setAttribute('class', 'edge' + (isSel ? ' selected' : ''));
      p.setAttribute('stroke-width', (e.strokeW ?? 2));
      p.setAttribute('stroke', e.strokeColor || "#7f8aa6");
      p.style.pointerEvents = 'none'; // Disable clicks on visible edge
      svg.appendChild(p);
      
      // Add invisible wide hit area for easier clicking
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg','path');
      hitArea.setAttribute('d', orthogonalPath(ax,ay,bx,by, e.route || 'hv'));
      hitArea.setAttribute('stroke', 'transparent');
      hitArea.setAttribute('stroke-width', 20); // Wide invisible hit area
      hitArea.setAttribute('fill', 'none');
      hitArea.style.cursor = 'pointer';
      hitArea.addEventListener('click', (ev) => { 
        ev.stopPropagation(); 
        if (ev.shiftKey) {
          if (state.selection.edges.has(e.id)) {
            state.selection.edges.delete(e.id);
            state.selected = null;
          } else {
            state.selection.edges.add(e.id);
            state.selected = null;
          }
          render();
          return;
        }
        select({type:'edge', id:e.id}); 
        state.connectFrom=null; 
        render(); 
      });
      svg.appendChild(hitArea);
      
      baseLabel = orthogonalBaseLabelPoint(ax,ay,bx,by, e.route || 'hv');
    } else if (e.style === 'curve') {
      // Draw the visible edge
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', quadraticCurvePath(ax, ay, bx, by, e.curveArch || 0.3));
      p.setAttribute('class', 'edge' + (isSel ? ' selected' : ''));
      p.setAttribute('stroke-width', (e.strokeW ?? 2));
      p.setAttribute('stroke', e.strokeColor || "#7f8aa6");
      p.setAttribute('fill', 'none');
      p.style.pointerEvents = 'none'; // Disable clicks on visible edge
      svg.appendChild(p);
      
      // Add invisible wide hit area for easier clicking
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg','path');
      hitArea.setAttribute('d', quadraticCurvePath(ax, ay, bx, by, e.curveArch || 0.3));
      hitArea.setAttribute('stroke', 'transparent');
      hitArea.setAttribute('stroke-width', 20); // Wide invisible hit area
      hitArea.setAttribute('fill', 'none');
      hitArea.style.cursor = 'pointer';
      hitArea.addEventListener('click', (ev) => { 
        ev.stopPropagation(); 
        if (ev.shiftKey) {
          if (state.selection.edges.has(e.id)) {
            state.selection.edges.delete(e.id);
            state.selected = null;
          } else {
            state.selection.edges.add(e.id);
            state.selected = null;
          }
          render();
          return;
        }
        select({type:'edge', id:e.id}); 
        state.connectFrom=null; 
        render(); 
      });
      svg.appendChild(hitArea);
      
      baseLabel = curveBaseLabelPoint(ax, ay, bx, by, e.curveArch || 0.3);
      
      // Draw draggable handle at curve midpoint when selected
      if (isSel) {
        const cp = getCurveControlPoint(ax, ay, bx, by, e.curveArch || 0.3);
        const handle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        handle.setAttribute('cx', cp.x);
        handle.setAttribute('cy', cp.y);
        handle.setAttribute('r', 6);
        handle.setAttribute('fill', '#ff6b6b');
        handle.setAttribute('stroke', '#ffffff');
        handle.setAttribute('stroke-width', 2);
        handle.style.cursor = 'grab';
        handle.addEventListener('mousedown', (ev) => {
          ev.stopPropagation();
          state.dragging = {type: 'curveHandle', edgeId: e.id, startX: ev.clientX, startY: ev.clientY, baseArch: e.curveArch || 0.3};
          handle.style.cursor = 'grabbing';
        });
        svg.appendChild(handle);
      }
    } else {
      console.log(`[DRAW EDGE] Creating STRAIGHT line from (${ax}, ${ay}) to (${bx}, ${by}), color: ${e.strokeColor || "#7f8aa6"}, strokeW: ${e.strokeW ?? 2}`);
      
      // Draw the visible edge
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', ax); line.setAttribute('y1', ay);
      line.setAttribute('x2', bx); line.setAttribute('y2', by);
      line.setAttribute('class', 'edge' + (isSel ? ' selected' : ''));
      line.setAttribute('stroke-width', (e.strokeW ?? 2));
      line.setAttribute('stroke', e.strokeColor || "#7f8aa6");
      line.style.pointerEvents = 'none'; // Disable clicks on visible edge
      console.log(`[DRAW EDGE] Line element created and appending to SVG`);
      svg.appendChild(line);
      
      // Add invisible wide hit area for easier clicking
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg','line');
      hitArea.setAttribute('x1', ax); hitArea.setAttribute('y1', ay);
      hitArea.setAttribute('x2', bx); hitArea.setAttribute('y2', by);
      hitArea.setAttribute('stroke', 'transparent');
      hitArea.setAttribute('stroke-width', 20); // Wide invisible hit area
      hitArea.style.cursor = 'pointer';
      hitArea.addEventListener('click', (ev) => { 
        ev.stopPropagation(); 
        if (ev.shiftKey) {
          if (state.selection.edges.has(e.id)) {
            state.selection.edges.delete(e.id);
            state.selected = null;
          } else {
            state.selection.edges.add(e.id);
            state.selected = null;
          }
          render();
          return;
        }
        select({type:'edge', id:e.id}); 
        state.connectFrom=null; 
        render(); 
      });
      svg.appendChild(hitArea);
      
      console.log(`[DRAW EDGE] Line appended to SVG`);
      baseLabel = { x:(ax+bx)/2, y:(ay+by)/2 };
    }

    const lx = baseLabel.x + (e.labelDx || 0);
    const ly = baseLabel.y + (e.labelDy || 0);

    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('x', lx);
    label.setAttribute('y', ly);
    label.setAttribute('class', 'edge-label');
    label.setAttribute('fill', e.labelColor || "#eaeaea");
    label.style.fontSize = (e.labelFont || 12) + "px";
    label.style.pointerEvents = "auto";
    setMultilineText(label, getEdgeLabelLines(e), (e.labelFont || 12));

    label.addEventListener('click', (ev) => { 
      ev.stopPropagation(); 
      if (ev.shiftKey) {
        if (state.selection.edges.has(e.id)) {
          state.selection.edges.delete(e.id);
          state.selected = null;
        } else {
          state.selection.edges.add(e.id);
          state.selected = null;
        }
        render();
        return;
      }
      select({type:'edge', id:e.id}); 
      state.connectFrom=null; 
      render(); 
    });
    label.addEventListener('mousedown', (ev) => {
      if (!(ev.ctrlKey || ev.metaKey)) return;
      ev.stopPropagation();
      const m = getMouse(ev);
      state.dragging = { type:'edgeLabel', id:e.id, dx: lx - m.x, dy: ly - m.y };
      select({type:'edge', id:e.id});
      state.connectFrom = null;
      render();
    });

    svg.appendChild(label);
  }

  function drawNode(n) {
    // console.log(`[DRAW] Creating node ${n.id} at (${n.x}, ${n.y})`);
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    const isSelected = (state.selected?.type==='node' && state.selected.id===n.id) || state.selection.nodes.has(n.id);
    const isLinkSource = linkMode && linkSourceNode === n.id;
    const isInLinkMode = linkMode && isSelected; // In link mode, all selected nodes show as potential sources
    
    let classes = 'node';
    // In link mode, show orange for source (pulsing) or any selected node (ready to be source)
    if (isLinkSource) {
      classes += ' link-source'; // Orange pulsing
    } else if (isInLinkMode) {
      classes += ' link-source'; // Orange (same style, shows it's ready to be selected as source)
    } else if (isSelected) {
      classes += ' selected'; // Normal cyan selection (when not in link mode)
    }
    g.setAttribute('class', classes);

    const r = (n.r ?? 24);
    const sw = (n.strokeW ?? 2);
    let c = null;
    const shape = (n.shape || 'circle');
    if (shape === 'square') {
      c = document.createElementNS('http://www.w3.org/2000/svg','rect');
      c.setAttribute('x', n.x - r);
      c.setAttribute('y', n.y - r);
      c.setAttribute('width', r*2);
      c.setAttribute('height', r*2);
      c.setAttribute('rx', 4);
      c.setAttribute('ry', 4);
    } else if (shape === 'rectangle') {
      c = document.createElementNS('http://www.w3.org/2000/svg','rect');
      c.setAttribute('x', n.x - r*1.35);
      c.setAttribute('y', n.y - r*0.85);
      c.setAttribute('width', r*2.7);
      c.setAttribute('height', r*1.7);
      c.setAttribute('rx', 6);
      c.setAttribute('ry', 6);
    } else if (shape === 'ellipse') {
      c = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
      c.setAttribute('cx', n.x);
      c.setAttribute('cy', n.y);
      c.setAttribute('rx', r*1.35);
      c.setAttribute('ry', r*0.9);
    } else if (shape === 'triangle') {
      c = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      c.setAttribute('points', polygonPoints(n.x, n.y, r*1.25, 3, -Math.PI/2));
    } else if (shape === 'hexagon') {
      c = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      c.setAttribute('points', polygonPoints(n.x, n.y, r*1.2, 6, Math.PI/6));
    } else {
      c = document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('cx', n.x);
      c.setAttribute('cy', n.y);
      c.setAttribute('r', r);
    }
    c.setAttribute('class', 'node-circle');
    c.setAttribute('fill', n.fill || "#1b2030");
    c.setAttribute('stroke', n.stroke || "#9fb3ff");
    c.setAttribute('stroke-width', sw);
    c.style.pointerEvents = "auto";
    c.style.cursor = "pointer";
    
    // Attach click listener directly to circle for better event capture
    // This is now handled by the group click listener above
    // console.log(`[DRAW] Attaching click listener to node ${n.id}`, {tagName: c.tagName, class: c.getAttribute('class'), r, x: n.x, y: n.y});
    // (old click listener code removed - now using group click handler)

    const nameX = n.x + (n.nameDx || 0);
    const nameY = n.y + (n.nameDy || 0);

    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', nameX);
    t.setAttribute('y', nameY);
    t.setAttribute('class', 'node-text');
    t.setAttribute('fill', n.nameColor || "#eaeaea");
    t.style.fontSize = (n.nameFont || 13) + "px";
    const nameLines = [];
    if (state.ui.showNodeCode && n.showCode && n.code && n.code.trim()) nameLines.push(n.code.trim());
    nameLines.push(n.name || `N${n.id}`);
    setMultilineText(t, nameLines, (n.nameFont || 13));
    t.style.pointerEvents = "auto";  // Enable pointer events for Ctrl+drag
    t.style.cursor = "default";

    const tagX = n.x + (n.tagDx || 0);
    const tagY = n.y + 26 + (n.tagDy || 0);

    const tags = document.createElementNS('http://www.w3.org/2000/svg','text');
    tags.setAttribute('x', tagX);
    tags.setAttribute('y', tagY);
    tags.setAttribute('class', 'tag-text');
    tags.setAttribute('fill', n.tagColor || "#b7c0df");
    tags.style.fontSize = (n.tagFont || 11) + "px";
    
    // Build tag text based on visibility settings
    const tagParts = [];
    if (state.ui.showNodeTags && n.tags?.length) {
      tagParts.push(n.tags.join(', '));
    }
    if (state.ui.showExtraTags && n.extraTags?.trim()) {
      tagParts.push(n.extraTags.trim());
    }
    tags.textContent = tagParts.join(' | ');
    
    tags.style.pointerEvents = "auto";  // Enable pointer events for Ctrl+drag
    tags.style.cursor = "default";

    g.appendChild(c); g.appendChild(t); g.appendChild(tags);

    // Handle clicks on the node group (for link mode and regular selection)
    // Use mouseup instead of click to ensure it fires even after mousedown's stopPropagation
    console.log(`[NODE LISTENER] Attaching mouseup listener to node ${n.id}`);
    g.addEventListener('mouseup', (ev) => {
      const isWithinGroup = g.contains(ev.target);
      const isCircle = ev.target === c;
      const isGroup = ev.target === g;
      console.log(`[NODE CLICK] Node ${n.id} - mouseup target: ${ev.target.tagName}/${ev.target.getAttribute?.('class') ?? 'none'}, isCircle: ${isCircle}, isGroup: ${isGroup}, withinGroup: ${isWithinGroup}, linkMode: ${linkMode}, dragging: ${!!state.dragging}`);
      
      // Process if clicked on circle, group, or any child within the group
      if (isCircle || isGroup || isWithinGroup) {
        console.log(`[NODE CLICK] Node ${n.id} clicked (mouseup) - linkMode: ${linkMode}, linkSourceNode: ${linkSourceNode}`);
        
        // Handle link mode clicks - these take priority over drag detection
        if (linkMode) {
          ev.stopPropagation(); // Only stop propagation in link mode
          if (linkSourceNode === null) {
            // First click - set source node
            linkSourceNode = n.id;
            console.log(`[LINK MODE] Node ${n.id} set as SOURCE - waiting for target click`);
            select({type:'node', id:n.id});
            render(); // Show the orange highlight for the source node
            showToast(`Link source selected: ${n.name || `N${n.id}`} ‚Üí Now click target node`);
            return;
          } else {
            // Second click - create link
            if (linkSourceNode === n.id) {
              console.log(`[LINK MODE] Node ${n.id} - ERROR: Cannot link to itself`);
              showToast('‚ùå Cannot link node to itself - click a different target node');
              return;
            }
            console.log(`[LINK MODE] Node ${n.id} set as TARGET - Creating link from ${linkSourceNode} to ${n.id}`);
            const sourceId = linkSourceNode;
            linkSourceNode = null;  // Reset for next link - ready to select new source
            createEdge(sourceId, n.id, true); // Skip edge selection in link mode
            clearSelection(); // Clear any selection to show we're ready for next source
            render(); // Update display to show cleared selection
            showToast(`‚úì Link created! Click a node to be the source for the next link`);
            return;
          }
        }
        
        // Check if this was actually a drag operation (only matters outside link mode)
        if (state.dragging) {
          console.log(`[NODE CLICK] Node ${n.id} - Was dragging, letting global handler clear state`);
          // Don't stop propagation - let the global mouseup handler clear state.dragging
          return;
        }
        
        // Not in link mode and not dragging - regular selection click
        console.log(`[NODE CLICK] Node ${n.id} - Normal selection`);
        ev.stopPropagation();
        
        // Handle shift-click for multi-selection
        if (ev.shiftKey) {
          if (state.selection.nodes.has(n.id)) {
            state.selection.nodes.delete(n.id);
            state.selected = null;
          } else {
            state.selection.nodes.add(n.id);
            state.selected = null;
          }
          render();
          return;
        }
        
        // Normal click - select this node
        select({type:'node', id:n.id});
        render();
      }
    });

    g.addEventListener('mousedown', (ev) => {
      // In link mode, don't set up dragging or select - let mouseup handle everything
      if (linkMode) {
        ev.stopPropagation();
        console.log(`[NODE MOUSEDOWN] Node ${n.id} - in link mode, skipping drag setup`);
        return;
      }

      // Shift+click without Ctrl - let mouseup handle multi-selection, don't set up dragging
      if (ev.shiftKey && !(ev.ctrlKey || ev.metaKey)) {
        ev.stopPropagation();
        console.log(`[NODE MOUSEDOWN] Node ${n.id} - Shift+click, letting mouseup handle multi-select`);
        return;
      }

      // Normal mode - set up dragging
      ev.stopPropagation();
      const m = getMouse(ev);
      state.lastMouse = { x: m.x, y: m.y };

      // Ctrl+Shift+drag duplicates current selection and drags the copy
      if ((ev.ctrlKey || ev.metaKey) && ev.shiftKey) {
        if (!state.selection.nodes.has(n.id) && !state.selection.groups.size && !state.selection.edges.size) {
          setSingleSelection({type:'node', id:n.id});
        }
        copySelection();
        pasteSelection();
        // start dragging the pasted selection as a block
        const origNodes = [...state.selection.nodes].map(id => {
          const nn = findNode(id); return nn ? {id, x: nn.x, y: nn.y} : null;
        }).filter(Boolean);
        const origGroups = [...state.selection.groups].map(id => {
          const gg = findGroup(id); return gg ? {id, x: gg.x, y: gg.y} : null;
        }).filter(Boolean);
        state.dragging = { type:'selection', mx0: m.x, my0: m.y, origNodes, origGroups };
        state.connectFrom = null;
        render();
        return;
      }

      // Check BEFORE calling select() to preserve multi-selection if dragging
      // If the clicked node is part of a multi-selection, drag entire selection
      if (state.selection.nodes.has(n.id) && (state.selection.nodes.size > 1 || state.selection.groups.size > 0)) {
        console.log(`[MULTI-DRAG] Node ${n.id} is part of multi-selection (${state.selection.nodes.size} nodes, ${state.selection.groups.size} groups) - setting up multi-drag`);
        const origNodes = [...state.selection.nodes].map(id => {
          const nn = findNode(id); return nn ? {id, x: nn.x, y: nn.y} : null;
        }).filter(Boolean);
        const origGroups = [...state.selection.groups].map(id => {
          const gg = findGroup(id); return gg ? {id, x: gg.x, y: gg.y} : null;
        }).filter(Boolean);
        state.dragging = { type:'selection', mx0: m.x, my0: m.y, origNodes, origGroups };
        state.selected = null; // Clear single selection when dragging multiple
        console.log(`[MULTI-DRAG] Dragging ${origNodes.length} nodes and ${origGroups.length} groups`);
      } else {
        console.log(`[SINGLE-DRAG] Node ${n.id} - single selection drag setup`);
        // Don't call select() here - it triggers render() which recreates DOM and breaks drag
        // Just add to selection set for visual feedback
        if (!state.selection.nodes.has(n.id)) {
          setSingleSelection({type:'node', id:n.id});
        }
        state.dragging = { type:'node', id:n.id, dx: n.x - m.x, dy: n.y - m.y };
      }
      state.connectFrom = null;
    });

    t.addEventListener('mousedown', (ev) => {
      console.log(`[TEXT MOUSEDOWN] Node ${n.id} name label - Ctrl: ${ev.ctrlKey}, Meta: ${ev.metaKey}`);
      // Ctrl+drag to move the label
      if (ev.ctrlKey || ev.metaKey) {
        console.log(`[TEXT MOUSEDOWN] Node ${n.id} - Setting up name label drag`);
        ev.stopPropagation();
        const m = getMouse(ev);
        state.dragging = { type:'nodeNameLabel', id:n.id, dx: nameX - m.x, dy: nameY - m.y };
        select({type:'node', id:n.id});
        state.connectFrom = null;
        render();
        return;
      }
      // Normal click - don't handle it here, let it bubble to parent group
    });
    
    tags.addEventListener('mousedown', (ev) => {
      console.log(`[TAGS MOUSEDOWN] Node ${n.id} tags - Ctrl: ${ev.ctrlKey}, Meta: ${ev.metaKey}`);
      // Ctrl+drag to move the tags
      if (ev.ctrlKey || ev.metaKey) {
        console.log(`[TAGS MOUSEDOWN] Node ${n.id} - Setting up tags drag`);
        ev.stopPropagation();
        const m = getMouse(ev);
        state.dragging = { type:'nodeTagLabel', id:n.id, dx: tagX - m.x, dy: tagY - m.y };
        select({type:'node', id:n.id});
        state.connectFrom = null;
        render();
        return;
      }
      // Normal click - don't handle it here, let it bubble to parent group
    });

    // console.log(`[DRAW] Node ${n.id} fully created, appending to SVG`);
    svg.appendChild(g);
    // Verify circle is in DOM and has proper bounds
    const circles = g.querySelectorAll('circle, polygon');
    // console.log(`[DRAW] Node ${n.id} appended - found ${circles.length} circle(s) in group`, circles[0] ? {cx: circles[0].getAttribute('cx'), cy: circles[0].getAttribute('cy'), r: circles[0].getAttribute('r')} : 'none');
  }

  const noSel = document.getElementById('noSelection');
  const nodeIns = document.getElementById('nodeInspector');
  const edgeIns = document.getElementById('edgeInspector');
  const groupIns = document.getElementById('groupInspector');

  // UUID fields (read-only)
  const nodeUUID = document.getElementById('nodeUUID');
  const edgeUUID = document.getElementById('edgeUUID');
  const edgeSourceUUID = document.getElementById('edgeSourceUUID');
  const edgeTargetUUID = document.getElementById('edgeTargetUUID');
  const groupUUID = document.getElementById('groupUUID');

  const nodeName = document.getElementById('nodeName');
  const nodeTags = document.getElementById('nodeTags');
  const nodeGroup = document.getElementById('nodeGroup');
  const nodeExtraTags = document.getElementById('nodeExtraTags');
  const nodeCode = document.getElementById('nodeCode');
  const nodeShowCode = document.getElementById('nodeShowCode');
  const nodeNameFont = document.getElementById('nodeNameFont');
  const nodeTagFont = document.getElementById('nodeTagFont');
  const nodeNameColor = document.getElementById('nodeNameColor');
  const nodeTagColor = document.getElementById('nodeTagColor');
  const nodeFill = document.getElementById('nodeFill');
  const nodeStroke = document.getElementById('nodeStroke');
  const nodeStrokeW = document.getElementById('nodeStrokeW');
  const nodeAddress = document.getElementById('nodeAddress');
const nodeCity = document.getElementById('nodeCity');
const nodeCountry = document.getElementById('nodeCountry');
  const nodeSize = document.getElementById('nodeSize');
const edgeTag = document.getElementById('edgeTag');
  const edgeFilterTags = document.getElementById('edgeFilterTags');
  const edgeLatency = document.getElementById('edgeLatency');
  const edgeExtraTags = document.getElementById('edgeExtraTags');
  const edgeCode = document.getElementById('edgeCode');
  const edgeShowCode = document.getElementById('edgeShowCode');
  const edgeStyle = document.getElementById('edgeStyle');
  const edgeRoute = document.getElementById('edgeRoute');
  const edgeLabelFont = document.getElementById('edgeLabelFont');
  const edgeLabelColor = document.getElementById('edgeLabelColor');
  const edgeStrokeW = document.getElementById('edgeStrokeW');
  const edgeCapacity = document.getElementById('edgeCapacity');
  const edgeStrokeColor = document.getElementById('edgeStrokeColor');
const groupTitle = document.getElementById('groupTitle');
  const groupFilterTags = document.getElementById('groupFilterTags');
  const groupType = document.getElementById('groupType');
  const groupParent = document.getElementById('groupParent');
  const groupExtraTags = document.getElementById('groupExtraTags');
  const groupW = document.getElementById('groupW');
  const groupH = document.getElementById('groupH');
  const groupTitleFont = document.getElementById('groupTitleFont');
  const groupTitleColor = document.getElementById('groupTitleColor');
  const groupFill = document.getElementById('groupFill');
  const groupStroke = document.getElementById('groupStroke');
  const groupStrokeW = document.getElementById('groupStrokeW');

  // Preset controls
  const btnNodePresetSave = document.getElementById('btnNodePresetSave');
  const btnNodePresetApply = document.getElementById('btnNodePresetApply');
  const btnNodePresetDelete = document.getElementById('btnNodePresetDelete');

  const btnEdgePresetSave = document.getElementById('btnEdgePresetSave');
  const btnEdgePresetApply = document.getElementById('btnEdgePresetApply');
  const btnEdgePresetDelete = document.getElementById('btnEdgePresetDelete');

  const btnGroupPresetSave = document.getElementById('btnGroupPresetSave');
  const btnGroupPresetApply = document.getElementById('btnGroupPresetApply');
  const btnGroupPresetDelete = document.getElementById('btnGroupPresetDelete');


  
  function clearSelection(keepSingle=false) {
    state.selection.nodes.clear();
    state.selection.edges.clear();
    state.selection.groups.clear();
    if (!keepSingle) state.selected = null;
  }

  function setSingleSelection(sel) {
    clearSelection(true);
    state.selected = sel;
    if (sel) {
      console.log(`[SELECTION] ${sel.type.toUpperCase()} selected: id=${sel.id}`);
    }
    if (!sel) return;

    // Apply format painter if armed (single-click targets)
    if (state.styleBrush && state.styleBrush.type === sel.type) {
      if (sel.type === 'node') {
        const n = findNode(sel.id); if (n) applyStyle('node', n, state.styleBrush.style);
      } else if (sel.type === 'edge') {
        const e = findEdge(sel.id); if (e) applyStyle('edge', e, state.styleBrush.style);
      } else if (sel.type === 'group') {
        const g = findGroup(sel.id); if (g) applyStyle('group', g, state.styleBrush.style);
      }
      commit();
    }

    if (sel.type === 'node') state.selection.nodes.add(sel.id);
    if (sel.type === 'edge') state.selection.edges.add(sel.id);
    if (sel.type === 'group') state.selection.groups.add(sel.id);
  }

  function setMultiSelection({nodes=[], edges=[], groups=[]}) {
    state.selected = null;
    state.selection.nodes = new Set(nodes);
    state.selection.edges = new Set(edges);
    state.selection.groups = new Set(groups);
  }

  function deleteSelection() {
    const nIds = new Set(state.selection.nodes);
    const eIds = new Set(state.selection.edges);
    const gIds = new Set(state.selection.groups);
    if (nIds.size===0 && eIds.size===0 && gIds.size===0) return;

    // Delete edges explicitly selected
    if (eIds.size) state.edges = state.edges.filter(e => !eIds.has(e.id));

    // Delete nodes and any edges attached to them
    if (nIds.size) {
      state.nodes = state.nodes.filter(n => !nIds.has(n.id));
      state.edges = state.edges.filter(e => !nIds.has(e.a) && !nIds.has(e.b));
    }

    // Delete groups (country/region)
    if (gIds.size) {
      state.groups = state.groups.filter(g => !gIds.has(g.id));
      // Clear node membership to deleted groups
      state.nodes.forEach(n => { if (n.groupId && gIds.has(n.groupId)) n.groupId = null; });
      // Clear parentId links pointing to deleted regions
      state.groups.forEach(g => { if (g.parentId && gIds.has(g.parentId)) g.parentId = null; });
    }

    clearSelection();
    state.connectFrom = null;
    refreshAllMemberships();
    commit();
    render();
    showToast('Deleted selection.');
  }

  function select(sel) { setSingleSelection(sel); }


  function updateInspector() {
    refreshPresetSelects();
    noSel.style.display='none'; nodeIns.style.display='none'; edgeIns.style.display='none'; groupIns.style.display='none';
    noSel.textContent = 'Nothing selected.';
    if (!state.selected) {
      const c = state.selection.nodes.size + state.selection.edges.size + state.selection.groups.size;
      if (c === 0) { noSel.style.display='block'; return; }
      noSel.style.display='block';
      noSel.textContent = `Multiple selected: ${c} item(s). (Ctrl+C to copy, Ctrl+V to paste)`;
      return;
    }

    if (state.selected.type === 'node') {
      const n = findNode(state.selected.id); if (!n) return;
      nodeIns.style.display='block';
      // Show UUID (generate if missing for legacy data)
      if (!n.uuid) n.uuid = generateUUID();
      if (nodeUUID) nodeUUID.value = n.uuid;
      nodeName.value = n.name || '';
      // Ensure 'default' tag is shown in tags field
      let tagsArray = n.tags || [];
      if (!tagsArray.some(t => t.trim().toLowerCase() === 'default')) {
        tagsArray = ['default', ...tagsArray];
      }
      nodeTags.value = tagsArray.join(', ');
      nodeExtraTags.value = n.extraTags || '';
      nodeCode.value = n.code || '';
      nodeShowCode.value = (n.showCode !== false) ? '1' : '0';
      nodeNameFont.value = n.nameFont ?? 13;
      nodeTagFont.value = n.tagFont ?? 11;
      nodeNameColor.value = n.nameColor || "#333333";
      nodeTagColor.value = n.tagColor || "#666666";
      nodeFill.value = n.fill || "#dae8fc";
      nodeStroke.value = n.stroke || "#6c8ebf";
      if (nodeStrokeW) nodeStrokeW.value = n.strokeW ?? 2;
      if (nodeSize) nodeSize.value = n.r ?? 24;
      if (nodeStrokeW) nodeStrokeW.value = n.strokeW ?? 2;
      const g = n.groupId ? findGroup(n.groupId) : null;
      nodeGroup.value = g ? g.title : '(none)';
      // Update color pickers
      if (window.updateColorPickers) window.updateColorPickers();
      return;
    }

    if (state.selected.type === 'edge') {
      const e = findEdge(state.selected.id); if (!e) return;
      edgeIns.style.display='block';
      // Show UUIDs (generate if missing for legacy data)
      if (!e.uuid) e.uuid = generateUUID();
      if (edgeUUID) edgeUUID.value = e.uuid;
      // Show source and target node UUIDs
      const sourceNode = findNode(e.a);
      const targetNode = findNode(e.b);
      if (edgeSourceUUID) {
        if (sourceNode) {
          if (!sourceNode.uuid) sourceNode.uuid = generateUUID();
          edgeSourceUUID.value = sourceNode.uuid;
        } else {
          edgeSourceUUID.value = '(unknown)';
        }
      }
      if (edgeTargetUUID) {
        if (targetNode) {
          if (!targetNode.uuid) targetNode.uuid = generateUUID();
          edgeTargetUUID.value = targetNode.uuid;
        } else {
          edgeTargetUUID.value = '(unknown)';
        }
      }
      edgeTag.value = e.tag || '';
      // Ensure 'default' tag is shown in filter tags field
      let edgeTagsArray = e.filterTags || [];
      if (!edgeTagsArray.some(t => t.trim().toLowerCase() === 'default')) {
        edgeTagsArray = ['default', ...edgeTagsArray];
      }
      if (edgeFilterTags) edgeFilterTags.value = edgeTagsArray.join(', ');
      edgeLatency.value = (typeof e.latencyMs === "number" && isFinite(e.latencyMs)) ? e.latencyMs : '';
      edgeExtraTags.value = e.extraTags || '';
      edgeCode.value = e.code || '';
      edgeShowCode.value = (e.showCode !== false) ? '1' : '0';
      edgeStyle.value = e.style || 'straight';
      edgeRoute.value = e.route || 'hv';
      edgeLabelFont.value = e.labelFont ?? 12;
      edgeLabelColor.value = e.labelColor || "#333333";
      if (edgeStrokeW) edgeStrokeW.value = e.strokeW ?? 2;
      if (edgeStrokeColor) edgeStrokeColor.value = e.strokeColor || "#666666";
      // Update color pickers
      if (window.updateColorPickers) window.updateColorPickers();
      // Show/hide curve arch control based on style
      const curveArchControl = document.getElementById('curveArchControl');
      if (e.style === 'curve') {
        curveArchControl.style.display = 'block';
        edgeCurveArch.value = (e.curveArch || 0.3);
        document.getElementById('curveArchValue').textContent = (e.curveArch || 0.3).toFixed(2);
      } else {
        curveArchControl.style.display = 'none';
      }
      return;
    }

    if (state.selected.type === 'group') {
      const g = findGroup(state.selected.id); if (!g) return;
      groupIns.style.display='block';
      // Show UUID (generate if missing for legacy data)
      if (!g.uuid) g.uuid = generateUUID();
      if (groupUUID) groupUUID.value = g.uuid;
      groupTitle.value = g.title || '';
      // Ensure 'default' tag is shown in filter tags field
      let groupTagsArray = g.filterTags || [];
      if (!groupTagsArray.some(t => t.trim().toLowerCase() === 'default')) {
        groupTagsArray = ['default', ...groupTagsArray];
      }
      if (groupFilterTags) groupFilterTags.value = groupTagsArray.join(', ');
      groupType.value = g.type || 'country';
      // Parent Region dropdown
      while (groupParent.firstChild) groupParent.removeChild(groupParent.firstChild);
      const optNone = document.createElement('option');
      optNone.value = '';
      optNone.textContent = '(none)';
      groupParent.appendChild(optNone);
      state.groups.filter(r => r.type === 'region').forEach(r => {
        const opt = document.createElement('option');
        opt.value = String(r.id);
        opt.textContent = r.title || `Region${r.id}`;
        groupParent.appendChild(opt);
      });
      groupParent.value = g.parentId ? String(g.parentId) : '';
      groupParent.disabled = (g.type !== 'country');

      groupExtraTags.value = g.extraTags || '';
      groupW.value = Math.round(g.w);
      groupH.value = Math.round(g.h);
      groupTitleFont.value = g.titleFont ?? 14;
      groupTitleColor.value = g.titleColor || "#333333";
      groupFill.value = g.fill || "#ffffff";
      groupStroke.value = g.stroke || "#666666";
      if (groupStrokeW) groupStrokeW.value = g.strokeW ?? 1;
      // Update color pickers
      if (window.updateColorPickers) window.updateColorPickers();
    }
  }

  nodeName.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.name = nodeName.value; commit(); render();
  });
  nodeTags.addEventListener('change', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    let tags = nodeTags.value.split(',').map(s=>s.trim()).filter(Boolean);
    // Ensure 'default' is always present
    if (!tags.some(t => t.toLowerCase() === 'default')) {
      tags = ['default', ...tags];
    }
    n.tags = tags;
    commit(); render();
  });
  nodeExtraTags.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.extraTags = nodeExtraTags.value; commit(); render();
  });
  nodeCode.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.code = nodeCode.value; commit(); render();
  });
  nodeShowCode.addEventListener('change', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.showCode = nodeShowCode.value === '1'; commit(); render();
  });

  nodeNameFont.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.nameFont = clamp(Number(nodeNameFont.value||13),6,72); commit(); render();
  });
  nodeTagFont.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.tagFont = clamp(Number(nodeTagFont.value||11),6,72); commit(); render();
  });
  nodeNameColor.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.nameColor = nodeNameColor.value; commit(); render();
  });
  nodeTagColor.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.tagColor = nodeTagColor.value; commit(); render();
  });
  nodeFill.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.fill = nodeFill.value; commit(); render();
  });
  nodeStroke.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.stroke = nodeStroke.value; commit(); render();
  });
  if (nodeStrokeW) nodeStrokeW.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.strokeW = clamp(Number(nodeStrokeW.value||2),0.5,12);
    commit(); render();
  });

if (edgeStrokeColor) edgeStrokeColor.addEventListener('input', () => {
  if (state.selected?.type!=='edge') return;
  const e = findEdge(state.selected.id); if (!e) return;
  e.strokeColor = edgeStrokeColor.value;
  commit(); render();
});

  if (nodeSize) nodeSize.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.r = clamp(Number(nodeSize.value||24),10,80);
    commit(); render();
  });

// Node address/city/country listeners
if (nodeAddress) nodeAddress.addEventListener('input', () => {
  if (state.selected?.type!=='node') return;
  const n = findNode(state.selected.id); if (!n) return;
  n.address = nodeAddress.value; commit(); render();
});

if (nodeCity) nodeCity.addEventListener('input', () => {
  if (state.selected?.type!=='node') return;
  const n = findNode(state.selected.id); if (!n) return;
  n.city = nodeCity.value; commit(); render();
});

if (nodeCountry) nodeCountry.addEventListener('input', () => {
  if (state.selected?.type!=='node') return;
  const n = findNode(state.selected.id); if (!n) return;
  n.country = nodeCountry.value; commit(); render();
});

// Edge capacity listener
if (edgeCapacity) edgeCapacity.addEventListener('input', () => {
  if (state.selected?.type!=='edge') return;
  const e = findEdge(state.selected.id); if (!e) return;
  e.capacity = edgeCapacity.value; commit(); render();
});

  edgeTag.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.tag = edgeTag.value; commit(); render();
  });
  if (edgeFilterTags) {
    edgeFilterTags.addEventListener('change', () => {
      if (state.selected?.type!=='edge') return;
      const e = findEdge(state.selected.id); if (!e) return;
      let tags = edgeFilterTags.value.split(',').map(s=>s.trim()).filter(Boolean);
      // Ensure 'default' is always present
      if (!tags.some(t => t.toLowerCase() === 'default')) {
        tags = ['default', ...tags];
      }
      e.filterTags = tags;
      commit(); render();
    });
  }
  edgeLatency.addEventListener('change', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    const raw = String(edgeLatency.value ?? '').trim();
    if (raw === '') { e.latencyMs = null; commit(); render(); return; }
    // Replace comma with period for locales that use comma as decimal separator
    const v = parseFloat(raw.replace(',', '.'));
    if (Number.isFinite(v) && v >= 0) { 
      e.latencyMs = v; 
      edgeLatency.value = v; // Normalize the display
      commit(); 
      render(); 
    } else {
      // Invalid input - revert to previous value
      edgeLatency.value = (typeof e.latencyMs === "number" && isFinite(e.latencyMs)) ? e.latencyMs : '';
    }
  });
  edgeExtraTags.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.extraTags = edgeExtraTags.value; commit(); render();
  });
  edgeCode.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.code = edgeCode.value; commit(); render();
  });
  edgeShowCode.addEventListener('change', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.showCode = edgeShowCode.value === '1'; commit(); render();
  });

  edgeStyle.addEventListener('change', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.style = edgeStyle.value; 
    // Show/hide curve arch control
    const curveArchControl = document.getElementById('curveArchControl');
    if (e.style === 'curve') {
      curveArchControl.style.display = 'block';
      if (!e.curveArch) e.curveArch = 0.3;
      edgeCurveArch.value = e.curveArch;
      document.getElementById('curveArchValue').textContent = e.curveArch.toFixed(2);
    } else {
      curveArchControl.style.display = 'none';
    }
    commit(); render();
  });
  edgeRoute.addEventListener('change', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.route = edgeRoute.value; commit(); render();
  });
  edgeCurveArch.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.curveArch = clamp(Number(edgeCurveArch.value||0.3), 0, 0.6);
    document.getElementById('curveArchValue').textContent = e.curveArch.toFixed(2);
    commit(); render();
  });
  edgeLabelFont.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.labelFont = clamp(Number(edgeLabelFont.value||12),6,72); commit(); render();
  });
  edgeLabelColor.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.labelColor = edgeLabelColor.value; commit(); render();
  });
  if (edgeStrokeW) edgeStrokeW.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.strokeW = clamp(Number(edgeStrokeW.value||2),0.5,12);
    commit(); render();
  });

  groupTitle.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.title = groupTitle.value; commit(); render();
  });
  if (groupFilterTags) {
    groupFilterTags.addEventListener('change', () => {
      if (state.selected?.type!=='group') return;
      const g = findGroup(state.selected.id); if (!g) return;
      let tags = groupFilterTags.value.split(',').map(s=>s.trim()).filter(Boolean);
      // Ensure 'default' is always present
      if (!tags.some(t => t.toLowerCase() === 'default')) {
        tags = ['default', ...tags];
      }
      g.filterTags = tags;
      commit(); render();
    });
  }
  groupType.addEventListener('change', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.type = groupType.value;
    // If switching away from country, clear parent + node memberships will recompute
    if (g.type !== 'country') g.parentId = null;
    refreshAllMemberships();
    commit(); render();
  });

  groupParent.addEventListener('change', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g || g.type !== 'country') return;
    g.parentId = groupParent.value ? Number(groupParent.value) : null;
    commit(); render();
  });

  groupExtraTags.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.extraTags = groupExtraTags.value; commit(); render();
  });
  groupW.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.w = clamp(Number(groupW.value||g.w),120,1600); refreshAllMemberships(); commit(); render();
  });
  groupH.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.h = clamp(Number(groupH.value||g.h),90,900); refreshAllMemberships(); commit(); render();
  });
  groupTitleFont.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.titleFont = clamp(Number(groupTitleFont.value||14),6,72); commit(); render();
  });
  groupTitleColor.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.titleColor = groupTitleColor.value; commit(); render();
  });
  groupFill.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.fill = groupFill.value; commit(); render();
  });
  groupStroke.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.stroke = groupStroke.value; commit(); render();
  });
  if (groupStrokeW) groupStrokeW.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.strokeW = clamp(Number(groupStrokeW.value||2),0.5,12);
    commit(); render();
  });


  // Preset buttons
  btnNodePresetSave.addEventListener('click', () => {
    console.log(`[PRESET SAVE] Button clicked - state.selected:`, state.selected);
    console.log(`[PRESET SAVE] state.selected?.type:`, state.selected?.type);
    if (state.selected?.type!=='node') { 
      showToast("Select a node first."); 
      console.log(`[PRESET SAVE] FAILED - not a node or no selection`);
      return; 
    }
    const n = findNode(state.selected.id); 
    console.log(`[PRESET SAVE] Found node:`, n);
    if (!n) return;
    savePreset('node', n);
  });
  btnNodePresetApply.addEventListener('click', () => {
    if (state.selected?.type!=='node') { showToast("Select a node first."); return; }
    const n = findNode(state.selected.id); if (!n) return;
    applyPreset('node', n, nodePresetSel.value);
  });
  btnNodePresetDelete.addEventListener('click', () => deletePreset('node', nodePresetSel.value));

  btnEdgePresetSave.addEventListener('click', () => {
    if (state.selected?.type!=='edge') { showToast("Select a link first."); return; }
    const e = findEdge(state.selected.id); if (!e) return;
    savePreset('edge', e);
  });
  btnEdgePresetApply.addEventListener('click', () => {
    if (state.selected?.type!=='edge') { showToast("Select a link first."); return; }
    const e = findEdge(state.selected.id); if (!e) return;
    applyPreset('edge', e, edgePresetSel.value);
  });
  btnEdgePresetDelete.addEventListener('click', () => deletePreset('edge', edgePresetSel.value));

  btnGroupPresetSave.addEventListener('click', () => {
    if (state.selected?.type!=='group') { showToast("Select a box first."); return; }
    const g = findGroup(state.selected.id); if (!g) return;
    savePreset('group', g);
  });
  btnGroupPresetApply.addEventListener('click', () => {
    if (state.selected?.type!=='group') { showToast("Select a box first."); return; }
    const g = findGroup(state.selected.id); if (!g) return;
    applyPreset('group', g, groupPresetSel.value);
  });
  btnGroupPresetDelete.addEventListener('click', () => deletePreset('group', groupPresetSel.value));

  function makeNode(id, x, y) {
    return {
      id,
      uuid: generateUUID(),
      x: x,
      y: y,
      shape: state.defaultNodeShape || 'circle', r:24, strokeW:2,
      address:'', city:'', country:'',
      name: `Node${id}`,
      code: `N-${id}`,
      showCode: true,
      tags: ['default'],
      extraTags:"",
      groupId:null,
      fill:"#dae8fc", stroke:"#6c8ebf",
      nameColor:"#333333", tagColor:"#666666",
      nameFont:13, tagFont:11,
      nameDx:0, nameDy:0, tagDx:0, tagDy:0
    };
  }

  function makeEdge(id, a, b) {
    return {
      id, a, b,
      uuid: generateUUID(),
      tag:'',
      filterTags: ['default'],
      latencyMs:null,
      strokeW:2,
      strokeColor:"#666666",
      capacity:'Up to 10G WL',
      code: `L-${id}`,
      showCode: true,
      extraTags:"",
      style:'straight',
      route:'hv',
      curveArch:0.3,
      labelDx:0, labelDy:0, labelFont:12, labelColor:"#333333"
    };
  }

  function makeGroup(id, x, y, type) {
    const isRegion = type === 'region';
    return {
      id,
      uuid: generateUUID(),
      type: isRegion ? 'region' : 'country',
      parentId: null,
      x: clamp(x,20,1400),
      y: clamp(y,20,760),
      w: isRegion ? 520 : 320,
      h: isRegion ? 320 : 220,
      title: isRegion ? `Region${id}` : "Country",
      filterTags: ['default'],
      extraTags:"",
      fill: isRegion ? "rgba(245, 245, 245, 0.9)" : "rgba(255, 255, 255, 0.95)",
      stroke: isRegion ? "#999999" : "#666666",
      strokeW: 1,
      titleColor:"#333333",
      titleFont: isRegion ? 15 : 14,
      titleDx:0, titleDy:0
    };
  }

  function createNode(x, y) {
    const id = state.nextNode++;
    const node = makeNode(id, x, y);
    state.nodes.push(node);
    updateNodeGroupMembership(node);
    select({type:'node', id});
    commit(); render();
    showToast(`Created node ${node.name}.`);
  }

  function createEdge(a, b, skipSelection = false) {
    // Allow multiple links between same nodes - no uniqueness check
    console.log(`[CREATE EDGE] Creating edge from node ${a} to node ${b}`);
    const id = state.nextEdge++;
    const newEdge = makeEdge(id, a, b);
    console.log(`[CREATE EDGE] Edge ${id} created, adding to state.edges. Total edges: ${state.edges.length + 1}`);
    state.edges.push(newEdge);
    if (!skipSelection) {
      select({type:'edge', id});
    }
    commit(); render();
    if (!skipSelection) {
      showToast('Created link. Edit fields in Inspector.');
    }
  }

  function createGroup(x, y, type='country') {
    const id = state.nextGroup++;
    const g = makeGroup(id, x, y, type);
    state.groups.push(g);

    if (g.type === 'country') updateCountryRegionMembership(g);
    refreshAllMemberships();

    select({type:'group', id});
    commit(); render();
    showToast(g.type === 'region' ? 'Created region box. Rename in Inspector.' : 'Created country box. Rename in Inspector.');
  }

    function deleteSelected() {
    const hasMulti = (state.selection.nodes.size + state.selection.edges.size + state.selection.groups.size) > 0;
    if (!state.selected && !hasMulti) return;

    // If single selection exists, ensure it's in sets
    if (state.selected) {
      if (state.selected.type==='node') state.selection.nodes.add(state.selected.id);
      if (state.selected.type==='edge') state.selection.edges.add(state.selected.id);
      if (state.selected.type==='group') state.selection.groups.add(state.selected.id);
      state.selected = null;
    }

    const nodeIds = new Set(state.selection.nodes);
    const edgeIds = new Set(state.selection.edges);
    const groupIds = new Set(state.selection.groups);

    // If deleting groups: remove them and clear node memberships
    if (groupIds.size) {
      state.groups = state.groups.filter(g => !groupIds.has(g.id));
      state.nodes.forEach(n => { if (groupIds.has(n.groupId)) n.groupId = null; });
    }

    // Delete nodes and any edges connected to them
    if (nodeIds.size) {
      state.nodes = state.nodes.filter(n => !nodeIds.has(n.id));
      state.edges = state.edges.filter(e => !nodeIds.has(e.a) && !nodeIds.has(e.b));
    }

    // Delete explicitly selected edges (if still present)
    if (edgeIds.size) {
      state.edges = state.edges.filter(e => !edgeIds.has(e.id));
    }

    refreshAllMemberships();
    clearSelection();
    commit();
    render();
    showToast('Deleted selected item(s).');
  }


  svg.addEventListener('mousedown', (ev) => {
    // Middle mouse button for panning
    if (ev.button === 1) {
      ev.preventDefault();
      const wrap = document.getElementById('wrap');
      state.dragging = { 
        type: 'canvasPan', 
        startScrollX: wrap.scrollLeft, 
        startScrollY: wrap.scrollTop,
        startMouseX: ev.clientX,
        startMouseY: ev.clientY
      };
      svg.style.cursor = 'grabbing';
      return;
    }

    // Only left button from here on
    if (ev.button !== 0) return;
    if (state.placingGroup) return;
    if (ev.target !== svg) return; // only empty space

    const m = getMouse(ev);
    state.lastMouse = { x: m.x, y: m.y };

    // Alt+drag for marquee selection
    if (ev.altKey) {
      state.marquee = { x0: m.x, y0: m.y, x: m.x, y: m.y, w: 0, h: 0, additive: ev.shiftKey };
      if (!state.marquee.additive) clearSelection();
      state.connectFrom = null;
      render();
      return;
    }

    // Default: click and drag to pan the canvas
    const wrap = document.getElementById('wrap');
    state.dragging = { 
      type: 'canvasPan', 
      startScrollX: wrap.scrollLeft, 
      startScrollY: wrap.scrollTop,
      startMouseX: ev.clientX,
      startMouseY: ev.clientY
    };
    svg.style.cursor = 'grabbing';
  });

  svg.addEventListener('dblclick', (ev) => {
    const m = getMouse(ev);
    if (state.placingGroup) return;
    createNode(m.x, m.y);
  });

  // Consolidated SVG canvas click handler: group placement + selection clearing + debug alt+click
  svg.addEventListener('click', (ev) => {
    const target = ev.target;
    const tagName = target?.tagName ?? 'unknown';
    const className = target?.getAttribute?.('class') ?? 'none';
    const isDirectSvg = ev.target === svg;
    console.log(`[CANVAS CLICK] target: ${tagName}/${className}, directSVG: ${isDirectSvg}, linkMode: ${linkMode}`);
    
    // Handle group placement
    if (state.placingGroup) {
      const m = getMouse(ev);
      createGroup(m.x, m.y, state.placingGroupType || 'country');
      state.placingGroup = false;
      state.placingGroupType = 'country';
      state.stylePresets = state.stylePresets || { node: {}, edge: {}, group: {} };
      state.styleBrush = null;
      document.getElementById('btnAddGroup').classList.remove('primary');
      document.getElementById('btnAddRegion').classList.remove('primary');
      render();
      return;
    }
    
    // Debug: Alt+click on canvas shows coordinates (helps confirm handlers are active)
    if (ev.altKey) {
      const m = getMouse(ev);
      showToast(`Canvas click @ ${Math.round(m.x)}, ${Math.round(m.y)}`);
    }
    
    // Only clear selection if clicking directly on the SVG background, not on child elements
    if (ev.target === svg) {
      console.log(`[CANVAS CLICK] Clearing selection (clicked empty canvas)`);
      clearSelection(); state.connectFrom=null; render();
    }
  });

  svg.addEventListener('mousemove', (ev) => {
    const m = getMouse(ev);
    state.lastMouse = { x: m.x, y: m.y };

    // Handle canvas panning
    if (state.dragging && state.dragging.type === 'canvasPan') {
      const wrap = document.getElementById('wrap');
      const dx = ev.clientX - state.dragging.startMouseX;
      const dy = ev.clientY - state.dragging.startMouseY;
      wrap.scrollLeft = state.dragging.startScrollX - dx;
      wrap.scrollTop = state.dragging.startScrollY - dy;
      return;
    }

    if (state.marquee) {
      const x1 = state.marquee.x0, y1 = state.marquee.y0;
      const x2 = m.x, y2 = m.y;
      const x = Math.min(x1, x2);
      const y = Math.min(y1, y2);
      const w = Math.abs(x2 - x1);
      const h = Math.abs(y2 - y1);
      state.marquee.x = x; state.marquee.y = y; state.marquee.w = w; state.marquee.h = h;
      render();
      return;
    }


    if (state.resizingGroup) {
      const g = findGroup(state.resizingGroup.id);
      if (!g) return;
      const dx = m.x - state.resizingGroup.mx0;
      const dy = m.y - state.resizingGroup.my0;
      g.w = Math.max(120, state.resizingGroup.startW + dx);
      g.h = Math.max(90, state.resizingGroup.startH + dy);
      refreshAllMemberships();
      render();
      return;
    }

    if (!state.dragging) return;

    if (state.dragging.type === 'selection') {
      const dx = m.x - state.dragging.mx0;
      const dy = m.y - state.dragging.my0;
      state.dragging.origGroups.forEach(o => {
        const g = findGroup(o.id); if (!g) return;
        g.x = o.x + dx;
        g.y = o.y + dy;
      });
      state.dragging.origNodes.forEach(o => {
        const n = findNode(o.id); if (!n) return;
        n.x = o.x + dx;
        n.y = o.y + dy;
      });
      refreshAllMemberships();
      render();
      return;
    }

    if (state.dragging.type === 'edgeLabel') {
      const e = findEdge(state.dragging.id); if (!e) return;
      const a = findNode(e.a), b = findNode(e.b); if (!a || !b) return;
      let base = (e.style==='orthogonal') ? orthogonalBaseLabelPoint(a.x,a.y,b.x,b.y,e.route||'hv') : {x:(a.x+b.x)/2,y:(a.y+b.y)/2};
      const targetX = m.x + state.dragging.dx;
      const targetY = m.y + state.dragging.dy;
      e.labelDx = targetX - base.x;
      e.labelDy = targetY - base.y;
      render();
      return;
    }

    if (state.dragging.type === 'curveHandle') {
      const e = findEdge(state.dragging.edgeId); if (!e) return;
      const a = findNode(e.a), b = findNode(e.b); if (!a || !b) return;
      // Calculate perpendicular distance from line AB
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist === 0) return;
      // Vector from A to current mouse
      const mx = m.x - a.x;
      const my = m.y - a.y;
      // Project onto perpendicular to AB
      const perpDist = (mx * (-dy) + my * dx) / dist;
      // Convert perpendicular distance to arch value
      // arch = perpDist / (dist * 0.5)
      e.curveArch = clamp(perpDist / (dist * 0.5), -0.6, 0.6);
      // Update slider to match
      edgeCurveArch.value = e.curveArch;
      document.getElementById('curveArchValue').textContent = e.curveArch.toFixed(2);
      render();
      return;
    }

    if (state.dragging.type === 'nodeNameLabel') {
      const n = findNode(state.dragging.id); if (!n) return;
      const targetX = m.x + state.dragging.dx;
      const targetY = m.y + state.dragging.dy;
      n.nameDx = targetX - n.x;
      n.nameDy = targetY - n.y;
      render();
      return;
    }

    if (state.dragging.type === 'nodeTagLabel') {
      const n = findNode(state.dragging.id); if (!n) return;
      const targetX = m.x + state.dragging.dx;
      const targetY = m.y + state.dragging.dy;
      n.tagDx = targetX - n.x;
      n.tagDy = targetY - (n.y + 26);
      render();
      return;
    }

    if (state.dragging.type === 'groupTitleLabel') {
      const g = findGroup(state.dragging.id); if (!g) return;
      const targetX = m.x + state.dragging.dx;
      const targetY = m.y + state.dragging.dy;
      g.titleDx = targetX - (g.x + 14);
      g.titleDy = targetY - (g.y + 22);
      render();
      return;
    }

    if (state.dragging.type === 'node') {
      const n = findNode(state.dragging.id); if (!n) return;
      n.x = m.x + state.dragging.dx;
      n.y = m.y + state.dragging.dy;
      updateNodeGroupMembership(n);
      render();
      return;
    }

    if (state.dragging.type === 'group') {
      const g = findGroup(state.dragging.id); if (!g) return;
      const oldX = g.x, oldY = g.y;
      g.x = m.x + state.dragging.dx;
      g.y = m.y + state.dragging.dy;
      const dx = g.x - oldX;
      const dy = g.y - oldY;

      if (g.type === 'region') {
        // Move all child countries (and their nodes) along with the region
        state.groups.forEach(c => {
          if (c.type === 'country' && c.parentId === g.id) {
            c.x = c.x + dx;
            c.y = c.y + dy;
          }
        });
        state.nodes.forEach(n => {
          const country = n.groupId ? findGroup(n.groupId) : null;
          if (country && country.type === 'country' && country.parentId === g.id) {
            n.x = n.x + dx;
            n.y = n.y + dy;
          }
        });
      } else {
        // Move nodes inside the country box along with it
        state.nodes.forEach(n => {
          if (n.groupId === g.id) {
            n.x = n.x + dx;
            n.y = n.y + dy;
          }
        });
      }

      refreshAllMemberships();
      render();
    }
  });

  window.addEventListener('mouseup', () => {
    // finalize marquee selection
    if (state.marquee) {
      const box = { x: state.marquee.x, y: state.marquee.y, w: state.marquee.w, h: state.marquee.h };
      const insideNode = (n) => n.x >= box.x && n.x <= box.x + box.w && n.y >= box.y && n.y <= box.y + box.h;
      const rectsIntersect = (a, b) => !(a.x+a.w < b.x || b.x+b.w < a.x || a.y+a.h < b.y || b.y+b.h < a.y);

      const nodes = state.nodes.filter(insideNode).map(n=>n.id);
      const groups = state.groups.filter(g => rectsIntersect({x:g.x,y:g.y,w:g.w,h:g.h}, box)).map(g=>g.id);

      // edges where both endpoints are selected (node selection)
      const nodeSet = new Set([...state.selection.nodes, ...nodes]);
      const edges = state.edges.filter(e => nodeSet.has(e.a) && nodeSet.has(e.b)).map(e=>e.id);

      // apply selection (additive if shift held at start)
      if (state.marquee.additive) {
        nodes.forEach(id => state.selection.nodes.add(id));
        groups.forEach(id => state.selection.groups.add(id));
        edges.forEach(id => state.selection.edges.add(id));
      } else {
        setMultiSelection({ nodes, groups, edges });
      }

      state.marquee = null;
      state.dragging = null;
      state.resizingGroup = null;
      render();
      return;
    }

    // Commit changes if we were dragging
    const wasDragging = state.dragging !== null;
    
    // Restore cursor after canvas panning
    if (state.dragging?.type === 'canvasPan') {
      svg.style.cursor = '';
    }
    
    // Commit changes if we were dragging curve handle
    if (state.dragging?.type === 'curveHandle') {
      commit();
    }
    
    state.dragging = null;
    state.resizingGroup = null;
    
    // Render if we were dragging to update cursor/state
    if (wasDragging) {
      render();
    }
  });

  window.addEventListener('keydown', (ev) => {
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'z') {
      ev.preventDefault();
      if (ev.shiftKey) redo(); else undo();
      return;
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'y') {
      ev.preventDefault(); redo(); return;
    }

    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'c') {
      ev.preventDefault();
      copySelection();
      return;
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'x') {
      ev.preventDefault();
      copySelection();
      deleteSelected();
      return;
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'v') {
      ev.preventDefault();
      pasteSelection();
      return;
    }

    if ((ev.key === 'Backspace' || ev.key === 'Delete') && !['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) {
      ev.preventDefault(); deleteSelected();
    }
    if (ev.key === 'Escape') {
      clearBrush();
      clearLinkMode();
      state.placingGroup=false;
      document.getElementById('btnAddGroup').classList.remove('primary');
      document.getElementById('btnAddRegion').classList.remove('primary');
      render();
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 's') {
      ev.preventDefault(); saveProject(false);
    }
  });

  document.getElementById('btnAddGroup').addEventListener('click', (ev) => {
    state.placingGroupType = 'country';
    state.placingGroup = !state.placingGroup;
    document.getElementById('btnAddGroup').classList.toggle('primary', state.placingGroup && state.placingGroupType==='country');
    document.getElementById('btnAddRegion').classList.toggle('primary', state.placingGroup && state.placingGroupType==='region');
    showToast(state.placingGroup ? 'Click the canvas to place a country box.' : 'Placement cancelled.');
  });

  document.getElementById('btnAddRegion').addEventListener('click', (ev) => {
    state.placingGroupType = 'region';
    state.placingGroup = !state.placingGroup;
    document.getElementById('btnAddRegion').classList.toggle('primary', state.placingGroup && state.placingGroupType==='region');
    document.getElementById('btnAddGroup').classList.remove('primary');
    showToast(state.placingGroup ? 'Click the canvas to place a region box.' : 'Placement cancelled.');
  });

document.getElementById('btnExportLinks').addEventListener('click', () => {
  // Create header row
  const headers = [
    'Link UUID',
    'A-End Node UUID',
    'A-End Node tag',
    'A-End node code',
    'B-End Node UUID',
    'B-End Node tag',
    'B-End Node code',
    'Link tag',
    'Link code',
    'Link latency',
    'Link Capacity Options',
    'Link Additional tags/Notes'
  ];
  
  let csv = headers.join(',') + '\r\n';
  
  // Add data rows
  for (const e of state.edges) {
    const a = findNode(e.a);
    const b = findNode(e.b);
    
    if (!a || !b) continue; // Skip if nodes don't exist
    
    // Ensure UUIDs exist
    if (!e.uuid) e.uuid = generateUUID();
    if (!a.uuid) a.uuid = generateUUID();
    if (!b.uuid) b.uuid = generateUUID();
    
    const row = [
      escapeCSV(e.uuid || ''),
      escapeCSV(a.uuid || ''),
      escapeCSV(a.name || ''),
      escapeCSV(a.code || ''),
      escapeCSV(b.uuid || ''),
      escapeCSV(b.name || ''),
      escapeCSV(b.code || ''),
      escapeCSV(e.tag || ''),
      escapeCSV(e.code || ''),
      escapeCSV((typeof e.latencyMs === "number" && isFinite(e.latencyMs)) ? e.latencyMs : ''),
      escapeCSV(e.capacity || ''),
      escapeCSV(e.extraTags || '')
    ];
    
    csv += row.join(',') + '\r\n';
  }
  
  downloadText('links.csv', csv, 'text/csv;charset=utf-8');
  showToast('Exported links.csv');
});

  document.getElementById('btnExportNodes').addEventListener('click', () => {
  const headers = [
    'Node UUID',
    'Node Name',
    'Node Code',
    'Tags',
    'Additional Tags',
    'Address',
    'City',
    'Country Box',
    'Country Box UUID',
    'X',
    'Y'
  ];
  
  let csv = headers.join(',') + '\r\n';
  
  for (const n of state.nodes) {
    // Ensure UUID exists
    if (!n.uuid) n.uuid = generateUUID();
    
    const g = n.groupId ? findGroup(n.groupId) : null;
    if (g && !g.uuid) g.uuid = generateUUID();
    
    const row = [
      escapeCSV(n.uuid || ''),
      escapeCSV(n.name || ''),
      escapeCSV(n.code || ''),
      escapeCSV((n.tags||[]).join('|')),
      escapeCSV(n.extraTags || ''),
      escapeCSV(n.address || ''),
      escapeCSV(n.city || ''),
      escapeCSV(g?.title || ''),
      escapeCSV(g?.uuid || ''),
      escapeCSV(Math.round(n.x)),
      escapeCSV(Math.round(n.y))
    ];
    
    csv += row.join(',') + '\r\n';
  }
  
  downloadText('nodes.csv', csv, 'text/csv;charset=utf-8');
  showToast('Exported nodes.csv');
});

  const NDG_FILETYPE = "NDG_PROJECT";
  const NDG_VERSION = 2;
  const LS_AUTOSAVE_KEY = "ndg_autosave_v2";
  const LS_LASTNAME_KEY = "ndg_last_filename_v2";
  const AUTOSAVE_INTERVAL_MS = 5000;

  function buildProjectObject() {
    return {
      fileType: NDG_FILETYPE,
      version: NDG_VERSION,
      savedAt: new Date().toISOString(),
      nodes: state.nodes,
      edges: state.edges,
      groups: state.groups,
      nextNode: state.nextNode,
      nextEdge: state.nextEdge,
      nextGroup: state.nextGroup,
      stylePresets: state.stylePresets,
      canvasWidth: state.canvasWidth,
      canvasHeight: state.canvasHeight,
      showCanvasBorder: state.showCanvasBorder,
      gridEnabled: state.gridEnabled,
      gridSize: state.gridSize,
      tagFilter: {
        mode: state.tagFilter.mode,
        selectedTags: Array.from(state.tagFilter.selectedTags)
      },
      ui: state.ui
    };
  }

  function sanitizeBaseName(name) {
    let trimmed = (name || "").trim();
    if (!trimmed) return null;

    // Remove leading dots (".", "..") to avoid browser/OS normalization to underscores
    trimmed = trimmed.replace(/^\.+/, "");

    // Replace invalid filename characters
    trimmed = trimmed.replace(/[<>:"/\\|?*\x00-\x1F]/g, "_");

    // Avoid empty or underscore-only names
    if (!trimmed || /^_+$/.test(trimmed)) return "project";

    return trimmed.slice(0, 80);
  }
  function getLastFilename() { return localStorage.getItem(LS_LASTNAME_KEY) || ""; }
  function setLastFilename(filename) { localStorage.setItem(LS_LASTNAME_KEY, filename); }

  function saveProject(forcePrompt) {
    let filename = getLastFilename();
    if (forcePrompt || !filename) {
      const base = sanitizeBaseName(prompt("Save project as (without extension):", filename.replace(/\\.ndg$/i, "") || "project"));
      if (!base) { showToast("Save cancelled."); return; }
      filename = base.toLowerCase().endsWith(".ndg") ? base : `${base}.ndg`;
      setLastFilename(filename);
    }
    const project = buildProjectObject();
    downloadText(filename, JSON.stringify(project, null, 2), "application/x-ndg+json");
    dirty = false;
    showToast(`Saved ${filename}`);
  }

  
function loadProjectObject(obj) {
  if (!obj) throw new Error('Empty project');
  if (obj.fileType && obj.fileType !== 'NDG_PROJECT') throw new Error('Not an NDG project');

  const nn = Array.isArray(obj.nodes) ? obj.nodes : [];
  const ee = Array.isArray(obj.edges) ? obj.edges : [];
  const gg = Array.isArray(obj.groups) ? obj.groups : [];

  state.nodes = nn.map(n => ({
    id: n.id,
    x: n.x, y: n.y,
    shape: n.shape || 'circle',
    r: (typeof n.r === 'number') ? n.r : 24,
    strokeW: (typeof n.strokeW === 'number') ? n.strokeW : 2,
    address: n.address || '',
    city: n.city || '',
    country: n.country || '',
    name: n.name || ('Node' + n.id),
    code: n.code || ('N-' + n.id),
    showCode: (n.showCode !== false),
    tags: Array.isArray(n.tags) ? n.tags : [],
    extraTags: n.extraTags || '',
    groupId: (typeof n.groupId === 'number') ? n.groupId : null,
    fill: n.fill || '#1b2030',
    stroke: n.stroke || '#9fb3ff',
    nameColor: n.nameColor || '#eaeaea',
    tagColor: n.tagColor || '#b7c0df',
    nameFont: (typeof n.nameFont === 'number') ? n.nameFont : 13,
    tagFont: (typeof n.tagFont === 'number') ? n.tagFont : 11,
    nameDx: (typeof n.nameDx === 'number') ? n.nameDx : 0,
    nameDy: (typeof n.nameDy === 'number') ? n.nameDy : 0,
    tagDx: (typeof n.tagDx === 'number') ? n.tagDx : 0,
    tagDy: (typeof n.tagDy === 'number') ? n.tagDy : 0
  }));

  state.edges = ee.map(e => ({
    id: e.id,
    a: e.a, b: e.b,
    tag: e.tag || '',
    latencyMs: (typeof e.latencyMs === 'number') ? e.latencyMs : null,
    code: e.code || ('L-' + e.id),
    showCode: (e.showCode !== false),
    extraTags: e.extraTags || '',
    style: e.style || 'straight',
    route: e.route || 'hv',
    labelDx: (typeof e.labelDx === 'number') ? e.labelDx : 0,
    labelDy: (typeof e.labelDy === 'number') ? e.labelDy : 0,
    labelFont: (typeof e.labelFont === 'number') ? e.labelFont : 12,
    labelColor: e.labelColor || '#eaeaea',
    strokeW: (typeof e.strokeW === 'number') ? e.strokeW : 2,
    strokeColor: e.strokeColor || '#7f8aa6',
    capacity: e.capacity || 'Up to 10G WL',
    curveArch: (typeof e.curveArch === 'number') ? e.curveArch : 0.3
  }));

  state.groups = gg.map(g => ({
    id: g.id,
    type: g.type || 'country',
    parentId: g.parentId ?? null,
    x: g.x, y: g.y, w: g.w, h: g.h,
    title: g.title || ((g.type==='region') ? ('Region' + g.id) : 'Country'),
    extraTags: g.extraTags || '',
    fill: g.fill || (g.type==='region' ? 'rgba(120, 140, 180, 0.10)' : 'rgba(54, 76, 140, 0.12)'),
    stroke: g.stroke || (g.type==='region' ? '#7f8aa6' : '#6073b8'),
    strokeW: (typeof g.strokeW === 'number') ? g.strokeW : 2,
    titleColor: g.titleColor || '#eaeaea',
    titleFont: (typeof g.titleFont === 'number') ? g.titleFont : (g.type==='region' ? 15 : 14),
    titleDx: (typeof g.titleDx === 'number') ? g.titleDx : 0,
    titleDy: (typeof g.titleDy === 'number') ? g.titleDy : 0
  }));

  state.nextNode = (typeof obj.nextNode === 'number') ? obj.nextNode : (Math.max(0, ...state.nodes.map(n=>n.id)) + 1);
  state.nextEdge = (typeof obj.nextEdge === 'number') ? obj.nextEdge : (Math.max(0, ...state.edges.map(e=>e.id)) + 1);
  state.nextGroup = (typeof obj.nextGroup === 'number') ? obj.nextGroup : (Math.max(0, ...state.groups.map(g=>g.id)) + 1);
  
  // Restore canvas dimensions
  if (typeof obj.canvasWidth === 'number') state.canvasWidth = obj.canvasWidth;
  if (typeof obj.canvasHeight === 'number') state.canvasHeight = obj.canvasHeight;
  if (typeof obj.showCanvasBorder === 'boolean') state.showCanvasBorder = obj.showCanvasBorder;
  
  // Restore grid settings
  if (typeof obj.gridEnabled === 'boolean') state.gridEnabled = obj.gridEnabled;
  if (typeof obj.gridSize === 'number') state.gridSize = obj.gridSize;
  // Update grid UI
  const gridEnabledCb = document.getElementById('gridEnabled');
  const btnGridToggle = document.getElementById('btnGridToggle');
  const gridMenu = document.getElementById('gridMenu');
  if (gridEnabledCb) gridEnabledCb.checked = state.gridEnabled;
  if (btnGridToggle) btnGridToggle.classList.toggle('active', state.gridEnabled);
  if (gridMenu) {
    gridMenu.querySelectorAll('.grid-size').forEach(item => {
      item.classList.toggle('active', parseInt(item.dataset.size) === state.gridSize);
    });
  }
  
  // Restore tag filter settings
  if (obj.tagFilter) {
    state.tagFilter.mode = obj.tagFilter.mode || 'all';
    state.tagFilter.selectedTags = new Set(obj.tagFilter.selectedTags || []);
  } else {
    state.tagFilter.mode = 'all';
    state.tagFilter.selectedTags = new Set();
  }
  // Update tag filter UI
  const tagFilterMenu = document.getElementById('tagFilterMenu');
  const btnTagFilter = document.getElementById('btnTagFilter');
  if (tagFilterMenu) {
    const modeRadio = tagFilterMenu.querySelector(`input[name="filterMode"][value="${state.tagFilter.mode}"]`);
    if (modeRadio) modeRadio.checked = true;
  }
  if (btnTagFilter) {
    const isFiltering = state.tagFilter.mode !== 'all' && state.tagFilter.selectedTags.size > 0;
    btnTagFilter.classList.toggle('filtering', isFiltering);
  }
  
  // Restore UI settings
  if (obj.ui) {
    state.ui = { ...state.ui, ...obj.ui };
  }
  // Sync UI toggles
  const tglShowNodeTags = document.getElementById('tglShowNodeTags');
  const tglShowExtraTags = document.getElementById('tglShowExtraTags');
  const tglShowLatency = document.getElementById('tglShowLatency');
  const tglShowNodeCode = document.getElementById('tglShowNodeCode');
  const tglShowLinkCode = document.getElementById('tglShowLinkCode');
  if (tglShowLatency) tglShowLatency.checked = !!state.ui.showLatency;
  if (tglShowNodeCode) tglShowNodeCode.checked = !!state.ui.showNodeCode;
  if (tglShowLinkCode) tglShowLinkCode.checked = !!state.ui.showLinkCode;
  if (tglShowNodeTags) tglShowNodeTags.checked = !!state.ui.showNodeTags;
  if (tglShowExtraTags) tglShowExtraTags.checked = !!state.ui.showExtraTags;
  
  svg.setAttribute('viewBox', `0 0 ${state.canvasWidth} ${state.canvasHeight}`);
  
  // Restore style presets
  state.stylePresets = obj.stylePresets || { node:{}, edge:{}, group:{} };
  
  // Clear transient state
  state.selected = null;
  state.connectFrom = null;
  state.dragging = null;
  state.resizingGroup = null;
  state.placingGroup = false;
  state.placingGroupType = 'country';
  state.styleBrush = null;
  clearSelection();
  
  // CRITICAL: Refresh all memberships
  refreshAllMemberships();
  
  // Reset history
  history.stack = [];
  history.index = -1;
  pushHistory();
  
  // Sync UI toggles
  syncGlobalToggles();
  
  // Render and update UI
  render();
  dirty = false;
}


  function autosaveNow() {
    try {
      localStorage.setItem(LS_AUTOSAVE_KEY, JSON.stringify(buildProjectObject()));
      dirty = false;
    } catch (e) { console.warn("Autosave failed:", e); }
  }
  setInterval(() => { if (dirty) autosaveNow(); }, AUTOSAVE_INTERVAL_MS);

  function recoverAutosave() {
    const raw = localStorage.getItem(LS_AUTOSAVE_KEY);
    if (!raw) { showToast("No autosave found."); return; }
    try { loadProjectObject(JSON.parse(raw)); showToast("Recovered autosave."); }
    catch (e) { showToast("Autosave recovery failed: " + e.message); }
  }
  function clearAutosave() { localStorage.removeItem(LS_AUTOSAVE_KEY); showToast("Autosave cleared."); }

  document.getElementById('fileLoad').addEventListener('change', async (ev) => {
    const f = ev.target.files?.[0];
    if (!f) return;
    try {
      const text = await f.text();
      loadProjectObject(JSON.parse(text));
      setLastFilename(f.name);
      showToast(`Opened ${f.name}`);
    } catch (e) {
      showToast('Open failed: ' + e.message);
    } finally {
      ev.target.value = '';
    }
  });

  function clearDiagram() {
    state.nodes=[]; state.edges=[]; state.groups=[];
    state.nextNode=1; state.nextEdge=1; state.nextGroup=1;
    state.selected=null; state.connectFrom=null; state.placingGroup=false; state.placingGroupType='country';
    state.selection.nodes.clear(); state.selection.edges.clear(); state.selection.groups.clear();
    history.stack=[]; history.index=-1; pushHistory();
    commit(); render();
    showToast('Cleared.');
  }

  // (legacy button) 
  document.getElementById('btnClear')?.addEventListener('click', () => { clearDiagram(); });
  (function autosaveStartupHint(){
    const raw = localStorage.getItem(LS_AUTOSAVE_KEY);
    if (raw) showToast("Autosave available ‚Äî click ‚ÄúRecover Autosave‚Äù if needed.");
  })();

  // Inspector panel controls (draggable, minimizable, closeable)
  const inspector = document.getElementById('inspector');
  const inspectorHeader = document.getElementById('inspectorHeader');
  const btnMinimizeInspector = document.getElementById('btnMinimizeInspector');
  const btnCloseInspector = document.getElementById('btnCloseInspector');
  const btnToggleInspector = document.getElementById('btnToggleInspector');

  let inspectorDragging = false;
  let inspectorDragOffset = { x: 0, y: 0 };
  let inspectorMinimized = false;

  // Toggle inspector from header button
  if (btnToggleInspector) {
    btnToggleInspector.addEventListener('click', () => {
      if (inspector.style.display === 'none') {
        inspector.style.display = 'flex';
        btnToggleInspector.classList.add('primary');
      } else {
        inspector.style.display = 'none';
        btnToggleInspector.classList.remove('primary');
      }
    });
  }

  // Make inspector draggable
  inspectorHeader.addEventListener('mousedown', (ev) => {
    if (ev.target.tagName === 'BUTTON' || ev.target.closest('button')) return;
    inspectorDragging = true;
    const rect = inspector.getBoundingClientRect();
    inspectorDragOffset.x = ev.clientX - rect.left;
    inspectorDragOffset.y = ev.clientY - rect.top;
    inspector.style.cursor = 'grabbing';
    ev.preventDefault();
  });

  window.addEventListener('mousemove', (ev) => {
    if (!inspectorDragging) return;
    const layout = document.getElementById('layout');
    const layoutRect = layout.getBoundingClientRect();
    
    let newLeft = ev.clientX - layoutRect.left - inspectorDragOffset.x;
    let newTop = ev.clientY - layoutRect.top - inspectorDragOffset.y;
    
    // Keep inspector within bounds
    const maxLeft = layoutRect.width - inspector.offsetWidth;
    const maxTop = layoutRect.height - 44; // At least show header
    
    newLeft = Math.max(0, Math.min(newLeft, maxLeft));
    newTop = Math.max(0, Math.min(newTop, maxTop));
    
    inspector.style.left = newLeft + 'px';
    inspector.style.top = newTop + 'px';
    inspector.style.right = 'auto'; // Remove right positioning
  });

  window.addEventListener('mouseup', () => {
    if (inspectorDragging) {
      inspectorDragging = false;
      inspector.style.cursor = '';
    }
  });

  // Minimize/Maximize toggle
  btnMinimizeInspector.addEventListener('click', () => {
    inspectorMinimized = !inspectorMinimized;
    inspector.classList.toggle('minimized', inspectorMinimized);
    btnMinimizeInspector.textContent = inspectorMinimized ? '+' : '‚àí';
    btnMinimizeInspector.title = inspectorMinimized ? 'Maximize' : 'Minimize';
  });

  // Close inspector
  btnCloseInspector.addEventListener('click', () => {
    inspector.style.display = 'none';
    if (btnToggleInspector) btnToggleInspector.classList.remove('primary');
    showToast('Inspector hidden. Press "I" to show it again.');
  });

  // Keyboard shortcut to toggle inspector visibility
  window.addEventListener('keydown', (ev) => {
    if (ev.key.toLowerCase() === 'i' && !['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) {
      if (inspector.style.display === 'none') {
        inspector.style.display = 'flex';
        if (btnToggleInspector) btnToggleInspector.classList.add('primary');
        showToast('Inspector shown.');
      } else {
        inspector.style.display = 'none';
        if (btnToggleInspector) btnToggleInspector.classList.remove('primary');
        showToast('Inspector hidden. Press "I" to show it again.');
      }
    }
  });

  refreshPresetSelects();
  syncGlobalToggles();
  pushHistory();
  updateViewBox(); // Initialize pan and zoom
  render();

  // Initialize color pickers with palette
  const colorInputs = [
    'nodeFill', 'nodeStroke', 'nodeNameColor', 'nodeTagColor',
    'edgeStrokeColor', 'edgeLabelColor',
    'groupFill', 'groupStroke', 'groupTitleColor'
  ];
  const colorPickers = {};
  colorInputs.forEach(id => {
    const input = document.getElementById(id);
    if (input && input.type === 'color') {
      colorPickers[id] = createColorPicker(input);
    }
  });

  // Update color pickers when inspector is populated
  const originalSyncInspector = window.syncInspector || (() => {});
  window.updateColorPickers = function() {
    Object.values(colorPickers).forEach(cp => {
      if (cp && cp.update) cp.update();
    });
  };

  // Initialize inspector button state
  if (btnToggleInspector) btnToggleInspector.classList.add('primary');

  showToast('Ready ‚Äî double-click to create a node.');
})();
</script>
</body>
</html>
