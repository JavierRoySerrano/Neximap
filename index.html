<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NexiMap Studio</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23667eea'/%3E%3Cstop offset='100%25' stop-color='%23764ba2'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect x='2' y='2' width='28' height='28' rx='4' fill='url(%23g)'/%3E%3Cpath d='M8 8H24M8 16H24M8 24H24M8 8V24M16 8V24M24 8V24' stroke='white' stroke-width='0.8' opacity='0.2'/%3E%3Cpath d='M8 8L16 16L24 8M16 16L8 24M16 16L24 24' stroke='white' stroke-width='1.8' stroke-linecap='round'/%3E%3Ccircle cx='8' cy='8' r='2.5' fill='white'/%3E%3Ccircle cx='24' cy='8' r='2.5' fill='white'/%3E%3Ccircle cx='16' cy='16' r='3' fill='white'/%3E%3Ccircle cx='8' cy='24' r='2.5' fill='white'/%3E%3Ccircle cx='24' cy='24' r='2.5' fill='white'/%3E%3C/svg%3E" />
  <style>
    :root { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif; }
    body { margin: 0; background:#ffffff; color:#333; }
    header {
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      padding:0; border-bottom:1px solid #e0e0e0;
      position: sticky; top: 0; background:#fafafa; z-index: 10;
    }
    
    /* Menu Bar Items */
    .menu-item {
      background: transparent;
      border: none;
      color: #444;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 13px;
      border-radius: 4px;
    }
    .menu-item:hover { background: #e8e8e8; }
    
    /* Tool Buttons */
    .tool-btn {
      background: transparent;
      border: 1px solid transparent;
      color: #555;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 16px;
      border-radius: 4px;
      min-width: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .tool-btn:hover { background: #e8e8e8; border-color: #d0d0d0; }
    .tool-btn.active, .tool-btn.primary { 
      background: #d0e8f5; 
      color: #0066a0; 
      border-color: #0096D6; 
    }
    .tool-btn.shape-tool.active { 
      background: #d0e8f5; 
      color: #0066a0; 
      border-color: #0096D6;
    }
    .tool-btn.active svg, .tool-btn.primary svg,
    .tool-btn.shape-tool.active svg {
      stroke: #0066a0;
    }
    
    .tool-sep { width: 1px; height: 24px; background: #d0d0d0; margin: 0 6px; }
    
    /* Toggle items in menu */
    .toggle-item { display: flex; align-items: center; gap: 8px; }
    .toggle-item input { accent-color: #0096D6; }
    
    /* Menu section headers */
    .menu-section-header {
      padding: 6px 12px 4px;
      font-size: 10px;
      font-weight: 600;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      background: #f8f8f8;
    }
    
    /* Inspector inline field controls */
    .field-with-controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .field-with-controls input,
    .field-with-controls textarea {
      flex: 1;
      min-width: 0;
    }
    .field-inline-controls {
      display: flex;
      align-items: center;
      gap: 3px;
      flex-shrink: 0;
    }
    .field-color-swatch {
      width: 20px;
      height: 20px;
      border: 1px solid #999;
      border-radius: 3px;
      cursor: pointer;
      position: relative;
    }
    .field-color-swatch:hover {
      border-color: #666;
    }
    .field-color-swatch input[type="color"] {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }
    .field-visibility-btn {
      width: 22px;
      height: 22px;
      border: 1px solid #ccc;
      border-radius: 3px;
      background: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      font-size: 12px;
      padding: 0;
    }
    .field-visibility-btn:hover {
      background: #f0f0f0;
      border-color: #999;
    }
    .field-visibility-btn.hidden {
      background: #f5f5f5;
      color: #bbb;
    }
    .field-visibility-btn svg {
      width: 14px;
      height: 14px;
    }
    .field-font-select {
      width: 52px;
      padding: 2px 4px;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 11px;
      background: #fff;
      cursor: pointer;
    }
    .field-font-select:hover {
      border-color: #999;
    }
    
    /* Inspector collapsible sections */
    .inspector-section {
      border-bottom: 1px solid #e8e8e8;
      margin-bottom: 0;
    }
    .inspector-section:last-child {
      border-bottom: none;
    }
    .inspector-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: #f8f9fa;
      cursor: pointer;
      user-select: none;
      font-size: 11px;
      font-weight: 600;
      color: #555;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    .inspector-section-header:hover {
      background: #f0f1f2;
    }
    .inspector-section-header .section-icon {
      font-size: 10px;
      color: #888;
      transition: transform 0.2s;
    }
    .inspector-section.collapsed .section-icon {
      transform: rotate(-90deg);
    }
    .inspector-section-content {
      padding: 10px 12px;
    }
    .inspector-section.collapsed .inspector-section-content {
      display: none;
    }
    .inspector-section-content .row {
      margin-bottom: 10px;
    }
    .inspector-section-content .row:last-child {
      margin-bottom: 0;
    }
    
    .btn {
      background:#fff; border:1px solid #d0d0d0; color:#333;
      padding:6px 10px; border-radius:6px; cursor:pointer; font-weight:500; font-size: 12px;
    }
    .btn:hover { background:#f5f5f5; border-color:#bbb; }
    .btn.primary { background:#0096D6; border-color:#0096D6; color:#fff; }
    .btn.primary:hover { background:#0080b8; }
    .mini-btn { padding:4px 8px; font-size:11px; }
    .hint { opacity:.7; font-size: 12px; color:#666; }
    input[type="file"]{ display:none; }

    #layout { display: flex; height: calc(100vh - 110px); position: relative; }
    #wrap { 
      flex: 1; 
      position: relative; 
      overflow: auto; 
      background: #f0f0f0; 
      min-width: 0;
    }
    /* Ensure scrollbars are styled and visible */
    #wrap::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }
    #wrap::-webkit-scrollbar-track {
      background: #e0e0e0;
      border-radius: 6px;
    }
    #wrap::-webkit-scrollbar-thumb {
      background: #a0a0a0;
      border-radius: 6px;
      border: 2px solid #e0e0e0;
    }
    #wrap::-webkit-scrollbar-thumb:hover {
      background: #888;
    }
    #wrap::-webkit-scrollbar-corner {
      background: #e0e0e0;
    }
    #inspector {
      position: absolute;
      right: 20px;
      top: 20px;
      width: 340px;
      max-height: calc(100vh - 160px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 100;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      resize: horizontal;
      min-width: 280px;
      max-width: 500px;
    }
    #inspector.minimized {
      height: 40px !important;
      max-height: 40px;
      resize: none;
    }
    
    /* Cable System Navigator Panel */
    #cableNavigator {
      position: absolute;
      left: 20px;
      top: 20px;
      width: 280px;
      max-height: calc(100vh - 160px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 100;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      resize: both;
      min-width: 220px;
      max-width: 400px;
      min-height: 200px;
    }
    #cableNavigator.minimized {
      height: 40px !important;
      max-height: 40px;
      resize: none;
    }
    
    /* Cable System Inspector Panel */
    #cableSystemInspectorPanel {
      position: absolute;
      left: 320px;
      top: 20px;
      width: 340px;
      max-height: calc(100vh - 160px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 100;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      resize: both;
      min-width: 280px;
      max-width: 500px;
      min-height: 200px;
    }
    #cableSystemInspectorPanel.minimized {
      height: 40px !important;
      max-height: 40px;
      resize: none;
    }
    #cableInspectorHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: #e8f4e8;
      border-bottom: 1px solid #e0e0e0;
      cursor: move;
      user-select: none;
    }
    #cableInspectorHeader h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }
    #cableInspectorControls {
      display: flex;
      gap: 4px;
    }
    #cableInspectorControls button {
      background: transparent;
      border: 1px solid #d0d0d0;
      color: #666;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #cableInspectorControls button:hover { background: #e8e8e8; }
    #cableInspectorContent {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }
    #cableInspectorContent .row { margin-bottom: 10px; }
    #cableInspectorContent label { display: block; font-size: 11px; color: #555; margin-bottom: 4px; font-weight: 500; }
    #cableInspectorContent input, #cableInspectorContent select, #cableInspectorContent textarea {
      width: 100%; box-sizing: border-box;
      padding: 6px 8px; border: 1px solid #d0d0d0; border-radius: 4px; font-size: 12px;
    }
    #cableInspectorContent .inline { display: flex; gap: 8px; }
    #cableInspectorContent .inline > div { flex: 1; }
    
    #cableNavigatorHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: #f0f4f8;
      border-bottom: 1px solid #e0e0e0;
      cursor: move;
      user-select: none;
    }
    #cableNavigatorHeader h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }
    #cableNavigatorControls {
      display: flex;
      gap: 4px;
    }
    #cableNavigatorControls button {
      background: transparent;
      border: 1px solid #d0d0d0;
      color: #666;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #cableNavigatorControls button:hover { background: #e8e8e8; }
    #cableNavigatorContent {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .cable-system-item {
      padding: 8px 12px;
      border-bottom: 1px solid #f0f0f0;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .cable-system-item:hover { background: #f5f5f5; }
    .cable-system-item.selected { background: #e3f2fd; border-left: 3px solid #0096D6; }
    .cable-system-item .cs-name { font-weight: 500; font-size: 12px; }
    .cable-system-item .cs-fullname { font-size: 10px; color: #666; }
    .cable-system-item .cs-count { font-size: 10px; color: #888; }
    
    #inspectorHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: #f8f8f8;
      border-bottom: 1px solid #e0e0e0;
      cursor: move;
      user-select: none;
    }
    #inspectorHeader h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }
    #inspectorControls {
      display: flex;
      gap: 4px;
    }
    #inspectorControls button {
      background: transparent;
      border: 1px solid #d0d0d0;
      color: #666;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    #inspectorControls button:hover {
      background: #e8e8e8;
      border-color: #bbb;
    }
    #inspectorContent {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 12px;
      background: #fff;
    }
    #inspector.minimized #inspectorContent {
      display: none;
    }
    #inspector h3 { margin:0 0 10px; font-size:14px; color:#333; }
    #inspector .muted { opacity:.8; font-size:11px; line-height:1.4; margin-bottom:10px; color:#666; }
    #inspector .row { margin:10px 0; }
    #inspector label { display:block; font-size:11px; color:#555; margin:0 0 4px; }
    #inspector input, #inspector textarea, #inspector select {
      width:100%; box-sizing:border-box;
      padding:8px 10px; border-radius:6px; border:1px solid #d0d0d0;
      background:#fff; color:#333; font-size: 13px;
    }
    #inspector input:focus, #inspector select:focus, #inspector textarea:focus {
      outline: none;
      border-color: #0096D6;
      box-shadow: 0 0 0 2px rgba(0,150,214,0.15);
    }
    #inspector textarea { min-height: 60px; resize: vertical; }
    #inspector .inline { display:flex; gap:8px; }
    #inspector .inline > * { flex:1; }
    #inspector h4 { color:#333; margin:16px 0 8px; font-size:11px; font-weight:600; text-transform:uppercase; letter-spacing:0.5px; }
    #inspector input[type="color"] { padding:2px; height:32px; }
    #inspector input[type="checkbox"] { width:auto; accent-color:#0096D6; }
    .muted kbd { background:#f0f0f0; padding:2px 5px; border-radius:3px; font-size:10px; border:1px solid #d0d0d0; }

    svg { display:block; user-select:none; background:#fff; }
    #svgContainer { display: block; min-width: max-content; min-height: max-content; }
    .grid { stroke:#e8e8e8; stroke-width:1; }

    .group-rect { rx:8; ry:8; }
    .group-selected .group-rect { 
      stroke: #0096D6 !important; 
      stroke-width: 2 !important; 
      filter: drop-shadow(0 0 3px rgba(0,150,214,0.4));
    }
    .group-label { font-weight:600; user-select:none; cursor: default; }
    .group-handle { fill:#888; opacity:.7; cursor:nwse-resize; }
    .group-handle.handle-nw { cursor:nwse-resize; }
    .group-handle.handle-ne { cursor:nesw-resize; }
    .group-handle.handle-sw { cursor:nesw-resize; }
    .group-handle.handle-se { cursor:nwse-resize; }
    .group-handle:hover { fill:#555; opacity:1; }
    
    /* Node resize handles - invisible but functional */
    .node-resize-handle { 
      fill: transparent; 
      stroke: none;
      cursor: nwse-resize; 
      pointer-events: auto;
    }
    .node-resize-handle.handle-nw { cursor: nwse-resize; }
    .node-resize-handle.handle-ne { cursor: nesw-resize; }
    .node-resize-handle.handle-sw { cursor: nesw-resize; }
    .node-resize-handle.handle-se { cursor: nwse-resize; }
    .node.selected .node-resize-handle,
    .node:hover .node-resize-handle { 
      fill: rgba(0, 150, 214, 0.15); 
      stroke: rgba(0, 150, 214, 0.4);
      stroke-width: 1;
    }
    .node-resize-handle:hover { 
      fill: rgba(0, 150, 214, 0.3) !important; 
      stroke: #0096D6 !important;
      stroke-width: 1.5 !important;
    }

    .edge { fill:none; }
    .edge.selected { stroke:#0096D6 !important; stroke-width: 3 !important; filter: drop-shadow(0 0 3px rgba(0,150,214,0.5)); }
    .edge-label {
      fill:#333;
      paint-order: stroke; stroke:#ffffff; stroke-width:3px;
      cursor: default; user-select:none;
    }

    .node { cursor: grab; }
    .node:active { cursor: grabbing; }
    .node-circle { }
    .node.selected .node-circle { 
      stroke: #0096D6 !important; 
      stroke-width: 3 !important; 
      filter: drop-shadow(0 0 4px rgba(0,150,214,0.5));
    }
    .node.link-source .node-circle {
      stroke: #ff9800 !important;
      stroke-width: 4 !important;
      filter: drop-shadow(0 0 6px rgba(255,152,0,0.6));
      animation: pulse 1s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .node-text, .tag-text { text-anchor: middle; user-select:none; cursor: default; }
    .node-text { dominant-baseline: middle; }
    .tag-text { dominant-baseline: hanging; opacity:.8; }

    /* Route Finder Highlighting */
    .node.route-origin .node-circle {
      stroke: #22c55e !important;
      stroke-width: 4 !important;
      filter: drop-shadow(0 0 8px rgba(34,197,94,0.7));
    }
    .node.route-dest .node-circle {
      stroke: #ef4444 !important;
      stroke-width: 4 !important;
      filter: drop-shadow(0 0 8px rgba(239,68,68,0.7));
    }
    /* Geo View node highlighting */
    circle.geo-node.route-origin {
      stroke: #22c55e !important;
      stroke-width: 4 !important;
      filter: drop-shadow(0 0 8px rgba(34,197,94,0.7));
    }
    circle.geo-node.route-dest {
      stroke: #ef4444 !important;
      stroke-width: 4 !important;
      filter: drop-shadow(0 0 8px rgba(239,68,68,0.7));
    }
    circle.geo-node.route-path-node {
      stroke: #0ea5e9 !important;
      stroke-width: 3 !important;
      filter: drop-shadow(0 0 6px rgba(14,165,233,0.6));
    }
    .edge.route-path-1 {
      stroke: #22c55e !important;
      stroke-width: 5 !important;
      filter: drop-shadow(0 0 8px rgba(34,197,94,0.8));
    }
    .edge.route-path-2 {
      stroke: #f59e0b !important;
      stroke-width: 5 !important;
      filter: drop-shadow(0 0 8px rgba(245,158,11,0.8));
    }
    .edge.route-path-3 {
      stroke: #f97316 !important;
      stroke-width: 5 !important;
      filter: drop-shadow(0 0 8px rgba(249,115,22,0.8));
    }
    .node.route-path-node .node-circle {
      stroke: #0ea5e9 !important;
      stroke-width: 3 !important;
      filter: drop-shadow(0 0 6px rgba(14,165,233,0.6));
    }
    /* Implicit route segments (dashed) */
    .route-implicit-segment {
      stroke-dasharray: 8,4;
      opacity: 0.85;
    }

    /* Route Finder Panel - Inspector Style */
    #routeFinderPanel {
      position: absolute;
      left: 20px;
      top: 20px;
      width: 320px;
      max-height: calc(100vh - 160px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 99;
      flex-direction: column;
      overflow: hidden;
      resize: horizontal;
      min-width: 280px;
      max-width: 450px;
    }
    #routeFinderPanel.visible {
      display: flex !important;
    }
    #routeFinderPanel:not(.visible) {
      display: none !important;
    }
    #routeFinderPanel.minimized {
      height: 40px !important;
      max-height: 40px;
      resize: none;
    }
    #routeFinderHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      border-bottom: 1px solid #16a34a;
      cursor: move;
      user-select: none;
    }
    #routeFinderHeader h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #fff;
    }
    #routeFinderControls {
      display: flex;
      gap: 4px;
    }
    #routeFinderControls button {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: #fff;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #routeFinderControls button:hover { background: rgba(255,255,255,0.3); }
    #routeFinderContent {
      flex: 1;
      overflow-y: auto;
    }
    #routeFinderPanel.minimized #routeFinderContent {
      display: none;
    }
    
    /* Route option cards */
    .route-option {
      padding: 10px 12px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.15s ease;
      background: #fff;
    }
    .route-option:last-child {
      margin-bottom: 0;
    }
    .route-option:hover {
      border-color: #0096D6;
      background: #f8fbfd;
    }
    .route-option.active {
      border-color: #22c55e;
      background: #f0fdf4;
      box-shadow: 0 0 0 2px rgba(34,197,94,0.2);
    }
    .route-option.active.route-2 {
      border-color: #f59e0b;
      background: #fffbeb;
      box-shadow: 0 0 0 2px rgba(245,158,11,0.2);
    }
    .route-option.active.route-3 {
      border-color: #f97316;
      background: #fff7ed;
      box-shadow: 0 0 0 2px rgba(249,115,22,0.2);
    }
    .route-option-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .route-option-rank {
      font-size: 16px;
    }
    .route-option-title {
      font-weight: 600;
      font-size: 12px;
      color: #333;
    }
    .route-option-cost {
      font-size: 13px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 4px;
      background: #f0f0f0;
    }
    .route-option.active .route-option-cost {
      background: #dcfce7;
      color: #166534;
    }
    .route-option.active.route-2 .route-option-cost {
      background: #fef3c7;
      color: #92400e;
    }
    .route-option.active.route-3 .route-option-cost {
      background: #ffedd5;
      color: #9a3412;
    }
    .route-option-path {
      font-size: 11px;
      color: #666;
      line-height: 1.5;
      word-break: break-word;
    }
    .route-option-stats {
      display: flex;
      gap: 12px;
      margin-top: 6px;
      font-size: 10px;
      color: #888;
    }
    .route-no-path {
      padding: 20px;
      text-align: center;
      color: #666;
    }
    .route-no-path-icon {
      font-size: 32px;
      margin-bottom: 8px;
    }

    /* Label Manager Panel */
    #labelManagerPanel {
      position: absolute;
      left: 360px;
      top: 20px;
      width: 340px;
      max-height: calc(100vh - 160px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 99;
      flex-direction: column;
      overflow: hidden;
      resize: horizontal;
      min-width: 300px;
      max-width: 500px;
      display: none;
    }
    #labelManagerPanel.visible {
      display: flex !important;
    }
    #labelManagerHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      border-bottom: 1px solid #7c3aed;
      cursor: move;
      user-select: none;
    }
    #labelManagerHeader h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #fff;
    }
    #labelManagerControls {
      display: flex;
      gap: 4px;
    }
    #labelManagerControls button {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: #fff;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #labelManagerControls button:hover { background: rgba(255,255,255,0.3); }
    #labelManagerContent {
      flex: 1;
      overflow-y: auto;
    }
    
    /* Tag items in Label Manager */
    .lm-tag-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.15s;
    }
    .lm-tag-item:hover {
      background: #f3f4f6;
    }
    .lm-tag-item.selected {
      background: #ede9fe;
    }
    .lm-tag-checkbox {
      width: 16px;
      height: 16px;
      accent-color: #8b5cf6;
    }
    .lm-tag-name {
      flex: 1;
      font-size: 12px;
      color: #374151;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .lm-tag-counts {
      display: flex;
      gap: 6px;
      font-size: 10px;
      color: #9ca3af;
    }
    .lm-tag-count {
      padding: 1px 4px;
      background: #f3f4f6;
      border-radius: 3px;
    }
    .lm-tag-count.nodes { background: #dbeafe; color: #1d4ed8; }
    .lm-tag-count.links { background: #fef3c7; color: #92400e; }
    .lm-tag-count.containers { background: #d1fae5; color: #065f46; }
    .lm-tag-menu {
      opacity: 0;
      padding: 2px 6px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 3px;
    }
    .lm-tag-item:hover .lm-tag-menu {
      opacity: 1;
    }
    .lm-tag-menu:hover {
      background: #e5e7eb;
    }
    
    /* Selection status indicator */
    .lm-selection-status {
      padding: 10px 12px;
      background: linear-gradient(135deg, #f3e8ff 0%, #ede9fe 100%);
      border-bottom: 1px solid #c4b5fd;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .lm-selection-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      background: #8b5cf6;
      color: white;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }
    
    /* Checkbox states */
    .lm-checkbox-partial {
      position: relative;
    }
    .lm-checkbox-partial::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 2px;
      background: #8b5cf6;
    }
    
    /* Tag pill style for selection display */
    .lm-tag-pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      background: #ede9fe;
      color: #6d28d9;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }
    .lm-tag-pill .remove {
      cursor: pointer;
      opacity: 0.7;
    }
    .lm-tag-pill .remove:hover {
      opacity: 1;
    }

    .toast {
      position:absolute; right:14px; bottom:14px; background:#333; border:1px solid #222;
      color:#fff; padding:10px 16px; border-radius:8px; max-width: 520px; font-size: 13px; opacity:0;
      transform: translateY(8px); transition: all .2s ease; z-index: 20;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .toast.show { opacity:1; transform: translateY(0); }
    kbd{ padding:1px 6px; border:1px solid #d0d0d0; border-bottom-width:2px; border-radius:4px; background:#f5f5f5; font-size:11px; color:#333; }

    header { position: sticky; top: 0; }
    .menu {
      position:absolute;
      top: 28px;
      left: 0;
      background:#ffffff;
      border:1px solid #d0d0d0;
      border-radius:6px;
      padding:4px 0;
      min-width: 200px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.12);
      z-index: 30;
    }
    .menu[hidden]{ display:none; }
    .menu .item{
      display:flex; align-items:center; gap:10px;
      padding:8px 14px;
      cursor:pointer;
      user-select:none;
      font-size: 13px;
      color:#333;
    }
    .menu .item:hover{ background:#f5f5f5; }
    .menu .item.active { background:#e8f4fc; color:#0096D6; }
    .menu .sep{ height:1px; background:#e0e0e0; margin:4px 0; }

    .toggle{ display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:4px; font-size:12px; color:#555; }
    .toggle input{ accent-color:#0096D6; }

    /* Tag filter styles */
    .tag-filter-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 12px;
    }
    .tag-filter-item:hover { background: #f5f5f5; }
    .tag-filter-item input { accent-color: #0096D6; }
    .tag-filter-item .tag-name { flex: 1; }
    .tag-filter-item .tag-count { 
      color: #999; 
      font-size: 11px;
      background: #f0f0f0;
      padding: 1px 6px;
      border-radius: 10px;
    }
    #btnTagFilter.filtering { 
      background: #e8f4fc; 
      color: #0096D6;
      border-color: #0096D6;
    }

    /* Apply Style Panel */
    .apply-style-section {
      border-bottom: 1px solid #e8e8e8;
    }
    .apply-style-section:last-child {
      border-bottom: none;
    }
    .apply-style-section-header {
      padding: 8px 12px;
      font-size: 10px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      background: #f5f5f5;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .apply-style-section-header .count {
      background: #e0e0e0;
      color: #555;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: normal;
    }
    .apply-style-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 12px;
      color: #333;
      transition: background 0.1s;
    }
    .apply-style-item:hover {
      background: #e8f4fc;
    }
    .apply-style-swatch {
      display: flex;
      align-items: center;
      gap: 2px;
      flex-shrink: 0;
    }
    .apply-style-swatch-fill {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.2);
    }
    .apply-style-swatch-stroke {
      width: 4px;
      height: 16px;
      border-radius: 1px;
      border: 1px solid rgba(0,0,0,0.15);
    }
    .apply-style-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .apply-style-empty-section {
      padding: 12px;
      text-align: center;
      color: #999;
      font-size: 11px;
      font-style: italic;
    }

    /* Inspector Palette Color Picker */
    .inspector-color-picker {
      position: relative;
      display: inline-block;
    }
    .inspector-color-swatch {
      width: 36px;
      height: 28px;
      border: 1px solid #aaa;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fff;
      transition: border-color 0.15s;
    }
    .inspector-color-swatch:hover {
      border-color: #666;
    }
    .inspector-color-swatch-inner {
      width: 28px;
      height: 20px;
      border-radius: 2px;
      border: 1px solid rgba(0,0,0,0.1);
    }
    .inspector-color-dropdown {
      position: absolute;
      top: 32px;
      left: 0;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 10px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      z-index: 1000;
      min-width: 200px;
    }
    .inspector-color-dropdown[hidden] {
      display: none;
    }
    .inspector-color-grid {
      display: grid;
      grid-template-columns: repeat(8, 22px);
      gap: 3px;
      margin-bottom: 10px;
    }
    .inspector-color-grid-item {
      width: 22px;
      height: 22px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.15);
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.1s;
    }
    .inspector-color-grid-item:hover {
      transform: scale(1.15);
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      z-index: 1;
      position: relative;
    }
    .inspector-color-custom {
      display: flex;
      align-items: center;
      gap: 8px;
      padding-top: 8px;
      border-top: 1px solid #e8e8e8;
    }
    .inspector-color-custom input[type="color"] {
      width: 32px;
      height: 28px;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 2px;
      cursor: pointer;
    }
    .inspector-color-custom input[type="text"] {
      width: 80px;
      padding: 4px 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 11px;
      font-family: monospace;
    }
    .inspector-color-custom span {
      font-size: 11px;
      color: #666;
    }

    /* Toolbar color grid */
    .color-grid {
      display: grid;
      grid-template-columns: repeat(8, 20px);
      gap: 3px;
    }
    .color-grid-item {
      width: 20px;
      height: 20px;
      border: 1px solid #ccc;
      border-radius: 2px;
      cursor: pointer;
    }
    .color-grid-item:hover {
      border-color: #0096D6;
      transform: scale(1.1);
    }
    .color-grid-item.selected {
      border: 2px solid #0096D6;
    }
    .link-style-item.active, .link-route-item.active {
      background: #e8f4fc;
      color: #0096D6;
    }

    .marquee { fill: rgba(0,150,214,0.1); stroke:#0096D6; stroke-width:1; stroke-dasharray:4 2; }
  
    /* Color Palette Picker */
    .color-picker-wrap { position: relative; }
    .color-swatch {
      width: 100%;
      height: 32px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      padding: 0 8px;
      gap: 8px;
    }
    .color-swatch:hover { border-color: #0096D6; }
    .color-swatch-preview {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.1);
    }
    .color-swatch-label { font-size: 11px; color: #666; }
    .color-palette {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #fff;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      padding: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 50;
      display: none;
    }
    .color-palette.show { display: block; }
    .color-palette-row {
      display: flex;
      gap: 4px;
      margin-bottom: 4px;
    }
    .color-palette-row:last-child { margin-bottom: 0; }
    .color-palette-item {
      width: 24px;
      height: 24px;
      border-radius: 3px;
      cursor: pointer;
      border: 1px solid rgba(0,0,0,0.1);
      transition: transform 0.1s;
    }
    .color-palette-item:hover { transform: scale(1.15); border-color: #0096D6; }
    .color-palette-item.selected { outline: 2px solid #0096D6; outline-offset: 1px; }
    .color-palette-custom {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e0e0e0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .color-palette-custom input[type="color"] {
      width: 32px;
      height: 24px;
      padding: 0;
      border: 1px solid #d0d0d0;
      border-radius: 3px;
      cursor: pointer;
    }
    .color-palette-custom span { font-size: 11px; color: #666; }

    .shape-bar{ display:flex; gap:4px; align-items:center; padding:4px 6px; border:1px solid #d0d0d0; border-radius:6px; background:#fff; }
    .shape-btn{ 
      background:transparent; 
      border:1px solid transparent; 
      color:#555; 
      padding:6px 10px; 
      border-radius:4px; 
      cursor:pointer; 
      font-size:14px;
      min-width:36px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .shape-btn:hover{ background:#f0f0f0; }
    .shape-btn.active{ background:#0096D6; border-color:#0096D6; color:#fff; }

    /* Print Preview Modal */
    #printPreviewModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 10000;
      justify-content: center;
      align-items: center;
    }
    #printPreviewModal.show { display: flex; }
    #printPreviewContent {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      max-width: 90vw;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #printPreviewHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #e0e0e0;
      background: #fafafa;
    }
    #printPreviewHeader h3 { margin: 0; font-size: 16px; }
    #printPreviewControls { display: flex; gap: 8px; align-items: center; }
    #printPreviewBody {
      flex: 1;
      overflow: auto;
      padding: 20px;
      background: #e0e0e0;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    #printPreviewPage {
      background: #fff;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      padding: 20px;
    }
    #printPreviewPage svg {
      display: block;
      max-width: 100%;
      height: auto;
    }
  
    @media print {
      body { background: #fff !important; margin: 0 !important; padding: 0 !important; }
      header, .toast, #inspector, #printPreviewModal { display: none !important; }
      #layout { height: auto !important; }
      #wrap { overflow: visible !important; background: #fff !important; }
      #svgContainer { 
        width: 100% !important; 
        height: auto !important;
      }
      svg { 
        background: #fff !important; 
        width: 100% !important;
        height: auto !important;
        max-width: 100%;
      }
      .grid { display: none !important; }
      .group-handle { display: none !important; }
      .node-resize-handle { display: none !important; }
    }

    /* Shape Library Panel */
    #shapeLibraryPanel {
      position: fixed;
      left: 0;
      top: 120px;
      width: 220px;
      max-height: calc(100vh - 140px);
      background: #fff;
      border: 1px solid #d0d0d0;
      border-left: none;
      border-radius: 0 8px 8px 0;
      box-shadow: 2px 2px 12px rgba(0,0,0,0.1);
      z-index: 100;
      display: none;
      flex-direction: column;
      overflow: hidden;
      transition: left 0.3s ease, top 0.3s ease;
    }
    #shapeLibraryPanel.visible {
      display: flex;
    }
    .library-header {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-weight: 600;
      font-size: 13px;
      cursor: grab;
      user-select: none;
    }
    .library-header:active {
      cursor: grabbing;
    }
    .library-header-actions {
      display: flex;
      gap: 4px;
    }
    .library-header-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    .library-header-btn:hover {
      background: rgba(255,255,255,0.3);
    }
    .library-tabs {
      display: flex;
      border-bottom: 1px solid #e8e8e8;
      background: #f8f9fa;
    }
    .library-tab {
      flex: 1;
      padding: 8px 12px;
      border: none;
      background: transparent;
      font-size: 11px;
      font-weight: 500;
      color: #666;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }
    .library-tab:hover {
      background: #f0f0f0;
      color: #333;
    }
    .library-tab.active {
      color: #667eea;
      border-bottom-color: #667eea;
      background: white;
    }
    .library-search {
      padding: 8px;
      border-bottom: 1px solid #e8e8e8;
    }
    .library-search input {
      width: 100%;
      padding: 6px 10px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      font-size: 12px;
    }
    .library-content {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }
    .library-category {
      margin-bottom: 12px;
      overflow: hidden;
    }
    .library-category-header {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: #f5f5f5;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      color: #555;
      cursor: pointer;
      user-select: none;
      position: relative;
      z-index: 1;
    }
    .library-category-header:hover {
      background: #eee;
    }
    .library-category-header .arrow {
      transition: transform 0.2s;
    }
    .library-category.collapsed .arrow {
      transform: rotate(-90deg);
    }
    .library-category.collapsed .library-items {
      display: none;
    }
    .library-items {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      padding: 8px 4px;
      overflow: hidden;
    }
    .library-item {
      aspect-ratio: 1;
      background: #f8f8f8;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      cursor: grab;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 4px;
      transition: all 0.15s;
      position: relative;
      overflow: hidden;
      min-height: 0;
    }
    .library-item:hover {
      border-color: #667eea;
      background: #f0f0ff;
      transform: scale(1.05);
    }
    .library-item:active {
      cursor: grabbing;
    }
    .library-item.selected {
      border-color: #667eea;
      background: #e8e8ff;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.3);
    }
    .library-item-preview {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      flex-shrink: 0;
    }
    .library-item-preview svg {
      max-width: 100%;
      max-height: 100%;
      width: 32px;
      height: 32px;
      object-fit: contain;
    }
    .library-item-name {
      font-size: 9px;
      color: #666;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      width: 100%;
      margin-top: 2px;
    }
    .library-item-menu {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 16px;
      height: 16px;
      background: rgba(0,0,0,0.4);
      border-radius: 3px;
      color: white;
      font-size: 10px;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .library-item:hover .library-item-menu {
      display: flex;
    }
    .library-actions {
      padding: 8px;
      border-top: 1px solid #e8e8e8;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .library-action-btn {
      width: 100%;
      padding: 8px 12px;
      background: #f5f5f5;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s;
    }
    .library-action-btn:hover {
      background: #e8e8e8;
      border-color: #bbb;
    }
    .library-action-btn.primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
    }
    .library-action-btn.primary:hover {
      filter: brightness(1.1);
    }
    .library-empty {
      text-align: center;
      padding: 20px;
      color: #999;
      font-size: 12px;
    }
    .library-empty svg {
      width: 48px;
      height: 48px;
      margin-bottom: 10px;
      opacity: 0.3;
    }
    
    /* Context menu for library */
    .context-menu {
      position: fixed;
      background: white;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      z-index: 10000;
      min-width: 160px;
      padding: 4px 0;
    }
    .context-menu-item {
      padding: 8px 14px;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .context-menu-item:hover {
      background: #f0f0ff;
    }
    .context-menu-item.danger {
      color: #c00;
    }
    .context-menu-item.danger:hover {
      background: #fff0f0;
    }
    .context-menu-sep {
      height: 1px;
      background: #e0e0e0;
      margin: 4px 0;
    }

    /* Canvas resize handle */
    #canvasResizeHandle {
      cursor: nwse-resize;
    }
    #canvasResizeHandle:hover path {
      stroke: #667eea;
      stroke-width: 2.5;
    }
  </style>
</head>
<body>

<header style="background:#fafafa; border-bottom:1px solid #e0e0e0;">
  <!-- Menu Bar (text menus) -->
  <div style="display:flex; align-items:center; gap:0; padding:4px 12px; background:#fff; border-bottom:1px solid #e8e8e8;">
    <div style="display:flex; align-items:center; gap:8px; margin-right:20px; cursor:default;">
      <!-- NexiMap Studio Logo - Minimal Network Grid -->
      <svg width="28" height="28" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#667eea"/>
            <stop offset="100%" style="stop-color:#764ba2"/>
          </linearGradient>
        </defs>
        <!-- Rounded square background -->
        <rect x="2" y="2" width="28" height="28" rx="4" fill="url(#logoGradient)"/>
        <!-- Subtle grid lines -->
        <path d="M8 8H24M8 16H24M8 24H24M8 8V24M16 8V24M24 8V24" stroke="white" stroke-width="0.8" opacity="0.2"/>
        <!-- Network highlight (X pattern) -->
        <path d="M8 8L16 16L24 8M16 16L8 24M16 16L24 24" stroke="white" stroke-width="1.8" stroke-linecap="round"/>
        <!-- Network nodes -->
        <circle cx="8" cy="8" r="2.5" fill="white"/>
        <circle cx="24" cy="8" r="2.5" fill="white"/>
        <circle cx="16" cy="16" r="3" fill="white"/>
        <circle cx="8" cy="24" r="2.5" fill="white"/>
        <circle cx="24" cy="24" r="2.5" fill="white"/>
      </svg>
      <span style="font-weight:600; font-size:15px; color:#5a67d8; letter-spacing:-0.3px;">NexiMap</span>
      <span style="font-weight:400; font-size:15px; color:#666; letter-spacing:-0.3px;">Studio</span>
    </div>
    <button class="menu-item" id="btnFile" type="button">File</button>
    <button class="menu-item" id="btnEditMenu" type="button">Edit</button>
    <button class="menu-item" id="btnViewMenu" type="button">View</button>
    <button class="menu-item" id="btnHelp" type="button">Help</button>
    <div class="menu" id="fileMenu" hidden>
      <div class="item" id="miNew">New <span style="opacity:0.5;float:right">Ctrl+N</span></div>
      <div class="sep"></div>
      <div class="item" id="miSave">Save <span style="opacity:0.5;float:right">Ctrl+S</span></div>
      <div class="item" id="miSaveAs">Save As‚Ä¶</div>
      <div class="sep"></div>
      <div class="item" id="miOpen">Open‚Ä¶ <span style="opacity:0.5;float:right">Ctrl+O</span></div>
      <div class="sep"></div>
      <div class="item" id="miRecover">Recover Autosave</div>
      <div class="item" id="miClearAutosave">Clear Autosave</div>
      <div class="sep"></div>
      <div class="item" id="miClearDiagram">Clear Diagram</div>
      <div class="item" id="miTrimCanvas">Trim Canvas to Content</div>
      <div class="sep"></div>
      <div class="item" id="miPrintPreview">Print Preview‚Ä¶</div>
      <div class="item" id="miPrint">Print‚Ä¶ <span style="opacity:0.5;float:right">Ctrl+P</span></div>
      <div class="sep"></div>
      <div class="item" id="miExportSVG">Export as SVG‚Ä¶</div>
      <div class="item" id="miExportPNG">Export as PNG‚Ä¶</div>
      <div class="item" id="miExportJPG">Export as JPG‚Ä¶</div>
      <div class="sep"></div>
      <div class="item" id="btnExportLinks">Export Links CSV</div>
      <div class="item" id="btnExportNodes">Export Nodes CSV</div>
    </div>
    <div class="menu" id="editMenu" hidden>
      <div class="item" id="miUndo">Undo <span style="opacity:0.5;float:right">Ctrl+Z</span></div>
      <div class="item" id="miRedo">Redo <span style="opacity:0.5;float:right">Ctrl+Shift+Z</span></div>
      <div class="sep"></div>
      <div class="item" id="miCopy">Copy <span style="opacity:0.5;float:right">Ctrl+C</span></div>
      <div class="item" id="miCut">Cut <span style="opacity:0.5;float:right">Ctrl+X</span></div>
      <div class="item" id="miPaste">Paste <span style="opacity:0.5;float:right">Ctrl+V</span></div>
      <div class="sep"></div>
      <div class="item" id="miDelete">Delete <span style="opacity:0.5;float:right">Del</span></div>
    </div>
    <div class="menu" id="viewMenu" hidden style="min-width:220px;">
      <div class="item" id="miZoomIn">Zoom In <span style="opacity:0.5;float:right">Ctrl++</span></div>
      <div class="item" id="miZoomOut">Zoom Out <span style="opacity:0.5;float:right">Ctrl+-</span></div>
      <div class="item" id="miFitView">Fit to View</div>
      <div class="sep"></div>
      <div class="item" id="miToggleInspector">Toggle Inspector <span style="opacity:0.5;float:right">I</span></div>
      <div class="item" id="miTagFilter">Tag Filter‚Ä¶ <span style="opacity:0.5;float:right">F</span></div>
      <div class="sep"></div>
      <div class="menu-section-header">üåç View Mode</div>
      <label class="item toggle-item"><input type="radio" name="viewMode" id="viewModeStandard" checked /> Standard Canvas</label>
      <label class="item toggle-item"><input type="radio" name="viewMode" id="viewModeGeo" /> Geographic View (GPS)</label>
      <div id="geoViewOptions" style="display:none; padding-left:10px; border-left:2px solid #0096D6;">
        <div class="menu-section-header" style="font-size:10px; margin-top:4px;">Map Background</div>
        <label class="item toggle-item"><input type="radio" name="mapSource" id="mapSourceUrl" checked /> Wikimedia Map (Default)</label>
        <label class="item toggle-item"><input type="radio" name="mapSource" id="mapSourceUpload" /> Uploaded Image</label>
        <label class="item toggle-item"><input type="radio" name="mapSource" id="mapSourceBuiltin" /> Built-in SVG Map</label>
        <div class="item" id="miLoadMapUrl" style="color:#0096D6;">üîó Load Map from URL...</div>
        <div class="item" id="miUploadGeoMap" style="color:#0096D6;">üì∑ Upload Map Image...</div>
        <div class="sep"></div>
        <div class="menu-section-header" style="font-size:10px;">Projection Adjustment</div>
        <div style="padding:6px 12px; font-size:11px;">
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
            <label style="width:70px; color:#666;">Scale X:</label>
            <input type="range" id="projScaleX" min="0.8" max="1.2" step="0.005" value="0.895" style="flex:1; cursor:pointer;">
            <input type="number" id="projScaleXVal" value="0.895" step="0.005" min="0.5" max="1.5" style="width:55px; font-size:10px; text-align:center; padding:2px;">
          </div>
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
            <label style="width:70px; color:#666;">Scale Y:</label>
            <input type="range" id="projScaleY" min="0.8" max="1.2" step="0.005" value="0.815" style="flex:1; cursor:pointer;">
            <input type="number" id="projScaleYVal" value="0.815" step="0.005" min="0.5" max="1.5" style="width:55px; font-size:10px; text-align:center; padding:2px;">
          </div>
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
            <label style="width:70px; color:#666;">Offset X:</label>
            <input type="range" id="projOffsetX" min="-100" max="100" step="1" value="-61" style="flex:1; cursor:pointer;">
            <input type="number" id="projOffsetXVal" value="-61" step="1" min="-200" max="200" style="width:55px; font-size:10px; text-align:center; padding:2px;">
          </div>
          <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
            <label style="width:70px; color:#666;">Offset Y:</label>
            <input type="range" id="projOffsetY" min="-100" max="100" step="1" value="-10" style="flex:1; cursor:pointer;">
            <input type="number" id="projOffsetYVal" value="-10" step="1" min="-200" max="200" style="width:55px; font-size:10px; text-align:center; padding:2px;">
          </div>
          <div style="display:flex; gap:6px; margin-top:8px;">
            <button id="projResetBtn" class="btn mini-btn" style="flex:1;">Reset</button>
            <button id="projShowValuesBtn" class="btn mini-btn" style="flex:1;">üìã Copy Values</button>
          </div>
          <div style="font-size:9px; color:#888; margin-top:6px;">Calibrated for Wikimedia world map</div>
        </div>
      </div>
      <div class="sep"></div>
      <div class="menu-section-header">Node Labels</div>
      <label class="item toggle-item"><input type="checkbox" id="tglShowNodeName" checked /> Node Names</label>
      <label class="item toggle-item"><input type="checkbox" id="tglShowNodeCode" checked /> Node Codes</label>
      <label class="item toggle-item"><input type="checkbox" id="tglShowNodeTags" /> Node Tags</label>
      <label class="item toggle-item"><input type="checkbox" id="tglShowExtraTags" /> Additional Tags</label>
      <div class="sep"></div>
      <div class="menu-section-header">Link Labels</div>
      <label class="item toggle-item"><input type="checkbox" id="tglShowLinkTag" checked /> Link Tags</label>
      <label class="item toggle-item"><input type="checkbox" id="tglShowLinkCode" checked /> Link Codes</label>
      <label class="item toggle-item"><input type="checkbox" id="tglShowLatency" checked /> Latency Values</label>
      <div class="sep"></div>
      <div class="menu-section-header">Container Labels</div>
      <label class="item toggle-item"><input type="checkbox" id="tglShowContainerTitle" checked /> Container Titles</label>
    </div>
    <div class="menu" id="helpMenu" hidden style="min-width:280px;">
      <div style="padding:10px 14px; font-weight:600; border-bottom:1px solid #e0e0e0; background:#f8f8f8;">
        Keyboard Shortcuts
      </div>
      <div style="padding:10px 14px; font-size:12px; line-height:1.8;">
        <div style="margin-bottom:10px; padding-bottom:8px; border-bottom:1px solid #f0f0f0;">
          <div style="font-weight:600; color:#555; margin-bottom:6px; font-size:11px; text-transform:uppercase;">Canvas Navigation</div>
          <div><kbd>Drag</kbd> Pan canvas</div>
          <div><kbd>Ctrl</kbd>+<kbd>Wheel</kbd> Zoom in/out</div>
          <div><kbd>Ctrl</kbd>+<kbd>0</kbd> Reset zoom to 100%</div>
        </div>
        <div style="margin-bottom:10px; padding-bottom:8px; border-bottom:1px solid #f0f0f0;">
          <div style="font-weight:600; color:#555; margin-bottom:6px; font-size:11px; text-transform:uppercase;">Creating & Selecting</div>
          <div><kbd>Double-click</kbd> Create new node</div>
          <div><kbd>Alt</kbd>+<kbd>Drag</kbd> Selection box</div>
          <div><kbd>Shift</kbd>+<kbd>Click</kbd> Add to selection</div>
          <div><kbd>Del</kbd> / <kbd>Backspace</kbd> Delete selected</div>
        </div>
        <div style="margin-bottom:10px; padding-bottom:8px; border-bottom:1px solid #f0f0f0;">
          <div style="font-weight:600; color:#555; margin-bottom:6px; font-size:11px; text-transform:uppercase;">Labels & Positioning</div>
          <div><kbd>Ctrl</kbd>+<kbd>Drag</kbd> Move text labels</div>
        </div>
        <div style="margin-bottom:10px; padding-bottom:8px; border-bottom:1px solid #f0f0f0;">
          <div style="font-weight:600; color:#555; margin-bottom:6px; font-size:11px; text-transform:uppercase;">Edit Operations</div>
          <div><kbd>Ctrl</kbd>+<kbd>C</kbd> Copy</div>
          <div><kbd>Ctrl</kbd>+<kbd>X</kbd> Cut</div>
          <div><kbd>Ctrl</kbd>+<kbd>V</kbd> Paste</div>
          <div><kbd>Ctrl</kbd>+<kbd>Z</kbd> Undo</div>
          <div><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Z</kbd> Redo</div>
        </div>
        <div>
          <div style="font-weight:600; color:#555; margin-bottom:6px; font-size:11px; text-transform:uppercase;">File Operations</div>
          <div><kbd>Ctrl</kbd>+<kbd>N</kbd> New diagram</div>
          <div><kbd>Ctrl</kbd>+<kbd>O</kbd> Open file</div>
          <div><kbd>Ctrl</kbd>+<kbd>S</kbd> Save</div>
          <div><kbd>Ctrl</kbd>+<kbd>P</kbd> Print</div>
        </div>
      </div>
    </div>
    <input type="file" id="fileLoad" accept=".ndg,application/json" style="display:none;" />
  </div>
  
  <!-- Icon Toolbar -->
  <div style="display:flex; align-items:center; gap:2px; padding:4px 12px; background:#fafafa;">
    <!-- Zoom Controls -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnZoomLevel" type="button" style="min-width:60px; font-size:12px; gap:4px;" title="Click for zoom options">
        <span id="zoomLevel">100%</span> <span style="font-size:10px;">‚ñæ</span>
      </button>
      <div class="menu" id="zoomMenu" hidden style="min-width:180px;">
        <div class="item" id="zoomFitView">Fit to View <span style="opacity:0.5;float:right">Enter</span></div>
        <div class="sep"></div>
        <div class="item zoom-preset" data-zoom="0.25">25%</div>
        <div class="item zoom-preset" data-zoom="0.50">50%</div>
        <div class="item zoom-preset" data-zoom="0.75">75%</div>
        <div class="item zoom-preset" data-zoom="1.00">100%</div>
        <div class="item zoom-preset" data-zoom="1.25">125%</div>
        <div class="item zoom-preset" data-zoom="1.50">150%</div>
        <div class="item zoom-preset" data-zoom="2.00">200%</div>
        <div class="item zoom-preset" data-zoom="3.00">300%</div>
        <div class="item zoom-preset" data-zoom="4.00">400%</div>
        <div class="sep"></div>
        <div class="item" id="zoomReset">Reset to 100% <span style="opacity:0.5;float:right">Ctrl+0</span></div>
      </div>
    </div>
    <!-- Zoom In -->
    <button class="tool-btn" id="btnZoomIn" type="button" title="Zoom In">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/>
      </svg>
    </button>
    <!-- Zoom Out -->
    <button class="tool-btn" id="btnZoomOut" type="button" title="Zoom Out">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/>
      </svg>
    </button>
    <!-- Fit to View -->
    <button class="tool-btn" id="btnZoomFit" type="button" title="Fit to View">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
      </svg>
    </button>
    <!-- Grid Toggle -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnGridToggle" type="button" title="Toggle Grid">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
          <line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/>
          <line x1="6" y1="3" x2="6" y2="21"/><line x1="12" y1="3" x2="12" y2="21"/><line x1="18" y1="3" x2="18" y2="21"/>
        </svg>
      </button>
      <div class="menu" id="gridMenu" hidden style="min-width:150px;">
        <label class="item toggle-item"><input type="checkbox" id="gridEnabled" checked /> Show Grid</label>
        <div class="sep"></div>
        <div class="item grid-size" data-size="10">Fine (10px)</div>
        <div class="item grid-size" data-size="20">Small (20px)</div>
        <div class="item grid-size active" data-size="40">Medium (40px)</div>
        <div class="item grid-size" data-size="60">Large (60px)</div>
        <div class="item grid-size" data-size="100">Extra Large (100px)</div>
      </div>
    </div>
    
    <div class="tool-sep"></div>
    
    <!-- Undo -->
    <button class="tool-btn" id="btnUndo" type="button" title="Undo (Ctrl+Z)">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M3 7v6h6"/><path d="M3 13c0-4.97 4.03-9 9-9s9 4.03 9 9-4.03 9-9 9c-2.12 0-4.07-.74-5.61-1.97"/>
      </svg>
    </button>
    <!-- Redo -->
    <button class="tool-btn" id="btnRedo" type="button" title="Redo (Ctrl+Shift+Z)">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 7v6h-6"/><path d="M21 13c0-4.97-4.03-9-9-9s-9 4.03-9 9 4.03 9 9 9c2.12 0 4.07-.74 5.61-1.97"/>
      </svg>
    </button>
    
    <div class="tool-sep"></div>
    
    <!-- Delete -->
    <button class="tool-btn" id="btnDelete" type="button" title="Delete Selected">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/>
      </svg>
    </button>
    
    <div class="tool-sep"></div>
    
    <!-- Container Box -->
    <button class="tool-btn" id="btnAddGroup" type="button" title="Add Container Box">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2"/>
      </svg>
    </button>
    <!-- Group Box -->
    <button class="tool-btn" id="btnAddRegion" type="button" title="Add Group Box (Container of Containers)">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="8" height="8" rx="1"/><rect x="13" y="3" width="8" height="8" rx="1"/><rect x="3" y="13" width="8" height="8" rx="1"/><rect x="13" y="13" width="8" height="8" rx="1"/>
      </svg>
    </button>
    
    <div class="tool-sep"></div>
    
    <!-- Shape Tools -->
    <button class="tool-btn shape-tool active" data-shape="circle" type="button" title="Circle">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/></svg>
    </button>
    <button class="tool-btn shape-tool" data-shape="square" type="button" title="Square">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16"/></svg>
    </button>
    <button class="tool-btn shape-tool" data-shape="triangle" type="button" title="Triangle">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"><polygon points="12,3 22,21 2,21"/></svg>
    </button>
    <button class="tool-btn shape-tool" data-shape="rectangle" type="button" title="Rectangle">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="6" width="20" height="12"/></svg>
    </button>
    <button class="tool-btn shape-tool" data-shape="ellipse" type="button" title="Ellipse">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><ellipse cx="12" cy="12" rx="10" ry="6"/></svg>
    </button>
    <button class="tool-btn shape-tool" data-shape="hexagon" type="button" title="Hexagon">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"><polygon points="12,2 21,7 21,17 12,22 3,17 3,7"/></svg>
    </button>
    
    <div class="tool-sep"></div>
    
    <!-- Link Tool -->
    <button class="tool-btn" id="btnCreateLink" type="button" title="Create Link (click two nodes)">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/>
      </svg>
    </button>
    
    <div class="tool-sep"></div>
    
    <!-- Fill Color -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnFillColor" type="button" title="Fill Color">
        <span style="display:flex; flex-direction:column; align-items:center; line-height:1;">
          <svg width="18" height="14" viewBox="0 0 24 18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M17 9l-6-6-7.4 7.4a2 2 0 0 0 0 2.8l4.2 4.2a2 2 0 0 0 2.8 0L17 9z"/>
            <path d="M4 2l4 4"/>
            <path d="M20 12c0 1.5-1.2 2.5-2.5 2.5S15 14 15 14s1.2-2.5 2.5-2.5S20 10.5 20 12z" fill="currentColor"/>
          </svg>
          <span id="fillColorIndicator" style="width:18px; height:4px; background:#dae8fc; border:1px solid #999; margin-top:2px; border-radius:1px;"></span>
        </span>
      </button>
      <div class="menu color-menu" id="fillColorMenu" hidden style="min-width:180px; padding:8px;">
        <div style="font-size:11px; color:#666; margin-bottom:6px;">Fill Color</div>
        <div class="color-grid" id="fillColorGrid"></div>
        <div style="margin-top:8px; display:flex; gap:4px; align-items:center;">
          <input type="color" id="fillColorCustom" style="width:28px; height:28px; border:none; padding:0; cursor:pointer;" />
          <span style="font-size:11px; color:#666;">Custom</span>
        </div>
      </div>
    </div>
    
    <div style="position:relative;">
      <button class="tool-btn" id="btnStrokeColor" type="button" title="Stroke/Line Color">
        <span style="display:flex; flex-direction:column; align-items:center; line-height:1;">
          <svg width="18" height="14" viewBox="0 0 24 18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M15 2a2.5 2.5 0 1 1 3.5 3.5L6 18l-4 1 1-4L15 2z"/>
          </svg>
          <span id="strokeColorIndicator" style="width:18px; height:4px; background:#6c8ebf; border:1px solid #999; margin-top:2px; border-radius:1px;"></span>
        </span>
      </button>
      <div class="menu color-menu" id="strokeColorMenu" hidden style="min-width:180px; padding:8px;">
        <div style="font-size:11px; color:#666; margin-bottom:6px;">Stroke/Line Color</div>
        <div class="color-grid" id="strokeColorGrid"></div>
        <div style="margin-top:8px; display:flex; gap:4px; align-items:center;">
          <input type="color" id="strokeColorCustom" style="width:28px; height:28px; border:none; padding:0; cursor:pointer;" />
          <span style="font-size:11px; color:#666;">Custom</span>
        </div>
      </div>
    </div>
    
    <!-- Line Format (Width + Style) -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnLineWidth" type="button" title="Line Format (Width & Style)">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none">
          <rect x="2" y="4" width="20" height="2" rx="1"/>
          <rect x="2" y="11" width="20" height="3" rx="1.5"/>
          <rect x="2" y="18" width="20" height="4" rx="2"/>
        </svg>
      </button>
      <div class="menu" id="lineWidthMenu" hidden style="min-width:160px;">
        <div style="padding:6px 12px; font-size:11px; color:#666; border-bottom:1px solid #e0e0e0;">Line Width</div>
        <div class="item line-width-item" data-width="1">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="1"/></svg> 1px
        </div>
        <div class="item line-width-item" data-width="2">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="2"/></svg> 2px
        </div>
        <div class="item line-width-item" data-width="3">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="3"/></svg> 3px
        </div>
        <div class="item line-width-item" data-width="4">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="4"/></svg> 4px
        </div>
        <div class="item line-width-item" data-width="5">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="5"/></svg> 5px
        </div>
        <div class="item line-width-item" data-width="6">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="6"/></svg> 6px
        </div>
        <div class="sep"></div>
        <div style="padding:6px 12px; font-size:11px; color:#666; border-bottom:1px solid #e0e0e0;">Line Style</div>
        <div class="item line-style-item" data-linestyle="solid">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="2"/></svg> Solid
        </div>
        <div class="item line-style-item" data-linestyle="dashed">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="2" stroke-dasharray="8,4"/></svg> Dashed
        </div>
        <div class="item line-style-item" data-linestyle="dotted">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="2" stroke-dasharray="2,3"/></svg> Dotted
        </div>
      </div>
    </div>
    
    <!-- Link Style -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnLinkStyle" type="button" title="Link Style">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
          <path d="M5 19 Q 5 5, 19 5"/>
        </svg>
      </button>
      <div class="menu" id="linkStyleMenu" hidden style="min-width:160px;">
        <div style="padding:6px 12px; font-size:11px; color:#666; border-bottom:1px solid #e0e0e0;">Link Style</div>
        <div class="item link-style-item" data-style="straight">‚Äï Straight</div>
        <div class="item link-style-item" data-style="orthogonal">‚îå Orthogonal (90¬∞)</div>
        <div class="item link-style-item" data-style="curve">‚àø Curved</div>
        <div class="sep"></div>
        <div style="padding:6px 12px; font-size:11px; color:#666;">Orthogonal Direction</div>
        <div class="item link-route-item" data-route="hv">‚Üí‚Üì Horizontal first</div>
        <div class="item link-route-item" data-route="vh">‚Üì‚Üí Vertical first</div>
      </div>
    </div>
    
    <div class="tool-sep"></div>
    
    <!-- Font Colour -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnFontColor" type="button" title="Font Colour">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <text x="6" y="16" font-size="14" font-weight="bold" fill="currentColor" stroke="none">A</text>
          <rect x="3" y="19" width="18" height="3" fill="#e53935" stroke="none"/>
        </svg>
      </button>
      <div class="menu" id="fontColorMenu" hidden style="min-width:260px; max-height:400px; overflow-y:auto;">
        <div style="padding:8px 12px; font-weight:600; border-bottom:1px solid #e0e0e0;">Font Colour & Visibility</div>
        <div id="fontColorNoSelection" class="muted" style="padding:12px;">Select a node, link, or container to format text.</div>
        <div id="fontColorFields" style="display:none;"></div>
      </div>
    </div>
    
    <!-- Font Type -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnFontType" type="button" title="Font Type & Size">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <text x="3" y="16" font-size="16" font-weight="bold" fill="currentColor" stroke="none">T</text>
          <text x="13" y="16" font-size="10" fill="currentColor" stroke="none">T</text>
        </svg>
      </button>
      <div class="menu" id="fontTypeMenu" hidden style="min-width:280px; max-height:400px; overflow-y:auto;">
        <div style="padding:8px 12px; font-weight:600; border-bottom:1px solid #e0e0e0;">Font Type & Size</div>
        <div id="fontTypeNoSelection" class="muted" style="padding:12px;">Select a node, link, or container to format text.</div>
        <div id="fontTypeFields" style="display:none;"></div>
      </div>
    </div>
    
    <div class="tool-sep"></div>
    
    <!-- Brush (Format Painter) - Tilted brush like reference -->
    <button class="tool-btn" id="btnBrush" type="button" title="Format Painter - Copy and apply formatting">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <!-- Handle -->
        <path d="M5 19 Q 7 17, 9 15"/>
        <circle cx="4" cy="20" r="1.5" fill="currentColor"/>
        <!-- Ferrule -->
        <rect x="8" y="8" width="8" height="4" rx="1" transform="rotate(-45 12 10)"/>
        <!-- Bristles -->
        <path d="M13 7 L19 1 L23 5 L17 11 Z"/>
        <path d="M15 5 L17 7" stroke-width="1.5"/>
        <path d="M17 3 L19 5" stroke-width="1.5"/>
        <path d="M19 5 L21 7" stroke-width="1.5"/>
      </svg>
    </button>
    
    <!-- Apply Style Button -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnApplyStyle" type="button" title="Apply Saved Style to Selection">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <!-- Magic wand -->
          <path d="M15 4l-9 9 3 3 9-9-3-3z"/>
          <path d="M14.5 4.5l3 3"/>
          <!-- Sparkles -->
          <path d="M3 11l1-1-1-1-1 1 1 1z" fill="currentColor" stroke="none"/>
          <path d="M7 7l1-1-1-1-1 1 1 1z" fill="currentColor" stroke="none"/>
          <path d="M11 3l1-1-1-1-1 1 1 1z" fill="currentColor" stroke="none"/>
          <path d="M19 11v2M18 12h2" stroke-width="1.5"/>
          <path d="M5 19v2M4 20h2" stroke-width="1.5"/>
        </svg>
      </button>
      <div class="menu" id="applyStyleMenu" hidden style="min-width:240px; max-width:320px; max-height:400px; overflow-y:auto;">
        <div style="padding:8px 12px; font-size:12px; font-weight:600; color:#333; border-bottom:1px solid #e0e0e0; background:#f8f8f8;">
          Apply Style to Selection
        </div>
        <div id="applyStyleContent">
          <!-- Content will be populated dynamically -->
        </div>
        <div id="applyStyleEmpty" style="padding:16px 12px; text-align:center; color:#888; font-size:12px;">
          Select items to apply styles
        </div>
        <div style="padding:8px 12px; border-top:1px solid #e0e0e0; background:#f8f8f8;">
          <button class="mini-btn" id="btnManageStyles" style="width:100%; font-size:11px;">Manage Styles...</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Toolbar Line 2: Filters and Panels -->
  <div style="display:flex; align-items:center; gap:2px; padding:4px 12px; background:#f5f5f5; border-top:1px solid #e8e8e8;">
    <!-- Tag Filter -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnTagFilter" type="button" title="Filter by Tags">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M19 12.5l-6 6a2 2 0 0 1-2.8 0L3 11.5V4h7.5l8.5 8.5z"/>
          <circle cx="7" cy="8" r="1.5" fill="currentColor"/>
        </svg>
        <span style="font-size:11px; margin-left:4px;">Tags</span>
      </button>
      <div class="menu" id="tagFilterMenu" hidden style="min-width:250px; max-height:450px; overflow-y:auto;">
        <div style="padding:8px 12px; font-weight:600; border-bottom:1px solid #e0e0e0;">Filter by Tags</div>
        <div style="padding:8px 12px;">
          <input type="text" id="tagFilterSearch" placeholder="Search tags..." style="width:100%; padding:6px 8px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
        </div>
        <label class="item toggle-item"><input type="radio" name="filterMode" value="all" checked /> Show All (no filter)</label>
        <label class="item toggle-item"><input type="radio" name="filterMode" value="include" /> Show only selected tags</label>
        <label class="item toggle-item"><input type="radio" name="filterMode" value="exclude" /> Hide selected tags</label>
        <div class="sep"></div>
        <label class="item toggle-item"><input type="checkbox" id="tagFilterExclusive" /> Exclusive (ignore Cable System filter)</label>
        <div class="sep"></div>
        <div style="padding:4px 12px; font-size:11px; color:#666;">Tags:</div>
        <div id="tagFilterList" style="max-height:200px; overflow-y:auto;"></div>
        <div class="sep"></div>
        <div style="display:flex; gap:8px; padding:8px 12px;">
          <button class="mini-btn" id="btnTagSelectAll" type="button">Select All</button>
          <button class="mini-btn" id="btnTagClearAll" type="button">Clear All</button>
        </div>
      </div>
    </div>
    
    <div class="tool-sep"></div>
    
    <!-- Inspector Toggle (for nodes, links, groups) -->
    <button class="tool-btn" id="btnToggleInspector" type="button" title="Toggle Inspector (I)">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <line x1="4" y1="7" x2="20" y2="7"/><circle cx="8" cy="7" r="2" fill="currentColor"/>
        <line x1="4" y1="12" x2="20" y2="12"/><circle cx="14" cy="12" r="2" fill="currentColor"/>
        <line x1="4" y1="17" x2="20" y2="17"/><circle cx="10" cy="17" r="2" fill="currentColor"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">Inspector</span>
    </button>
    
    <!-- Shape Library Toggle -->
    <button class="tool-btn" id="btnToggleLibrary" type="button" title="Toggle Shape Library">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
        <circle cx="12" cy="10" r="3"/>
        <path d="M9 16h6"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">Library</span>
    </button>
    
    <div class="tool-sep"></div>
    
    <!-- Cable System List Toggle -->
    <button class="tool-btn" id="btnToggleCableNavigator" type="button" title="Toggle Cable System List">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 4h6v6H4zM14 4h6v6h-6zM4 14h6v6H4z"/>
        <line x1="17" y1="14" x2="17" y2="20"/>
        <line x1="14" y1="17" x2="20" y2="17"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">CS List</span>
    </button>
    
    <!-- Cable System Details Toggle -->
    <button class="tool-btn" id="btnToggleCableInspector" type="button" title="Toggle Cable System Details">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2"/>
        <line x1="3" y1="9" x2="21" y2="9"/>
        <line x1="9" y1="21" x2="9" y2="9"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">CS Details</span>
    </button>
    
    <div class="tool-sep"></div>
    
    <!-- Cable System Filter -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnCableSystemFilter" type="button" title="Filter by Cable System">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>
        </svg>
        <span style="font-size:11px; margin-left:4px;">System Filter</span>
      </button>
      <div class="menu" id="cableSystemFilterMenu" hidden style="min-width:280px; max-height:450px; overflow-y:auto;">
        <div style="padding:8px 12px; font-weight:600; border-bottom:1px solid #e0e0e0;">Filter by Cable System</div>
        <div style="padding:8px 12px;">
          <input type="text" id="cableSystemFilterSearch" placeholder="Search cable systems..." style="width:100%; padding:6px 8px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
        </div>
        <label class="item toggle-item"><input type="radio" name="cableFilterMode" value="all" checked /> Show All</label>
        <label class="item toggle-item"><input type="radio" name="cableFilterMode" value="selected" /> Show selected systems only</label>
        <div class="sep"></div>
        <label class="item toggle-item"><input type="checkbox" id="cableFilterShowUnmapped" checked /> Include unmapped items</label>
        <label class="item toggle-item"><input type="checkbox" id="cableFilterExclusive" /> Exclusive (ignore Tag filter)</label>
        <div class="sep"></div>
        <div style="padding:4px 12px; font-size:11px; color:#666;">Cable Systems:</div>
        <div id="cableSystemFilterList" style="max-height:200px; overflow-y:auto;"></div>
        <div class="sep"></div>
        <div style="display:flex; gap:8px; padding:8px 12px;">
          <button class="mini-btn" id="btnCableSelectAll" type="button">Select All</button>
          <button class="mini-btn" id="btnCableClearAll" type="button">Clear All</button>
        </div>
      </div>
    </div>
    
    <div class="tool-sep"></div>
    
    <!-- Node Filter -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnNodeFilter" type="button" title="Filter by Node">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="8"/>
          <line x1="12" y1="2" x2="12" y2="6"/>
          <line x1="12" y1="18" x2="12" y2="22"/>
          <line x1="2" y1="12" x2="6" y2="12"/>
          <line x1="18" y1="12" x2="22" y2="12"/>
        </svg>
        <span style="font-size:11px; margin-left:4px;">Node Filter</span>
      </button>
      <div class="menu" id="nodeFilterMenu" hidden style="min-width:280px; max-height:450px; overflow-y:auto;">
        <div style="padding:8px 12px; font-weight:600; border-bottom:1px solid #e0e0e0;">Filter by Node</div>
        <div style="padding:8px 12px;">
          <input type="text" id="nodeFilterSearch" placeholder="Search nodes..." style="width:100%; padding:6px 8px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
        </div>
        <label class="item toggle-item"><input type="radio" name="nodeFilterMode" value="all" checked /> Show All</label>
        <label class="item toggle-item"><input type="radio" name="nodeFilterMode" value="selected" /> Show selected nodes only</label>
        <div class="sep"></div>
        <div style="padding:4px 12px; font-size:11px; color:#666;">Display as:</div>
        <label class="item toggle-item"><input type="radio" name="nodeDisplayMode" value="name" checked /> Node Name</label>
        <label class="item toggle-item"><input type="radio" name="nodeDisplayMode" value="code" /> Node Code</label>
        <div class="sep"></div>
        <label class="item toggle-item"><input type="checkbox" id="nodeFilterExclusive" /> Exclusive (ignore other filters)</label>
        <div class="sep"></div>
        <div style="padding:4px 12px; font-size:11px; color:#666;">Nodes:</div>
        <div id="nodeFilterList" style="max-height:200px; overflow-y:auto;"></div>
        <div class="sep"></div>
        <div style="display:flex; gap:8px; padding:8px 12px;">
          <button class="mini-btn" id="btnNodeSelectAll" type="button">Select All</button>
          <button class="mini-btn" id="btnNodeClearAll" type="button">Clear All</button>
        </div>
      </div>
    </div>
    
    <div class="tool-sep"></div>
    
    <!-- Container Filter -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnContainerFilter" type="button" title="Filter by Container">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="3" y="3" width="18" height="18" rx="2"/>
          <rect x="7" y="7" width="10" height="10" rx="1"/>
        </svg>
        <span style="font-size:11px; margin-left:4px;">Container</span>
      </button>
      <div class="menu" id="containerFilterMenu" hidden style="min-width:300px; max-height:500px; overflow-y:auto;">
        <div style="padding:8px 12px; font-weight:600; border-bottom:1px solid #e0e0e0;">Filter by Container</div>
        <div style="padding:8px 12px;">
          <input type="text" id="containerFilterSearch" placeholder="Search containers..." style="width:100%; padding:6px 8px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
        </div>
        <label class="item toggle-item"><input type="radio" name="containerFilterMode" value="all" checked /> Show All</label>
        <label class="item toggle-item"><input type="radio" name="containerFilterMode" value="selected" /> Show selected containers only</label>
        <div class="sep"></div>
        <label class="item toggle-item"><input type="checkbox" id="containerFilterExclusive" /> Exclusive (ignore other filters)</label>
        <div class="sep"></div>
        <div id="containerFilterSections">
          <div style="padding:4px 12px; font-size:11px; color:#666; background:#f5f5f5; border-top:1px solid #e0e0e0;">‚ñ¢ Container Boxes:</div>
          <div id="containerFilterListBoxes" style="max-height:150px; overflow-y:auto;"></div>
          <div style="padding:4px 12px; font-size:11px; color:#666; background:#f5f5f5; border-top:1px solid #e0e0e0;">‚ñ£ Groups (Container of Containers):</div>
          <div id="containerFilterListGroups" style="max-height:150px; overflow-y:auto;"></div>
        </div>
        <div class="sep"></div>
        <div style="display:flex; gap:8px; padding:8px 12px;">
          <button class="mini-btn" id="btnContainerSelectAll" type="button">Select All</button>
          <button class="mini-btn" id="btnContainerClearAll" type="button">Clear All</button>
        </div>
      </div>
    </div>
    
    <div style="flex:1;"></div>
    
    <!-- Label Manager Button -->
    <button class="tool-btn" id="btnLabelManager" type="button" title="Label Manager - Manage tags across nodes, links, and containers">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 2L2 7l10 5 10-5-10-5z"/>
        <path d="M2 17l10 5 10-5"/>
        <path d="M2 12l10 5 10-5"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">Labels</span>
    </button>
    
    <!-- Geographic View Toggle Button -->
    <button class="tool-btn" id="btnGeoView" type="button" title="Toggle Geographic View - Show nodes on world map based on GPS coordinates">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="10"/>
        <ellipse cx="12" cy="12" rx="10" ry="4"/>
        <path d="M12 2v20"/>
        <path d="M2 12h20"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">Geo</span>
    </button>
    
    <!-- Route Finder Button -->
    <button class="tool-btn" id="btnRouteFinder" type="button" title="Route Finder - Find optimal paths between nodes">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <!-- Path/route icon -->
        <circle cx="5" cy="5" r="3" fill="#22c55e" stroke="#22c55e"/>
        <circle cx="19" cy="19" r="3" fill="#ef4444" stroke="#ef4444"/>
        <path d="M7 7 L12 12 L17 17" stroke-dasharray="3,2"/>
        <path d="M5 8 L5 16 L8 19" stroke-width="1.5"/>
        <path d="M8 5 L16 5 L19 8" stroke-width="1.5"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">Routes</span>
    </button>
  </div>
</header>

<!-- Shape Library Panel -->
<div id="shapeLibraryPanel">
  <div class="library-header" title="Drag to move ‚Ä¢ Double-click to reset position">
    <span>üìö Shape Library</span>
    <div class="library-header-actions">
      <button class="library-header-btn" id="btnLibraryImport" title="Import SVG">+</button>
      <button class="library-header-btn" id="btnLibraryMenu" title="Library Options">‚ãÆ</button>
      <button class="library-header-btn" id="btnLibraryClose" title="Close Library">√ó</button>
    </div>
  </div>
  <!-- Library Tabs -->
  <div class="library-tabs">
    <button class="library-tab active" data-tab="nodes">üîµ Nodes</button>
    <button class="library-tab" data-tab="containers">üì¶ Containers</button>
  </div>
  <div class="library-search">
    <input type="text" id="librarySearch" placeholder="Search shapes..." />
  </div>
  <div class="library-content" id="libraryContent">
    <!-- Library items will be populated here -->
  </div>
  <div class="library-actions" id="libraryActionsNodes">
    <button class="library-action-btn primary" id="btnSaveNodeToLibrary">
      <span>üíæ</span> Save Selected Node
    </button>
    <button class="library-action-btn" id="btnImportSVGToLibrary">
      <span>üìÅ</span> Import SVG File
    </button>
    <button class="library-action-btn" id="btnExportLibrary">
      <span>üì§</span> Export Library
    </button>
  </div>
  <div class="library-actions" id="libraryActionsContainers" style="display:none;">
    <button class="library-action-btn" id="btnImportContainerShape">
      <span>üìÅ</span> Import Shape SVG
    </button>
    <div style="font-size:10px; color:#888; text-align:center; padding:4px 8px;">
      Drag shapes to canvas to create containers
    </div>
  </div>
</div>

<!-- Hidden file inputs for library -->
<input type="file" id="svgImportInput" accept=".svg,image/svg+xml" style="display:none;" />
<input type="file" id="libraryImportInput" accept=".ndl,.json" style="display:none;" />

<div id="layout">
  <div id="wrap">
    <div id="svgContainer" style="transform-origin: 0 0;">
      <svg id="svg" viewBox="0 0 1600 900" preserveAspectRatio="none"></svg>
    </div>
    <div class="toast" id="toast"></div>
  </div>

  <!-- Floating Projection Adjustment Panel (visible in Geo View) -->
  <div id="projectionPanel" style="
    position: absolute;
    left: 20px;
    top: 20px;
    width: 280px;
    background: #ffffff;
    border: 1px solid #d0d0d0;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.12);
    z-index: 100;
    display: none;
    font-size: 12px;
  ">
    <div style="
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      background: #f8f9fa;
      border-bottom: 1px solid #e8e8e8;
      border-radius: 8px 8px 0 0;
    ">
      <span style="font-weight: 600; color: #333;">üéØ Projection Adjustment</span>
      <button id="projPanelClose" style="
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
        color: #999;
        padding: 0 4px;
      ">‚úï</button>
    </div>
    <div style="padding: 12px;">
      <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
        <label style="width:65px; color:#666; font-size:11px;">Scale X:</label>
        <input type="range" id="projScaleX2" min="0.8" max="1.2" step="0.005" value="0.895" style="flex:1; cursor:pointer;">
        <input type="number" id="projScaleXVal2" value="0.895" step="0.005" min="0.5" max="1.5" style="width:50px; font-size:10px; text-align:center; padding:3px; border:1px solid #ccc; border-radius:3px;">
      </div>
      <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
        <label style="width:65px; color:#666; font-size:11px;">Scale Y:</label>
        <input type="range" id="projScaleY2" min="0.8" max="1.2" step="0.005" value="0.815" style="flex:1; cursor:pointer;">
        <input type="number" id="projScaleYVal2" value="0.815" step="0.005" min="0.5" max="1.5" style="width:50px; font-size:10px; text-align:center; padding:3px; border:1px solid #ccc; border-radius:3px;">
      </div>
      <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
        <label style="width:65px; color:#666; font-size:11px;">Offset X:</label>
        <input type="range" id="projOffsetX2" min="-100" max="100" step="1" value="-61" style="flex:1; cursor:pointer;">
        <input type="number" id="projOffsetXVal2" value="-61" step="1" min="-200" max="200" style="width:50px; font-size:10px; text-align:center; padding:3px; border:1px solid #ccc; border-radius:3px;">
      </div>
      <div style="display:flex; align-items:center; gap:8px; margin-bottom:10px;">
        <label style="width:65px; color:#666; font-size:11px;">Offset Y:</label>
        <input type="range" id="projOffsetY2" min="-100" max="100" step="1" value="-10" style="flex:1; cursor:pointer;">
        <input type="number" id="projOffsetYVal2" value="-10" step="1" min="-200" max="200" style="width:50px; font-size:10px; text-align:center; padding:3px; border:1px solid #ccc; border-radius:3px;">
      </div>
      <div style="display:flex; gap:6px;">
        <button id="projResetBtn2" class="btn mini-btn" style="flex:1; font-size:10px;">üîÑ Reset</button>
        <button id="projCopyBtn2" class="btn mini-btn" style="flex:1; font-size:10px;">üìã Copy</button>
      </div>
      <div style="font-size:9px; color:#888; margin-top:8px; line-height:1.4;">
        üí° Scale &lt;1 shrinks nodes toward center.<br>
        Adjust until nodes align with map features.
      </div>
    </div>
  </div>

  <aside id="inspector">
    <div id="inspectorHeader">
      <h3>Inspector</h3>
      <div id="inspectorControls">
        <button id="btnMinimizeInspector" title="Minimize/Maximize">‚àí</button>
        <button id="btnCloseInspector" title="Hide Inspector">‚úï</button>
      </div>
    </div>
    <div id="inspectorContent">
      <div class="muted" id="inspectorHelp">
        Select a node, link, or container box to edit it. Use Delete/Backspace to remove selected.
        <br/>Move any label only with <kbd>Ctrl</kbd>+drag (so normal dragging moves nodes/boxes).
      </div>

      <div id="canvasSettings">
        <h4 style="margin: 12px 0 10px; font-size: 13px; opacity: 0.9;">Canvas Settings</h4>
        <div class="row inline">
          <div>
            <label>Canvas Width</label>
            <input id="canvasWidth" type="number" min="400" step="100" />
        </div>
        <div>
          <label>Canvas Height</label>
          <input id="canvasHeight" type="number" min="300" step="100" />
        </div>
      </div>
      <div style="display:flex; gap:6px; margin-top:8px;">
        <button class="btn" id="btnAutoFitCanvas" style="flex:1; font-size:11px; padding:6px;" title="Automatically expand canvas to fit all elements">
          üìê Auto-fit Canvas
        </button>
        <button class="btn" id="btnCenterElements" style="flex:1; font-size:11px; padding:6px;" title="Center all elements on canvas">
          ‚äõ Center All
        </button>
      </div>
      <label class="toggle"><input type="checkbox" id="tglCanvasBorder" checked />Show Canvas Border</label>
      <label class="toggle"><input type="checkbox" id="tglAutoExpandCanvas" checked />Auto-expand on drag</label>
      <div class="muted" style="margin-top: 8px;">Drag objects beyond the border to expand the workspace.</div>
    </div>

    <div id="noSelection" class="muted">Nothing selected.</div>

<div id="nodeInspector" style="display:none;">
  <!-- Identity Section -->
  <div class="inspector-section" data-section="node-identity">
    <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
      <span>Identity</span>
      <span class="section-icon">‚ñº</span>
    </div>
    <div class="inspector-section-content">
      <div class="row">
        <label>Node Name</label>
        <div class="field-with-controls">
          <input id="nodeName" />
          <div class="field-inline-controls">
            <select class="field-font-select" id="nodeNameFontInline" title="Font size">
              <option value="8">8</option><option value="10">10</option><option value="11">11</option>
              <option value="12">12</option><option value="13" selected>13</option><option value="14">14</option>
              <option value="16">16</option><option value="18">18</option><option value="20">20</option>
              <option value="24">24</option><option value="28">28</option><option value="32">32</option>
            </select>
            <div class="field-color-swatch" id="nodeNameColorSwatch" title="Name color">
              <input type="color" id="nodeNameColorInline" />
            </div>
            <button class="field-visibility-btn" id="nodeNameVisibility" title="Toggle visibility">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
            </button>
          </div>
        </div>
      </div>
      <div class="row">
        <label>Node Code</label>
        <div class="field-with-controls">
          <input id="nodeCode" placeholder="e.g. N-001" />
          <div class="field-inline-controls">
            <select class="field-font-select" id="nodeCodeFontInline" title="Font size">
              <option value="8">8</option><option value="10">10</option><option value="11">11</option>
              <option value="12">12</option><option value="13" selected>13</option><option value="14">14</option>
              <option value="16">16</option><option value="18">18</option><option value="20">20</option>
              <option value="24">24</option><option value="28">28</option><option value="32">32</option>
            </select>
            <div class="field-color-swatch" id="nodeCodeColorSwatch" title="Code color">
              <input type="color" id="nodeCodeColorInline" />
            </div>
            <button class="field-visibility-btn" id="nodeCodeVisibility" title="Toggle visibility">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Tags Section -->
  <div class="inspector-section" data-section="node-tags">
    <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
      <span>Tags & Metadata</span>
      <span class="section-icon">‚ñº</span>
    </div>
    <div class="inspector-section-content">
      <div class="row">
        <label>Filter Tags (comma-separated)</label>
        <textarea id="nodeTags" placeholder="default, core, production"></textarea>
      </div>
      <div class="row">
        <label>Additional Tags (free text)</label>
        <div class="field-with-controls">
          <input id="nodeExtraTags" placeholder="e.g. role=core, owner=teamA" />
          <div class="field-inline-controls">
            <select class="field-font-select" id="nodeExtraTagsFontInline" title="Font size">
              <option value="8">8</option><option value="9">9</option><option value="10">10</option>
              <option value="11" selected>11</option><option value="12">12</option><option value="13">13</option>
              <option value="14">14</option><option value="16">16</option>
            </select>
            <div class="field-color-swatch" id="nodeExtraTagsColorSwatch" title="Tags color">
              <input type="color" id="nodeExtraTagsColorInline" />
            </div>
            <button class="field-visibility-btn" id="nodeExtraTagsVisibility" title="Toggle visibility">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Location Section -->
  <div class="inspector-section collapsed" data-section="node-location">
    <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
      <span>Location</span>
      <span class="section-icon">‚ñº</span>
    </div>
    <div class="inspector-section-content">
      <div class="row">
        <label>Address</label>
        <input id="nodeAddress" placeholder="e.g. 123 Main Street" />
      </div>
      <div class="row inline">
        <div>
          <label>City</label>
          <input id="nodeCity" placeholder="e.g. New York" />
        </div>
        <div>
          <label>Country</label>
          <input id="nodeCountry" placeholder="e.g. USA" />
        </div>
      </div>
      
      <!-- GPS Coordinates -->
      <div style="margin-top:12px; padding-top:10px; border-top:1px solid #e0e0e0;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
          <label style="font-weight:600; font-size:11px; color:#1d4ed8;">üåç GPS Coordinates</label>
          <select id="nodeGpsFormat" style="font-size:10px; padding:2px 6px; border-radius:3px;">
            <option value="DD">Decimal (DD)</option>
            <option value="DMS">Deg/Min/Sec (DMS)</option>
          </select>
        </div>
        
        <!-- Quick lookup buttons -->
        <div style="display:flex; gap:6px; margin-bottom:8px;">
          <button id="btnLookupCity" type="button" style="flex:1; font-size:10px; padding:5px 8px; background:#e0f2fe; border:1px solid #7dd3fc; border-radius:4px; cursor:pointer; color:#0369a1;" title="Lookup GPS by city or country name">
            üèôÔ∏è Lookup City/Country
          </button>
          <button id="btnUseAddress" type="button" style="flex:1; font-size:10px; padding:5px 8px; background:#fef3c7; border:1px solid #fcd34d; border-radius:4px; cursor:pointer; color:#92400e;" title="Try to get GPS from node's address">
            üìç From Address
          </button>
        </div>
        
        <!-- Decimal Degrees Format -->
        <div id="gpsFormatDD" class="row inline">
          <div>
            <label style="font-size:10px;">Latitude (Y)</label>
            <input id="nodeLatDD" type="text" placeholder="e.g. 40.7128" style="font-family:monospace; font-size:11px;" />
            <div style="font-size:9px; color:#888; margin-top:2px;">-90 to 90 (N positive)</div>
          </div>
          <div>
            <label style="font-size:10px;">Longitude (X)</label>
            <input id="nodeLonDD" type="text" placeholder="e.g. -74.0060" style="font-family:monospace; font-size:11px;" />
            <div style="font-size:9px; color:#888; margin-top:2px;">-180 to 180 (E positive)</div>
          </div>
        </div>
        
        <!-- Degrees Minutes Seconds Format -->
        <div id="gpsFormatDMS" style="display:none;">
          <div class="row">
            <label style="font-size:10px;">Latitude (Y)</label>
            <div style="display:flex; gap:4px; align-items:center;">
              <input id="nodeLatDeg" type="number" min="-90" max="90" placeholder="40" style="width:45px; font-size:11px; text-align:center;" />
              <span style="font-size:10px;">¬∞</span>
              <input id="nodeLatMin" type="number" min="0" max="59" placeholder="42" style="width:40px; font-size:11px; text-align:center;" />
              <span style="font-size:10px;">'</span>
              <input id="nodeLatSec" type="number" min="0" max="59.99" step="0.01" placeholder="46" style="width:50px; font-size:11px; text-align:center;" />
              <span style="font-size:10px;">"</span>
              <select id="nodeLatDir" style="font-size:11px; padding:2px;">
                <option value="N">N</option>
                <option value="S">S</option>
              </select>
            </div>
          </div>
          <div class="row">
            <label style="font-size:10px;">Longitude (X)</label>
            <div style="display:flex; gap:4px; align-items:center;">
              <input id="nodeLonDeg" type="number" min="-180" max="180" placeholder="74" style="width:45px; font-size:11px; text-align:center;" />
              <span style="font-size:10px;">¬∞</span>
              <input id="nodeLonMin" type="number" min="0" max="59" placeholder="0" style="width:40px; font-size:11px; text-align:center;" />
              <span style="font-size:10px;">'</span>
              <input id="nodeLonSec" type="number" min="0" max="59.99" step="0.01" placeholder="21" style="width:50px; font-size:11px; text-align:center;" />
              <span style="font-size:10px;">"</span>
              <select id="nodeLonDir" style="font-size:11px; padding:2px;">
                <option value="E">E</option>
                <option value="W">W</option>
              </select>
            </div>
          </div>
        </div>
        
        <div style="margin-top:6px; font-size:9px; color:#666; background:#f0f9ff; padding:4px 6px; border-radius:3px;">
          üí° Nodes with GPS data appear in Geographic View
        </div>
      </div>
    </div>
  </div>

  <!-- Appearance Section -->
  <div class="inspector-section" data-section="node-appearance">
    <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
      <span>Appearance</span>
      <span class="section-icon">‚ñº</span>
    </div>
    <div class="inspector-section-content">
      <div class="row">
        <label>Style Preset</label>
        <div class="inline">
          <select id="nodePreset"></select>
          <button class="mini-btn" id="btnNodePresetSave" title="Save current style">Save</button>
          <button class="mini-btn" id="btnNodePresetApply" title="Apply preset">Apply</button>
          <button class="mini-btn" id="btnNodePresetDelete" title="Delete preset">Del</button>
        </div>
      </div>
      <div class="row inline">
        <div>
          <label>Fill Color</label>
          <div class="inspector-color-picker" id="nodeFillPicker">
            <div class="inspector-color-swatch" title="Click to choose color">
              <div class="inspector-color-swatch-inner" id="nodeFillSwatch"></div>
            </div>
            <div class="inspector-color-dropdown" hidden>
              <div class="inspector-color-grid" data-target="nodeFill"></div>
              <div class="inspector-color-custom">
                <input type="color" id="nodeFillCustom" />
                <input type="text" id="nodeFillHex" placeholder="#000000" maxlength="7" />
              </div>
            </div>
            <input id="nodeFill" type="hidden" />
          </div>
        </div>
        <div>
          <label>Stroke Color</label>
          <div class="inspector-color-picker" id="nodeStrokePicker">
            <div class="inspector-color-swatch" title="Click to choose color">
              <div class="inspector-color-swatch-inner" id="nodeStrokeSwatch"></div>
            </div>
            <div class="inspector-color-dropdown" hidden>
              <div class="inspector-color-grid" data-target="nodeStroke"></div>
              <div class="inspector-color-custom">
                <input type="color" id="nodeStrokeCustom" />
                <input type="text" id="nodeStrokeHex" placeholder="#000000" maxlength="7" />
              </div>
            </div>
            <input id="nodeStroke" type="hidden" />
          </div>
        </div>
      </div>
      <div class="row inline">
        <div>
          <label>Line Width</label>
          <input id="nodeStrokeW" type="number" min="0.5" max="12" step="0.5" />
        </div>
        <div>
          <label>Node Size</label>
          <input id="nodeSize" type="number" min="10" max="80" step="1" />
        </div>
      </div>
    </div>
  </div>

  <!-- Connections Section -->
  <div class="inspector-section" data-section="node-connections">
    <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
      <span>Connections</span>
      <span class="section-icon">‚ñº</span>
    </div>
    <div class="inspector-section-content">
      <div class="row">
        <label>Cable Systems</label>
        <div id="nodeCableSystems" style="max-height:100px; overflow-y:auto; border:1px solid #d0d0d0; border-radius:4px; padding:4px; background:#fafafa;">
          <div class="muted" style="font-size:11px;">No cable systems defined</div>
        </div>
      </div>
      <div class="row">
        <label>Container Box</label>
        <input id="nodeGroup" disabled style="background:#f5f5f5;" />
      </div>
    </div>
  </div>

  <!-- Advanced Section -->
  <div class="inspector-section collapsed" data-section="node-advanced">
    <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
      <span>Advanced</span>
      <span class="section-icon">‚ñº</span>
    </div>
    <div class="inspector-section-content">
      <div class="row">
        <label>Unique ID (UUID)</label>
        <input id="nodeUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:10px;" />
      </div>
    </div>
  </div>
  
  <!-- Hidden fields for compatibility -->
  <input type="hidden" id="nodeNameFont" />
  <input type="hidden" id="nodeTagFont" />
  <input type="hidden" id="nodeNameColor" />
  <input type="hidden" id="nodeTagColor" />
  <input type="hidden" id="nodeShowCode" />
</div>

    <div id="edgeInspector" style="display:none;">
      <!-- Identity Section -->
      <div class="inspector-section" data-section="edge-identity">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Identity</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Link Tag</label>
            <div class="field-with-controls">
              <input id="edgeTag" />
              <div class="field-inline-controls">
                <select class="field-font-select" id="edgeLabelFontInline" title="Font size">
                  <option value="8">8</option><option value="9">9</option><option value="10">10</option>
                  <option value="11">11</option><option value="12" selected>12</option><option value="13">13</option>
                  <option value="14">14</option><option value="16">16</option><option value="18">18</option>
                </select>
                <div class="field-color-swatch" id="edgeTagColorSwatch" title="Label color">
                  <input type="color" id="edgeTagColorInline" />
                </div>
                <button class="field-visibility-btn" id="edgeTagVisibility" title="Toggle visibility">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                </button>
              </div>
            </div>
          </div>
          <div class="row">
            <label>Link Code</label>
            <div class="field-with-controls">
              <input id="edgeCode" placeholder="e.g. L-010" />
              <div class="field-inline-controls">
                <button class="field-visibility-btn" id="edgeCodeVisibility" title="Toggle visibility">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                </button>
              </div>
            </div>
          </div>
          <div class="row">
            <label>Cable System</label>
            <select id="edgeCableSystem" style="width:100%;">
              <option value="">(None)</option>
            </select>
            <div id="edgeCableSystemInfo" class="muted" style="margin-top:4px; font-size:11px;"></div>
          </div>
        </div>
      </div>

      <!-- Data Section -->
      <div class="inspector-section" data-section="edge-data">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Data</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Latency (ms)</label>
            <div class="field-with-controls">
              <input id="edgeLatency" type="text" inputmode="decimal" placeholder="e.g. 1.234" />
              <div class="field-inline-controls">
                <button class="field-visibility-btn" id="edgeLatencyVisibility" title="Toggle visibility">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                </button>
              </div>
            </div>
          </div>
          <div class="row inline">
            <div>
              <label>Capacity</label>
              <input id="edgeCapacity" placeholder="e.g. 100G" />
            </div>
            <div>
              <label>Priority (-100 to +100)</label>
              <input id="edgePriority" type="number" min="-100" max="100" step="1" placeholder="0" />
              <div class="hint">+100 = half cost (preferred), -100 = 1.5√ó cost (avoided)</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Tags Section -->
      <div class="inspector-section collapsed" data-section="edge-tags">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Tags & Metadata</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Filter Tags (comma-separated)</label>
            <textarea id="edgeFilterTags" placeholder="default, onnet, Asia" style="height:40px;"></textarea>
          </div>
          <div class="row">
            <label>Additional Tags (free text)</label>
            <input id="edgeExtraTags" placeholder="e.g. provider=ISP1, circuit=ABC123" />
          </div>
        </div>
      </div>

      <!-- Appearance Section -->
      <div class="inspector-section" data-section="edge-appearance">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Appearance</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Style Preset</label>
            <div class="inline">
              <select id="edgePreset"></select>
              <button class="mini-btn" id="btnEdgePresetSave" title="Save">Save</button>
              <button class="mini-btn" id="btnEdgePresetApply" title="Apply">Apply</button>
              <button class="mini-btn" id="btnEdgePresetDelete" title="Delete">Del</button>
            </div>
          </div>
          <div class="row inline">
            <div>
              <label>Line Style</label>
              <select id="edgeStyle">
                <option value="straight">Straight</option>
                <option value="orthogonal">90¬∞ Orthogonal</option>
                <option value="curve">Curve (Bezier)</option>
              </select>
            </div>
            <div>
              <label>Routing</label>
              <select id="edgeRoute">
                <option value="hv">H ‚Üí V</option>
                <option value="vh">V ‚Üí H</option>
              </select>
            </div>
          </div>
          <div class="row" id="curveArchControl" style="display:none;">
            <label>Curve Bend</label>
            <input id="edgeCurveArch" type="range" min="-0.6" max="0.6" step="0.05" />
            <span id="curveArchValue" style="font-size:11px; color:#666;">0.30</span>
          </div>
          <div class="row inline">
            <div>
              <label>Line Width</label>
              <input id="edgeStrokeW" type="number" min="0.5" max="12" step="0.5" />
            </div>
            <div>
              <label>Line Color</label>
              <div class="inspector-color-picker" id="edgeStrokeColorPicker">
                <div class="inspector-color-swatch" title="Click to choose color">
                  <div class="inspector-color-swatch-inner" id="edgeStrokeColorSwatch"></div>
                </div>
                <div class="inspector-color-dropdown" hidden>
                  <div class="inspector-color-grid" data-target="edgeStrokeColor"></div>
                  <div class="inspector-color-custom">
                    <input type="color" id="edgeStrokeColorCustom" />
                    <input type="text" id="edgeStrokeColorHex" placeholder="#000000" maxlength="7" />
                  </div>
                </div>
                <input id="edgeStrokeColor" type="hidden" />
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Advanced Section -->
      <div class="inspector-section collapsed" data-section="edge-advanced">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Advanced</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Unique ID (UUID)</label>
            <input id="edgeUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:10px;" />
          </div>
          <div class="row inline">
            <div>
              <label>Source UUID</label>
              <input id="edgeSourceUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:9px;" />
            </div>
            <div>
              <label>Target UUID</label>
              <input id="edgeTargetUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:9px;" />
            </div>
          </div>
        </div>
      </div>
      
      <!-- Hidden fields for compatibility -->
      <input type="hidden" id="edgeLabelFont" />
      <input type="hidden" id="edgeLabelColor" />
      <input type="hidden" id="edgeShowCode" />
    </div>
     
    <div id="groupInspector" style="display:none;">
      <!-- Identity Section -->
      <div class="inspector-section" data-section="group-identity">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Identity</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Title</label>
            <div class="field-with-controls">
              <input id="groupTitle" />
              <div class="field-inline-controls">
                <select class="field-font-select" id="groupTitleFontInline" title="Font size">
                  <option value="10">10</option><option value="11">11</option><option value="12">12</option>
                  <option value="13">13</option><option value="14" selected>14</option><option value="16">16</option>
                  <option value="18">18</option><option value="20">20</option><option value="24">24</option>
                </select>
                <div class="field-color-swatch" id="groupTitleColorSwatch" title="Title color">
                  <input type="color" id="groupTitleColorInline" />
                </div>
                <button class="field-visibility-btn" id="groupTitleVisibility" title="Toggle visibility">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                </button>
              </div>
            </div>
          </div>
          <div class="row inline">
            <div>
              <label>Type</label>
              <select id="groupType">
                <option value="country">Container</option>
                <option value="region">Group</option>
              </select>
            </div>
            <div>
              <label>Parent Group</label>
              <select id="groupParent"></select>
            </div>
          </div>
        </div>
      </div>

      <!-- Tags Section -->
      <div class="inspector-section collapsed" data-section="group-tags">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Tags & Metadata</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Filter Tags (comma-separated)</label>
            <textarea id="groupFilterTags" placeholder="default, APAC, production" style="height:40px;"></textarea>
          </div>
          <div class="row">
            <label>Additional Tags (free text)</label>
            <input id="groupExtraTags" placeholder="e.g. area=APAC" />
          </div>
        </div>
      </div>

      <!-- Routing Section -->
      <div class="inspector-section" data-section="group-routing">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>‚ö° Routing</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Transit Latency (ms)</label>
            <input id="groupTransitLatency" type="number" min="0" step="0.1" placeholder="Default: use global setting" />
            <div class="hint" style="margin-top:4px;">Latency added when routing through this container. Leave empty to use global default.</div>
          </div>
        </div>
      </div>

      <!-- Appearance Section -->
      <div class="inspector-section" data-section="group-appearance">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Appearance</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Style Preset</label>
            <div class="inline">
              <select id="groupPreset"></select>
              <button class="mini-btn" id="btnGroupPresetSave" title="Save">Save</button>
              <button class="mini-btn" id="btnGroupPresetApply" title="Apply">Apply</button>
              <button class="mini-btn" id="btnGroupPresetDelete" title="Delete">Del</button>
            </div>
          </div>
          <div class="row">
            <label>Fill Color</label>
            <div class="field-with-controls" style="gap:8px;">
              <div class="inspector-color-picker" id="groupFillColorPicker">
                <div class="inspector-color-swatch" title="Click to choose color">
                  <div class="inspector-color-swatch-inner" id="groupFillColorSwatch"></div>
                </div>
                <div class="inspector-color-dropdown" hidden>
                  <div class="inspector-color-grid" data-target="groupFillColor"></div>
                  <div class="inspector-color-custom">
                    <input type="color" id="groupFillColorCustom" />
                    <input type="text" id="groupFillColorHex" placeholder="#000000" maxlength="7" />
                  </div>
                </div>
                <input id="groupFillColor" type="hidden" />
              </div>
              <div style="flex:1; display:flex; align-items:center; gap:6px;">
                <span style="font-size:10px; color:#666;">Opacity:</span>
                <input id="groupFillOpacity" type="range" min="0" max="100" value="100" style="flex:1;" />
                <span id="groupFillOpacityValue" style="font-size:10px; color:#666; min-width:32px;">100%</span>
              </div>
            </div>
            <input id="groupFill" type="hidden" />
          </div>
          <div class="row">
            <label>Stroke Color</label>
            <div class="inspector-color-picker" id="groupStrokePicker">
              <div class="inspector-color-swatch" title="Click to choose color">
                <div class="inspector-color-swatch-inner" id="groupStrokeSwatch"></div>
              </div>
              <div class="inspector-color-dropdown" hidden>
                <div class="inspector-color-grid" data-target="groupStroke"></div>
                <div class="inspector-color-custom">
                  <input type="color" id="groupStrokeCustom" />
                  <input type="text" id="groupStrokeHex" placeholder="#000000" maxlength="7" />
                </div>
              </div>
              <input id="groupStroke" type="hidden" />
            </div>
          </div>
          <div class="row inline">
            <div>
              <label>Border Width</label>
              <input id="groupStrokeW" type="number" min="0.5" max="12" step="0.5" />
            </div>
            <div style="flex:0;">
              <!-- Spacer -->
            </div>
          </div>
        </div>
      </div>

      <!-- Size Section -->
      <div class="inspector-section" data-section="group-size">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Size</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row inline">
            <div>
              <label>Width</label>
              <input id="groupW" type="number" min="120" />
            </div>
            <div>
              <label>Height</label>
              <input id="groupH" type="number" min="90" />
            </div>
          </div>
        </div>
      </div>

      <!-- Container Shape Section -->
      <div class="inspector-section collapsed" data-section="group-decoration">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>üó∫Ô∏è Container Shape</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row" id="groupShapeInfo">
            <div style="font-size:11px; color:#666; font-style:italic;">Standard rectangular container</div>
          </div>
          <div class="row" style="display:flex; gap:6px;">
            <button class="btn" id="btnOpenLibraryForShape" style="flex:1; font-size:11px;">
              üìö Open Library
            </button>
            <button class="btn" id="btnRemoveGroupShape" style="flex:1; font-size:11px;" disabled>
              üîÑ Reset to Rect
            </button>
          </div>
          <div class="hint" style="margin-top:6px;">Drag shapes from Library ‚Üí Containers tab to create shaped containers</div>
        </div>
      </div>

      <!-- Advanced Section -->
      <div class="inspector-section collapsed" data-section="group-advanced">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Advanced</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Unique ID (UUID)</label>
            <input id="groupUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:10px;" />
          </div>
        </div>
      </div>
      
      <!-- Hidden fields for compatibility -->
      <input type="hidden" id="groupTitleFont" />
      <input type="hidden" id="groupTitleColor" />
    </div>
    </div><!-- end inspectorContent -->
  </aside>

  <!-- Cable System Details Panel -->
  <aside id="cableSystemInspectorPanel" style="display:none;">
    <div id="cableInspectorHeader">
      <h3>Cable System Details</h3>
      <div id="cableInspectorControls">
        <button id="btnMinimizeCableInspector" title="Minimize/Maximize">‚àí</button>
        <button id="btnCloseCableInspector" title="Hide">‚úï</button>
      </div>
    </div>
    <div id="cableInspectorContent">
      <div id="cableSystemInspector">
        <div id="csNoSelection" class="muted" style="padding:12px;">Select a cable system from the Systems List to view/edit details.</div>
        
        <div id="csDetails" style="display:none;">
          <div class="row">
            <label>Unique ID</label>
            <input id="csUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:11px;" />
          </div>

          <div class="row">
            <label>Short Name</label>
            <input id="csShortName" placeholder="e.g. SMW6" maxlength="20" />
          </div>

          <div class="row">
            <label>Full Name</label>
            <input id="csName" placeholder="e.g. SEA-ME-WE 6" />
          </div>

          <div class="row inline">
            <div>
              <label>Type</label>
              <select id="csType">
                <option value="wet">Submarine (Wet)</option>
                <option value="terrestrial">Terrestrial</option>
              </select>
            </div>
            <div>
              <label>Status</label>
              <select id="csStatus">
                <option value="planned">Planned</option>
                <option value="operational">In Operation</option>
              </select>
            </div>
          </div>

          <div class="row inline">
            <div>
              <label>RFS Year</label>
              <input id="csRfsYear" type="number" min="1980" max="2100" placeholder="2025" />
            </div>
            <div>
              <label>Fiber Pairs</label>
              <input id="csFiberPairs" type="number" min="1" max="100" placeholder="8" />
            </div>
          </div>

          <div class="row">
            <label>Total Capacity (Tbps)</label>
            <input id="csCapacity" type="number" min="0" step="0.1" placeholder="100" />
          </div>

          <div class="row">
            <label>Owners (comma-separated)</label>
            <input id="csOwners" placeholder="e.g. Google, Meta, Orange" />
          </div>

          <div class="row">
            <label>Filter Tags (comma-separated)</label>
            <textarea id="csFilterTags" placeholder="default, submarine, Asia" style="height:40px;"></textarea>
          </div>

          <div class="row">
            <label>Notes</label>
            <textarea id="csNotes" placeholder="Additional notes..." style="height:60px;"></textarea>
          </div>

          <div class="sep" style="margin:12px 0;"></div>

          <div class="row">
            <label style="font-weight:600;">Member Links (<span id="csMemberLinksCount">0</span>)
              <button class="mini-btn" id="btnAddLinksToCS" style="margin-left:8px;" title="Click links on canvas to add">+ Add</button>
            </label>
            <div id="csMemberLinks" style="max-height:100px; overflow-y:auto; border:1px solid #d0d0d0; border-radius:4px; padding:4px; background:#fafafa; font-size:11px;">
              <div class="muted">No links assigned</div>
            </div>
          </div>

          <div class="row">
            <label style="font-weight:600;">Member Nodes (<span id="csMemberNodesCount">0</span>)
              <button class="mini-btn" id="btnAddNodesToCS" style="margin-left:8px;" title="Click nodes on canvas to add">+ Add</button>
            </label>
            <div id="csMemberNodes" style="max-height:100px; overflow-y:auto; border:1px solid #d0d0d0; border-radius:4px; padding:4px; background:#fafafa; font-size:11px;">
              <div class="muted">No nodes assigned</div>
            </div>
          </div>
          
          <!-- Add mode indicator bar (hidden by default) -->
          <div id="csAddModeBar" style="display:none; position:sticky; bottom:0; background:#fff3cd; border:1px solid #ffc107; border-radius:4px; padding:8px; margin-top:12px;">
            <div style="font-size:12px; font-weight:500; color:#856404;">
              <span id="csAddModeText">Click links on canvas to add them...</span>
            </div>
            <div style="display:flex; gap:8px; margin-top:8px;">
              <button class="btn primary" id="btnAcceptAddToCS" style="flex:1;">Accept</button>
              <button class="btn" id="btnCancelAddToCS" style="flex:1;">Cancel</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </aside>

  <!-- Cable System List Panel -->
  <aside id="cableNavigator" style="display:none;">
    <div id="cableNavigatorHeader">
      <h3>Cable System List</h3>
      <div id="cableNavigatorControls">
        <button id="btnMinimizeCableNav" title="Minimize/Maximize">‚àí</button>
        <button id="btnCloseCableNav" title="Hide Navigator">‚úï</button>
      </div>
    </div>
    <div id="cableNavigatorContent">
      <div style="padding:8px 12px; border-bottom:1px solid #e0e0e0;">
        <input type="text" id="cableNavSearch" placeholder="Search cable systems..." style="width:100%; padding:6px 8px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
      </div>
      <div id="cableSystemList" style="flex:1; overflow-y:auto; padding:4px;">
        <div class="muted" style="padding:12px; text-align:center;">No cable systems defined.<br/>Click "New" to create one.</div>
      </div>
      <div style="padding:8px 12px; border-top:1px solid #e0e0e0; display:flex; gap:8px;">
        <button class="btn primary" id="btnNewCableSystem" style="flex:1;">+ New</button>
        <button class="btn" id="btnDeleteCableSystem" style="flex:1;">Delete</button>
      </div>
    </div>
  </aside>

  <!-- Route Finder Panel (Inspector Style) -->
  <aside id="routeFinderPanel">
    <div id="routeFinderHeader">
      <h3>üõ§Ô∏è Route Finder</h3>
      <div id="routeFinderControls">
        <button id="btnCloseRouteFinder" title="Exit Route Finder">‚úï</button>
      </div>
    </div>
    <div id="routeFinderContent">
      <!-- Mode Indicator -->
      <div style="padding:10px 12px; background:linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); border-bottom:1px solid #93c5fd;">
        <div style="display:flex; align-items:center; gap:8px;">
          <span style="font-size:16px;">üß≠</span>
          <div>
            <div style="font-weight:600; font-size:12px; color:#1e40af;">Calculation Mode Active</div>
            <div style="font-size:11px; color:#3b82f6;">Click nodes or use dropdowns to select endpoints</div>
          </div>
        </div>
      </div>

      <!-- Visibility Filter -->
      <div style="padding:10px 12px; background:#f8fafc; border-bottom:1px solid #e2e8f0;">
        <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:12px;">
          <input type="checkbox" id="routeVisibleOnly" style="width:16px; height:16px; accent-color:#5a67d8;">
          <span style="color:#475569;">Calculate using <strong>visible elements only</strong></span>
        </label>
        <div style="font-size:10px; color:#94a3b8; margin-top:4px; margin-left:24px;">Respects current tag filters and visibility settings</div>
      </div>

      <!-- Endpoint Selection Section -->
      <div class="inspector-section" data-section="route-endpoints">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Endpoints</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label style="color:#166534; font-weight:600;">üü¢ Origin (A-Node)</label>
            <select id="routeOriginSelect" style="width:100%; padding:8px; border:2px solid #86efac; border-radius:4px; background:#f0fff4; font-size:12px;">
              <option value="">-- Click a node or select from list --</option>
            </select>
          </div>
          <div class="row">
            <label style="color:#991b1b; font-weight:600;">üî¥ Destination (B-Node)</label>
            <select id="routeDestSelect" style="width:100%; padding:8px; border:2px solid #fca5a5; border-radius:4px; background:#fef2f2; font-size:12px;">
              <option value="">-- Click a node or select from list --</option>
            </select>
          </div>
          <div class="row" style="display:flex; gap:8px; margin-top:12px;">
            <button class="btn" id="btnSwapEndpoints" style="flex:1;">‚áÑ Swap</button>
            <button class="btn primary" id="btnCalculateRoutes" style="flex:1;" disabled>üîç Calculate</button>
          </div>
        </div>
      </div>

      <!-- Restrictions Section -->
      <div class="inspector-section collapsed" data-section="route-restrictions">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>üö´ Restrictions</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <!-- Excluded Nodes -->
          <div class="row">
            <label style="font-weight:600; color:#7c3aed; font-size:11px;">Excluded Nodes</label>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <select id="routeExcludeNodeSelect" style="flex:1; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd;">
                <option value="">-- Select node to exclude --</option>
              </select>
              <button class="btn" id="btnAddExcludeNode" style="padding:6px 10px; font-size:11px;" title="Add selected node">+</button>
              <button class="btn" id="btnPickExcludeNode" style="padding:6px 10px; font-size:11px;" title="Click on canvas to pick">‚äï</button>
            </div>
            <div id="excludedNodesList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:4px;">
              <!-- Excluded nodes will appear here as tags -->
            </div>
          </div>

          <!-- Excluded Links -->
          <div class="row" style="margin-top:12px;">
            <label style="font-weight:600; color:#dc2626; font-size:11px;">Excluded Links</label>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <select id="routeExcludeLinkSelect" style="flex:1; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd;">
                <option value="">-- Select link to exclude --</option>
              </select>
              <button class="btn" id="btnAddExcludeLink" style="padding:6px 10px; font-size:11px;" title="Add selected link">+</button>
              <button class="btn" id="btnPickExcludeLink" style="padding:6px 10px; font-size:11px;" title="Click on canvas to pick">‚äï</button>
            </div>
            <div id="excludedLinksList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:4px;">
              <!-- Excluded links will appear here as tags -->
            </div>
          </div>

          <!-- Clear All Exclusions -->
          <div class="row" style="margin-top:12px;">
            <button class="btn" id="btnClearAllRestrictions" style="width:100%; font-size:11px; padding:6px; background:#fef2f2; border-color:#fecaca; color:#991b1b;">
              üóëÔ∏è Clear All Exclusions
            </button>
          </div>
        </div>
      </div>

      <!-- Must-Use Constraints Section -->
      <div class="inspector-section collapsed" data-section="route-must-use">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>‚úÖ Must-Use Constraints</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="hint" style="margin-bottom:10px; padding:6px; background:#f0fdf4; border-radius:4px; color:#166534;">
            Force routes to pass through specific nodes or links.
          </div>
          
          <!-- Must-Use Nodes -->
          <div class="row">
            <label style="font-weight:600; color:#16a34a; font-size:11px;">Must-Use Nodes</label>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <select id="routeMustUseNodeSelect" style="flex:1; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd;">
                <option value="">-- Select node (must pass through) --</option>
              </select>
              <button class="btn" id="btnAddMustUseNode" style="padding:6px 10px; font-size:11px; background:#f0fdf4; border-color:#86efac;" title="Add must-use node">+</button>
              <button class="btn" id="btnPickMustUseNode" style="padding:6px 10px; font-size:11px; background:#f0fdf4; border-color:#86efac;" title="Click on canvas to pick">‚äï</button>
            </div>
            <div id="mustUseNodesList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:4px;">
              <!-- Must-use nodes will appear here as tags -->
            </div>
          </div>

          <!-- Must-Use Links -->
          <div class="row" style="margin-top:12px;">
            <label style="font-weight:600; color:#16a34a; font-size:11px;">Must-Use Links</label>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <select id="routeMustUseLinkSelect" style="flex:1; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd;">
                <option value="">-- Select link (must use) --</option>
              </select>
              <button class="btn" id="btnAddMustUseLink" style="padding:6px 10px; font-size:11px; background:#f0fdf4; border-color:#86efac;" title="Add must-use link">+</button>
              <button class="btn" id="btnPickMustUseLink" style="padding:6px 10px; font-size:11px; background:#f0fdf4; border-color:#86efac;" title="Click on canvas to pick">‚äï</button>
            </div>
            <div id="mustUseLinksList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:4px;">
              <!-- Must-use links will appear here as tags -->
            </div>
          </div>

          <!-- Clear All Must-Use -->
          <div class="row" style="margin-top:12px;">
            <button class="btn" id="btnClearAllMustUse" style="width:100%; font-size:11px; padding:6px; background:#f0fdf4; border-color:#86efac; color:#166534;">
              üóëÔ∏è Clear All Must-Use Constraints
            </button>
          </div>
        </div>
      </div>

      <!-- Routes Results Section -->
      <div class="inspector-section" data-section="route-results" id="routeResultsSection" style="display:none;">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Routes Found</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content" id="routeResultsContent">
          <!-- Route options will be dynamically inserted here -->
        </div>
      </div>

      <!-- Route Details Section -->
      <div class="inspector-section collapsed" data-section="route-details" id="routeDetailsSection" style="display:none;">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Route Details</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content" id="routeDetailsContent">
          <!-- Selected route details will be shown here -->
        </div>
      </div>

      <!-- Settings Section -->
      <div class="inspector-section collapsed" data-section="route-settings">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Settings</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label class="toggle-item" style="display:flex; align-items:center; gap:8px; cursor:pointer;">
              <input type="checkbox" id="routeEnableContainerTransit" checked style="accent-color:#0096D6;" />
              <span style="font-weight:600;">Enable Container Transit</span>
            </label>
            <div class="hint">When enabled, nodes within the same container can connect implicitly. Disable to only use explicit links.</div>
          </div>
          <div class="row">
            <label class="toggle-item" style="display:flex; align-items:center; gap:8px; cursor:pointer;">
              <input type="checkbox" id="routeEnableRegionTransit" checked style="accent-color:#0096D6;" />
              <span style="font-weight:600;">Enable Region Transit</span>
            </label>
            <div class="hint">When enabled, nodes in sibling containers (same region) can connect implicitly.</div>
          </div>
          <div class="row" id="containerLatencyRow">
            <label>Default Container Latency (ms)</label>
            <input id="routeContainerLatency" type="number" value="1" min="0.000001" step="0.1" style="width:100%;" />
            <div class="hint">Implicit connection within same container. Can be overridden per-container in Inspector ‚Üí Routing.</div>
          </div>
          <div class="row" id="regionLatencyRow">
            <label>Default Region Latency (ms)</label>
            <input id="routeRegionLatency" type="number" value="10" min="0.000001" step="1" style="width:100%;" />
            <div class="hint">Implicit connection between sibling containers. Can be overridden per-group in Inspector ‚Üí Routing.</div>
          </div>
        </div>
      </div>

      <!-- Exit Button -->
      <div style="padding:12px; border-top:1px solid #e0e0e0;">
        <button class="btn" id="btnExitRouteFinder" style="width:100%; background:#f3f4f6; border-color:#d1d5db;">
          ‚Üê Exit Route Finder (Return to Edit Mode)
        </button>
      </div>
    </div>
  </aside>

  <!-- Label Manager Panel -->
  <aside id="labelManagerPanel">
    <div id="labelManagerHeader">
      <h3>üè∑Ô∏è Label Manager</h3>
      <div id="labelManagerControls">
        <button id="btnCloseLabelManager" title="Close Label Manager">‚úï</button>
      </div>
    </div>
    <div id="labelManagerContent">
      <!-- Selection Status -->
      <div id="lmSelectionStatus" class="lm-selection-status">
        <span style="font-size:14px;">üìå</span>
        <div style="flex:1;">
          <div style="font-weight:600; font-size:12px; color:#5b21b6;">Selection</div>
          <div id="lmSelectionSummary" style="font-size:11px; color:#7c3aed;">Nothing selected</div>
        </div>
      </div>

      <!-- Project Tags Section -->
      <div class="inspector-section" data-section="lm-project-tags">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>üìã Project Tags</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div style="margin-bottom:8px;">
            <input type="text" id="lmTagSearch" placeholder="Search tags..." style="width:100%; padding:6px 10px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
          </div>
          <div style="display:flex; gap:4px; margin-bottom:8px;">
            <button class="btn" id="lmFilterAll" style="flex:1; font-size:10px; padding:4px 6px;" title="Show all tags">All</button>
            <button class="btn" id="lmFilterNodes" style="flex:1; font-size:10px; padding:4px 6px;" title="Show tags used on nodes">üîµ Nodes</button>
            <button class="btn" id="lmFilterLinks" style="flex:1; font-size:10px; padding:4px 6px;" title="Show tags used on links">üî∂ Links</button>
            <button class="btn" id="lmFilterContainers" style="flex:1; font-size:10px; padding:4px 6px;" title="Show tags used on containers">üü© Boxes</button>
          </div>
          <div id="lmProjectTagsList" style="max-height:200px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:4px;">
            <!-- Tags will be rendered here -->
          </div>
          <div style="display:flex; gap:6px; margin-top:8px;">
            <button class="btn" id="lmSelectAllWithTag" style="flex:1; font-size:11px; padding:6px;" disabled>
              üéØ Select All with Checked Tags
            </button>
          </div>
          <div style="display:flex; gap:6px; margin-top:6px;">
            <button class="btn" id="lmNewTag" style="flex:1; font-size:11px; padding:6px;">
              + New Tag
            </button>
            <button class="btn" id="lmDeleteUnused" style="flex:1; font-size:11px; padding:6px;" title="Remove tags not used anywhere">
              üóëÔ∏è Delete Unused
            </button>
          </div>
        </div>
      </div>

      <!-- Selection Tags Section -->
      <div class="inspector-section" data-section="lm-selection-tags">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>‚úèÔ∏è Selection Tags</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div id="lmNoSelection" style="padding:12px; text-align:center; color:#9ca3af; font-size:12px;">
            <div style="font-size:24px; margin-bottom:6px;">üëÜ</div>
            Select nodes, links, or containers<br>to manage their tags
          </div>
          <div id="lmSelectionTags" style="display:none;">
            <div style="font-size:11px; color:#6b7280; margin-bottom:8px;">
              Check/uncheck to add/remove tags from selection:
            </div>
            <div id="lmSelectionTagsList" style="max-height:180px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:4px;">
              <!-- Selection tags with checkboxes -->
            </div>
            <div style="display:flex; gap:6px; margin-top:8px;">
              <button class="btn" id="lmApplyChecked" style="flex:1; font-size:11px; padding:6px; background:#f0fdf4; border-color:#86efac; color:#166534;">
                ‚úì Apply Checked
              </button>
              <button class="btn" id="lmRemoveUnchecked" style="flex:1; font-size:11px; padding:6px; background:#fef2f2; border-color:#fecaca; color:#991b1b;">
                ‚úó Remove Unchecked
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Bulk Apply Section -->
      <div class="inspector-section" data-section="lm-bulk-apply">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>‚ö° Bulk Apply</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="hint" style="margin-bottom:10px; padding:6px; background:#f3e8ff; border-radius:4px; color:#6d28d9; font-size:11px;">
            Apply or remove multiple tags at once
          </div>
          
          <!-- Tags to apply/remove -->
          <div class="row">
            <label style="font-weight:600; font-size:11px;">Tags to Apply/Remove</label>
            <div id="lmBulkTagsSelected" style="min-height:30px; padding:6px; background:#f9fafb; border:1px solid #e5e7eb; border-radius:4px; margin-top:4px; display:flex; flex-wrap:wrap; gap:4px;">
              <span style="color:#9ca3af; font-size:11px;">Click tags below to add</span>
            </div>
          </div>
          
          <!-- Available tags multiselect -->
          <div class="row" style="margin-top:8px;">
            <label style="font-weight:600; font-size:11px;">Available Tags (click to add)</label>
            <div id="lmBulkAvailableTags" style="max-height:100px; overflow-y:auto; padding:6px; background:#f9fafb; border:1px solid #e5e7eb; border-radius:4px; margin-top:4px; display:flex; flex-wrap:wrap; gap:4px;">
              <!-- Available tags -->
            </div>
            <div style="display:flex; gap:4px; margin-top:6px;">
              <input type="text" id="lmBulkNewTag" placeholder="Or type new tag..." style="flex:1; padding:6px; font-size:11px; border:1px solid #d0d0d0; border-radius:4px;" />
              <button class="btn" id="lmBulkAddNewTag" style="padding:6px 10px; font-size:11px;">+</button>
            </div>
          </div>
          
          <!-- Action mode -->
          <div class="row" style="margin-top:10px;">
            <label style="font-weight:600; font-size:11px;">Action</label>
            <div style="display:flex; flex-direction:column; gap:4px; margin-top:4px;">
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:12px;">
                <input type="radio" name="lmBulkAction" value="add" checked style="accent-color:#8b5cf6;" />
                <span style="color:#166534;">‚ûï Add tags to targets</span>
              </label>
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:12px;">
                <input type="radio" name="lmBulkAction" value="remove" style="accent-color:#8b5cf6;" />
                <span style="color:#991b1b;">‚ûñ Remove tags from targets</span>
              </label>
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:12px;">
                <input type="radio" name="lmBulkAction" value="set" style="accent-color:#8b5cf6;" />
                <span style="color:#1d4ed8;">üîÑ Set tags exactly (replace all)</span>
              </label>
            </div>
          </div>
          
          <!-- Target selection -->
          <div class="row" style="margin-top:10px;">
            <label style="font-weight:600; font-size:11px;">Target Elements</label>
            <div style="display:flex; flex-direction:column; gap:4px; margin-top:4px;">
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:12px;">
                <input type="radio" name="lmBulkTarget" value="selection" checked style="accent-color:#8b5cf6;" />
                <span>Current selection</span>
                <span id="lmBulkSelectionCount" class="lm-selection-badge" style="font-size:10px;">0 items</span>
              </label>
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:12px;">
                <input type="radio" name="lmBulkTarget" value="pick" style="accent-color:#8b5cf6;" />
                <span>Pick elements on canvas</span>
                <button class="btn" id="lmBulkPickMode" style="padding:2px 8px; font-size:10px; margin-left:auto;">üéØ Start Pick</button>
              </label>
            </div>
            <div id="lmBulkPickList" style="display:none; margin-top:8px; padding:6px; background:#fef3c7; border-radius:4px;">
              <div style="font-size:11px; font-weight:600; color:#92400e; margin-bottom:4px;">Picked elements:</div>
              <div id="lmBulkPickedItems" style="display:flex; flex-wrap:wrap; gap:4px;">
                <!-- Picked items will appear here -->
              </div>
              <button class="btn" id="lmBulkClearPicked" style="width:100%; margin-top:6px; font-size:10px; padding:4px;">Clear All</button>
            </div>
          </div>
          
          <!-- Apply button -->
          <div class="row" style="margin-top:12px;">
            <button class="btn primary" id="lmBulkApply" style="width:100%; padding:10px; font-size:12px; background:linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); border:none; color:white;">
              ‚ö° Apply Changes
            </button>
          </div>
        </div>
      </div>

      <!-- Rename Tag Section -->
      <div class="inspector-section collapsed" data-section="lm-rename">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>‚úèÔ∏è Rename Tag</span>
          <span class="section-icon">‚ñº</span>
        </div>
        <div class="inspector-section-content">
          <div class="hint" style="margin-bottom:10px; padding:6px; background:#fef3c7; border-radius:4px; color:#92400e; font-size:11px;">
            Rename a tag across all nodes, links, and containers
          </div>
          <div class="row">
            <label style="font-weight:600; font-size:11px;">Current Tag Name</label>
            <select id="lmRenameFrom" style="width:100%; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd; margin-top:4px;">
              <option value="">-- Select tag to rename --</option>
            </select>
          </div>
          <div class="row" style="margin-top:8px;">
            <label style="font-weight:600; font-size:11px;">New Tag Name</label>
            <input type="text" id="lmRenameTo" placeholder="Enter new name..." style="width:100%; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd; margin-top:4px;" />
          </div>
          <div class="row" style="margin-top:10px;">
            <button class="btn" id="lmRenameApply" style="width:100%; padding:8px; font-size:11px; background:#fef3c7; border-color:#fcd34d; color:#92400e;">
              ‚úèÔ∏è Rename Tag Globally
            </button>
          </div>
        </div>
      </div>
    </div>
  </aside>
</div>

<script>
(() => {
  const svg = document.getElementById('svg');
  const toastEl = document.getElementById('toast');

  // UUID generation for unique identifiers
  function generateUUID() {
    // Use crypto.randomUUID if available (modern browsers), fallback to manual generation
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    // Fallback UUID v4 generation
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  // Color Palette System
  const colorPalette = {
    // Row 1: White, Light grays, Soft colors
    row1: ['#ffffff', '#f5f5f5', '#e8e8e8', '#dae8fc', '#d5e8d4', '#fff2cc', '#f8cecc', '#e1d5e7'],
    // Row 2: Pastel colors
    row2: ['#eeeeee', '#dae8fc', '#d5e8d4', '#fff2cc', '#f8cecc', '#e1d5e7', '#fce5cd', '#cce5ff'],
    // Row 3: Medium colors  
    row3: ['#b3b3b3', '#6c8ebf', '#82b366', '#d6b656', '#b85450', '#9673a6', '#d79b00', '#36a2eb'],
    // Row 4: Darker/saturated colors
    row4: ['#666666', '#1a5276', '#196f3d', '#b7950b', '#922b21', '#6c3483', '#a04000', '#1f618d']
  };

  function createColorPicker(inputElement, onChange) {
    const wrapper = document.createElement('div');
    wrapper.className = 'color-picker-wrap';
    
    const swatch = document.createElement('div');
    swatch.className = 'color-swatch';
    
    const preview = document.createElement('div');
    preview.className = 'color-swatch-preview';
    preview.style.backgroundColor = inputElement.value || '#ffffff';
    
    const label = document.createElement('span');
    label.className = 'color-swatch-label';
    label.textContent = inputElement.value || '#ffffff';
    
    swatch.appendChild(preview);
    swatch.appendChild(label);
    
    const palette = document.createElement('div');
    palette.className = 'color-palette';
    
    // Add color rows
    [colorPalette.row1, colorPalette.row2, colorPalette.row3, colorPalette.row4].forEach(row => {
      const rowDiv = document.createElement('div');
      rowDiv.className = 'color-palette-row';
      row.forEach(color => {
        const item = document.createElement('div');
        item.className = 'color-palette-item';
        item.style.backgroundColor = color;
        item.dataset.color = color;
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          selectColor(color);
        });
        rowDiv.appendChild(item);
      });
      palette.appendChild(rowDiv);
    });
    
    // Custom color picker
    const customDiv = document.createElement('div');
    customDiv.className = 'color-palette-custom';
    const customInput = document.createElement('input');
    customInput.type = 'color';
    customInput.value = inputElement.value || '#ffffff';
    customInput.addEventListener('input', (e) => {
      selectColor(e.target.value);
    });
    const customLabel = document.createElement('span');
    customLabel.textContent = 'Custom color';
    customDiv.appendChild(customInput);
    customDiv.appendChild(customLabel);
    palette.appendChild(customDiv);
    
    wrapper.appendChild(swatch);
    wrapper.appendChild(palette);
    
    // Replace original input
    inputElement.style.display = 'none';
    inputElement.parentNode.insertBefore(wrapper, inputElement);
    
    function selectColor(color) {
      inputElement.value = color;
      preview.style.backgroundColor = color;
      label.textContent = color;
      customInput.value = color;
      palette.classList.remove('show');
      if (onChange) onChange(color);
      // Trigger change event on original input
      inputElement.dispatchEvent(new Event('input', { bubbles: true }));
    }
    
    function updateFromInput() {
      const color = inputElement.value || '#ffffff';
      preview.style.backgroundColor = color;
      label.textContent = color;
      customInput.value = color;
    }
    
    swatch.addEventListener('click', (e) => {
      e.stopPropagation();
      // Close other palettes
      document.querySelectorAll('.color-palette.show').forEach(p => {
        if (p !== palette) p.classList.remove('show');
      });
      palette.classList.toggle('show');
    });
    
    // Close palette when clicking outside
    document.addEventListener('click', () => {
      palette.classList.remove('show');
    });
    
    palette.addEventListener('click', (e) => {
      e.stopPropagation();
    });
    
    return { update: updateFromInput };
  }

  // Global visibility toggles
  const tglShowLatency = document.getElementById('tglShowLatency');
  const tglShowNodeCode = document.getElementById('tglShowNodeCode');
  const tglShowLinkCode = document.getElementById('tglShowLinkCode');
  const tglShowNodeTags = document.getElementById('tglShowNodeTags');
  const tglShowExtraTags = document.getElementById('tglShowExtraTags');
  const tglShowNodeName = document.getElementById('tglShowNodeName');
  const tglShowLinkTag = document.getElementById('tglShowLinkTag');
  const tglShowContainerTitle = document.getElementById('tglShowContainerTitle');
  const canvasWidth = document.getElementById('canvasWidth');
  const canvasHeight = document.getElementById('canvasHeight');
  const tglCanvasBorder = document.getElementById('tglCanvasBorder');

  function syncGlobalToggles() {
    if (tglShowLatency) tglShowLatency.checked = !!state.ui.showLatency;
    if (tglShowNodeCode) tglShowNodeCode.checked = !!state.ui.showNodeCode;
    if (tglShowLinkCode) tglShowLinkCode.checked = !!state.ui.showLinkCode;
    if (tglShowNodeTags) tglShowNodeTags.checked = !!state.ui.showNodeTags;
    if (tglShowExtraTags) tglShowExtraTags.checked = !!state.ui.showExtraTags;
    if (tglShowNodeName) tglShowNodeName.checked = state.ui.showNodeName !== false;
    if (tglShowLinkTag) tglShowLinkTag.checked = state.ui.showLinkTag !== false;
    if (tglShowContainerTitle) tglShowContainerTitle.checked = state.ui.showContainerTitle !== false;
    if (canvasWidth) canvasWidth.value = state.canvasWidth;
    if (canvasHeight) canvasHeight.value = state.canvasHeight;
    if (tglCanvasBorder) tglCanvasBorder.checked = !!state.showCanvasBorder;
  }

  [tglShowLatency, tglShowNodeCode, tglShowLinkCode, tglShowNodeTags, tglShowExtraTags, tglShowNodeName, tglShowLinkTag, tglShowContainerTitle].forEach(el => {
    if (!el) return;
    el.addEventListener('change', () => {
      state.ui.showLatency = !!tglShowLatency?.checked;
      state.ui.showNodeCode = !!tglShowNodeCode?.checked;
      state.ui.showLinkCode = !!tglShowLinkCode?.checked;
      state.ui.showNodeTags = !!tglShowNodeTags?.checked;
      state.ui.showExtraTags = !!tglShowExtraTags?.checked;
      state.ui.showNodeName = tglShowNodeName?.checked !== false;
      state.ui.showLinkTag = tglShowLinkTag?.checked !== false;
      state.ui.showContainerTitle = tglShowContainerTitle?.checked !== false;
      render();
    });
  });

  // Canvas settings handlers are initialized later after state is defined

  if (tglCanvasBorder) {
    // This handler is also moved later
  }




  const state = {
    nodes: [],
    edges: [],
    groups: [],
    cableSystems: [],  // Cable system objects
    nextNode: 1,
    nextEdge: 1,
    nextGroup: 1,
    nextCableSystem: 1,
    selected: null,
    selectedCableSystem: null,  // Currently selected cable system ID
    connectFrom: null,
    dragging: null,
    resizingGroup: null,
    resizingNode: null,
    placingGroup: false,
    defaultNodeShape: 'circle',
    placingGroupType: 'country',

    // Canvas dimensions (now customizable)
    canvasWidth: 1600,
    canvasHeight: 900,
    showCanvasBorder: true,

    // Grid settings
    gridEnabled: true,
    gridSize: 40,

    // Tag filter settings
    tagFilter: {
      mode: 'all',  // 'all', 'include', 'exclude'
      selectedTags: new Set(),
      exclusive: false  // If true, ignore other filters
    },

    // Cable system filter settings
    cableSystemFilter: {
      mode: 'all',  // 'all', 'selected'
      selectedSystems: new Set(),
      showUnmapped: true,
      exclusive: false  // If true, ignore other filters
    },

    // Node filter settings
    nodeFilter: {
      mode: 'all',  // 'all', 'selected'
      selectedNodes: new Set(),
      displayMode: 'name',  // 'name' or 'code'
      exclusive: false  // If true, ignore other filters
    },

    // Container filter settings
    containerFilter: {
      mode: 'all',  // 'all', 'selected'
      selectedBoxes: new Set(),    // Container boxes (country type)
      selectedGroups: new Set(),   // Groups/regions (container of containers)
      exclusive: false  // If true, ignore other filters
    },

    // Zoom level (CSS transform based)
    zoom: 1,

    // UI/global toggles
    ui: { showLatency: true, showNodeCode: true, showLinkCode: true, showNodeTags: false, showExtraTags: false },

    // Named style presets (saved inside .ndg)
    stylePresets: { node: {}, edge: {}, group: {} },

    // Shape Library (persisted to localStorage)
    shapeLibrary: {
      shapes: {},      // id -> node shape definition
      categories: ['Network Devices', 'Cloud Services', 'Custom'],  // default categories for nodes
      containerShapes: {},  // id -> container shape definition (decorative SVG)
      containerCategories: ['Regions', 'Countries', 'Custom']  // default categories for containers
    },
    
    // Current library tab
    libraryTab: 'nodes',  // 'nodes' or 'containers'

    // Format painter (session-only)
    styleBrush: null,

    // Multi-selection (ids)
    selection: { nodes: new Set(), edges: new Set(), groups: new Set() },
    marquee: null,
    lastMouse: { x: 0, y: 0 }
  };

  const history = { stack: [], index: -1, max: 120 };
  let dirty = false;

  // Pan and Zoom functionality using CSS transform and scrollbars
  function updateViewBox() {
    // Keep the viewBox matching canvas dimensions
    svg.setAttribute('viewBox', `0 0 ${state.canvasWidth} ${state.canvasHeight}`);
    
    // Update SVG size based on zoom - always use the full canvas size
    // This ensures the entire canvas is always scrollable
    const scaledWidth = state.canvasWidth * state.zoom;
    const scaledHeight = state.canvasHeight * state.zoom;
    
    svg.setAttribute('width', scaledWidth);
    svg.setAttribute('height', scaledHeight);
    
    // Also set the container size explicitly to ensure scroll works
    const svgContainer = document.getElementById('svgContainer');
    if (svgContainer) {
      svgContainer.style.width = scaledWidth + 'px';
      svgContainer.style.height = scaledHeight + 'px';
    }
    
    // Update zoom level display
    const zoomPct = Math.round(state.zoom * 100);
    const zoomLevelEl = document.getElementById('zoomLevel');
    if (zoomLevelEl) zoomLevelEl.textContent = `${zoomPct}%`;
  }

  function setZoom(newZoom, centerOnMouse = false, mouseX = 0, mouseY = 0) {
    newZoom = Math.max(0.1, Math.min(5, newZoom)); // Clamp between 10% and 500%
    
    const wrap = document.getElementById('wrap');
    const oldZoom = state.zoom;
    
    if (centerOnMouse && wrap) {
      // Calculate the point under the mouse in canvas coordinates before zoom
      const scrollLeft = wrap.scrollLeft;
      const scrollTop = wrap.scrollTop;
      const pointX = (scrollLeft + mouseX) / oldZoom;
      const pointY = (scrollTop + mouseY) / oldZoom;
      
      state.zoom = newZoom;
      updateViewBox();
      
      // After zoom, scroll to keep the same point under the mouse
      wrap.scrollLeft = pointX * newZoom - mouseX;
      wrap.scrollTop = pointY * newZoom - mouseY;
    } else {
      state.zoom = newZoom;
      updateViewBox();
    }
  }

  function fitToView() {
    if (state.nodes.length === 0 && state.groups.length === 0) {
      // Nothing to fit - reset to 100%
      state.zoom = 1;
      updateViewBox();
      const wrap = document.getElementById('wrap');
      if (wrap) {
        wrap.scrollLeft = 0;
        wrap.scrollTop = 0;
      }
      return;
    }

    // Calculate bounding box of all content
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    state.nodes.forEach(n => {
      const r = n.r || 24;
      minX = Math.min(minX, n.x - r - 50);
      minY = Math.min(minY, n.y - r - 50);
      maxX = Math.max(maxX, n.x + r + 50);
      maxY = Math.max(maxY, n.y + r + 50);
    });
    
    state.groups.forEach(g => {
      minX = Math.min(minX, g.x - 20);
      minY = Math.min(minY, g.y - 20);
      maxX = Math.max(maxX, g.x + g.w + 20);
      maxY = Math.max(maxY, g.y + g.h + 20);
    });

    const contentWidth = maxX - minX;
    const contentHeight = maxY - minY;
    
    const wrap = document.getElementById('wrap');
    const wrapWidth = wrap.clientWidth;
    const wrapHeight = wrap.clientHeight;
    
    // Calculate scale to fit content
    const scaleX = wrapWidth / contentWidth;
    const scaleY = wrapHeight / contentHeight;
    let scale = Math.min(scaleX, scaleY) * 0.9; // 90% to add padding
    
    // Ensure zoom doesn't make canvas smaller than viewport (so scrollbars remain)
    // The canvas at this zoom level should be larger than the viewport
    const minZoomForScrollX = (wrapWidth + 50) / state.canvasWidth;
    const minZoomForScrollY = (wrapHeight + 50) / state.canvasHeight;
    const minZoomForScroll = Math.max(minZoomForScrollX, minZoomForScrollY);
    
    // Use the larger of: content fit zoom, or minimum zoom for scrolling
    scale = Math.max(scale, minZoomForScroll);
    
    state.zoom = Math.max(0.1, Math.min(5, scale));
    updateViewBox();
    
    // Calculate scroll position to center the content
    if (wrap) {
      // Center the content in the viewport
      const contentCenterX = (minX + maxX) / 2;
      const contentCenterY = (minY + maxY) / 2;
      
      // Scroll to position content center in the middle of viewport
      const scrollX = (contentCenterX * state.zoom) - (wrapWidth / 2);
      const scrollY = (contentCenterY * state.zoom) - (wrapHeight / 2);
      
      wrap.scrollLeft = Math.max(0, scrollX);
      wrap.scrollTop = Math.max(0, scrollY);
    }
  }

  function trimCanvasToContent() {
    if (state.nodes.length === 0 && state.groups.length === 0) {
      showToast('No content to trim to.');
      return;
    }

    // Calculate bounding box of all content
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    state.nodes.forEach(n => {
      const r = n.r || 24;
      minX = Math.min(minX, n.x - r);
      minY = Math.min(minY, n.y - r);
      maxX = Math.max(maxX, n.x + r);
      maxY = Math.max(maxY, n.y + r);
    });
    
    state.groups.forEach(g => {
      minX = Math.min(minX, g.x);
      minY = Math.min(minY, g.y);
      maxX = Math.max(maxX, g.x + g.w);
      maxY = Math.max(maxY, g.y + g.h);
    });

    // Add padding around content
    const padding = 50;
    minX = Math.max(0, minX - padding);
    minY = Math.max(0, minY - padding);
    maxX = maxX + padding;
    maxY = maxY + padding;

    // Calculate offset to move all objects
    const offsetX = -minX;
    const offsetY = -minY;

    // Move all nodes
    state.nodes.forEach(n => {
      n.x += offsetX;
      n.y += offsetY;
    });

    // Move all groups
    state.groups.forEach(g => {
      g.x += offsetX;
      g.y += offsetY;
    });

    // Update canvas size to fit content
    const newWidth = Math.max(400, maxX - minX);
    const newHeight = Math.max(300, maxY - minY);
    
    state.canvasWidth = Math.ceil(newWidth);
    state.canvasHeight = Math.ceil(newHeight);

    // Reset zoom to 100% and update
    state.zoom = 1;
    updateViewBox();
    
    // Scroll to top-left
    const wrap = document.getElementById('wrap');
    if (wrap) {
      wrap.scrollLeft = 0;
      wrap.scrollTop = 0;
    }

    commit();
    render();
    showToast(`Canvas trimmed to ${state.canvasWidth} √ó ${state.canvasHeight} pixels.`);
  }

  // Auto-fit canvas to include all elements with padding
  function autoFitCanvas() {
    if (state.nodes.length === 0 && state.groups.length === 0) {
      showToast('No content to fit.');
      return;
    }

    // Calculate bounding box of ALL content (including those outside canvas)
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    // Include nodes with their labels (estimate label width)
    state.nodes.forEach(n => {
      const r = n.r || 24;
      const labelPadding = 60; // Extra space for labels
      minX = Math.min(minX, n.x - r - labelPadding);
      minY = Math.min(minY, n.y - r - 30); // Space above for labels
      maxX = Math.max(maxX, n.x + r + labelPadding);
      maxY = Math.max(maxY, n.y + r + 40); // Space below for labels
    });
    
    // Include groups/containers
    state.groups.forEach(g => {
      minX = Math.min(minX, g.x - 20);
      minY = Math.min(minY, g.y - 30); // Title space above
      maxX = Math.max(maxX, g.x + g.w + 20);
      maxY = Math.max(maxY, g.y + g.h + 20);
    });

    // Add padding around content
    const padding = 80;
    
    // Calculate how much we need to shift elements (if minX or minY is negative or too small)
    const shiftX = minX < padding ? padding - minX : 0;
    const shiftY = minY < padding ? padding - minY : 0;
    
    // Move all nodes if needed
    if (shiftX > 0 || shiftY > 0) {
      state.nodes.forEach(n => {
        n.x += shiftX;
        n.y += shiftY;
      });
      
      // Move all groups
      state.groups.forEach(g => {
        g.x += shiftX;
        g.y += shiftY;
      });
      
      // Update bounds after shift
      minX += shiftX;
      minY += shiftY;
      maxX += shiftX;
      maxY += shiftY;
    }

    // Calculate new canvas size
    const newWidth = Math.max(state.canvasWidth, maxX + padding);
    const newHeight = Math.max(state.canvasHeight, maxY + padding);
    
    const wasExpanded = newWidth > state.canvasWidth || newHeight > state.canvasHeight;
    const wasShifted = shiftX > 0 || shiftY > 0;
    
    state.canvasWidth = Math.ceil(newWidth);
    state.canvasHeight = Math.ceil(newHeight);

    // Update viewBox
    updateViewBox();
    
    // Update canvas size inputs
    const canvasWidthInput = document.getElementById('canvasWidth');
    const canvasHeightInput = document.getElementById('canvasHeight');
    if (canvasWidthInput) canvasWidthInput.value = state.canvasWidth;
    if (canvasHeightInput) canvasHeightInput.value = state.canvasHeight;

    commit();
    render();
    
    if (wasShifted && wasExpanded) {
      showToast(`üìê Canvas expanded to ${state.canvasWidth} √ó ${state.canvasHeight} and elements repositioned`);
    } else if (wasShifted) {
      showToast(`üìê Elements repositioned to fit within canvas`);
    } else if (wasExpanded) {
      showToast(`üìê Canvas expanded to ${state.canvasWidth} √ó ${state.canvasHeight}`);
    } else {
      showToast(`üìê All elements already fit within canvas`);
    }
  }

  // Center all elements on the canvas
  function centerElements() {
    if (state.nodes.length === 0 && state.groups.length === 0) {
      showToast('No content to center.');
      return;
    }

    // Calculate bounding box of all content
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    state.nodes.forEach(n => {
      const r = n.r || 24;
      minX = Math.min(minX, n.x - r);
      minY = Math.min(minY, n.y - r);
      maxX = Math.max(maxX, n.x + r);
      maxY = Math.max(maxY, n.y + r);
    });
    
    state.groups.forEach(g => {
      minX = Math.min(minX, g.x);
      minY = Math.min(minY, g.y);
      maxX = Math.max(maxX, g.x + g.w);
      maxY = Math.max(maxY, g.y + g.h);
    });

    // Calculate content dimensions
    const contentWidth = maxX - minX;
    const contentHeight = maxY - minY;
    
    // Calculate offset to center content
    const targetX = (state.canvasWidth - contentWidth) / 2;
    const targetY = (state.canvasHeight - contentHeight) / 2;
    
    const offsetX = targetX - minX;
    const offsetY = targetY - minY;

    // Move all nodes
    state.nodes.forEach(n => {
      n.x += offsetX;
      n.y += offsetY;
    });

    // Move all groups
    state.groups.forEach(g => {
      g.x += offsetX;
      g.y += offsetY;
    });

    commit();
    render();
    showToast('‚äõ Elements centered on canvas');
  }

  // Check if elements are outside canvas bounds and auto-expand if enabled
  function checkAndAutoExpandCanvas() {
    const autoExpandCheckbox = document.getElementById('tglAutoExpandCanvas');
    if (!autoExpandCheckbox || !autoExpandCheckbox.checked) return;
    
    let needsExpansion = false;
    let maxX = state.canvasWidth;
    let maxY = state.canvasHeight;
    let minX = 0;
    let minY = 0;
    
    // Check nodes
    state.nodes.forEach(n => {
      const r = n.r || 24;
      if (n.x + r + 50 > maxX) { maxX = n.x + r + 100; needsExpansion = true; }
      if (n.y + r + 50 > maxY) { maxY = n.y + r + 100; needsExpansion = true; }
      if (n.x - r < minX + 50) { minX = n.x - r - 100; needsExpansion = true; }
      if (n.y - r < minY + 50) { minY = n.y - r - 100; needsExpansion = true; }
    });
    
    // Check groups
    state.groups.forEach(g => {
      if (g.x + g.w + 50 > maxX) { maxX = g.x + g.w + 100; needsExpansion = true; }
      if (g.y + g.h + 50 > maxY) { maxY = g.y + g.h + 100; needsExpansion = true; }
      if (g.x < minX + 50) { minX = g.x - 100; needsExpansion = true; }
      if (g.y < minY + 50) { minY = g.y - 100; needsExpansion = true; }
    });
    
    if (!needsExpansion) return;
    
    // Calculate shift needed for left/top expansion
    const shiftX = minX < 0 ? -minX : 0;
    const shiftY = minY < 0 ? -minY : 0;
    
    if (shiftX > 0 || shiftY > 0) {
      // Shift all elements to accommodate left/top expansion
      state.nodes.forEach(n => {
        n.x += shiftX;
        n.y += shiftY;
      });
      state.groups.forEach(g => {
        g.x += shiftX;
        g.y += shiftY;
      });
      maxX += shiftX;
      maxY += shiftY;
    }
    
    // Update canvas size
    state.canvasWidth = Math.ceil(Math.max(state.canvasWidth, maxX));
    state.canvasHeight = Math.ceil(Math.max(state.canvasHeight, maxY));
    
    updateViewBox();
    
    // Update canvas size inputs
    const canvasWidthInput = document.getElementById('canvasWidth');
    const canvasHeightInput = document.getElementById('canvasHeight');
    if (canvasWidthInput) canvasWidthInput.value = state.canvasWidth;
    if (canvasHeightInput) canvasHeightInput.value = state.canvasHeight;
  }

  // In-app clipboard (for copy/paste)
  let clipboard = null; // { nodes:[], groups:[], edges:[], bbox:{minX,minY} }

  function selectionToClipboard() {
    const nodeIds = new Set(state.selection.nodes);
    const groupIds = new Set(state.selection.groups);

    // Include edges where both endpoints are selected (plus any explicitly selected)
    const edgeIds = new Set(state.selection.edges);
    state.edges.forEach(e => { if (nodeIds.has(e.a) && nodeIds.has(e.b)) edgeIds.add(e.id); });

    const nodes = state.nodes.filter(n => nodeIds.has(n.id)).map(n => ({...n}));
    const groups = state.groups.filter(g => groupIds.has(g.id)).map(g => ({...g}));
    const edges = state.edges.filter(e => edgeIds.has(e.id)).map(e => ({...e}));

    if (nodes.length===0 && groups.length===0 && edges.length===0) return null;

    // bbox of nodes + groups (for paste offset)
    const xs = [], ys = [];
    nodes.forEach(n => { xs.push(n.x); ys.push(n.y); });
    groups.forEach(g => { xs.push(g.x, g.x+g.w); ys.push(g.y, g.y+g.h); });
    const minX = xs.length ? Math.min(...xs) : 0;
    const minY = ys.length ? Math.min(...ys) : 0;

    return { nodes, groups, edges, bbox: { minX, minY } };
  }

  function copySelection() {
    const clip = selectionToClipboard();
    if (!clip) { showToast('Nothing selected to copy.'); return; }
    clipboard = clip;
    showToast(`Copied ${clip.nodes.length} node(s), ${clip.edges.length} link(s), ${clip.groups.length} box(es).`);
  }

  function cutSelection() {
    copySelection();
    // If nothing copied, don't delete.
    if (!clipboard) return;
    deleteSelection();
  }

  function pasteSelection() {
    if (!clipboard) { showToast('Clipboard is empty.'); return; }

    const offset = 24;
    const targetX = state.lastMouse?.x ?? 200;
    const targetY = state.lastMouse?.y ?? 200;

    // Paste near last mouse position (or just offset)
    const dx = (targetX - clipboard.bbox.minX) + offset;
    const dy = (targetY - clipboard.bbox.minY) + offset;

    const nodeIdMap = new Map();
    const groupIdMap = new Map();

    // Duplicate groups first (so nodes can reference them)
    const newGroupIds = [];
    for (const g of clipboard.groups) {
      const id = state.nextGroup++;
      const ng = { ...g, id, x: g.x + dx, y: g.y + dy };
      // remap parentId if parent was also copied
      if (ng.parentId && groupIdMap.has(ng.parentId)) ng.parentId = groupIdMap.get(ng.parentId);
      state.groups.push(ng);
      groupIdMap.set(g.id, id);
      newGroupIds.push(id);
    }

    const newNodeIds = [];
    for (const n of clipboard.nodes) {
      const id = state.nextNode++;
      const nn = { ...n, id, x: n.x + dx, y: n.y + dy };
      if (nn.groupId && groupIdMap.has(nn.groupId)) nn.groupId = groupIdMap.get(nn.groupId);
      state.nodes.push(nn);
      nodeIdMap.set(n.id, id);
      newNodeIds.push(id);
    }

    const newEdgeIds = [];
    for (const e of clipboard.edges) {
      // only recreate edges whose endpoints were included in clipboard (typical copy behavior)
      if (!nodeIdMap.has(e.a) || !nodeIdMap.has(e.b)) continue;
      const id = state.nextEdge++;
      const ne = { ...e, id, a: nodeIdMap.get(e.a), b: nodeIdMap.get(e.b) };
      state.edges.push(ne);
      newEdgeIds.push(id);
    }

    refreshAllMemberships();
    commit();

    setMultiSelection({ nodes: newNodeIds, edges: newEdgeIds, groups: newGroupIds });
    render();
    showToast('Pasted selection.');
  }

  function cloneSelectionForDrag() {
    const clip = selectionToClipboard();
    if (!clip) return false;
    clipboard = clip;
    pasteSelection();
    return true;
  }



  const showToast = (msg) => {
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toastEl.classList.remove('show'), 2400);
  };

  // Ribbon tabs (File/Home). This does not change any existing handlers.
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  // Color helper functions for rgba support
  function parseColorWithOpacity(colorStr) {
    if (!colorStr) return { color: '#ffffff', opacity: 1 };
    
    // Handle rgba format
    const rgbaMatch = colorStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
    if (rgbaMatch) {
      const r = parseInt(rgbaMatch[1]);
      const g = parseInt(rgbaMatch[2]);
      const b = parseInt(rgbaMatch[3]);
      const a = rgbaMatch[4] !== undefined ? parseFloat(rgbaMatch[4]) : 1;
      const hex = '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
      return { color: hex, opacity: a };
    }
    
    // Handle hex format (with optional alpha)
    if (colorStr.startsWith('#')) {
      if (colorStr.length === 9) {
        // #RRGGBBAA
        const alpha = parseInt(colorStr.slice(7, 9), 16) / 255;
        return { color: colorStr.slice(0, 7), opacity: alpha };
      }
      return { color: colorStr.slice(0, 7), opacity: 1 };
    }
    
    return { color: colorStr, opacity: 1 };
  }
  
  function combineColorWithOpacity(hexColor, opacity) {
    if (opacity >= 1) return hexColor;
    // Convert hex to rgba
    const r = parseInt(hexColor.slice(1, 3), 16);
    const g = parseInt(hexColor.slice(3, 5), 16);
    const b = parseInt(hexColor.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${opacity.toFixed(2)})`;
  }

  // Node shape tool (sets default for NEW nodes only)
  const shapeButtons = document.querySelectorAll('.shape-tool');
  function setActiveShape(shape){
    state.defaultNodeShape = shape;
    shapeButtons.forEach(b=>{
      b.classList.toggle('active', b.dataset.shape === shape);
    });
  }
  
  shapeButtons.forEach(btn => {
    btn.addEventListener('click', (ev) => {
      const shape = btn.dataset.shape;
      setActiveShape(shape);

      // If a node is selected, update ONLY that node
      if (state.selected?.type === 'node'){
        const n = findNode(state.selected.id);
        if (n){
          n.shape = shape;
          commit(); render();
          showToast('Changed node shape to ' + shape + '.');
          return;
        }
      }
      showToast('New nodes will be ' + shape + '.');
    });
  });

  // --- File menu UI ---
  const fileBtn = document.getElementById('btnFile');
  const fileMenu = document.getElementById('fileMenu');
  const editBtn = document.getElementById('btnEditMenu');
  const editMenu = document.getElementById('editMenu');
  const viewBtn = document.getElementById('btnViewMenu');
  const viewMenu = document.getElementById('viewMenu');
  
  function closeAllMenus(){ 
    fileMenu.hidden = true; 
    if (editMenu) editMenu.hidden = true;
    if (viewMenu) viewMenu.hidden = true;
    const zoomMenu = document.getElementById('zoomMenu');
    if (zoomMenu) zoomMenu.hidden = true;
    const gridMenu = document.getElementById('gridMenu');
    if (gridMenu) gridMenu.hidden = true;
    const helpMenuEl = document.getElementById('helpMenu');
    if (helpMenuEl) helpMenuEl.hidden = true;
  }
  
  function toggleMenu(btn, menu) {
    closeAllMenus();
    menu.hidden = !menu.hidden;
    if (!menu.hidden) {
      const r = btn.getBoundingClientRect();
      menu.style.left = r.left + "px";
      menu.style.top = r.bottom + "px";
    }
  }
  
  fileBtn.addEventListener('click', (ev) => { ev.stopPropagation(); toggleMenu(fileBtn, fileMenu); });
  if (editBtn && editMenu) editBtn.addEventListener('click', (ev) => { ev.stopPropagation(); toggleMenu(editBtn, editMenu); });
  if (viewBtn && viewMenu) viewBtn.addEventListener('click', (ev) => { ev.stopPropagation(); toggleMenu(viewBtn, viewMenu); });
  
  document.addEventListener('click', () => closeAllMenus());
  window.addEventListener('keydown', (ev) => { if (ev.key === 'Escape') closeAllMenus(); });

  // Edit menu actions
  if (document.getElementById('miUndo')) document.getElementById('miUndo').addEventListener('click', () => { undo(); closeAllMenus(); });
  if (document.getElementById('miRedo')) document.getElementById('miRedo').addEventListener('click', () => { redo(); closeAllMenus(); });
  if (document.getElementById('miCopy')) document.getElementById('miCopy').addEventListener('click', () => { copySelection(); closeAllMenus(); });
  if (document.getElementById('miCut')) document.getElementById('miCut').addEventListener('click', () => { copySelection(); deleteSelected(); closeAllMenus(); });
  if (document.getElementById('miPaste')) document.getElementById('miPaste').addEventListener('click', () => { pasteSelection(); closeAllMenus(); });
  if (document.getElementById('miDelete')) document.getElementById('miDelete').addEventListener('click', () => { deleteSelected(); closeAllMenus(); });

  // View menu actions
  if (document.getElementById('miZoomIn')) document.getElementById('miZoomIn').addEventListener('click', () => { setZoom(state.zoom * 1.2); closeAllMenus(); });
  if (document.getElementById('miZoomOut')) document.getElementById('miZoomOut').addEventListener('click', () => { setZoom(state.zoom / 1.2); closeAllMenus(); });
  if (document.getElementById('miFitView')) document.getElementById('miFitView').addEventListener('click', () => { fitToView(); closeAllMenus(); });
  if (document.getElementById('miToggleInspector')) document.getElementById('miToggleInspector').addEventListener('click', () => {
    const inspector = document.getElementById('inspector');
    inspector.style.display = inspector.style.display === 'none' ? 'flex' : 'none';
    closeAllMenus();
  });

  // Toolbar button actions
  if (document.getElementById('btnUndo')) document.getElementById('btnUndo').addEventListener('click', () => undo());
  if (document.getElementById('btnRedo')) document.getElementById('btnRedo').addEventListener('click', () => redo());
  if (document.getElementById('btnDelete')) document.getElementById('btnDelete').addEventListener('click', () => deleteSelected());


  
  // --- Export helpers (SVG/PNG/JPG) ---
  function downloadBlob(blob, filename){
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 800);
  }

  function getSvgCloneForExport(){
    const svg = document.getElementById('svg');
    const clone = svg.cloneNode(true);

    clone.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
    // Remove resize handles - they are editing aids, not part of the diagram
    clone.querySelectorAll('.group-handle').forEach(el => el.remove());
    clone.querySelectorAll('.node-resize-handle').forEach(el => el.remove());
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');

    const style = document.createElementNS('http://www.w3.org/2000/svg','style');
    style.textContent = `
      .edge{ fill:none; stroke-linecap:round; }
      .edge-label{ font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
      .node-label{ font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
      .group-title{ font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    `;
    clone.insertBefore(style, clone.firstChild);

    const vb = clone.getAttribute('viewBox');
    let w=1600,h=900;
    if (vb){
      const p = vb.split(/\s+/).map(Number);
      if (p.length===4 && p.every(n=>isFinite(n))) { w=p[2]; h=p[3]; }
    }
    const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
    bg.setAttribute('x','0'); bg.setAttribute('y','0');
    bg.setAttribute('width', String(w)); bg.setAttribute('height', String(h));
    bg.setAttribute('fill', '#ffffff');
    clone.insertBefore(bg, style.nextSibling);

    clone.querySelectorAll('.edge-label').forEach(el => el.setAttribute('fill', '#000000'));
    clone.querySelectorAll('.node-label').forEach(el => el.setAttribute('fill', '#000000'));
    clone.querySelectorAll('.group-title').forEach(el => el.setAttribute('fill', '#000000'));

    return clone;
  }

  function exportSVG(){
    const clone = getSvgCloneForExport();
    const text = new XMLSerializer().serializeToString(clone);
    const blob = new Blob([text], {type:'image/svg+xml;charset=utf-8'});
    const name = (sanitizeBaseName(state.projectName || 'diagram') || 'diagram') + '.svg';
    downloadBlob(blob, name);
  }

  async function exportRaster(kind){
    const clone = getSvgCloneForExport();
    // Use viewBox for sizing if present
    const vb = clone.getAttribute('viewBox');
    let w = 1600, h = 900;
    if (vb){
      const p = vb.split(/\s+/).map(Number);
      if (p.length===4 && p.every(n=>isFinite(n))) { w = p[2]; h = p[3]; }
    } else {
      const ww = Number(clone.getAttribute('width')); const hh = Number(clone.getAttribute('height'));
      if (isFinite(ww)) w = ww;
      if (isFinite(hh)) h = hh;
    }

    const svgText = new XMLSerializer().serializeToString(clone);
    const svgBlob = new Blob([svgText], {type:'image/svg+xml;charset=utf-8'});
    const url = URL.createObjectURL(svgBlob);

    const img = new Image();
    await new Promise((res, rej)=>{ img.onload=res; img.onerror=rej; img.src=url; });

    const scale = 2; // sharper output
    const canvas = document.createElement('canvas');
    canvas.width = Math.round(w*scale);
    canvas.height = Math.round(h*scale);
    const ctx = canvas.getContext('2d');

    // Background (match page background)
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.scale(scale, scale);
    ctx.drawImage(img, 0, 0, w, h);
    URL.revokeObjectURL(url);

    const mime = (kind==='png') ? 'image/png' : 'image/jpeg';
    const ext = (kind==='png') ? '.png' : '.jpg';
    const quality = (kind==='png') ? undefined : 0.92;
    const dataUrl = canvas.toDataURL(mime, quality);

    const bin = atob(dataUrl.split(',')[1]);
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    const outBlob = new Blob([bytes], {type:mime});
    const name = (sanitizeBaseName(state.projectName || 'diagram') || 'diagram') + ext;
    downloadBlob(outBlob, name);
  }

document.getElementById('miNew').addEventListener('click', () => { closeAllMenus(); newDiagram(); });
document.getElementById('miSave').addEventListener('click', () => { closeAllMenus(); saveProject(false); });
  document.getElementById('miSaveAs').addEventListener('click', () => { closeAllMenus(); saveProject(true); });
  document.getElementById('miOpen').addEventListener('click', () => { closeAllMenus(); openProjectWithFilePicker(); });
  document.getElementById('miRecover').addEventListener('click', () => { closeAllMenus(); recoverAutosave(); });
  document.getElementById('miClearAutosave').addEventListener('click', () => { closeAllMenus(); clearAutosave(); });
  document.getElementById('miClearDiagram').addEventListener('click', () => { closeAllMenus(); clearDiagram(); });
  document.getElementById('miTrimCanvas').addEventListener('click', () => { closeAllMenus(); trimCanvasToContent(); });

  document.getElementById('miExportSVG').addEventListener('click', () => { closeAllMenus(); exportSVG(); showToast('Exported SVG.'); });
  document.getElementById('miExportPNG').addEventListener('click', () => { closeAllMenus(); exportRaster('png'); showToast('Exported PNG.'); });
  document.getElementById('miExportJPG').addEventListener('click', () => { closeAllMenus(); exportRaster('jpg'); showToast('Exported JPG.'); });

  // --- Style presets helpers ---
  const STYLE_FIELDS = {
    node: ["fill","stroke","nameColor","tagColor","nameFont","tagFont","showCode","nameDx","nameDy","tagDx","tagDy"],
    edge: ["labelFont","labelColor","style","route","showCode","labelDx","labelDy","strokeW","strokeColor"],
    group:["fill","stroke","titleColor","titleFont","titleDx","titleDy"]
  };
  function pickStyle(type, obj){
    const s = {};
    (STYLE_FIELDS[type]||[]).forEach(k => { if (k in obj) s[k] = obj[k]; });
    return s;
  }
  function applyStyle(type, obj, style){
    if (!style) return;
    (STYLE_FIELDS[type]||[]).forEach(k => { if (k in style) obj[k] = style[k]; });
  }

  // Preset UI elements
  const nodePresetSel = document.getElementById('nodePreset');
  const edgePresetSel = document.getElementById('edgePreset');
  const groupPresetSel = document.getElementById('groupPreset');

  function refreshPresetSelects(){
    const fill = (sel, map) => {
      if (!sel) return;
      const cur = sel.value;
      sel.innerHTML = "";
      const opt0 = document.createElement('option');
      opt0.value = ""; opt0.textContent = "(none)";
      sel.appendChild(opt0);
      Object.keys(map||{}).sort((a,b)=>a.localeCompare(b)).forEach(name=>{
        const o = document.createElement('option');
        o.value = name; o.textContent = name;
        sel.appendChild(o);
      });
      sel.value = cur && (map||{})[cur] ? cur : "";
    };
    fill(nodePresetSel, state.stylePresets.node);
    fill(edgePresetSel, state.stylePresets.edge);
    fill(groupPresetSel, state.stylePresets.group);
  }

  function savePreset(type, obj){
    console.log(`[SAVE PRESET] Function called - type: ${type}, obj:`, obj);
    const name = sanitizeBaseName(prompt(`Save ${type} style as:`, "")) || "";
    console.log(`[SAVE PRESET] Prompt returned name: "${name}"`);
    if (!name) { showToast("Preset save cancelled."); return; }
    state.stylePresets[type][name] = pickStyle(type, obj);
    commit(); // persist in history and autosave
    refreshPresetSelects();
    showToast(`Saved preset: ${name}`);
  }
  function applyPreset(type, obj, name){
    const style = state.stylePresets[type][name];
    if (!style) { showToast("No preset selected."); return; }
    applyStyle(type, obj, style);
    commit(); render();
    showToast(`Applied preset: ${name}`);
  }
  function deletePreset(type, name){
    if (!name) { showToast("No preset selected."); return; }
    if (!confirm(`Delete preset "${name}"?`)) return;
    delete state.stylePresets[type][name];
    commit();
    refreshPresetSelects();
    showToast("Preset deleted.");
  }

  // --- Format painter (brush) ---
  const btnBrush = document.getElementById('btnBrush');
  function setBrushFromSelected(){
    const sel = state.selected;
    if (!sel) { showToast("Select an object first."); return; }
    if (sel.type === 'node') {
      const n = findNode(sel.id); if (!n) return;
      state.styleBrush = { type:'node', style: pickStyle('node', n) };
    } else if (sel.type === 'edge') {
      const e = findEdge(sel.id); if (!e) return;
      state.styleBrush = { type:'edge', style: pickStyle('edge', e) };
    } else if (sel.type === 'group') {
      const g = findGroup(sel.id); if (!g) return;
      state.styleBrush = { type:'group', style: pickStyle('group', g) };
    } else return;
    btnBrush.classList.add('primary');
    showToast("Format painter armed ‚Äî click targets to apply (Esc cancels).");
  }
  function clearBrush(){
    state.styleBrush = null;
    btnBrush.classList.remove('primary');
  }
  btnBrush.addEventListener('click', (ev) => {
    ev.stopPropagation();
    if (state.styleBrush) { clearBrush(); showToast("Format painter off."); return; }
    setBrushFromSelected();
  });

  // --- Apply Style Panel ---
  const btnApplyStyle = document.getElementById('btnApplyStyle');
  const applyStyleMenu = document.getElementById('applyStyleMenu');
  const applyStyleContent = document.getElementById('applyStyleContent');
  const applyStyleEmpty = document.getElementById('applyStyleEmpty');
  const btnManageStyles = document.getElementById('btnManageStyles');

  function getSelectionCounts() {
    // Count selected items of each type
    let nodeCount = state.selection.nodes.size;
    let edgeCount = state.selection.edges.size;
    let groupCount = state.selection.groups.size;
    
    // Also include single selection if not in multi-select
    if (state.selected) {
      if (state.selected.type === 'node' && !state.selection.nodes.has(state.selected.id)) nodeCount++;
      if (state.selected.type === 'edge' && !state.selection.edges.has(state.selected.id)) edgeCount++;
      if (state.selected.type === 'group' && !state.selection.groups.has(state.selected.id)) groupCount++;
    }
    
    return { nodes: nodeCount, edges: edgeCount, groups: groupCount };
  }

  function getSelectedItemsOfType(type) {
    const items = [];
    
    if (type === 'node') {
      state.selection.nodes.forEach(id => {
        const n = findNode(id);
        if (n) items.push(n);
      });
      // Include single selection if applicable
      if (state.selected?.type === 'node' && !state.selection.nodes.has(state.selected.id)) {
        const n = findNode(state.selected.id);
        if (n) items.push(n);
      }
    } else if (type === 'edge') {
      state.selection.edges.forEach(id => {
        const e = findEdge(id);
        if (e) items.push(e);
      });
      if (state.selected?.type === 'edge' && !state.selection.edges.has(state.selected.id)) {
        const e = findEdge(state.selected.id);
        if (e) items.push(e);
      }
    } else if (type === 'group') {
      state.selection.groups.forEach(id => {
        const g = findGroup(id);
        if (g) items.push(g);
      });
      if (state.selected?.type === 'group' && !state.selection.groups.has(state.selected.id)) {
        const g = findGroup(state.selected.id);
        if (g) items.push(g);
      }
    }
    
    return items;
  }

  function createStyleSwatch(style, type) {
    const swatch = document.createElement('div');
    swatch.className = 'apply-style-swatch';
    
    // Fill swatch
    const fillDiv = document.createElement('div');
    fillDiv.className = 'apply-style-swatch-fill';
    
    // Stroke swatch  
    const strokeDiv = document.createElement('div');
    strokeDiv.className = 'apply-style-swatch-stroke';
    
    if (type === 'node') {
      fillDiv.style.background = style.fill || '#1b2030';
      strokeDiv.style.background = style.stroke || '#9fb3ff';
    } else if (type === 'edge') {
      fillDiv.style.background = style.strokeColor || '#6c8ebf';
      strokeDiv.style.display = 'none'; // Edges don't have separate stroke
    } else if (type === 'group') {
      fillDiv.style.background = style.fill || '#ffffff';
      strokeDiv.style.background = style.stroke || '#666666';
    }
    
    swatch.appendChild(fillDiv);
    swatch.appendChild(strokeDiv);
    
    return swatch;
  }

  function buildApplyStyleSection(type, count, presets) {
    const section = document.createElement('div');
    section.className = 'apply-style-section';
    
    // Header
    const header = document.createElement('div');
    header.className = 'apply-style-section-header';
    
    const typeLabels = { node: 'Node Styles', edge: 'Link Styles', group: 'Container Styles' };
    header.innerHTML = `<span>${typeLabels[type]}</span><span class="count">${count} selected</span>`;
    section.appendChild(header);
    
    // Style items
    const presetNames = Object.keys(presets || {}).sort((a, b) => a.localeCompare(b));
    
    if (presetNames.length === 0) {
      const emptyMsg = document.createElement('div');
      emptyMsg.className = 'apply-style-empty-section';
      emptyMsg.textContent = `No ${type} styles saved yet`;
      section.appendChild(emptyMsg);
    } else {
      presetNames.forEach(name => {
        const style = presets[name];
        const item = document.createElement('div');
        item.className = 'apply-style-item';
        item.dataset.type = type;
        item.dataset.preset = name;
        
        // Swatch preview
        const swatch = createStyleSwatch(style, type);
        item.appendChild(swatch);
        
        // Name
        const nameSpan = document.createElement('span');
        nameSpan.className = 'apply-style-name';
        nameSpan.textContent = name;
        nameSpan.title = name;
        item.appendChild(nameSpan);
        
        // Click handler
        item.addEventListener('click', () => {
          applyStyleToSelection(type, name);
        });
        
        section.appendChild(item);
      });
    }
    
    return section;
  }

  function applyStyleToSelection(type, presetName) {
    const style = state.stylePresets[type]?.[presetName];
    if (!style) {
      showToast('Style not found.');
      return;
    }
    
    const items = getSelectedItemsOfType(type);
    if (items.length === 0) {
      showToast('No items to apply style to.');
      return;
    }
    
    // Apply style to all selected items of this type
    items.forEach(item => {
      applyStyle(type, item, style);
    });
    
    commit();
    render();
    
    // Close menu and show confirmation
    applyStyleMenu.hidden = true;
    const typeLabel = type === 'node' ? 'node' : (type === 'edge' ? 'link' : 'container');
    showToast(`Applied "${presetName}" to ${items.length} ${typeLabel}${items.length > 1 ? 's' : ''}`);
  }

  function updateApplyStyleMenu() {
    const counts = getSelectionCounts();
    const hasSelection = counts.nodes > 0 || counts.edges > 0 || counts.groups > 0;
    
    // Clear content
    applyStyleContent.innerHTML = '';
    
    if (!hasSelection) {
      applyStyleEmpty.style.display = 'block';
      applyStyleContent.style.display = 'none';
      return;
    }
    
    applyStyleEmpty.style.display = 'none';
    applyStyleContent.style.display = 'block';
    
    // Build sections for each type that has selections
    if (counts.nodes > 0) {
      applyStyleContent.appendChild(buildApplyStyleSection('node', counts.nodes, state.stylePresets.node));
    }
    if (counts.edges > 0) {
      applyStyleContent.appendChild(buildApplyStyleSection('edge', counts.edges, state.stylePresets.edge));
    }
    if (counts.groups > 0) {
      applyStyleContent.appendChild(buildApplyStyleSection('group', counts.groups, state.stylePresets.group));
    }
  }

  if (btnApplyStyle && applyStyleMenu) {
    btnApplyStyle.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateApplyStyleMenu();
      applyStyleMenu.hidden = !applyStyleMenu.hidden;
    });
    
    applyStyleMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }

  if (btnManageStyles) {
    btnManageStyles.addEventListener('click', () => {
      applyStyleMenu.hidden = true;
      showManageStylesDialog();
    });
  }

  // Help Button Handler
  const btnHelp = document.getElementById('btnHelp');
  const helpMenu = document.getElementById('helpMenu');
  if (btnHelp && helpMenu) {
    btnHelp.addEventListener('click', (ev) => { ev.stopPropagation(); toggleMenu(btnHelp, helpMenu); });
    helpMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }

  function showManageStylesDialog() {
    // Create modal dialog for managing styles
    const modal = document.createElement('div');
    modal.id = 'manageStylesModal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); z-index: 10000;
      display: flex; align-items: center; justify-content: center;
    `;
    
    const dialog = document.createElement('div');
    dialog.style.cssText = `
      background: white; border-radius: 8px; padding: 0;
      min-width: 400px; max-width: 500px; max-height: 80vh;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      display: flex; flex-direction: column;
    `;
    
    // Header
    const header = document.createElement('div');
    header.style.cssText = `
      padding: 16px 20px; border-bottom: 1px solid #e0e0e0;
      font-size: 16px; font-weight: 600; color: #333;
      display: flex; justify-content: space-between; align-items: center;
    `;
    header.innerHTML = `
      <span>Manage Styles</span>
      <button id="closeManageStyles" style="background:none; border:none; font-size:20px; cursor:pointer; color:#666;">√ó</button>
    `;
    dialog.appendChild(header);
    
    // Content
    const content = document.createElement('div');
    content.style.cssText = `padding: 0; overflow-y: auto; flex: 1;`;
    
    function buildStyleList(type, label) {
      const section = document.createElement('div');
      section.style.cssText = `border-bottom: 1px solid #e8e8e8;`;
      
      const sectionHeader = document.createElement('div');
      sectionHeader.style.cssText = `
        padding: 10px 20px; background: #f5f5f5;
        font-size: 11px; font-weight: 600; color: #666;
        text-transform: uppercase; letter-spacing: 0.5px;
      `;
      sectionHeader.textContent = label;
      section.appendChild(sectionHeader);
      
      const presets = state.stylePresets[type] || {};
      const names = Object.keys(presets).sort((a, b) => a.localeCompare(b));
      
      if (names.length === 0) {
        const empty = document.createElement('div');
        empty.style.cssText = `padding: 12px 20px; color: #999; font-size: 12px; font-style: italic;`;
        empty.textContent = 'No styles saved';
        section.appendChild(empty);
      } else {
        names.forEach(name => {
          const row = document.createElement('div');
          row.style.cssText = `
            display: flex; align-items: center; gap: 10px;
            padding: 10px 20px; border-top: 1px solid #f0f0f0;
          `;
          
          const swatch = createStyleSwatch(presets[name], type);
          row.appendChild(swatch);
          
          const nameSpan = document.createElement('span');
          nameSpan.style.cssText = `flex: 1; font-size: 13px;`;
          nameSpan.textContent = name;
          row.appendChild(nameSpan);
          
          const deleteBtn = document.createElement('button');
          deleteBtn.style.cssText = `
            background: none; border: 1px solid #ddd; border-radius: 4px;
            padding: 4px 8px; font-size: 11px; cursor: pointer; color: #c00;
          `;
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click', () => {
            if (confirm(`Delete style "${name}"?`)) {
              delete state.stylePresets[type][name];
              commit();
              refreshPresetSelects();
              row.remove();
              showToast(`Deleted style: ${name}`);
            }
          });
          row.appendChild(deleteBtn);
          
          section.appendChild(row);
        });
      }
      
      return section;
    }
    
    content.appendChild(buildStyleList('node', 'Node Styles'));
    content.appendChild(buildStyleList('edge', 'Link Styles'));
    content.appendChild(buildStyleList('group', 'Container Styles'));
    
    dialog.appendChild(content);
    
    // Footer
    const footer = document.createElement('div');
    footer.style.cssText = `
      padding: 12px 20px; border-top: 1px solid #e0e0e0;
      display: flex; justify-content: flex-end;
    `;
    footer.innerHTML = `<button class="btn" id="closeManageStylesBtn">Close</button>`;
    dialog.appendChild(footer);
    
    modal.appendChild(dialog);
    document.body.appendChild(modal);
    
    // Event handlers
    const closeModal = () => modal.remove();
    modal.querySelector('#closeManageStyles').addEventListener('click', closeModal);
    modal.querySelector('#closeManageStylesBtn').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
    document.addEventListener('keydown', function escHandler(e) {
      if (e.key === 'Escape') {
        closeModal();
        document.removeEventListener('keydown', escHandler);
      }
    });
  }

  const btnCreateLink = document.getElementById('btnCreateLink');
  
  let linkMode = false;
  let linkSourceNode = null;  // Track the source node ID
  
  function clearLinkMode() {
    linkMode = false;
    linkSourceNode = null;
    state.connectFrom = null;
    btnCreateLink.classList.remove('primary');
  }
  
  btnCreateLink.addEventListener('click', (ev) => {
    ev.stopPropagation();
    linkMode = !linkMode;
    linkSourceNode = null;
    state.connectFrom = null;
    btnCreateLink.classList.toggle('primary', linkMode);
    console.log(`[LINK MODE] ${linkMode ? 'ACTIVATED' : 'DEACTIVATED'} - linkMode=${linkMode}, linkSourceNode=${linkSourceNode}`);
    if (linkMode) {
      // Check if a node is already selected
      if (state.selected && state.selected.type === 'node') {
        linkSourceNode = state.selected.id;
        const node = findNode(linkSourceNode);
        console.log(`[LINK MODE] Node ${linkSourceNode} already selected - using as source`);
        showToast(`Link source: ${node?.name || `N${linkSourceNode}`} ‚Üí Click target node`);
      } else {
        console.log(`[LINK MODE] No node selected - waiting for first click`);
        showToast('Link mode ON - Click first node');
      }
    } else {
      showToast('Link mode OFF');
    }
    render();
  });

  // Zoom controls
  const btnZoomIn = document.getElementById('btnZoomIn');
  const btnZoomOut = document.getElementById('btnZoomOut');
  const btnZoomFit = document.getElementById('btnZoomFit');
  const btnZoomLevel = document.getElementById('btnZoomLevel');
  const zoomMenu = document.getElementById('zoomMenu');

  if (btnZoomIn) {
    btnZoomIn.addEventListener('click', () => {
      setZoom(state.zoom * 1.2);
    });
  }

  if (btnZoomOut) {
    btnZoomOut.addEventListener('click', () => {
      setZoom(state.zoom / 1.2);
    });
  }

  if (btnZoomFit) {
    btnZoomFit.addEventListener('click', () => {
      fitToView();
    });
  }

  // Zoom dropdown menu
  if (btnZoomLevel && zoomMenu) {
    btnZoomLevel.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      zoomMenu.hidden = !zoomMenu.hidden;
      if (!zoomMenu.hidden) {
        const r = btnZoomLevel.getBoundingClientRect();
        zoomMenu.style.left = '0';
        zoomMenu.style.top = '100%';
      }
    });

    // Zoom preset items
    zoomMenu.querySelectorAll('.zoom-preset').forEach(item => {
      item.addEventListener('click', () => {
        const zoom = parseFloat(item.dataset.zoom);
        if (zoom) setZoom(zoom);
        zoomMenu.hidden = true;
      });
    });

    // Fit to view
    const zoomFitView = document.getElementById('zoomFitView');
    if (zoomFitView) {
      zoomFitView.addEventListener('click', () => {
        fitToView();
        zoomMenu.hidden = true;
      });
    }

    // Reset to 100%
    const zoomReset = document.getElementById('zoomReset');
    if (zoomReset) {
      zoomReset.addEventListener('click', () => {
        setZoom(1.0);
        zoomMenu.hidden = true;
      });
    }

    // Close menu when clicking outside
    document.addEventListener('click', () => {
      zoomMenu.hidden = true;
    });
    
    zoomMenu.addEventListener('click', (ev) => {
      ev.stopPropagation();
    });
  }

  // Keyboard shortcut for reset zoom
  window.addEventListener('keydown', (ev) => {
    if ((ev.ctrlKey || ev.metaKey) && ev.key === '0') {
      ev.preventDefault();
      setZoom(1.0);
    }
  });

  // Grid toggle and settings
  const btnGridToggle = document.getElementById('btnGridToggle');
  const gridMenu = document.getElementById('gridMenu');
  const gridEnabledCheckbox = document.getElementById('gridEnabled');

  if (btnGridToggle && gridMenu) {
    btnGridToggle.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      gridMenu.hidden = !gridMenu.hidden;
    });

    // Grid enable/disable checkbox
    if (gridEnabledCheckbox) {
      gridEnabledCheckbox.addEventListener('change', () => {
        state.gridEnabled = gridEnabledCheckbox.checked;
        btnGridToggle.classList.toggle('active', state.gridEnabled);
        render();
      });
    }

    // Grid size options
    gridMenu.querySelectorAll('.grid-size').forEach(item => {
      item.addEventListener('click', () => {
        const size = parseInt(item.dataset.size);
        if (size) {
          state.gridSize = size;
          // Update active state
          gridMenu.querySelectorAll('.grid-size').forEach(i => i.classList.remove('active'));
          item.classList.add('active');
          render();
        }
      });
    });

    // Close menu when clicking outside
    document.addEventListener('click', () => {
      gridMenu.hidden = true;
    });
    
    gridMenu.addEventListener('click', (ev) => {
      ev.stopPropagation();
    });

    // Initialize button state
    btnGridToggle.classList.toggle('active', state.gridEnabled);
  }

  // ============== TAG FILTER SYSTEM ==============
  const btnTagFilter = document.getElementById('btnTagFilter');
  const tagFilterMenu = document.getElementById('tagFilterMenu');
  const tagFilterList = document.getElementById('tagFilterList');
  const btnTagSelectAll = document.getElementById('btnTagSelectAll');
  const btnTagClearAll = document.getElementById('btnTagClearAll');
  const miTagFilter = document.getElementById('miTagFilter');

  // Collect all unique tags from nodes, edges, and groups - returns separate counts
  function collectAllTags() {
    const nodeTags = new Map();
    const edgeTags = new Map();
    const groupTags = new Map();
    const cableSystemTags = new Map();
    const allTags = new Set();
    
    // Count from nodes
    for (const node of state.nodes) {
      const tags = getNodeTags(node);
      for (const tag of tags) {
        nodeTags.set(tag, (nodeTags.get(tag) || 0) + 1);
        allTags.add(tag);
      }
    }
    // Count from edges
    for (const edge of state.edges) {
      const tags = getEdgeTags(edge);
      for (const tag of tags) {
        edgeTags.set(tag, (edgeTags.get(tag) || 0) + 1);
        allTags.add(tag);
      }
    }
    // Count from groups
    for (const group of state.groups) {
      const tags = getGroupTags(group);
      for (const tag of tags) {
        groupTags.set(tag, (groupTags.get(tag) || 0) + 1);
        allTags.add(tag);
      }
    }
    // Count from cable systems
    for (const cs of state.cableSystems) {
      const tags = getCableSystemTags(cs);
      for (const tag of tags) {
        cableSystemTags.set(tag, (cableSystemTags.get(tag) || 0) + 1);
        allTags.add(tag);
      }
    }
    return { nodeTags, edgeTags, groupTags, cableSystemTags, allTags };
  }

  // Get all tags for a cable system
  function getCableSystemTags(cs) {
    const tags = new Set();
    tags.add('default');
    if (Array.isArray(cs.filterTags)) {
      cs.filterTags.forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    return tags;
  }

  // Get all tags for a node (from tags array + extraTags)
  function getNodeTags(node) {
    const tags = new Set();
    // Always add 'default' tag
    tags.add('default');
    // Add from tags array
    if (Array.isArray(node.tags)) {
      node.tags.forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    // Add from extraTags (comma-separated)
    if (node.extraTags) {
      node.extraTags.split(',').forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    return tags;
  }

  // Get all tags for an edge (from filterTags array + extraTags)
  function getEdgeTags(edge) {
    const tags = new Set();
    // Always add 'default' tag
    tags.add('default');
    // Add from filterTags array
    if (Array.isArray(edge.filterTags)) {
      edge.filterTags.forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    // Add from extraTags (comma-separated)
    if (edge.extraTags) {
      edge.extraTags.split(',').forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    return tags;
  }

  // Get all tags for a group (from filterTags array + extraTags)
  function getGroupTags(group) {
    const tags = new Set();
    // Always add 'default' tag
    tags.add('default');
    // Add from filterTags array
    if (Array.isArray(group.filterTags)) {
      group.filterTags.forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    // Add from extraTags (comma-separated)
    if (group.extraTags) {
      group.extraTags.split(',').forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    return tags;
  }

  // Check if a node should be visible based on current filter
  function isNodeVisible(node) {
    // ========== CHECK EXCLUSIVE MODES FIRST ==========
    // If Tag Filter is exclusive, ONLY apply tag filter (bypass all other filters)
    if (state.tagFilter.exclusive && state.tagFilter.mode !== 'all') {
      const nodeTags = getNodeTags(node);
      const selectedTags = state.tagFilter.selectedTags;
      if (selectedTags.size === 0) return true;
      
      let hasSelectedTag = false;
      for (const tag of nodeTags) {
        if (selectedTags.has(tag)) {
          hasSelectedTag = true;
          break;
        }
      }
      
      if (state.tagFilter.mode === 'include') {
        // Node is visible if it has a selected tag
        if (hasSelectedTag) return true;
        
        // OR if any connected edge has a selected tag
        const connectedEdges = state.edges.filter(e => e.a === node.id || e.b === node.id);
        for (const edge of connectedEdges) {
          const edgeTags = getEdgeTags(edge);
          for (const tag of edgeTags) {
            if (selectedTags.has(tag)) {
              return true;
            }
          }
        }
        return false;
      }
      if (state.tagFilter.mode === 'exclude') return !hasSelectedTag;
      return true;
    }
    
    // If Cable System Filter is exclusive, ONLY apply cable system filter (bypass container/node/tag filters)
    if (state.cableSystemFilter.exclusive && 
        state.cableSystemFilter.mode === 'selected' && 
        state.cableSystemFilter.selectedSystems.size > 0) {
      const nodeCSIds = node.cableSystemIds || [];
      const isUnmapped = nodeCSIds.length === 0;
      
      if (isUnmapped && state.cableSystemFilter.showUnmapped) {
        return true;
      }
      // Check if node belongs to any selected cable system
      for (const csId of nodeCSIds) {
        if (state.cableSystemFilter.selectedSystems.has(csId)) {
          return true;
        }
      }
      // Also check if any connected edge belongs to a selected cable system
      const connectedEdges = state.edges.filter(e => e.a === node.id || e.b === node.id);
      for (const edge of connectedEdges) {
        const edgeCSId = edge.cableSystemId;
        if (edgeCSId && state.cableSystemFilter.selectedSystems.has(edgeCSId)) {
          return true;
        }
        // Check if edge is unmapped and we're showing unmapped
        if ((edgeCSId === null || edgeCSId === undefined) && state.cableSystemFilter.showUnmapped) {
          return true;
        }
      }
      return false;
    }
    
    // ========== NORMAL FILTER HIERARCHY ==========
    // Check Container Filter first
    if (state.containerFilter.mode === 'selected' && 
        (state.containerFilter.selectedBoxes.size > 0 || state.containerFilter.selectedGroups.size > 0)) {
      
      let passesContainerFilter = false;
      
      // Check if node is in a selected box
      if (node.groupId && state.containerFilter.selectedBoxes.has(node.groupId)) {
        passesContainerFilter = true;
      }
      
      // Check if node is in a box that belongs to a selected group
      if (!passesContainerFilter && node.groupId) {
        const nodeBox = findGroup(node.groupId);
        if (nodeBox && nodeBox.parentId && state.containerFilter.selectedGroups.has(nodeBox.parentId)) {
          passesContainerFilter = true;
        }
      }
      
      if (state.containerFilter.exclusive) {
        return passesContainerFilter;
      }
      if (!passesContainerFilter) return false;
    }
    
    // Check Node Filter
    if (state.nodeFilter.mode === 'selected' && state.nodeFilter.selectedNodes.size > 0) {
      const passesNodeFilter = state.nodeFilter.selectedNodes.has(node.id);
      if (state.nodeFilter.exclusive) {
        return passesNodeFilter;
      }
      if (!passesNodeFilter) return false;
    }
    
    // Check Cable System Filter (non-exclusive mode)
    if (state.cableSystemFilter.mode === 'selected' && state.cableSystemFilter.selectedSystems.size > 0) {
      const nodeCSIds = node.cableSystemIds || [];
      const isUnmapped = nodeCSIds.length === 0;
      
      let passesCSFilter = false;
      if (isUnmapped && state.cableSystemFilter.showUnmapped) {
        passesCSFilter = true;
      } else {
        // Check if node belongs to any selected cable system
        for (const csId of nodeCSIds) {
          if (state.cableSystemFilter.selectedSystems.has(csId)) {
            passesCSFilter = true;
            break;
          }
        }
      }
      
      // Also check if any connected edge belongs to a selected cable system
      if (!passesCSFilter) {
        const connectedEdges = state.edges.filter(e => e.a === node.id || e.b === node.id);
        for (const edge of connectedEdges) {
          const edgeCSId = edge.cableSystemId;
          if (edgeCSId && state.cableSystemFilter.selectedSystems.has(edgeCSId)) {
            passesCSFilter = true;
            break;
          }
          // Check if edge is unmapped and we're showing unmapped
          if ((edgeCSId === null || edgeCSId === undefined) && state.cableSystemFilter.showUnmapped) {
            passesCSFilter = true;
            break;
          }
        }
      }
      
      if (!passesCSFilter) return false;
    }
    
    // Check Tag Filter (non-exclusive mode)
    if (state.tagFilter.mode === 'all') return true;
    
    const nodeTags = getNodeTags(node);
    const selectedTags = state.tagFilter.selectedTags;
    
    if (selectedTags.size === 0) return true; // No tags selected = show all
    
    // Check if node has ANY of the selected tags
    let hasSelectedTag = false;
    for (const tag of nodeTags) {
      if (selectedTags.has(tag)) {
        hasSelectedTag = true;
        break;
      }
    }
    
    if (state.tagFilter.mode === 'include') {
      // Node is visible if it has a selected tag
      if (hasSelectedTag) return true;
      
      // OR if any connected edge has a selected tag (so edges with tags can be shown)
      const connectedEdges = state.edges.filter(e => e.a === node.id || e.b === node.id);
      for (const edge of connectedEdges) {
        const edgeTags = getEdgeTags(edge);
        for (const tag of edgeTags) {
          if (selectedTags.has(tag)) {
            return true;
          }
        }
      }
      return false;
    } else if (state.tagFilter.mode === 'exclude') {
      return !hasSelectedTag;
    }
    
    return true;
  }

  // Check if an edge should be visible
  // Hierarchy: Check container filter, node filter, cable system filter, then tag filter
  function isEdgeVisible(edge) {
    const nodeA = findNode(edge.a);
    const nodeB = findNode(edge.b);
    if (!nodeA || !nodeB) return false;
    
    // ========== CHECK EXCLUSIVE MODES FIRST ==========
    // If Tag Filter is exclusive, ONLY apply tag filter (bypass all other filters except node visibility)
    if (state.tagFilter.exclusive && state.tagFilter.mode !== 'all') {
      // Still need both nodes to be visible (using tag filter logic)
      if (!isNodeVisible(nodeA) || !isNodeVisible(nodeB)) return false;
      
      const edgeTags = getEdgeTags(edge);
      const selectedTags = state.tagFilter.selectedTags;
      if (selectedTags.size === 0) return true;
      
      let hasSelectedTag = false;
      for (const tag of edgeTags) {
        if (selectedTags.has(tag)) {
          hasSelectedTag = true;
          break;
        }
      }
      
      if (state.tagFilter.mode === 'include') return hasSelectedTag;
      if (state.tagFilter.mode === 'exclude') return !hasSelectedTag;
      return true;
    }
    
    // If Cable System Filter is exclusive, ONLY apply cable system filter
    if (state.cableSystemFilter.exclusive && 
        state.cableSystemFilter.mode === 'selected' && 
        state.cableSystemFilter.selectedSystems.size > 0) {
      const edgeCSId = edge.cableSystemId;
      const isUnmapped = edgeCSId === null || edgeCSId === undefined;
      
      if (isUnmapped && state.cableSystemFilter.showUnmapped) {
        return true;
      }
      if (edgeCSId && state.cableSystemFilter.selectedSystems.has(edgeCSId)) {
        return true;
      }
      return false;
    }
    
    // ========== NORMAL FILTER HIERARCHY ==========
    // Check Container Filter (both nodes must be in selected containers)
    if (state.containerFilter.mode === 'selected' && 
        (state.containerFilter.selectedBoxes.size > 0 || state.containerFilter.selectedGroups.size > 0)) {
      
      // Helper to check if a node is in a selected container
      const nodeInSelectedContainer = (node) => {
        // Check if node is in a selected box
        if (node.groupId && state.containerFilter.selectedBoxes.has(node.groupId)) {
          return true;
        }
        // Check if node is in a box that belongs to a selected group
        if (node.groupId) {
          const nodeBox = findGroup(node.groupId);
          if (nodeBox && nodeBox.parentId && state.containerFilter.selectedGroups.has(nodeBox.parentId)) {
            return true;
          }
        }
        return false;
      };
      
      const bothNodesInContainer = nodeInSelectedContainer(nodeA) && nodeInSelectedContainer(nodeB);
      
      if (state.containerFilter.exclusive) {
        return bothNodesInContainer;
      }
      if (!bothNodesInContainer) return false;
    }
    
    // Check Node Filter (show edges connecting to selected nodes)
    if (state.nodeFilter.mode === 'selected' && state.nodeFilter.selectedNodes.size > 0) {
      const connectedToSelectedNode = state.nodeFilter.selectedNodes.has(edge.a) || 
                                       state.nodeFilter.selectedNodes.has(edge.b);
      if (state.nodeFilter.exclusive) {
        return connectedToSelectedNode;
      }
      if (!connectedToSelectedNode) return false;
    }
    
    // Check Cable System Filter (non-exclusive mode)
    if (state.cableSystemFilter.mode === 'selected' && state.cableSystemFilter.selectedSystems.size > 0) {
      const edgeCSId = edge.cableSystemId;
      const isUnmapped = edgeCSId === null || edgeCSId === undefined;
      
      let passesCSFilter = false;
      if (isUnmapped && state.cableSystemFilter.showUnmapped) {
        passesCSFilter = true;
      } else if (edgeCSId && state.cableSystemFilter.selectedSystems.has(edgeCSId)) {
        passesCSFilter = true;
      }
      
      if (!passesCSFilter) return false;
    }
    
    // FIRST: Both nodes must be visible (node filtering takes priority)
    if (!isNodeVisible(nodeA) || !isNodeVisible(nodeB)) return false;
    
    // THEN: Apply edge's own tag filter (non-exclusive mode, only if nodes are visible)
    if (state.tagFilter.mode === 'all') return true;
    
    const edgeTags = getEdgeTags(edge);
    const selectedTags = state.tagFilter.selectedTags;
    
    if (selectedTags.size === 0) return true;
    
    let hasSelectedTag = false;
    for (const tag of edgeTags) {
      if (selectedTags.has(tag)) {
        hasSelectedTag = true;
        break;
      }
    }
    
    if (state.tagFilter.mode === 'include') {
      return hasSelectedTag;
    } else if (state.tagFilter.mode === 'exclude') {
      return !hasSelectedTag;
    }
    
    return true;
  }

  // Check if a group contains any visible nodes
  function groupHasVisibleNodes(group) {
    return state.nodes.some(n => n.groupId === group.id && isNodeVisible(n));
  }

  // Check if a group should be visible based on current filter
  // Hierarchy: First check if group contains visible nodes, then apply group's own tag filter
  function isGroupVisible(group) {
    // Always show empty containers (so users can see and work with them)
    // Only apply filtering to containers that have content
    
    if (group.type === 'region') {
      // Region: check if it has any country boxes (visible or not)
      const hasAnyCountry = state.groups.some(g => 
        g.type === 'country' && g.parentId === group.id
      );
      // If region has no children, always show it (empty region)
      // If region has children, check if any are visible
      if (hasAnyCountry) {
        const hasVisibleCountry = state.groups.some(g => 
          g.type === 'country' && g.parentId === group.id && isCountryBoxVisible(g)
        );
        if (!hasVisibleCountry) return false;
      }
    } else {
      // Country box: check if it has any nodes
      const hasAnyNodes = state.nodes.some(n => n.groupId === group.id);
      // If container has no nodes, always show it (empty container)
      // If container has nodes, check if any are visible
      if (hasAnyNodes && !groupHasVisibleNodes(group)) return false;
    }
    
    // THEN: Apply group's own tag filter (only if it has visible content)
    if (state.tagFilter.mode === 'all') return true;
    
    const groupTags = getGroupTags(group);
    const selectedTags = state.tagFilter.selectedTags;
    
    if (selectedTags.size === 0) return true;
    
    let hasSelectedTag = false;
    for (const tag of groupTags) {
      if (selectedTags.has(tag)) {
        hasSelectedTag = true;
        break;
      }
    }
    
    if (state.tagFilter.mode === 'include') {
      return hasSelectedTag;
    } else if (state.tagFilter.mode === 'exclude') {
      return !hasSelectedTag;
    }
    
    return true;
  }

  // Helper for country boxes specifically (checks if it has visible nodes)
  function isCountryBoxVisible(group) {
    if (group.type !== 'country') return isGroupVisible(group);
    
    // Check if it has any nodes
    const hasAnyNodes = state.nodes.some(n => n.groupId === group.id);
    // If container has no nodes, always show it (empty container)
    // If container has nodes, check if any are visible
    if (hasAnyNodes && !groupHasVisibleNodes(group)) return false;
    
    // Then apply tag filter
    if (state.tagFilter.mode === 'all') return true;
    
    const groupTags = getGroupTags(group);
    const selectedTags = state.tagFilter.selectedTags;
    
    if (selectedTags.size === 0) return true;
    
    let hasSelectedTag = false;
    for (const tag of groupTags) {
      if (selectedTags.has(tag)) {
        hasSelectedTag = true;
        break;
      }
    }
    
    if (state.tagFilter.mode === 'include') {
      return hasSelectedTag;
    } else if (state.tagFilter.mode === 'exclude') {
      return !hasSelectedTag;
    }
    
    return true;
  }

  // Update the tag filter list UI
  function updateTagFilterList() {
    if (!tagFilterList) return;
    
    const { nodeTags, edgeTags, groupTags, cableSystemTags, allTags } = collectAllTags();
    tagFilterList.innerHTML = '';
    
    // Helper function to sort tags (default first, then alphabetically)
    const sortTags = (tagsMap) => {
      return Array.from(tagsMap.keys()).sort((a, b) => {
        if (a === 'default') return -1;
        if (b === 'default') return 1;
        return a.localeCompare(b);
      });
    };
    
    // Helper function to create a tag item
    const createTagItem = (tag, count) => {
      const label = document.createElement('label');
      label.className = 'tag-filter-item';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = state.tagFilter.selectedTags.has(tag);
      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          state.tagFilter.selectedTags.add(tag);
        } else {
          state.tagFilter.selectedTags.delete(tag);
        }
        updateFilterButtonState();
        render();
      });
      
      const nameSpan = document.createElement('span');
      nameSpan.className = 'tag-name';
      nameSpan.textContent = tag;
      
      const countSpan = document.createElement('span');
      countSpan.className = 'tag-count';
      countSpan.textContent = count;
      
      label.appendChild(checkbox);
      label.appendChild(nameSpan);
      label.appendChild(countSpan);
      return label;
    };
    
    // Helper function to create section header
    const createSectionHeader = (title, icon) => {
      const header = document.createElement('div');
      header.style.cssText = 'padding:6px 12px; font-size:11px; font-weight:600; color:#666; background:#f5f5f5; border-top:1px solid #e0e0e0; border-bottom:1px solid #e0e0e0;';
      header.textContent = `${icon} ${title}`;
      return header;
    };
    
    // Node Tags Section
    if (nodeTags.size > 0) {
      tagFilterList.appendChild(createSectionHeader('Node Tags', '‚óã'));
      const sortedNodeTags = sortTags(nodeTags);
      for (const tag of sortedNodeTags) {
        tagFilterList.appendChild(createTagItem(tag, nodeTags.get(tag)));
      }
    }
    
    // Link Tags Section
    if (edgeTags.size > 0) {
      tagFilterList.appendChild(createSectionHeader('Link Tags', '‚Üó'));
      const sortedEdgeTags = sortTags(edgeTags);
      for (const tag of sortedEdgeTags) {
        tagFilterList.appendChild(createTagItem(tag, edgeTags.get(tag)));
      }
    }
    
    // Box Tags Section
    if (groupTags.size > 0) {
      tagFilterList.appendChild(createSectionHeader('Container Box Tags', '‚ñ¢'));
      const sortedGroupTags = sortTags(groupTags);
      for (const tag of sortedGroupTags) {
        tagFilterList.appendChild(createTagItem(tag, groupTags.get(tag)));
      }
    }
    
    // Cable System Tags Section
    if (cableSystemTags.size > 0) {
      tagFilterList.appendChild(createSectionHeader('Cable System Tags', '‚ö°'));
      const sortedCSTags = sortTags(cableSystemTags);
      for (const tag of sortedCSTags) {
        tagFilterList.appendChild(createTagItem(tag, cableSystemTags.get(tag)));
      }
    }
  }

  // Update filter button state (highlight if filtering)
  function updateFilterButtonState() {
    if (!btnTagFilter) return;
    const isFiltering = state.tagFilter.mode !== 'all' && state.tagFilter.selectedTags.size > 0;
    btnTagFilter.classList.toggle('filtering', isFiltering);
  }

  // Tag filter menu handling
  if (btnTagFilter && tagFilterMenu) {
    btnTagFilter.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateTagFilterList();
      tagFilterMenu.hidden = !tagFilterMenu.hidden;
    });

    // Filter mode radio buttons
    tagFilterMenu.querySelectorAll('input[name="filterMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        state.tagFilter.mode = radio.value;
        updateFilterButtonState();
        render();
      });
    });

    // Exclusive checkbox
    const tagFilterExclusive = document.getElementById('tagFilterExclusive');
    if (tagFilterExclusive) {
      tagFilterExclusive.addEventListener('change', () => {
        state.tagFilter.exclusive = tagFilterExclusive.checked;
        render();
      });
    }

    // Select All button
    if (btnTagSelectAll) {
      btnTagSelectAll.addEventListener('click', () => {
        const tagCounts = collectAllTags();
        state.tagFilter.selectedTags = new Set(tagCounts.keys());
        updateTagFilterList();
        updateFilterButtonState();
        render();
      });
    }

    // Clear All button
    if (btnTagClearAll) {
      btnTagClearAll.addEventListener('click', () => {
        state.tagFilter.selectedTags.clear();
        updateTagFilterList();
        updateFilterButtonState();
        render();
      });
    }

    // Close menu when clicking outside
    document.addEventListener('click', () => {
      tagFilterMenu.hidden = true;
    });
    
    tagFilterMenu.addEventListener('click', (ev) => {
      ev.stopPropagation();
    });
  }

  // View menu - Tag Filter option
  if (miTagFilter) {
    miTagFilter.addEventListener('click', (ev) => {
      ev.stopPropagation();
      // Close other menus but not tagFilterMenu
      fileMenu.hidden = true;
      if (editMenu) editMenu.hidden = true;
      if (viewMenu) viewMenu.hidden = true;
      const zoomMenu = document.getElementById('zoomMenu');
      if (zoomMenu) zoomMenu.hidden = true;
      const gridMenu = document.getElementById('gridMenu');
      if (gridMenu) gridMenu.hidden = true;
      
      // Get elements directly to ensure they're found
      const tagFilterBtn = document.getElementById('btnTagFilter');
      const tagFilterPanel = document.getElementById('tagFilterMenu');
      
      if (tagFilterBtn && tagFilterPanel) {
        updateTagFilterList();
        tagFilterPanel.hidden = false;
        // Position near the button
        const rect = tagFilterBtn.getBoundingClientRect();
        tagFilterPanel.style.position = 'fixed';
        tagFilterPanel.style.left = rect.left + 'px';
        tagFilterPanel.style.top = rect.bottom + 'px';
      }
    });
  }

  // Keyboard shortcut for tag filter (F key)
  window.addEventListener('keydown', (ev) => {
    if (ev.key === 'f' || ev.key === 'F') {
      if (ev.target.tagName === 'INPUT' || ev.target.tagName === 'TEXTAREA') return;
      ev.preventDefault();
      if (btnTagFilter && tagFilterMenu) {
        closeAllMenus();
        updateTagFilterList();
        tagFilterMenu.hidden = !tagFilterMenu.hidden;
      }
    }
  });

  // Add tagFilterMenu to closeAllMenus
  const originalCloseAllMenus = closeAllMenus;
  closeAllMenus = function() {
    originalCloseAllMenus();
    if (tagFilterMenu) tagFilterMenu.hidden = true;
    const nodeFilterMenu = document.getElementById('nodeFilterMenu');
    const cableSystemFilterMenu = document.getElementById('cableSystemFilterMenu');
    const containerFilterMenu = document.getElementById('containerFilterMenu');
    const fillColorMenu = document.getElementById('fillColorMenu');
    const strokeColorMenu = document.getElementById('strokeColorMenu');
    const linkStyleMenu = document.getElementById('linkStyleMenu');
    const lineWidthMenu = document.getElementById('lineWidthMenu');
    const fontColorMenu = document.getElementById('fontColorMenu');
    const fontTypeMenu = document.getElementById('fontTypeMenu');
    const applyStyleMenu = document.getElementById('applyStyleMenu');
    const helpMenu = document.getElementById('helpMenu');
    if (nodeFilterMenu) nodeFilterMenu.hidden = true;
    if (cableSystemFilterMenu) cableSystemFilterMenu.hidden = true;
    if (containerFilterMenu) containerFilterMenu.hidden = true;
    if (fillColorMenu) fillColorMenu.hidden = true;
    if (strokeColorMenu) strokeColorMenu.hidden = true;
    if (linkStyleMenu) linkStyleMenu.hidden = true;
    if (lineWidthMenu) lineWidthMenu.hidden = true;
    if (fontColorMenu) fontColorMenu.hidden = true;
    if (fontTypeMenu) fontTypeMenu.hidden = true;
    if (applyStyleMenu) applyStyleMenu.hidden = true;
    if (helpMenu) helpMenu.hidden = true;
  };

  // ============== NODE FILTER ==============
  const btnNodeFilter = document.getElementById('btnNodeFilter');
  const nodeFilterMenu = document.getElementById('nodeFilterMenu');
  const nodeFilterList = document.getElementById('nodeFilterList');
  const nodeFilterSearch = document.getElementById('nodeFilterSearch');
  const btnNodeSelectAll = document.getElementById('btnNodeSelectAll');
  const btnNodeClearAll = document.getElementById('btnNodeClearAll');

  function updateNodeFilterList() {
    if (!nodeFilterList) return;
    
    const searchTerm = (nodeFilterSearch?.value || '').toLowerCase();
    const displayMode = state.nodeFilter.displayMode || 'name';
    
    nodeFilterList.innerHTML = '';
    
    // Sort nodes by display value
    const sortedNodes = [...state.nodes].sort((a, b) => {
      const aVal = displayMode === 'name' ? (a.name || '') : (a.code || '');
      const bVal = displayMode === 'name' ? (b.name || '') : (b.code || '');
      return aVal.localeCompare(bVal);
    });
    
    // Filter by search
    const filteredNodes = sortedNodes.filter(n => {
      if (!searchTerm) return true;
      const name = (n.name || '').toLowerCase();
      const code = (n.code || '').toLowerCase();
      return name.includes(searchTerm) || code.includes(searchTerm);
    });
    
    if (filteredNodes.length === 0) {
      nodeFilterList.innerHTML = '<div class="muted" style="padding:8px 12px;">No nodes found.</div>';
      return;
    }
    
    filteredNodes.forEach(n => {
      const label = document.createElement('label');
      label.className = 'tag-filter-item';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = state.nodeFilter.selectedNodes.has(n.id);
      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          state.nodeFilter.selectedNodes.add(n.id);
        } else {
          state.nodeFilter.selectedNodes.delete(n.id);
        }
        updateNodeFilterButtonState();
        render();
      });
      
      const nameSpan = document.createElement('span');
      nameSpan.className = 'tag-name';
      const displayVal = displayMode === 'name' ? (n.name || `Node${n.id}`) : (n.code || `N-${n.id}`);
      const secondary = displayMode === 'name' ? (n.code || '') : (n.name || '');
      nameSpan.innerHTML = `${displayVal} <span style="color:#999; font-size:10px;">${secondary}</span>`;
      
      // Count connected links
      const linkCount = state.edges.filter(e => e.a === n.id || e.b === n.id).length;
      const countSpan = document.createElement('span');
      countSpan.className = 'tag-count';
      countSpan.textContent = `${linkCount}L`;
      countSpan.title = `${linkCount} connected links`;
      
      label.appendChild(checkbox);
      label.appendChild(nameSpan);
      label.appendChild(countSpan);
      nodeFilterList.appendChild(label);
    });
  }

  function updateNodeFilterButtonState() {
    if (!btnNodeFilter) return;
    const isFiltering = state.nodeFilter.mode !== 'all' && state.nodeFilter.selectedNodes.size > 0;
    btnNodeFilter.classList.toggle('filtering', isFiltering);
  }

  if (btnNodeFilter && nodeFilterMenu) {
    btnNodeFilter.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateNodeFilterList();
      nodeFilterMenu.hidden = !nodeFilterMenu.hidden;
    });

    // Filter mode radio buttons
    nodeFilterMenu.querySelectorAll('input[name="nodeFilterMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        state.nodeFilter.mode = radio.value;
        updateNodeFilterButtonState();
        render();
      });
    });

    // Display mode radio buttons
    nodeFilterMenu.querySelectorAll('input[name="nodeDisplayMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        state.nodeFilter.displayMode = radio.value;
        updateNodeFilterList();
      });
    });

    // Exclusive checkbox
    const nodeFilterExclusive = document.getElementById('nodeFilterExclusive');
    if (nodeFilterExclusive) {
      nodeFilterExclusive.addEventListener('change', () => {
        state.nodeFilter.exclusive = nodeFilterExclusive.checked;
        render();
      });
    }

    // Select All button
    if (btnNodeSelectAll) {
      btnNodeSelectAll.addEventListener('click', () => {
        state.nodes.forEach(n => state.nodeFilter.selectedNodes.add(n.id));
        updateNodeFilterList();
        updateNodeFilterButtonState();
        render();
      });
    }

    // Clear All button
    if (btnNodeClearAll) {
      btnNodeClearAll.addEventListener('click', () => {
        state.nodeFilter.selectedNodes.clear();
        updateNodeFilterList();
        updateNodeFilterButtonState();
        render();
      });
    }

    // Search input
    if (nodeFilterSearch) {
      nodeFilterSearch.addEventListener('input', () => {
        updateNodeFilterList();
      });
    }

    // Close menu when clicking outside
    document.addEventListener('click', () => {
      nodeFilterMenu.hidden = true;
    });
    
    nodeFilterMenu.addEventListener('click', (ev) => {
      ev.stopPropagation();
    });
  }

  // ============== CABLE SYSTEM FILTER ==============
  const btnCableSystemFilter = document.getElementById('btnCableSystemFilter');
  const cableSystemFilterMenu = document.getElementById('cableSystemFilterMenu');
  const cableSystemFilterList = document.getElementById('cableSystemFilterList');
  const cableSystemFilterSearch = document.getElementById('cableSystemFilterSearch');
  const btnCableSelectAll = document.getElementById('btnCableSelectAll');
  const btnCableClearAll = document.getElementById('btnCableClearAll');

  function updateCableSystemFilterList() {
    if (!cableSystemFilterList) return;
    
    const searchTerm = (cableSystemFilterSearch?.value || '').toLowerCase();
    
    cableSystemFilterList.innerHTML = '';
    
    const filtered = state.cableSystems.filter(cs => {
      if (!searchTerm) return true;
      return cs.shortName.toLowerCase().includes(searchTerm) ||
             cs.name.toLowerCase().includes(searchTerm);
    });
    
    if (filtered.length === 0) {
      cableSystemFilterList.innerHTML = '<div class="muted" style="padding:8px 12px;">No cable systems found.</div>';
      return;
    }
    
    filtered.forEach(cs => {
      const label = document.createElement('label');
      label.className = 'tag-filter-item';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = state.cableSystemFilter.selectedSystems.has(cs.id);
      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          state.cableSystemFilter.selectedSystems.add(cs.id);
        } else {
          state.cableSystemFilter.selectedSystems.delete(cs.id);
        }
        updateCableSystemFilterButtonState();
        render();
      });
      
      const nameSpan = document.createElement('span');
      nameSpan.className = 'tag-name';
      nameSpan.innerHTML = `<strong>${cs.shortName}</strong> <span style="color:#999; font-size:10px;">${cs.name}</span>`;
      
      const linkCount = getCableSystemLinks(cs.id).length;
      const countSpan = document.createElement('span');
      countSpan.className = 'tag-count';
      countSpan.textContent = `${linkCount}L`;
      
      label.appendChild(checkbox);
      label.appendChild(nameSpan);
      label.appendChild(countSpan);
      cableSystemFilterList.appendChild(label);
    });
  }

  function updateCableSystemFilterButtonState() {
    if (!btnCableSystemFilter) return;
    const isFiltering = state.cableSystemFilter.mode !== 'all' && state.cableSystemFilter.selectedSystems.size > 0;
    btnCableSystemFilter.classList.toggle('filtering', isFiltering);
  }

  if (btnCableSystemFilter && cableSystemFilterMenu) {
    btnCableSystemFilter.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateCableSystemFilterList();
      cableSystemFilterMenu.hidden = !cableSystemFilterMenu.hidden;
    });

    // Filter mode radio buttons
    cableSystemFilterMenu.querySelectorAll('input[name="cableFilterMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        state.cableSystemFilter.mode = radio.value;
        updateCableSystemFilterButtonState();
        render();
      });
    });

    // Unmapped checkbox
    const cableFilterShowUnmapped = document.getElementById('cableFilterShowUnmapped');
    if (cableFilterShowUnmapped) {
      cableFilterShowUnmapped.addEventListener('change', () => {
        state.cableSystemFilter.showUnmapped = cableFilterShowUnmapped.checked;
        render();
      });
    }

    // Exclusive checkbox
    const cableFilterExclusive = document.getElementById('cableFilterExclusive');
    if (cableFilterExclusive) {
      cableFilterExclusive.addEventListener('change', () => {
        state.cableSystemFilter.exclusive = cableFilterExclusive.checked;
        render();
      });
    }

    // Select All button
    if (btnCableSelectAll) {
      btnCableSelectAll.addEventListener('click', () => {
        state.cableSystems.forEach(cs => state.cableSystemFilter.selectedSystems.add(cs.id));
        updateCableSystemFilterList();
        updateCableSystemFilterButtonState();
        render();
      });
    }

    // Clear All button
    if (btnCableClearAll) {
      btnCableClearAll.addEventListener('click', () => {
        state.cableSystemFilter.selectedSystems.clear();
        updateCableSystemFilterList();
        updateCableSystemFilterButtonState();
        render();
      });
    }

    // Search input
    if (cableSystemFilterSearch) {
      cableSystemFilterSearch.addEventListener('input', () => {
        updateCableSystemFilterList();
      });
    }

    // Close menu when clicking outside
    document.addEventListener('click', () => {
      cableSystemFilterMenu.hidden = true;
    });
    
    cableSystemFilterMenu.addEventListener('click', (ev) => {
      ev.stopPropagation();
    });
  }

  // ============== CONTAINER FILTER ==============
  const btnContainerFilter = document.getElementById('btnContainerFilter');
  const containerFilterMenu = document.getElementById('containerFilterMenu');
  const containerFilterListBoxes = document.getElementById('containerFilterListBoxes');
  const containerFilterListGroups = document.getElementById('containerFilterListGroups');
  const containerFilterSearch = document.getElementById('containerFilterSearch');
  const btnContainerSelectAll = document.getElementById('btnContainerSelectAll');
  const btnContainerClearAll = document.getElementById('btnContainerClearAll');

  function updateContainerFilterList() {
    if (!containerFilterListBoxes || !containerFilterListGroups) return;
    
    const searchTerm = (containerFilterSearch?.value || '').toLowerCase();
    
    // Separate boxes (country) and groups (region)
    const boxes = state.groups.filter(g => g.type === 'country' || !g.type);
    const groups = state.groups.filter(g => g.type === 'region');
    
    // Filter by search
    const filteredBoxes = boxes.filter(g => {
      if (!searchTerm) return true;
      return (g.title || '').toLowerCase().includes(searchTerm);
    });
    
    const filteredGroups = groups.filter(g => {
      if (!searchTerm) return true;
      return (g.title || '').toLowerCase().includes(searchTerm);
    });
    
    // Render boxes
    if (filteredBoxes.length === 0) {
      containerFilterListBoxes.innerHTML = '<div class="muted" style="padding:8px 12px; font-size:11px;">No container boxes found.</div>';
    } else {
      containerFilterListBoxes.innerHTML = '';
      filteredBoxes.forEach(g => {
        const label = document.createElement('label');
        label.className = 'tag-filter-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = state.containerFilter.selectedBoxes.has(g.id);
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            state.containerFilter.selectedBoxes.add(g.id);
          } else {
            state.containerFilter.selectedBoxes.delete(g.id);
          }
          updateContainerFilterButtonState();
          render();
        });
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'tag-name';
        nameSpan.textContent = g.title || `Container ${g.id}`;
        
        // Count nodes in this box
        const nodeCount = state.nodes.filter(n => n.groupId === g.id).length;
        const countSpan = document.createElement('span');
        countSpan.className = 'tag-count';
        countSpan.textContent = `${nodeCount}N`;
        countSpan.title = `${nodeCount} nodes`;
        
        label.appendChild(checkbox);
        label.appendChild(nameSpan);
        label.appendChild(countSpan);
        containerFilterListBoxes.appendChild(label);
      });
    }
    
    // Render groups
    if (filteredGroups.length === 0) {
      containerFilterListGroups.innerHTML = '<div class="muted" style="padding:8px 12px; font-size:11px;">No groups found.</div>';
    } else {
      containerFilterListGroups.innerHTML = '';
      filteredGroups.forEach(g => {
        const label = document.createElement('label');
        label.className = 'tag-filter-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = state.containerFilter.selectedGroups.has(g.id);
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            state.containerFilter.selectedGroups.add(g.id);
          } else {
            state.containerFilter.selectedGroups.delete(g.id);
          }
          updateContainerFilterButtonState();
          render();
        });
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'tag-name';
        nameSpan.textContent = g.title || `Group ${g.id}`;
        
        // Count child boxes in this group
        const boxCount = state.groups.filter(b => b.parentId === g.id).length;
        const countSpan = document.createElement('span');
        countSpan.className = 'tag-count';
        countSpan.textContent = `${boxCount}B`;
        countSpan.title = `${boxCount} container boxes`;
        
        label.appendChild(checkbox);
        label.appendChild(nameSpan);
        label.appendChild(countSpan);
        containerFilterListGroups.appendChild(label);
      });
    }
  }

  function updateContainerFilterButtonState() {
    if (!btnContainerFilter) return;
    const isFiltering = state.containerFilter.mode !== 'all' && 
      (state.containerFilter.selectedBoxes.size > 0 || state.containerFilter.selectedGroups.size > 0);
    btnContainerFilter.classList.toggle('filtering', isFiltering);
  }

  if (btnContainerFilter && containerFilterMenu) {
    btnContainerFilter.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateContainerFilterList();
      containerFilterMenu.hidden = !containerFilterMenu.hidden;
    });

    // Filter mode radio buttons
    containerFilterMenu.querySelectorAll('input[name="containerFilterMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        state.containerFilter.mode = radio.value;
        updateContainerFilterButtonState();
        render();
      });
    });

    // Exclusive checkbox
    const containerFilterExclusive = document.getElementById('containerFilterExclusive');
    if (containerFilterExclusive) {
      containerFilterExclusive.addEventListener('change', () => {
        state.containerFilter.exclusive = containerFilterExclusive.checked;
        render();
      });
    }

    // Select All button
    if (btnContainerSelectAll) {
      btnContainerSelectAll.addEventListener('click', () => {
        state.groups.forEach(g => {
          if (g.type === 'region') {
            state.containerFilter.selectedGroups.add(g.id);
          } else {
            state.containerFilter.selectedBoxes.add(g.id);
          }
        });
        updateContainerFilterList();
        updateContainerFilterButtonState();
        render();
      });
    }

    // Clear All button
    if (btnContainerClearAll) {
      btnContainerClearAll.addEventListener('click', () => {
        state.containerFilter.selectedBoxes.clear();
        state.containerFilter.selectedGroups.clear();
        updateContainerFilterList();
        updateContainerFilterButtonState();
        render();
      });
    }

    // Search input
    if (containerFilterSearch) {
      containerFilterSearch.addEventListener('input', () => {
        updateContainerFilterList();
      });
    }

    // Close menu when clicking outside
    document.addEventListener('click', () => {
      containerFilterMenu.hidden = true;
    });
    
    containerFilterMenu.addEventListener('click', (ev) => {
      ev.stopPropagation();
    });
  }

  // ============== QUICK FORMAT TOOLBAR ==============
  
  // Standard color palette (Draw.io style) for toolbar
  const toolbarColorPalette = [
    // Row 1 - Basic
    '#ffffff', '#f5f5f5', '#e0e0e0', '#bdbdbd', '#9e9e9e', '#757575', '#424242', '#000000',
    // Row 2 - Blues
    '#e3f2fd', '#90caf9', '#42a5f5', '#1e88e5', '#1565c0', '#0d47a1', '#002171', '#000051',
    // Row 3 - Greens
    '#e8f5e9', '#a5d6a7', '#66bb6a', '#43a047', '#2e7d32', '#1b5e20', '#003300', '#001a00',
    // Row 4 - Oranges/Yellows
    '#fff3e0', '#ffcc80', '#ffa726', '#fb8c00', '#ef6c00', '#e65100', '#bf360c', '#8c2703',
    // Row 5 - Reds/Pinks
    '#ffebee', '#ef9a9a', '#ef5350', '#e53935', '#c62828', '#b71c1c', '#7f0000', '#4a0000',
    // Row 6 - Purples
    '#f3e5f5', '#ce93d8', '#ab47bc', '#8e24aa', '#6a1b9a', '#4a148c', '#2a0050', '#12002a',
    // Row 7 - Cyans
    '#e0f7fa', '#80deea', '#26c6da', '#00acc1', '#00838f', '#006064', '#003d40', '#002020',
    // Row 8 - Draw.io defaults
    '#dae8fc', '#d5e8d4', '#ffe6cc', '#fff2cc', '#f8cecc', '#e1d5e7', '#60a917', '#6c8ebf'
  ];
  
  // Initialize color grids
  function initColorGrid(gridId, onColorSelect) {
    const grid = document.getElementById(gridId);
    if (!grid) return;
    grid.innerHTML = '';
    toolbarColorPalette.forEach(color => {
      const item = document.createElement('div');
      item.className = 'color-grid-item';
      item.style.backgroundColor = color;
      item.dataset.color = color;
      item.addEventListener('click', () => onColorSelect(color));
      grid.appendChild(item);
    });
  }
  
  // Fill Color Button
  const btnFillColor = document.getElementById('btnFillColor');
  const fillColorMenu = document.getElementById('fillColorMenu');
  const fillColorIndicator = document.getElementById('fillColorIndicator');
  const fillColorCustom = document.getElementById('fillColorCustom');
  
  if (btnFillColor && fillColorMenu) {
    initColorGrid('fillColorGrid', (color) => {
      applyFillColor(color);
      fillColorMenu.hidden = true;
    });
    
    btnFillColor.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      fillColorMenu.hidden = !fillColorMenu.hidden;
    });
    
    if (fillColorCustom) {
      fillColorCustom.addEventListener('input', (ev) => {
        applyFillColor(ev.target.value);
      });
      fillColorCustom.addEventListener('change', () => {
        fillColorMenu.hidden = true;
      });
    }
    
    fillColorMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }
  
  function applyFillColor(color) {
    if (fillColorIndicator) fillColorIndicator.style.backgroundColor = color;
    
    // Apply to selected elements
    if (state.selected) {
      if (state.selected.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) { n.fill = color; commit(); render(); }
      } else if (state.selected.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) { g.fill = color; commit(); render(); }
      }
    }
    
    // Apply to multi-selection
    if (state.selection.nodes.size > 0) {
      state.selection.nodes.forEach(id => {
        const n = findNode(id);
        if (n) n.fill = color;
      });
      commit(); render();
    }
    if (state.selection.groups.size > 0) {
      state.selection.groups.forEach(id => {
        const g = findGroup(id);
        if (g) g.fill = color;
      });
      commit(); render();
    }
  }
  
  // Stroke Color Button
  const btnStrokeColor = document.getElementById('btnStrokeColor');
  const strokeColorMenu = document.getElementById('strokeColorMenu');
  const strokeColorIndicator = document.getElementById('strokeColorIndicator');
  const strokeColorCustom = document.getElementById('strokeColorCustom');
  
  if (btnStrokeColor && strokeColorMenu) {
    initColorGrid('strokeColorGrid', (color) => {
      applyStrokeColor(color);
      strokeColorMenu.hidden = true;
    });
    
    btnStrokeColor.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      strokeColorMenu.hidden = !strokeColorMenu.hidden;
    });
    
    if (strokeColorCustom) {
      strokeColorCustom.addEventListener('input', (ev) => {
        applyStrokeColor(ev.target.value);
      });
      strokeColorCustom.addEventListener('change', () => {
        strokeColorMenu.hidden = true;
      });
    }
    
    strokeColorMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }
  
  function applyStrokeColor(color) {
    if (strokeColorIndicator) strokeColorIndicator.style.backgroundColor = color;
    
    // Apply to selected elements
    if (state.selected) {
      if (state.selected.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) { n.stroke = color; commit(); render(); }
      } else if (state.selected.type === 'edge') {
        const e = findEdge(state.selected.id);
        if (e) { e.strokeColor = color; commit(); render(); }
      } else if (state.selected.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) { g.stroke = color; commit(); render(); }
      }
    }
    
    // Apply to multi-selection
    if (state.selection.nodes.size > 0) {
      state.selection.nodes.forEach(id => {
        const n = findNode(id);
        if (n) n.stroke = color;
      });
      commit(); render();
    }
    if (state.selection.edges.size > 0) {
      state.selection.edges.forEach(id => {
        const e = findEdge(id);
        if (e) e.strokeColor = color;
      });
      commit(); render();
    }
    if (state.selection.groups.size > 0) {
      state.selection.groups.forEach(id => {
        const g = findGroup(id);
        if (g) g.stroke = color;
      });
      commit(); render();
    }
  }
  
  // ============== INSPECTOR PALETTE COLOR PICKERS ==============
  
  // Initialize an inspector color picker
  function initInspectorColorPicker(config) {
    const { pickerId, swatchId, hiddenInputId, customColorId, hexInputId, gridSelector, onChange } = config;
    
    const picker = document.getElementById(pickerId);
    const swatch = document.getElementById(swatchId);
    const hiddenInput = document.getElementById(hiddenInputId);
    const customColor = document.getElementById(customColorId);
    const hexInput = document.getElementById(hexInputId);
    const dropdown = picker?.querySelector('.inspector-color-dropdown');
    const grid = picker?.querySelector(gridSelector || '.inspector-color-grid');
    
    if (!picker || !swatch || !dropdown || !grid) return;
    
    // Build color grid
    grid.innerHTML = '';
    toolbarColorPalette.forEach(color => {
      const item = document.createElement('div');
      item.className = 'inspector-color-grid-item';
      item.style.backgroundColor = color;
      item.dataset.color = color;
      item.addEventListener('click', (ev) => {
        ev.stopPropagation();
        setColor(color);
        dropdown.hidden = true;
      });
      grid.appendChild(item);
    });
    
    // Swatch click - toggle dropdown
    swatch.addEventListener('click', (ev) => {
      ev.stopPropagation();
      // Close other inspector dropdowns
      document.querySelectorAll('.inspector-color-dropdown').forEach(d => {
        if (d !== dropdown) d.hidden = true;
      });
      dropdown.hidden = !dropdown.hidden;
    });
    
    // Custom color input
    if (customColor) {
      customColor.addEventListener('input', (ev) => {
        setColor(ev.target.value);
        if (hexInput) hexInput.value = ev.target.value;
      });
    }
    
    // Hex input
    if (hexInput) {
      hexInput.addEventListener('change', () => {
        let val = hexInput.value.trim();
        if (val && !val.startsWith('#')) val = '#' + val;
        if (/^#[0-9A-Fa-f]{6}$/.test(val)) {
          setColor(val);
          if (customColor) customColor.value = val;
        }
      });
    }
    
    // Dropdown click - prevent close
    dropdown.addEventListener('click', (ev) => ev.stopPropagation());
    
    function setColor(color) {
      swatch.style.backgroundColor = color;
      if (hiddenInput) hiddenInput.value = color;
      if (hexInput) hexInput.value = color;
      if (customColor) customColor.value = color;
      if (onChange) onChange(color);
    }
    
    // Return update function
    return {
      setValue: (color) => {
        swatch.style.backgroundColor = color;
        if (hiddenInput) hiddenInput.value = color;
        if (hexInput) hexInput.value = color;
        if (customColor) customColor.value = color;
      }
    };
  }
  
  // Close inspector dropdowns when clicking outside
  document.addEventListener('click', () => {
    document.querySelectorAll('.inspector-color-dropdown').forEach(d => d.hidden = true);
  });
  
  // Initialize all inspector color pickers
  const inspectorColorPickers = {};
  
  // Node Fill Color
  inspectorColorPickers.nodeFill = initInspectorColorPicker({
    pickerId: 'nodeFillPicker',
    swatchId: 'nodeFillSwatch',
    hiddenInputId: 'nodeFill',
    customColorId: 'nodeFillCustom',
    hexInputId: 'nodeFillHex',
    onChange: (color) => {
      if (state.selected?.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) { n.fill = color; commit(); render(); }
      }
    }
  });
  
  // Node Stroke Color
  inspectorColorPickers.nodeStroke = initInspectorColorPicker({
    pickerId: 'nodeStrokePicker',
    swatchId: 'nodeStrokeSwatch',
    hiddenInputId: 'nodeStroke',
    customColorId: 'nodeStrokeCustom',
    hexInputId: 'nodeStrokeHex',
    onChange: (color) => {
      if (state.selected?.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) { n.stroke = color; commit(); render(); }
      }
    }
  });
  
  // Edge Stroke Color
  inspectorColorPickers.edgeStrokeColor = initInspectorColorPicker({
    pickerId: 'edgeStrokeColorPicker',
    swatchId: 'edgeStrokeColorSwatch',
    hiddenInputId: 'edgeStrokeColor',
    customColorId: 'edgeStrokeColorCustom',
    hexInputId: 'edgeStrokeColorHex',
    onChange: (color) => {
      if (state.selected?.type === 'edge') {
        const e = findEdge(state.selected.id);
        if (e) { e.strokeColor = color; commit(); render(); }
      }
    }
  });
  
  // Group Fill Color
  inspectorColorPickers.groupFillColor = initInspectorColorPicker({
    pickerId: 'groupFillColorPicker',
    swatchId: 'groupFillColorSwatch',
    hiddenInputId: 'groupFillColor',
    customColorId: 'groupFillColorCustom',
    hexInputId: 'groupFillColorHex',
    onChange: (color) => {
      if (state.selected?.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) {
          // Combine with opacity
          const opacity = parseInt(document.getElementById('groupFillOpacity')?.value || 100) / 100;
          g.fill = hexToRgba(color, opacity);
          document.getElementById('groupFill').value = g.fill;
          commit(); render();
        }
      }
    }
  });
  
  // Group Stroke Color
  inspectorColorPickers.groupStroke = initInspectorColorPicker({
    pickerId: 'groupStrokePicker',
    swatchId: 'groupStrokeSwatch',
    hiddenInputId: 'groupStroke',
    customColorId: 'groupStrokeCustom',
    hexInputId: 'groupStrokeHex',
    onChange: (color) => {
      if (state.selected?.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) { g.stroke = color; commit(); render(); }
      }
    }
  });
  
  // Convert the inline field-color-swatch elements to palette pickers
  function initInlineColorSwatch(swatchContainerId, colorInputId, onChange) {
    const container = document.getElementById(swatchContainerId);
    const colorInput = document.getElementById(colorInputId);
    
    if (!container || !colorInput) return;
    
    // Create dropdown
    const dropdown = document.createElement('div');
    dropdown.className = 'inspector-color-dropdown';
    dropdown.hidden = true;
    dropdown.style.cssText = 'top: 24px; left: -80px;';
    
    // Build grid
    const grid = document.createElement('div');
    grid.className = 'inspector-color-grid';
    toolbarColorPalette.forEach(color => {
      const item = document.createElement('div');
      item.className = 'inspector-color-grid-item';
      item.style.backgroundColor = color;
      item.addEventListener('click', (ev) => {
        ev.stopPropagation();
        colorInput.value = color;
        container.style.backgroundColor = color;
        dropdown.hidden = true;
        if (onChange) onChange(color);
      });
      grid.appendChild(item);
    });
    dropdown.appendChild(grid);
    
    // Custom color row
    const customRow = document.createElement('div');
    customRow.className = 'inspector-color-custom';
    customRow.innerHTML = `
      <input type="color" value="${colorInput.value}" />
      <span>Custom</span>
    `;
    const customInput = customRow.querySelector('input');
    customInput.addEventListener('input', (ev) => {
      colorInput.value = ev.target.value;
      container.style.backgroundColor = ev.target.value;
      if (onChange) onChange(ev.target.value);
    });
    dropdown.appendChild(customRow);
    
    // Prevent dropdown close
    dropdown.addEventListener('click', (ev) => ev.stopPropagation());
    
    container.appendChild(dropdown);
    
    // Make the container clickable to toggle dropdown
    container.style.cursor = 'pointer';
    container.style.position = 'relative';
    container.addEventListener('click', (ev) => {
      ev.stopPropagation();
      // Close other dropdowns
      document.querySelectorAll('.inspector-color-dropdown').forEach(d => {
        if (d !== dropdown) d.hidden = true;
      });
      // Sync custom input
      customInput.value = colorInput.value;
      dropdown.hidden = !dropdown.hidden;
    });
    
    // Hide native color input visually but keep for form handling
    colorInput.style.opacity = '0';
    colorInput.style.position = 'absolute';
    colorInput.style.pointerEvents = 'none';
  }
  
  // Initialize inline color swatches
  initInlineColorSwatch('nodeNameColorSwatch', 'nodeNameColorInline', (color) => {
    if (state.selected?.type === 'node') {
      const n = findNode(state.selected.id);
      if (n) { n.nameColor = color; commit(); render(); }
    }
  });
  
  initInlineColorSwatch('nodeCodeColorSwatch', 'nodeCodeColorInline', (color) => {
    if (state.selected?.type === 'node') {
      const n = findNode(state.selected.id);
      if (n) { n.tagColor = color; commit(); render(); }
    }
  });
  
  initInlineColorSwatch('nodeExtraTagsColorSwatch', 'nodeExtraTagsColorInline', (color) => {
    if (state.selected?.type === 'node') {
      const n = findNode(state.selected.id);
      if (n) { n.extraTagsColor = color; commit(); render(); }
    }
  });
  
  initInlineColorSwatch('edgeTagColorSwatch', 'edgeTagColorInline', (color) => {
    if (state.selected?.type === 'edge') {
      const e = findEdge(state.selected.id);
      if (e) { e.labelColor = color; commit(); render(); }
    }
  });
  
  initInlineColorSwatch('groupTitleColorSwatch', 'groupTitleColorInline', (color) => {
    if (state.selected?.type === 'group') {
      const g = findGroup(state.selected.id);
      if (g) { g.titleColor = color; commit(); render(); }
    }
  });
  
  // Link Style Button
  const btnLinkStyle = document.getElementById('btnLinkStyle');
  const linkStyleMenu = document.getElementById('linkStyleMenu');
  
  if (btnLinkStyle && linkStyleMenu) {
    btnLinkStyle.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateLinkStyleMenu();
      linkStyleMenu.hidden = !linkStyleMenu.hidden;
    });
    
    // Link style items
    linkStyleMenu.querySelectorAll('.link-style-item').forEach(item => {
      item.addEventListener('click', () => {
        const style = item.dataset.style;
        applyLinkStyle(style);
        updateLinkStyleMenu();
      });
    });
    
    // Link route items
    linkStyleMenu.querySelectorAll('.link-route-item').forEach(item => {
      item.addEventListener('click', () => {
        const route = item.dataset.route;
        applyLinkRoute(route);
        updateLinkStyleMenu();
      });
    });
    
    linkStyleMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }
  
  function updateLinkStyleMenu() {
    if (!linkStyleMenu) return;
    
    // Get current selected edge style
    let currentStyle = 'straight';
    let currentRoute = 'hv';
    
    if (state.selected?.type === 'edge') {
      const e = findEdge(state.selected.id);
      if (e) {
        currentStyle = e.style || 'straight';
        currentRoute = e.route || 'hv';
      }
    }
    
    // Update active states
    linkStyleMenu.querySelectorAll('.link-style-item').forEach(item => {
      item.classList.toggle('active', item.dataset.style === currentStyle);
    });
    linkStyleMenu.querySelectorAll('.link-route-item').forEach(item => {
      item.classList.toggle('active', item.dataset.route === currentRoute);
    });
  }
  
  function applyLinkStyle(style) {
    // Apply to selected edge
    if (state.selected?.type === 'edge') {
      const e = findEdge(state.selected.id);
      if (e) { e.style = style; commit(); render(); }
    }
    
    // Apply to multi-selection
    if (state.selection.edges.size > 0) {
      state.selection.edges.forEach(id => {
        const e = findEdge(id);
        if (e) e.style = style;
      });
      commit(); render();
    }
  }
  
  function applyLinkRoute(route) {
    // Apply to selected edge
    if (state.selected?.type === 'edge') {
      const e = findEdge(state.selected.id);
      if (e) { e.route = route; commit(); render(); }
    }
    
    // Apply to multi-selection
    if (state.selection.edges.size > 0) {
      state.selection.edges.forEach(id => {
        const e = findEdge(id);
        if (e) e.route = route;
      });
      commit(); render();
    }
  }
  
  // Line Width Button
  const btnLineWidth = document.getElementById('btnLineWidth');
  const lineWidthMenu = document.getElementById('lineWidthMenu');
  
  if (btnLineWidth && lineWidthMenu) {
    btnLineWidth.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateLineWidthMenu();
      lineWidthMenu.hidden = !lineWidthMenu.hidden;
    });
    
    lineWidthMenu.querySelectorAll('.line-width-item').forEach(item => {
      item.addEventListener('click', () => {
        const width = parseInt(item.dataset.width);
        applyLineWidth(width);
        updateLineWidthMenu();
        lineWidthMenu.hidden = true;
      });
    });
    
    lineWidthMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }
  
  function updateLineWidthMenu() {
    if (!lineWidthMenu) return;
    
    let currentWidth = 2;
    let currentStyle = 'solid';
    
    if (state.selected?.type === 'edge') {
      const e = findEdge(state.selected.id);
      if (e) {
        currentWidth = e.strokeW || 2;
        currentStyle = e.lineStyle || 'solid';
      }
    } else if (state.selected?.type === 'node') {
      const n = findNode(state.selected.id);
      if (n) {
        currentWidth = n.strokeW || 2;
        currentStyle = n.lineStyle || 'solid';
      }
    } else if (state.selected?.type === 'group') {
      const g = findGroup(state.selected.id);
      if (g) {
        currentWidth = g.strokeW || 1;
        currentStyle = g.lineStyle || 'solid';
      }
    }
    
    lineWidthMenu.querySelectorAll('.line-width-item').forEach(item => {
      item.classList.toggle('active', parseInt(item.dataset.width) === currentWidth);
    });
    
    lineWidthMenu.querySelectorAll('.line-style-item').forEach(item => {
      item.classList.toggle('active', item.dataset.linestyle === currentStyle);
    });
  }
  
  function applyLineWidth(width) {
    // Apply to selected element
    if (state.selected) {
      if (state.selected.type === 'edge') {
        const e = findEdge(state.selected.id);
        if (e) { e.strokeW = width; commit(); render(); }
      } else if (state.selected.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) { n.strokeW = width; commit(); render(); }
      } else if (state.selected.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) { g.strokeW = width; commit(); render(); }
      }
    }
    
    // Apply to multi-selection
    if (state.selection.edges.size > 0) {
      state.selection.edges.forEach(id => {
        const e = findEdge(id);
        if (e) e.strokeW = width;
      });
      commit(); render();
    }
    if (state.selection.nodes.size > 0) {
      state.selection.nodes.forEach(id => {
        const n = findNode(id);
        if (n) n.strokeW = width;
      });
      commit(); render();
    }
    if (state.selection.groups.size > 0) {
      state.selection.groups.forEach(id => {
        const g = findGroup(id);
        if (g) g.strokeW = width;
      });
      commit(); render();
    }
  }
  
  // Line Style handler
  if (lineWidthMenu) {
    lineWidthMenu.querySelectorAll('.line-style-item').forEach(item => {
      item.addEventListener('click', () => {
        const lineStyle = item.dataset.linestyle;
        applyLineStyle(lineStyle);
        updateLineStyleMenu();
        lineWidthMenu.hidden = true;
      });
    });
  }
  
  function updateLineStyleMenu() {
    if (!lineWidthMenu) return;
    
    let currentStyle = 'solid';
    
    if (state.selected?.type === 'edge') {
      const e = findEdge(state.selected.id);
      if (e) currentStyle = e.lineStyle || 'solid';
    } else if (state.selected?.type === 'node') {
      const n = findNode(state.selected.id);
      if (n) currentStyle = n.lineStyle || 'solid';
    } else if (state.selected?.type === 'group') {
      const g = findGroup(state.selected.id);
      if (g) currentStyle = g.lineStyle || 'solid';
    }
    
    lineWidthMenu.querySelectorAll('.line-style-item').forEach(item => {
      item.classList.toggle('active', item.dataset.linestyle === currentStyle);
    });
  }
  
  function applyLineStyle(lineStyle) {
    // Apply to selected element
    if (state.selected) {
      if (state.selected.type === 'edge') {
        const e = findEdge(state.selected.id);
        if (e) { e.lineStyle = lineStyle; commit(); render(); }
      } else if (state.selected.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) { n.lineStyle = lineStyle; commit(); render(); }
      } else if (state.selected.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) { g.lineStyle = lineStyle; commit(); render(); }
      }
    }
    
    // Apply to multi-selection
    if (state.selection.edges.size > 0) {
      state.selection.edges.forEach(id => {
        const e = findEdge(id);
        if (e) e.lineStyle = lineStyle;
      });
      commit(); render();
    }
    if (state.selection.nodes.size > 0) {
      state.selection.nodes.forEach(id => {
        const n = findNode(id);
        if (n) n.lineStyle = lineStyle;
      });
      commit(); render();
    }
    if (state.selection.groups.size > 0) {
      state.selection.groups.forEach(id => {
        const g = findGroup(id);
        if (g) g.lineStyle = lineStyle;
      });
      commit(); render();
    }
  }
  
  // Font families and sizes available
  const fontFamilies = ['Arial', 'Times New Roman', 'Courier New', 'Verdana', 'Georgia', 'Helvetica'];
  const fontSizes = [6, 8, 9, 10, 11, 12, 14, 16, 18, 20, 24];
  
  // Text field definitions per object type
  // Simplified to match actual rendering: one text block per visual element
  const textFieldDefs = {
    node: [
      { key: 'name', label: 'Node Name', colorKey: 'nameColor', visibleKey: 'showName', fontKey: 'nameFont', sizeKey: 'nameSize', defaultVisible: true },
      { key: 'code', label: 'Node Code', colorKey: 'codeColor', visibleKey: 'showCode', fontKey: 'codeFont', sizeKey: 'codeSize', defaultVisible: true },
      { key: 'extraTags', label: 'Additional Tags', colorKey: 'extraTagsColor', visibleKey: 'showExtraTags', fontKey: 'extraTagsFont', sizeKey: 'extraTagsSize', defaultVisible: false }
    ],
    edge: [
      { key: 'tag', label: 'Link Label', colorKey: 'tagColor', visibleKey: 'showTag', fontKey: 'tagFont', sizeKey: 'tagSize', defaultVisible: true }
    ],
    group: [
      { key: 'title', label: 'Title', colorKey: 'titleColor', visibleKey: 'showTitle', fontKey: 'titleFont', sizeKey: 'titleSize', defaultVisible: true }
    ]
  };
  
  // Font Color Menu
  const btnFontColor = document.getElementById('btnFontColor');
  const fontColorMenu = document.getElementById('fontColorMenu');
  const fontColorNoSelection = document.getElementById('fontColorNoSelection');
  const fontColorFields = document.getElementById('fontColorFields');
  
  if (btnFontColor && fontColorMenu) {
    btnFontColor.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateFontColorMenu();
      fontColorMenu.hidden = !fontColorMenu.hidden;
    });
    
    fontColorMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }
  
  function updateFontColorMenu() {
    if (!fontColorFields || !fontColorNoSelection) return;
    
    const obj = getSelectedObject();
    if (!obj) {
      fontColorNoSelection.style.display = 'block';
      fontColorFields.style.display = 'none';
      return;
    }
    
    fontColorNoSelection.style.display = 'none';
    fontColorFields.style.display = 'block';
    fontColorFields.innerHTML = '';
    
    const type = state.selected.type === 'edge' ? 'edge' : (state.selected.type === 'node' ? 'node' : 'group');
    const fields = textFieldDefs[type] || [];
    
    fields.forEach(field => {
      const row = document.createElement('div');
      row.style.cssText = 'display:flex; align-items:center; gap:8px; padding:8px 12px; border-bottom:1px solid #f0f0f0;';
      
      // Visibility checkbox
      const visCheck = document.createElement('input');
      visCheck.type = 'checkbox';
      visCheck.checked = obj[field.visibleKey] !== false; // default true unless explicitly false
      visCheck.title = 'Show/Hide';
      visCheck.style.cssText = 'width:16px; height:16px; cursor:pointer; flex-shrink:0;';
      visCheck.addEventListener('change', () => {
        obj[field.visibleKey] = visCheck.checked;
        commit(); render();
      });
      
      // Label
      const label = document.createElement('span');
      label.textContent = field.label;
      label.style.cssText = 'flex:1; font-size:12px;';
      
      // Color button that opens palette
      const colorBtn = document.createElement('div');
      const currentColor = obj[field.colorKey] || '#eaeaea';
      colorBtn.style.cssText = `width:24px; height:24px; border:1px solid #999; border-radius:3px; cursor:pointer; background:${currentColor}; flex-shrink:0; position:relative;`;
      colorBtn.title = 'Click to change color';
      
      // Color palette dropdown
      const paletteDropdown = document.createElement('div');
      paletteDropdown.style.cssText = 'display:none; position:absolute; right:0; top:28px; background:white; border:1px solid #ccc; border-radius:4px; padding:6px; box-shadow:0 2px 8px rgba(0,0,0,0.15); z-index:1000; width:180px;';
      
      // Build palette grid
      const grid = document.createElement('div');
      grid.style.cssText = 'display:grid; grid-template-columns:repeat(8,1fr); gap:2px;';
      toolbarColorPalette.forEach(color => {
        const swatch = document.createElement('div');
        swatch.style.cssText = `width:18px; height:18px; background:${color}; border:1px solid #ccc; cursor:pointer; border-radius:2px;`;
        swatch.addEventListener('click', (ev) => {
          ev.stopPropagation();
          obj[field.colorKey] = color;
          colorBtn.style.background = color;
          paletteDropdown.style.display = 'none';
          commit(); render();
        });
        grid.appendChild(swatch);
      });
      paletteDropdown.appendChild(grid);
      
      // Custom color input
      const customRow = document.createElement('div');
      customRow.style.cssText = 'margin-top:6px; display:flex; align-items:center; gap:4px;';
      const customLabel = document.createElement('span');
      customLabel.textContent = 'Custom:';
      customLabel.style.cssText = 'font-size:10px;';
      const customInput = document.createElement('input');
      customInput.type = 'color';
      customInput.value = currentColor;
      customInput.style.cssText = 'width:24px; height:20px; border:none; cursor:pointer;';
      customInput.addEventListener('input', (ev) => {
        obj[field.colorKey] = ev.target.value;
        colorBtn.style.background = ev.target.value;
        commit(); render();
      });
      customRow.appendChild(customLabel);
      customRow.appendChild(customInput);
      paletteDropdown.appendChild(customRow);
      
      colorBtn.appendChild(paletteDropdown);
      
      colorBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        // Close other palettes
        fontColorFields.querySelectorAll('div[style*="position:absolute"]').forEach(p => {
          if (p !== paletteDropdown) p.style.display = 'none';
        });
        paletteDropdown.style.display = paletteDropdown.style.display === 'none' ? 'block' : 'none';
      });
      
      row.appendChild(visCheck);
      row.appendChild(label);
      row.appendChild(colorBtn);
      fontColorFields.appendChild(row);
    });
    
    // Close palettes when clicking elsewhere in the menu
    fontColorMenu.addEventListener('click', (ev) => {
      if (!ev.target.closest('div[style*="position:absolute"]') && !ev.target.closest('div[style*="cursor:pointer"]')) {
        fontColorFields.querySelectorAll('div[style*="position:absolute"]').forEach(p => {
          p.style.display = 'none';
        });
      }
    });
  }
  
  // Font Type Menu
  const btnFontType = document.getElementById('btnFontType');
  const fontTypeMenu = document.getElementById('fontTypeMenu');
  const fontTypeNoSelection = document.getElementById('fontTypeNoSelection');
  const fontTypeFields = document.getElementById('fontTypeFields');
  
  if (btnFontType && fontTypeMenu) {
    btnFontType.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateFontTypeMenu();
      fontTypeMenu.hidden = !fontTypeMenu.hidden;
    });
    
    fontTypeMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }
  
  function updateFontTypeMenu() {
    if (!fontTypeFields || !fontTypeNoSelection) return;
    
    const obj = getSelectedObject();
    if (!obj) {
      fontTypeNoSelection.style.display = 'block';
      fontTypeFields.style.display = 'none';
      return;
    }
    
    fontTypeNoSelection.style.display = 'none';
    fontTypeFields.style.display = 'block';
    fontTypeFields.innerHTML = '';
    
    const type = state.selected.type === 'edge' ? 'edge' : (state.selected.type === 'node' ? 'node' : 'group');
    const fields = textFieldDefs[type] || [];
    
    fields.forEach(field => {
      const row = document.createElement('div');
      row.style.cssText = 'display:flex; align-items:center; gap:6px; padding:6px 12px; border-bottom:1px solid #f0f0f0;';
      
      // Label
      const label = document.createElement('span');
      label.textContent = field.label;
      label.style.cssText = 'width:90px; font-size:11px; flex-shrink:0;';
      
      // Font family select
      const fontSelect = document.createElement('select');
      fontSelect.style.cssText = 'flex:1; font-size:11px; padding:2px 4px; border:1px solid #ccc; border-radius:3px;';
      fontFamilies.forEach(f => {
        const opt = document.createElement('option');
        opt.value = f;
        opt.textContent = f;
        opt.selected = (obj[field.fontKey] || 'Arial') === f;
        fontSelect.appendChild(opt);
      });
      fontSelect.addEventListener('change', () => {
        obj[field.fontKey] = fontSelect.value;
        commit(); render();
      });
      
      // Font size select
      const sizeSelect = document.createElement('select');
      sizeSelect.style.cssText = 'width:50px; font-size:11px; padding:2px 4px; border:1px solid #ccc; border-radius:3px;';
      fontSizes.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s;
        opt.textContent = s + 'px';
        opt.selected = (obj[field.sizeKey] || 12) === s;
        sizeSelect.appendChild(opt);
      });
      sizeSelect.addEventListener('change', () => {
        obj[field.sizeKey] = parseInt(sizeSelect.value);
        commit(); render();
      });
      
      row.appendChild(label);
      row.appendChild(fontSelect);
      row.appendChild(sizeSelect);
      fontTypeFields.appendChild(row);
    });
  }
  
  // Helper to get currently selected object
  function getSelectedObject() {
    if (!state.selected) return null;
    if (state.selected.type === 'node') return findNode(state.selected.id);
    if (state.selected.type === 'edge') return findEdge(state.selected.id);
    if (state.selected.type === 'group') return findGroup(state.selected.id);
    return null;
  }
  
  // Helper to get stroke-dasharray value for line style
  function getStrokeDasharray(lineStyle, strokeWidth) {
    const sw = strokeWidth || 2;
    if (lineStyle === 'dashed') return `${sw * 4},${sw * 2}`;
    if (lineStyle === 'dotted') return `${sw},${sw * 1.5}`;
    return 'none';
  }
  
  // Update color indicators when selection changes
  function updateFormatIndicators() {
    if (state.selected) {
      if (state.selected.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) {
          if (fillColorIndicator) fillColorIndicator.style.backgroundColor = n.fill || '#dae8fc';
          if (strokeColorIndicator) strokeColorIndicator.style.backgroundColor = n.stroke || '#6c8ebf';
        }
      } else if (state.selected.type === 'edge') {
        const e = findEdge(state.selected.id);
        if (e) {
          if (strokeColorIndicator) strokeColorIndicator.style.backgroundColor = e.strokeColor || '#666666';
        }
      } else if (state.selected.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) {
          if (fillColorIndicator) fillColorIndicator.style.backgroundColor = g.fill || '#ffffff';
          if (strokeColorIndicator) strokeColorIndicator.style.backgroundColor = g.stroke || '#666666';
        }
      }
    }
  }

  // Mouse wheel zoom (centered on mouse position)
  svg.addEventListener('wheel', (ev) => {
    if (ev.ctrlKey || ev.metaKey) {
      ev.preventDefault();
      const delta = ev.deltaY > 0 ? 0.9 : 1.1;
      const rect = svg.getBoundingClientRect();
      const mouseX = ev.clientX - rect.left;
      const mouseY = ev.clientY - rect.top;
      setZoom(state.zoom * delta, true, mouseX, mouseY);
    }
  }, { passive: false });


  const downloadText = (filename, text, mime="text/plain") => {
    const blob = new Blob([text], {type: mime});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(a.href), 500);
  };

  const escapeCSV = (v) => {
    const s = String(v ?? "");
    if (/[,"\n]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  };

  function getMouse(ev) {
    const pt = svg.createSVGPoint();
    pt.x = ev.clientX; pt.y = ev.clientY;
    const m = pt.matrixTransform(svg.getScreenCTM().inverse());
    return { x: m.x, y: m.y };
  }

  const findNode = (id) => state.nodes.find(n => n.id === id);
  const findEdge = (id) => state.edges.find(e => e.id === id);
  const findGroup = (id) => state.groups.find(g => g.id === id);

  function pointInGroup(x,y,g){
    // Always use bounding rectangle for containment (simpler, works for all shapes)
    return x >= g.x && x <= g.x+g.w && y >= g.y && y <= g.y+g.h;
  }
  function updateNodeGroupMembership(node) {
    let gid = null;
    // Nodes belong to the top-most *country* box they are inside (regions don't directly own nodes)
    for (let i = state.groups.length - 1; i >= 0; i--) {
      const g = state.groups[i];
      if (g.type !== 'country') continue;
      if (pointInGroup(node.x, node.y, g)) { gid = g.id; break; }
    }
    node.groupId = gid;
  }
  function updateCountryRegionMembership(country) {
    if (!country || country.type !== 'country') return;
    let rid = null;
    const cx = country.x + country.w / 2;
    const cy = country.y + country.h / 2;
    for (let i = state.groups.length - 1; i >= 0; i--) {
      const g = state.groups[i];
      if (g.type !== 'region') continue;
      if (pointInGroup(cx, cy, g)) { rid = g.id; break; }
    }
    country.parentId = rid;
  }

  function refreshAllMemberships() {
    state.groups.forEach(g => { if (g.type === 'country') updateCountryRegionMembership(g); });
    state.nodes.forEach(updateNodeGroupMembership);
  }

  function projectSnapshot() {
    return JSON.parse(JSON.stringify({
      nodes: state.nodes, edges: state.edges, groups: state.groups,
      cableSystems: state.cableSystems,
      nextNode: state.nextNode, nextEdge: state.nextEdge, nextGroup: state.nextGroup,
      nextCableSystem: state.nextCableSystem,
      stylePresets: state.stylePresets,
      canvasWidth: state.canvasWidth,
      canvasHeight: state.canvasHeight,
      showCanvasBorder: state.showCanvasBorder
    }));
  }
  function applySnapshot(snap) {
    state.nodes = snap.nodes || [];
    state.edges = snap.edges || [];
    state.groups = snap.groups || [];
    state.cableSystems = snap.cableSystems || [];
    state.nextNode = snap.nextNode || (Math.max(0, ...state.nodes.map(n=>n.id)) + 1);
    state.nextEdge = snap.nextEdge || (Math.max(0, ...state.edges.map(e=>e.id)) + 1);
    state.nextGroup = snap.nextGroup || (Math.max(0, ...state.groups.map(g=>g.id)) + 1);
    state.nextCableSystem = snap.nextCableSystem || (Math.max(0, ...state.cableSystems.map(cs=>cs.id)) + 1);

    // Backward compatibility: ensure cableSystemId exists on edges
    state.edges.forEach(e => {
      if (e.cableSystemId === undefined) e.cableSystemId = null;
    });
    // Backward compatibility: ensure cableSystemIds exists on nodes
    state.nodes.forEach(n => {
      if (!Array.isArray(n.cableSystemIds)) n.cableSystemIds = [];
    });

    // Restore presets if snapshot carries them; otherwise keep current
    state.stylePresets = snap.stylePresets || state.stylePresets || { node: {}, edge: {}, group: {} };
    state.styleBrush = null;

    // Restore canvas dimensions
    if (typeof snap.canvasWidth === 'number') state.canvasWidth = snap.canvasWidth;
    if (typeof snap.canvasHeight === 'number') state.canvasHeight = snap.canvasHeight;
    if (typeof snap.showCanvasBorder === 'boolean') state.showCanvasBorder = snap.showCanvasBorder;
    svg.setAttribute('viewBox', `0 0 ${state.canvasWidth} ${state.canvasHeight}`);
    syncGlobalToggles();

    // Clear transient UI state
    state.selected = null;
    state.connectFrom = null;
    state.dragging = null;
    state.resizingGroup = null;
    state.resizingNode = null;
    state.placingGroup = false;
    state.placingGroupType = 'country';

    refreshAllMemberships();
    render();
    updateInspector();
    updateCableSystemNavigator && updateCableSystemNavigator();
  }
  function pushHistory() {
    const snap = projectSnapshot();
    if (history.index < history.stack.length - 1) {
      history.stack = history.stack.slice(0, history.index + 1);
    }
    history.stack.push(snap);
    if (history.stack.length > history.max) history.stack.shift();
    else history.index++;
  }
  function commit() { dirty = true; pushHistory(); }
  function undo() {
    if (history.index <= 0) { showToast("Nothing to undo."); return; }
    history.index--;
    applySnapshot(history.stack[history.index]);
    dirty = true;
    showToast("Undo");
  }
  function redo() {
    if (history.index >= history.stack.length - 1) { showToast("Nothing to redo."); return; }
    history.index++;
    applySnapshot(history.stack[history.index]);
    dirty = true;
    showToast("Redo");
  }

  function svgLine(x1,y1,x2,y2,cls){
    const l = document.createElementNS('http://www.w3.org/2000/svg','line');
    l.setAttribute('x1', x1); l.setAttribute('y1', y1);
    l.setAttribute('x2', x2); l.setAttribute('y2', y2);
    l.setAttribute('class', cls);
    return l;
  }
  
  function drawCanvasBorder() {
    if (state.showCanvasBorder) {
      const border = document.createElementNS('http://www.w3.org/2000/svg','rect');
      border.setAttribute('x', 0);
      border.setAttribute('y', 0);
      border.setAttribute('width', state.canvasWidth);
      border.setAttribute('height', state.canvasHeight);
      border.setAttribute('fill', 'none');
      border.setAttribute('stroke', '#444');
      border.setAttribute('stroke-width', 2);
      border.setAttribute('stroke-dasharray', '8 4');
      border.style.pointerEvents = 'none';
      svg.appendChild(border);
    }
    
    // Always draw resize handle in corner
    drawCanvasResizeHandle();
  }
  
  function drawCanvasResizeHandle() {
    const x = state.canvasWidth - 20;
    const y = state.canvasHeight - 20;
    
    // Create resize handle group
    const handleGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    handleGroup.setAttribute('id', 'canvasResizeHandle');
    handleGroup.style.cursor = 'nwse-resize';

    // Background (larger hit area)
    const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    hitArea.setAttribute('x', x);
    hitArea.setAttribute('y', y);
    hitArea.setAttribute('width', 20);
    hitArea.setAttribute('height', 20);
    hitArea.setAttribute('fill', 'rgba(102, 126, 234, 0.1)');
    hitArea.setAttribute('rx', 3);
    handleGroup.appendChild(hitArea);

    // Visual handle (diagonal lines like typical resize grip)
    const grip = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    grip.setAttribute('d', `
      M${x + 6} ${y + 18} L${x + 18} ${y + 6}
      M${x + 10} ${y + 18} L${x + 18} ${y + 10}
      M${x + 14} ${y + 18} L${x + 18} ${y + 14}
    `);
    grip.setAttribute('stroke', '#888');
    grip.setAttribute('stroke-width', '1.5');
    grip.setAttribute('stroke-linecap', 'round');
    grip.setAttribute('fill', 'none');
    grip.style.pointerEvents = 'none';
    handleGroup.appendChild(grip);

    // Event handler for mousedown
    handleGroup.addEventListener('mousedown', startCanvasResize);

    svg.appendChild(handleGroup);
  }
  
  // Canvas resize state
  let canvasResizing = false;
  let canvasResizeStartX, canvasResizeStartY;
  let canvasStartWidth, canvasStartHeight;
  
  function startCanvasResize(e) {
    e.preventDefault();
    e.stopPropagation();
    canvasResizing = true;
    canvasResizeStartX = e.clientX;
    canvasResizeStartY = e.clientY;
    canvasStartWidth = state.canvasWidth;
    canvasStartHeight = state.canvasHeight;
    document.body.style.cursor = 'nwse-resize';
    document.body.style.userSelect = 'none';
  }
  
  document.addEventListener('mousemove', (e) => {
    if (!canvasResizing) return;

    const dx = (e.clientX - canvasResizeStartX) / state.zoom;
    const dy = (e.clientY - canvasResizeStartY) / state.zoom;

    const newWidth = Math.max(400, Math.round(canvasStartWidth + dx));
    const newHeight = Math.max(300, Math.round(canvasStartHeight + dy));

    state.canvasWidth = newWidth;
    state.canvasHeight = newHeight;

    // Update viewBox AND visual size
    updateViewBox();
    
    // Update inspector inputs
    if (canvasWidth) canvasWidth.value = state.canvasWidth;
    if (canvasHeight) canvasHeight.value = state.canvasHeight;
    
    // Redraw
    render();
  });
  
  document.addEventListener('mouseup', () => {
    if (canvasResizing) {
      canvasResizing = false;
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      commit();
      showToast(`Canvas: ${state.canvasWidth} √ó ${state.canvasHeight}`);
    }
  });
  
  function drawGrid() {
    const w = state.canvasWidth, h = state.canvasHeight;
    // Only draw grid if enabled
    if (state.gridEnabled) {
      const step = state.gridSize || 40;
      for (let x=0; x<=w; x+=step) svg.appendChild(svgLine(x,0,x,h,'grid'));
      for (let y=0; y<=h; y+=step) svg.appendChild(svgLine(0,y,w,y,'grid'));
    }
    drawCanvasBorder();
  }


  function polygonPoints(cx, cy, r, sides, rotationRad=0){
    const pts = [];
    for (let i=0;i<sides;i++){
      const a = rotationRad + (i * 2*Math.PI / sides);
      pts.push([cx + r*Math.cos(a), cy + r*Math.sin(a)]);
    }
    return pts.map(p=>p[0].toFixed(2)+","+p[1].toFixed(2)).join(" ");
  }
  function setMultilineText(textEl, lines, fontSizePx) {
    while (textEl.firstChild) textEl.removeChild(textEl.firstChild);
    const fs = fontSizePx ?? 12;
    lines.forEach((line, i) => {
      const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      tspan.setAttribute('x', textEl.getAttribute('x'));
      if (i === 0) tspan.setAttribute('dy', '0');
      else tspan.setAttribute('dy', (fs * 1.2).toString());
      tspan.textContent = line;
      textEl.appendChild(tspan);
    });
  }

  // New function for styled multiline text (each line can have different styles)
  function setStyledMultilineText(textEl, styledLines) {
    while (textEl.firstChild) textEl.removeChild(textEl.firstChild);
    let prevFontSize = 12;
    styledLines.forEach((item, i) => {
      const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      tspan.setAttribute('x', textEl.getAttribute('x'));
      if (i === 0) {
        tspan.setAttribute('dy', '0');
      } else {
        tspan.setAttribute('dy', (prevFontSize * 1.2).toString());
      }
      tspan.textContent = item.text;
      // Apply individual styles
      if (item.fill) tspan.setAttribute('fill', item.fill);
      if (item.fontSize) {
        tspan.style.fontSize = item.fontSize + 'px';
        prevFontSize = item.fontSize;
      }
      if (item.fontFamily) tspan.style.fontFamily = item.fontFamily;
      textEl.appendChild(tspan);
    });
  }

  function render() {
    svg.innerHTML = '';
    drawGrid();
    
    // Filter groups (regions first, then countries) based on tag filter
    state.groups.filter(g=>g.type==='region').forEach(g => {
      if (isGroupVisible(g)) drawGroup(g);
    });
    state.groups.filter(g=>g.type!=='region').forEach(g => {
      if (isGroupVisible(g)) drawGroup(g);
    });
    
    // Filter edges based on node visibility and edge tags
    state.edges.forEach(e => {
      if (isEdgeVisible(e)) {
        drawEdge(e);
      }
    });
    
    // Filter nodes based on tag filter
    state.nodes.forEach(n => {
      if (isNodeVisible(n)) {
        drawNode(n);
      }
    });

    if (state.connectFrom) {
      const n = findNode(state.connectFrom);
      if (n && isNodeVisible(n)) {
        const hint = document.createElementNS('http://www.w3.org/2000/svg','text');
        hint.setAttribute('x', n.x);
        hint.setAttribute('y', n.y - 40);
        hint.setAttribute('class', 'edge-label');
        hint.style.fontSize = "12px";
        hint.textContent = "Select target node‚Ä¶";
        svg.appendChild(hint);
      }
    }
    if (state.marquee) {
      const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
      r.setAttribute('class','marquee');
      r.setAttribute('x', state.marquee.x);
      r.setAttribute('y', state.marquee.y);
      r.setAttribute('width', state.marquee.w);
      r.setAttribute('height', state.marquee.h);
      svg.appendChild(r);
    }
    updateInspector();
    // Refresh Label Manager if visible
    if (window.labelManagerState?.visible && typeof window.refreshLabelManager === 'function') {
      window.refreshLabelManager();
    }
  }

  function drawGroup(g) {
    const grp = document.createElementNS('http://www.w3.org/2000/svg','g');
    const isSel = (state.selected?.type==='group' && state.selected?.id===g.id) || state.selection.groups.has(g.id);
    if (isSel) grp.classList.add('group-selected');

    // Check if this is a shape-based container
    const isShapeContainer = g.shapeContainer && g.decorativeShape && g.decorativeShape.pathData;
    
    // Create invisible rect for bounds/interaction (always needed for dragging)
    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x', g.x);
    rect.setAttribute('y', g.y);
    rect.setAttribute('width', g.w);
    rect.setAttribute('height', g.h);
    rect.setAttribute('class', 'group-rect');
    
    if (isShapeContainer) {
      // For shape containers, make rect invisible - shape will be the visual
      rect.setAttribute('fill', 'transparent');
      rect.setAttribute('stroke', 'none');
    } else {
      rect.setAttribute('fill', g.fill || "rgba(54, 76, 140, 0.12)");
      rect.setAttribute('stroke', g.stroke || "#6073b8");
      rect.setAttribute('stroke-width', (g.strokeW ?? 2));
      // Apply line style to container border
      if (g.lineStyle && g.lineStyle !== 'solid') {
        rect.setAttribute('stroke-dasharray', getStrokeDasharray(g.lineStyle, g.strokeW ?? 2));
      }
    }
    rect.style.pointerEvents = "auto";  // Make clickable for selection and dragging
    rect.style.cursor = "grab";  // Show hand cursor

    // Render shape as container visual (for shape containers) or decorative overlay
    let shapeEl = null;
    if (g.decorativeShape && g.decorativeShape.pathData) {
      const padding = isShapeContainer ? 0 : 10;
      const innerW = g.w - padding * 2;
      const innerH = g.h - padding * 2;
      
      // Parse viewBox to get original dimensions
      const vbParts = (g.decorativeShape.viewBox || '0 0 100 100').split(/\s+/).map(parseFloat);
      const origW = vbParts[2] || 100;
      const origH = vbParts[3] || 100;
      
      // Calculate scale to fit within container while maintaining aspect ratio
      const scaleX = innerW / origW;
      const scaleY = innerH / origH;
      const scale = Math.min(scaleX, scaleY);
      
      // Calculate offset to center the shape
      const scaledW = origW * scale;
      const scaledH = origH * scale;
      const offsetX = g.x + padding + (innerW - scaledW) / 2 - vbParts[0] * scale;
      const offsetY = g.y + padding + (innerH - scaledH) / 2 - vbParts[1] * scale;
      
      shapeEl = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      shapeEl.setAttribute('transform', `translate(${offsetX}, ${offsetY}) scale(${scale})`);
      
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', g.decorativeShape.pathData);
      
      if (isShapeContainer) {
        // Shape IS the container - draw with full styling
        path.setAttribute('fill', g.fill || 'rgba(54, 76, 140, 0.15)');
        path.setAttribute('stroke', g.stroke || '#6073b8');
        path.setAttribute('stroke-width', (g.strokeW ?? 2) / scale); // Adjust for scale
        if (g.lineStyle && g.lineStyle !== 'solid') {
          const dashArray = getStrokeDasharray(g.lineStyle, g.strokeW ?? 2);
          // Scale dash array
          const scaledDash = dashArray.split(',').map(v => parseFloat(v) / scale).join(',');
          path.setAttribute('stroke-dasharray', scaledDash);
        }
        // Make shape clickable for dragging
        path.style.pointerEvents = 'auto';
        path.style.cursor = 'grab';
        
        // Add mousedown handler to shape path for dragging
        path.addEventListener('mousedown', (ev) => {
          ev.stopPropagation();
          const m = getMouse(ev);
          
          if (window.routeFinderState && window.routeFinderState.active) return;
          if (linkMode) return;
          if (ev.shiftKey && !(ev.ctrlKey || ev.metaKey)) return;
          
          if (state.selection.groups.has(g.id) && (state.selection.groups.size > 1 || state.selection.nodes.size > 0)) {
            const origNodes = [...state.selection.nodes].map(id => {
              const nn = findNode(id); return nn ? {id, x: nn.x, y: nn.y} : null;
            }).filter(Boolean);
            const origGroups = [...state.selection.groups].map(id => {
              const gg = findGroup(id); return gg ? {id, x: gg.x, y: gg.y} : null;
            }).filter(Boolean);
            state.dragging = { type:'selection', mx0: m.x, my0: m.y, origNodes, origGroups };
            state.selected = null;
          } else {
            if (!state.selection.groups.has(g.id)) {
              setSingleSelection({type:'group', id:g.id});
            }
            state.dragging = { type:'group', id:g.id, dx: g.x - m.x, dy: g.y - m.y };
          }
          path.style.cursor = 'grabbing';
          state.connectFrom = null;
        });
        
        // Selection highlight
        if (isSel) {
          path.setAttribute('stroke', '#2563eb');
          path.setAttribute('stroke-width', (g.strokeW ?? 2) / scale + 2/scale);
        }
      } else {
        // Decorative overlay only
        path.setAttribute('fill', g.stroke || '#6073b8');
        path.setAttribute('fill-opacity', '0.08');
        path.setAttribute('stroke', 'none');
        path.style.pointerEvents = 'none';
      }
      
      shapeEl.appendChild(path);
    }

    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('x', g.x + 14 + (g.titleDx || 0));
    label.setAttribute('y', g.y + 22 + (g.titleDy || 0));
    label.setAttribute('class', 'group-label');
    label.setAttribute('fill', g.titleColor || "#eaeaea");
    label.style.fontSize = (g.titleSize || 14) + "px";
    label.style.fontFamily = g.titleFont || 'Arial';
    // Only show title if globally enabled AND per-container enabled (defaults to true)
    if (state.ui.showContainerTitle !== false && g.showTitle !== false) {
      label.textContent = g.title || (g.type==='region' ? `Group${g.id}` : `Container${g.id}`);
    } else {
      label.textContent = '';
    }
    label.style.pointerEvents = "auto";

    // Create 4 resize handles (one for each corner)
    const handleSize = 10;
    const handlePositions = [
      { corner: 'nw', x: g.x, y: g.y },
      { corner: 'ne', x: g.x + g.w - handleSize, y: g.y },
      { corner: 'sw', x: g.x, y: g.y + g.h - handleSize },
      { corner: 'se', x: g.x + g.w - handleSize, y: g.y + g.h - handleSize }
    ];
    
    const handles = handlePositions.map(pos => {
      const handle = document.createElementNS('http://www.w3.org/2000/svg','rect');
      handle.setAttribute('x', pos.x);
      handle.setAttribute('y', pos.y);
      handle.setAttribute('width', handleSize);
      handle.setAttribute('height', handleSize);
      handle.setAttribute('class', `group-handle handle-${pos.corner}`);
      handle.setAttribute('data-corner', pos.corner);
      
      handle.addEventListener('mousedown', (ev) => {
        ev.stopPropagation();
        const m = getMouse(ev);
        select({type:'group', id:g.id});
        state.resizingGroup = { 
          id: g.id, 
          corner: pos.corner,
          startX: g.x, 
          startY: g.y, 
          startW: g.w, 
          startH: g.h, 
          mx0: m.x, 
          my0: m.y 
        };
        state.connectFrom = null;
        render();
      });
      
      return handle;
    });

    rect.addEventListener('mousedown', (ev) => {
      ev.stopPropagation();
      const m = getMouse(ev);
      
      // In calculation mode, don't allow group dragging/selection
      if (window.routeFinderState && window.routeFinderState.active) {
        return;
      }
      
      // In link mode, don't allow group dragging
      if (linkMode) {
        return;
      }
      
      // Shift+click without Ctrl - let mouseup/click handle multi-selection, don't set up dragging
      if (ev.shiftKey && !(ev.ctrlKey || ev.metaKey)) {
        console.log(`[GROUP MOUSEDOWN] Group ${g.id} - Shift+click, letting click handler handle multi-select`);
        return;
      }
      
      // Check BEFORE calling select() to preserve multi-selection if dragging
      // If the clicked group is part of a multi-selection, drag entire selection
      if (state.selection.groups.has(g.id) && (state.selection.groups.size > 1 || state.selection.nodes.size > 0)) {
        console.log(`[MULTI-DRAG] Group ${g.id} is part of multi-selection (${state.selection.nodes.size} nodes, ${state.selection.groups.size} groups) - setting up multi-drag`);
        const origNodes = [...state.selection.nodes].map(id => {
          const nn = findNode(id); return nn ? {id, x: nn.x, y: nn.y} : null;
        }).filter(Boolean);
        const origGroups = [...state.selection.groups].map(id => {
          const gg = findGroup(id); return gg ? {id, x: gg.x, y: gg.y} : null;
        }).filter(Boolean);
        state.dragging = { type:'selection', mx0: m.x, my0: m.y, origNodes, origGroups };
        state.selected = null; // Clear single selection when dragging multiple
        console.log(`[MULTI-DRAG] Dragging ${origNodes.length} nodes and ${origGroups.length} groups`);
      } else {
        console.log(`[SINGLE-DRAG] Group ${g.id} - single selection drag setup`);
        // Don't call select() here - it may trigger render() which recreates DOM
        if (!state.selection.groups.has(g.id)) {
          setSingleSelection({type:'group', id:g.id});
        }
        state.dragging = { type:'group', id:g.id, dx: g.x - m.x, dy: g.y - m.y };
      }
      rect.style.cursor = "grabbing";
      state.connectFrom = null;
    });

    label.addEventListener('mousedown', (ev) => {
      if (!(ev.ctrlKey || ev.metaKey)) return;
      ev.stopPropagation();
      const m = getMouse(ev);
      state.dragging = { type:'groupTitleLabel', id:g.id,
        dx: (g.x + 14 + (g.titleDx||0)) - m.x,
        dy: (g.y + 22 + (g.titleDy||0)) - m.y
      };
      select({type:'group', id:g.id});
      state.connectFrom = null;
      render();
    });

    rect.addEventListener('mouseup', (ev) => {
      // Don't stop propagation - let global handler clear dragging state
      // Just restore cursor
      rect.style.cursor = "grab";
    });

    rect.addEventListener('click', (ev) => { 
      ev.stopPropagation(); 
      if (ev.shiftKey) {
        // Shift+click toggles multi-selection for this group
        if (state.selection.groups.has(g.id)) {
          state.selection.groups.delete(g.id);
          state.selected = null;
        } else {
          state.selection.groups.add(g.id);
          state.selected = null;
        }
        render();
        return;
      }
      select({type:'group', id:g.id}); 
      state.connectFrom=null; 
      render(); 
    });
    label.addEventListener('click', (ev) => { 
      ev.stopPropagation(); 
      if (ev.shiftKey) {
        // Shift+click toggles multi-selection for this group
        if (state.selection.groups.has(g.id)) {
          state.selection.groups.delete(g.id);
          state.selected = null;
        } else {
          state.selection.groups.add(g.id);
          state.selected = null;
        }
        render();
        return;
      }
      select({type:'group', id:g.id}); 
      state.connectFrom=null; 
      render(); 
    });

    grp.appendChild(rect);
    if (shapeEl) grp.appendChild(shapeEl);
    grp.appendChild(label);
    // Append all 4 corner handles
    handles.forEach(h => grp.appendChild(h));
    svg.appendChild(grp);
  }

  function orthogonalPath(x1,y1,x2,y2, route){
    if (route === 'vh') return `M ${x1} ${y1} L ${x1} ${y2} L ${x2} ${y2}`;
    return `M ${x1} ${y1} L ${x2} ${y1} L ${x2} ${y2}`;
  }
  function orthogonalBaseLabelPoint(x1,y1,x2,y2, route){
    if (route === 'vh') return { x: x1 + 8, y: y2 - 8 };
    return { x: x2 + 8, y: y1 - 8 };
  }
  function getEdgeLabelLines(e) {
    const lines = [];
    // Link Code - show if globally enabled AND per-link enabled (defaults to true)
    if (state.ui.showLinkCode && e.showCode !== false && e.code && e.code.trim()) {
      lines.push(e.code.trim());
    }
    // Link Tag - show if globally enabled AND per-link enabled (defaults to true)
    if (state.ui.showLinkTag !== false && e.showTag !== false) {
      lines.push((e.tag && e.tag.trim()) ? e.tag.trim() : "‚Äî");
    }
    // Latency - show if globally enabled AND per-link enabled (defaults to true)
    if (state.ui.showLatency && e.showLatency !== false && typeof e.latencyMs === "number" && isFinite(e.latencyMs)) {
      lines.push(`${e.latencyMs} ms`);
    }
    // Capacity - show if per-link enabled (defaults to false)
    if (e.showCapacity && e.capacity && e.capacity.trim()) {
      lines.push(e.capacity.trim());
    }
    // Additional Tags - show if per-link enabled (defaults to false)
    if (e.showExtraTags && e.extraTags && e.extraTags.trim()) {
      lines.push(e.extraTags.trim());
    }
    return lines;
  }

  function quadraticCurvePath(x1, y1, x2, y2, arch) {
    // Create bezier curve path
    // arch controls how much the curve bends (0.3 = moderate, 0 = straight, 0.6 = extreme)
    const mx = (x1 + x2) / 2;
    const my = (y1 + y2) / 2;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const offset = dist * arch * 0.5;
    const cpx = mx - dy/dist * offset;
    const cpy = my + dx/dist * offset;
    return `M ${x1} ${y1} Q ${cpx} ${cpy} ${x2} ${y2}`;
  }

  function curveBaseLabelPoint(x1, y1, x2, y2, arch) {
    // Label position on curve (midpoint adjusted)
    const mx = (x1 + x2) / 2;
    const my = (y1 + y2) / 2;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const offset = dist * arch * 0.25;
    return { x: mx - dy/dist * offset + 8, y: my + dx/dist * offset - 8 };
  }

  function getCurveControlPoint(x1, y1, x2, y2, arch) {
    // Returns the bezier control point (used for draggable handle position)
    const mx = (x1 + x2) / 2;
    const my = (y1 + y2) / 2;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const offset = dist * arch * 0.5;
    const cpx = mx - dy/dist * offset;
    const cpy = my + dx/dist * offset;
    return { x: cpx, y: cpy };
  }

  function drawEdge(e) {
    const a = findNode(e.a), b = findNode(e.b);
    if (!a || !b) {
      console.log(`[DRAW EDGE] Edge ${e.id} NOT drawn - missing nodes: a=${!!a}, b=${!!b}`);
      return;
    }
    console.log(`[DRAW EDGE] Drawing edge ${e.id} from node ${e.a} to node ${e.b}, style=${e.style}`);
    const isSel = (state.selected?.type==='edge' && state.selected?.id===e.id) || state.selection.edges.has(e.id);
    
    // Check if this edge should be highlighted (cable system selection or temporary highlight)
    const isCSHighlighted = state.selectedCableSystem && e.cableSystemId === state.selectedCableSystem;
    const isTempHighlighted = state._highlightedLinks && state._highlightedLinks.has(e.id);
    const isHighlighted = isCSHighlighted || isTempHighlighted;

    // Calculate offset for parallel edges between same nodes
    // Normalize node pair to ensure consistent ordering (smaller id first)
    const nodeA = Math.min(e.a, e.b);
    const nodeB = Math.max(e.a, e.b);
    const isReversed = e.a > e.b; // Track if this edge is in reverse direction
    
    const parallelEdges = state.edges.filter(edge => {
      const edgeNodeA = Math.min(edge.a, edge.b);
      const edgeNodeB = Math.max(edge.a, edge.b);
      return edgeNodeA === nodeA && edgeNodeB === nodeB;
    });
    
    // Sort parallel edges by id for consistent ordering
    parallelEdges.sort((x, y) => x.id - y.id);
    
    const edgeIndex = parallelEdges.findIndex(edge => edge.id === e.id);
    const totalParallel = parallelEdges.length;
    
    console.log(`[PARALLEL] Edge ${e.id}: index=${edgeIndex}, total=${totalParallel}`);
    
    // Calculate perpendicular offset
    let offsetX = 0, offsetY = 0;
    if (totalParallel > 1) {
      // Always calculate direction from lower node id to higher node id for consistency
      const lowNode = findNode(nodeA);
      const highNode = findNode(nodeB);
      const dx = highNode.x - lowNode.x;
      const dy = highNode.y - lowNode.y;
      const len = Math.sqrt(dx*dx + dy*dy) || 1;
      // Perpendicular unit vector
      const perpX = -dy / len;
      const perpY = dx / len;
      // Spread edges evenly: offset from center
      const spacing = 15; // pixels between parallel edges
      const offsetAmount = (edgeIndex - (totalParallel - 1) / 2) * spacing;
      offsetX = perpX * offsetAmount;
      offsetY = perpY * offsetAmount;
      
      console.log(`[PARALLEL] Edge ${e.id}: offsetAmount=${offsetAmount}, offsetX=${offsetX.toFixed(2)}, offsetY=${offsetY.toFixed(2)}`);
    }

    // Offset node positions for this edge
    const ax = a.x + offsetX;
    const ay = a.y + offsetY;
    const bx = b.x + offsetX;
    const by = b.y + offsetY;

    // Draw highlight glow behind edge if highlighted
    if (isHighlighted) {
      const glowPath = document.createElementNS('http://www.w3.org/2000/svg','path');
      if (e.style === 'orthogonal') {
        glowPath.setAttribute('d', orthogonalPath(ax,ay,bx,by, e.route || 'hv'));
      } else if (e.style === 'curve') {
        glowPath.setAttribute('d', quadraticCurvePath(ax, ay, bx, by, e.curveArch || 0.3));
      } else {
        glowPath.setAttribute('d', `M${ax},${ay} L${bx},${by}`);
      }
      glowPath.setAttribute('stroke', '#00d4ff');
      glowPath.setAttribute('stroke-width', (e.strokeW ?? 2) + 8);
      glowPath.setAttribute('fill', 'none');
      glowPath.setAttribute('opacity', '0.5');
      glowPath.style.pointerEvents = 'none';
      svg.appendChild(glowPath);
    }

    let baseLabel = null;
    if (e.style === 'orthogonal') {
      // Draw the visible edge
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', orthogonalPath(ax,ay,bx,by, e.route || 'hv'));
      p.setAttribute('class', 'edge' + (isSel ? ' selected' : ''));
      p.setAttribute('data-edge-id', e.id);
      p.setAttribute('stroke-width', (e.strokeW ?? 2));
      p.setAttribute('stroke', e.strokeColor || "#7f8aa6");
      // Apply line style
      if (e.lineStyle && e.lineStyle !== 'solid') {
        p.setAttribute('stroke-dasharray', getStrokeDasharray(e.lineStyle, e.strokeW ?? 2));
      }
      p.style.pointerEvents = 'none'; // Disable clicks on visible edge
      svg.appendChild(p);
      
      // Add invisible wide hit area for easier clicking
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg','path');
      hitArea.setAttribute('d', orthogonalPath(ax,ay,bx,by, e.route || 'hv'));
      hitArea.setAttribute('stroke', 'transparent');
      hitArea.setAttribute('stroke-width', 20); // Wide invisible hit area
      hitArea.setAttribute('fill', 'none');
      hitArea.style.cursor = 'pointer';
      hitArea.addEventListener('click', (ev) => { 
        ev.stopPropagation(); 
        // Handle link pick modes in calculation mode
        if (window.routeFinderState && window.routeFinderState.active) {
          if (window.routeFinderState.pickMode === 'excludeLink') {
            addExcludedLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          if (window.routeFinderState.pickMode === 'mustUseLink') {
            addMustUseLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          return;
        }
        // Handle cable system add mode
        if (typeof handleAddModeClick === 'function' && handleAddModeClick('edge', e.id)) {
          return;
        }
        if (ev.shiftKey) {
          if (state.selection.edges.has(e.id)) {
            state.selection.edges.delete(e.id);
            state.selected = null;
          } else {
            state.selection.edges.add(e.id);
            state.selected = null;
          }
          render();
          return;
        }
        select({type:'edge', id:e.id}); 
        state.connectFrom=null; 
        render(); 
      });
      svg.appendChild(hitArea);
      
      baseLabel = orthogonalBaseLabelPoint(ax,ay,bx,by, e.route || 'hv');
    } else if (e.style === 'curve') {
      // Draw the visible edge
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', quadraticCurvePath(ax, ay, bx, by, e.curveArch || 0.3));
      p.setAttribute('class', 'edge' + (isSel ? ' selected' : ''));
      p.setAttribute('data-edge-id', e.id);
      p.setAttribute('stroke-width', (e.strokeW ?? 2));
      p.setAttribute('stroke', e.strokeColor || "#7f8aa6");
      p.setAttribute('fill', 'none');
      // Apply line style
      if (e.lineStyle && e.lineStyle !== 'solid') {
        p.setAttribute('stroke-dasharray', getStrokeDasharray(e.lineStyle, e.strokeW ?? 2));
      }
      p.style.pointerEvents = 'none'; // Disable clicks on visible edge
      svg.appendChild(p);
      
      // Add invisible wide hit area for easier clicking
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg','path');
      hitArea.setAttribute('d', quadraticCurvePath(ax, ay, bx, by, e.curveArch || 0.3));
      hitArea.setAttribute('stroke', 'transparent');
      hitArea.setAttribute('stroke-width', 20); // Wide invisible hit area
      hitArea.setAttribute('fill', 'none');
      hitArea.style.cursor = 'pointer';
      hitArea.addEventListener('click', (ev) => { 
        ev.stopPropagation(); 
        // Handle link pick modes in calculation mode
        if (window.routeFinderState && window.routeFinderState.active) {
          if (window.routeFinderState.pickMode === 'excludeLink') {
            addExcludedLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          if (window.routeFinderState.pickMode === 'mustUseLink') {
            addMustUseLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          return;
        }
        // Handle cable system add mode
        if (typeof handleAddModeClick === 'function' && handleAddModeClick('edge', e.id)) {
          return;
        }
        if (ev.shiftKey) {
          if (state.selection.edges.has(e.id)) {
            state.selection.edges.delete(e.id);
            state.selected = null;
          } else {
            state.selection.edges.add(e.id);
            state.selected = null;
          }
          render();
          return;
        }
        select({type:'edge', id:e.id}); 
        state.connectFrom=null; 
        render(); 
      });
      svg.appendChild(hitArea);
      
      baseLabel = curveBaseLabelPoint(ax, ay, bx, by, e.curveArch || 0.3);
      
      // Draw draggable handle at curve midpoint when selected
      if (isSel) {
        const cp = getCurveControlPoint(ax, ay, bx, by, e.curveArch || 0.3);
        const handle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        handle.setAttribute('cx', cp.x);
        handle.setAttribute('cy', cp.y);
        handle.setAttribute('r', 6);
        handle.setAttribute('fill', '#ff6b6b');
        handle.setAttribute('stroke', '#ffffff');
        handle.setAttribute('stroke-width', 2);
        handle.style.cursor = 'grab';
        handle.addEventListener('mousedown', (ev) => {
          ev.stopPropagation();
          state.dragging = {type: 'curveHandle', edgeId: e.id, startX: ev.clientX, startY: ev.clientY, baseArch: e.curveArch || 0.3};
          handle.style.cursor = 'grabbing';
        });
        svg.appendChild(handle);
      }
    } else {
      console.log(`[DRAW EDGE] Creating STRAIGHT line from (${ax}, ${ay}) to (${bx}, ${by}), color: ${e.strokeColor || "#7f8aa6"}, strokeW: ${e.strokeW ?? 2}`);
      
      // Draw the visible edge
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', ax); line.setAttribute('y1', ay);
      line.setAttribute('x2', bx); line.setAttribute('y2', by);
      line.setAttribute('class', 'edge' + (isSel ? ' selected' : ''));
      line.setAttribute('data-edge-id', e.id);
      line.setAttribute('stroke-width', (e.strokeW ?? 2));
      line.setAttribute('stroke', e.strokeColor || "#7f8aa6");
      // Apply line style
      if (e.lineStyle && e.lineStyle !== 'solid') {
        line.setAttribute('stroke-dasharray', getStrokeDasharray(e.lineStyle, e.strokeW ?? 2));
      }
      line.style.pointerEvents = 'none'; // Disable clicks on visible edge
      console.log(`[DRAW EDGE] Line element created and appending to SVG`);
      svg.appendChild(line);
      
      // Add invisible wide hit area for easier clicking
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg','line');
      hitArea.setAttribute('x1', ax); hitArea.setAttribute('y1', ay);
      hitArea.setAttribute('x2', bx); hitArea.setAttribute('y2', by);
      hitArea.setAttribute('stroke', 'transparent');
      hitArea.setAttribute('stroke-width', 20); // Wide invisible hit area
      hitArea.style.cursor = 'pointer';
      hitArea.addEventListener('click', (ev) => { 
        ev.stopPropagation(); 
        // Handle link pick modes in calculation mode
        if (window.routeFinderState && window.routeFinderState.active) {
          if (window.routeFinderState.pickMode === 'excludeLink') {
            addExcludedLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          if (window.routeFinderState.pickMode === 'mustUseLink') {
            addMustUseLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          return;
        }
        // Handle cable system add mode
        if (typeof handleAddModeClick === 'function' && handleAddModeClick('edge', e.id)) {
          return;
        }
        if (ev.shiftKey) {
          if (state.selection.edges.has(e.id)) {
            state.selection.edges.delete(e.id);
            state.selected = null;
          } else {
            state.selection.edges.add(e.id);
            state.selected = null;
          }
          render();
          return;
        }
        select({type:'edge', id:e.id}); 
        state.connectFrom=null; 
        render(); 
      });
      svg.appendChild(hitArea);
      
      console.log(`[DRAW EDGE] Line appended to SVG`);
      baseLabel = { x:(ax+bx)/2, y:(ay+by)/2 };
    }

    const lx = baseLabel.x + (e.labelDx || 0);
    const ly = baseLabel.y + (e.labelDy || 0);

    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('x', lx);
    label.setAttribute('y', ly);
    label.setAttribute('class', 'edge-label');
    label.setAttribute('fill', e.tagColor || "#eaeaea");
    label.style.fontSize = (e.tagSize || 12) + "px";
    label.style.fontFamily = e.tagFont || 'Arial';
    label.style.pointerEvents = "auto";
    setMultilineText(label, getEdgeLabelLines(e), (e.tagSize || 12));

    label.addEventListener('click', (ev) => { 
      ev.stopPropagation(); 
      if (ev.shiftKey) {
        if (state.selection.edges.has(e.id)) {
          state.selection.edges.delete(e.id);
          state.selected = null;
        } else {
          state.selection.edges.add(e.id);
          state.selected = null;
        }
        render();
        return;
      }
      select({type:'edge', id:e.id}); 
      state.connectFrom=null; 
      render(); 
    });
    label.addEventListener('mousedown', (ev) => {
      if (!(ev.ctrlKey || ev.metaKey)) return;
      ev.stopPropagation();
      const m = getMouse(ev);
      state.dragging = { type:'edgeLabel', id:e.id, dx: lx - m.x, dy: ly - m.y };
      select({type:'edge', id:e.id});
      state.connectFrom = null;
      render();
    });

    svg.appendChild(label);
  }

  // Calculate node bounding box based on shape and size
  function getNodeBounds(n) {
    const r = n.r ?? 24;
    const shape = n.shape || 'circle';
    
    let x, y, w, h;
    
    switch (shape) {
      case 'square':
        x = n.x - r;
        y = n.y - r;
        w = r * 2;
        h = r * 2;
        break;
      case 'rectangle':
        x = n.x - r * 1.35;
        y = n.y - r * 0.85;
        w = r * 2.7;
        h = r * 1.7;
        break;
      case 'ellipse':
        x = n.x - r * 1.35;
        y = n.y - r * 0.9;
        w = r * 2.7;
        h = r * 1.8;
        break;
      case 'triangle':
        x = n.x - r * 1.25;
        y = n.y - r * 1.25;
        w = r * 2.5;
        h = r * 2.5;
        break;
      case 'hexagon':
        x = n.x - r * 1.2;
        y = n.y - r * 1.2;
        w = r * 2.4;
        h = r * 2.4;
        break;
      default: // circle
        x = n.x - r;
        y = n.y - r;
        w = r * 2;
        h = r * 2;
    }
    
    return { x, y, w, h };
  }

  function drawNode(n) {
    // console.log(`[DRAW] Creating node ${n.id} at (${n.x}, ${n.y})`);
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.dataset.nodeId = n.id; // For context menu lookup
    const isSelected = (state.selected?.type==='node' && state.selected.id===n.id) || state.selection.nodes.has(n.id);
    const isLinkSource = linkMode && linkSourceNode === n.id;
    const isInLinkMode = linkMode && isSelected; // In link mode, all selected nodes show as potential sources
    
    // Check if this node should be highlighted (cable system selection or temporary highlight)
    const nodeCSIds = n.cableSystemIds || [];
    const isCSHighlighted = state.selectedCableSystem && nodeCSIds.includes(state.selectedCableSystem);
    const isTempHighlighted = state._highlightedNodes && state._highlightedNodes.has(n.id);
    const isHighlighted = isCSHighlighted || isTempHighlighted;
    
    let classes = 'node';
    // In link mode, show orange for source (pulsing) or any selected node (ready to be source)
    if (isLinkSource) {
      classes += ' link-source'; // Orange pulsing
    } else if (isInLinkMode) {
      classes += ' link-source'; // Orange (same style, shows it's ready to be selected as source)
    } else if (isSelected) {
      classes += ' selected'; // Normal cyan selection (when not in link mode)
    }
    g.setAttribute('class', classes);

    const r = (n.r ?? 24);
    const sw = (n.strokeW ?? 2);
    
    // Draw highlight glow behind node if highlighted
    if (isHighlighted) {
      const shape = (n.shape || 'circle');
      let glow = null;
      if (shape === 'square') {
        glow = document.createElementNS('http://www.w3.org/2000/svg','rect');
        glow.setAttribute('x', n.x - r - 4);
        glow.setAttribute('y', n.y - r - 4);
        glow.setAttribute('width', r*2 + 8);
        glow.setAttribute('height', r*2 + 8);
        glow.setAttribute('rx', 6);
        glow.setAttribute('ry', 6);
      } else if (shape === 'rectangle') {
        glow = document.createElementNS('http://www.w3.org/2000/svg','rect');
        glow.setAttribute('x', n.x - r*1.35 - 4);
        glow.setAttribute('y', n.y - r*0.85 - 4);
        glow.setAttribute('width', r*2.7 + 8);
        glow.setAttribute('height', r*1.7 + 8);
        glow.setAttribute('rx', 8);
        glow.setAttribute('ry', 8);
      } else if (shape === 'ellipse') {
        glow = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
        glow.setAttribute('cx', n.x);
        glow.setAttribute('cy', n.y);
        glow.setAttribute('rx', r*1.35 + 4);
        glow.setAttribute('ry', r*0.9 + 4);
      } else {
        glow = document.createElementNS('http://www.w3.org/2000/svg','circle');
        glow.setAttribute('cx', n.x);
        glow.setAttribute('cy', n.y);
        glow.setAttribute('r', r + 4);
      }
      glow.setAttribute('fill', 'none');
      glow.setAttribute('stroke', '#00d4ff');
      glow.setAttribute('stroke-width', 6);
      glow.setAttribute('opacity', '0.6');
      glow.style.pointerEvents = 'none';
      g.appendChild(glow);
    }
    
    let c = null;
    const shape = (n.shape || 'circle');
    
    // Check for custom SVG shape from library
    if (n.customSvg) {
      // Create a group to hold the custom SVG
      c = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      c.setAttribute('class', 'node-circle custom-svg-node');
      
      // Parse and insert the SVG
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(n.customSvg, 'image/svg+xml');
      const svgEl = svgDoc.querySelector('svg');
      
      if (svgEl) {
        // Get viewBox or create one
        let vb = svgEl.getAttribute('viewBox');
        if (!vb) {
          const w = parseFloat(svgEl.getAttribute('width')) || 64;
          const h = parseFloat(svgEl.getAttribute('height')) || 64;
          vb = `0 0 ${w} ${h}`;
        }
        const [vbX, vbY, vbW, vbH] = vb.split(/[\s,]+/).map(Number);
        
        // Calculate scale and position
        const size = r * 2;
        const scale = size / Math.max(vbW, vbH);
        const offsetX = n.x - (vbW * scale) / 2;
        const offsetY = n.y - (vbH * scale) / 2;
        
        c.setAttribute('transform', `translate(${offsetX}, ${offsetY}) scale(${scale})`);
        
        // Clone child elements into our group
        Array.from(svgEl.childNodes).forEach(child => {
          if (child.nodeType === 1) { // Element node
            c.appendChild(child.cloneNode(true));
          }
        });
      }
      
      // Set pointerEvents to none on the visual, hitArea will handle clicks
      c.style.pointerEvents = 'none';
      
      // Add hit area AFTER c so it's on top in the DOM (but visually transparent)
      // This is handled below after c is appended to g
    } else if (shape === 'square') {
      c = document.createElementNS('http://www.w3.org/2000/svg','rect');
      c.setAttribute('x', n.x - r);
      c.setAttribute('y', n.y - r);
      c.setAttribute('width', r*2);
      c.setAttribute('height', r*2);
      c.setAttribute('rx', 4);
      c.setAttribute('ry', 4);
    } else if (shape === 'rectangle') {
      c = document.createElementNS('http://www.w3.org/2000/svg','rect');
      c.setAttribute('x', n.x - r*1.35);
      c.setAttribute('y', n.y - r*0.85);
      c.setAttribute('width', r*2.7);
      c.setAttribute('height', r*1.7);
      c.setAttribute('rx', 6);
      c.setAttribute('ry', 6);
    } else if (shape === 'ellipse') {
      c = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
      c.setAttribute('cx', n.x);
      c.setAttribute('cy', n.y);
      c.setAttribute('rx', r*1.35);
      c.setAttribute('ry', r*0.9);
    } else if (shape === 'triangle') {
      c = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      c.setAttribute('points', polygonPoints(n.x, n.y, r*1.25, 3, -Math.PI/2));
    } else if (shape === 'hexagon') {
      c = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      c.setAttribute('points', polygonPoints(n.x, n.y, r*1.2, 6, Math.PI/6));
    } else {
      c = document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('cx', n.x);
      c.setAttribute('cy', n.y);
      c.setAttribute('r', r);
    }
    
    // Apply styling only to built-in shapes (not custom SVGs)
    if (!n.customSvg) {
      c.setAttribute('class', 'node-circle');
      c.setAttribute('fill', n.fill || "#1b2030");
      c.setAttribute('stroke', n.stroke || "#9fb3ff");
      c.setAttribute('stroke-width', sw);
      // Apply line style to node border
      if (n.lineStyle && n.lineStyle !== 'solid') {
        c.setAttribute('stroke-dasharray', getStrokeDasharray(n.lineStyle, sw));
      }
      c.style.pointerEvents = "auto";
      c.style.cursor = "pointer";
    }
    
    // Attach click listener directly to circle for better event capture
    // This is now handled by the group click listener above
    // console.log(`[DRAW] Attaching click listener to node ${n.id}`, {tagName: c.tagName, class: c.getAttribute('class'), r, x: n.x, y: n.y});
    // (old click listener code removed - now using group click handler)

    const nameX = n.x + (n.nameDx || 0);
    const nameY = n.y + (n.nameDy || 0);

    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', nameX);
    t.setAttribute('y', nameY);
    t.setAttribute('class', 'node-text');
    // Default fill (will be overridden by tspan styles)
    t.setAttribute('fill', n.nameColor || "#eaeaea");
    
    const styledLines = [];
    // Node Code - show if globally enabled AND per-node enabled (defaults to true)
    if (state.ui.showNodeCode && n.showCode !== false && n.code && n.code.trim()) {
      styledLines.push({
        text: n.code.trim(),
        fill: n.codeColor || "#000000",
        fontSize: n.codeSize || 13,
        fontFamily: n.codeFont || 'Arial'
      });
    }
    // Node Name - show if globally enabled AND per-node enabled (defaults to true)
    if (state.ui.showNodeName !== false && n.showName !== false) {
      styledLines.push({
        text: n.name || `N${n.id}`,
        fill: n.nameColor || "#eaeaea",
        fontSize: n.nameSize || 13,
        fontFamily: n.nameFont || 'Arial'
      });
    }
    setStyledMultilineText(t, styledLines);
    t.style.pointerEvents = "auto";  // Enable pointer events for Ctrl+drag
    t.style.cursor = "default";

    const tagX = n.x + (n.tagDx || 0);
    const tagY = n.y + 26 + (n.tagDy || 0);

    const tags = document.createElementNS('http://www.w3.org/2000/svg','text');
    tags.setAttribute('x', tagX);
    tags.setAttribute('y', tagY);
    tags.setAttribute('class', 'tag-text');
    tags.setAttribute('fill', n.extraTagsColor || "#b7c0df");
    tags.style.fontSize = (n.extraTagsSize || 11) + "px";
    tags.style.fontFamily = n.extraTagsFont || 'Arial';
    
    // Build tag text based on visibility settings
    const tagParts = [];
    // Show node tags if globally enabled AND per-node enabled
    if (state.ui.showNodeTags && n.tags?.length) {
      tagParts.push(n.tags.join(', '));
    }
    // Show extra tags if per-node enabled (defaults to false)
    if (n.showExtraTags && n.extraTags?.trim()) {
      tagParts.push(n.extraTags.trim());
    }
    tags.textContent = tagParts.join(' | ');
    
    tags.style.pointerEvents = "auto";  // Enable pointer events for Ctrl+drag
    tags.style.cursor = "default";

    g.appendChild(c); g.appendChild(t); g.appendChild(tags);
    
    // For custom SVG nodes, add hit area on top for click detection
    if (n.customSvg) {
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      hitArea.setAttribute('cx', n.x);
      hitArea.setAttribute('cy', n.y);
      hitArea.setAttribute('r', r);
      hitArea.setAttribute('fill', 'transparent');
      hitArea.setAttribute('class', 'node-circle node-circle-hit');
      hitArea.style.pointerEvents = 'auto';
      hitArea.style.cursor = 'pointer';
      g.appendChild(hitArea);
    }

    // Add resize handles at corners (invisible but functional)
    const handleSize = 8;
    const nodeBounds = getNodeBounds(n);
    const nodeHandlePositions = [
      { corner: 'nw', x: nodeBounds.x, y: nodeBounds.y },
      { corner: 'ne', x: nodeBounds.x + nodeBounds.w - handleSize, y: nodeBounds.y },
      { corner: 'sw', x: nodeBounds.x, y: nodeBounds.y + nodeBounds.h - handleSize },
      { corner: 'se', x: nodeBounds.x + nodeBounds.w - handleSize, y: nodeBounds.y + nodeBounds.h - handleSize }
    ];
    
    nodeHandlePositions.forEach(pos => {
      const resizeHandle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      resizeHandle.setAttribute('x', pos.x);
      resizeHandle.setAttribute('y', pos.y);
      resizeHandle.setAttribute('width', handleSize);
      resizeHandle.setAttribute('height', handleSize);
      resizeHandle.setAttribute('rx', 2);
      resizeHandle.setAttribute('ry', 2);
      resizeHandle.setAttribute('class', `node-resize-handle handle-${pos.corner}`);
      resizeHandle.setAttribute('data-corner', pos.corner);
      
      resizeHandle.addEventListener('mousedown', (ev) => {
        ev.stopPropagation();
        const m = getMouse(ev);
        select({type:'node', id:n.id});
        state.resizingNode = {
          id: n.id,
          corner: pos.corner,
          startR: r,
          startX: n.x,
          startY: n.y,
          mx0: m.x,
          my0: m.y
        };
        state.connectFrom = null;
        render();
      });
      
      g.appendChild(resizeHandle);
    });

    // Handle clicks on the node group (for link mode and regular selection)
    // Use mouseup instead of click to ensure it fires even after mousedown's stopPropagation
    console.log(`[NODE LISTENER] Attaching mouseup listener to node ${n.id}`);
    g.addEventListener('mouseup', (ev) => {
      const isWithinGroup = g.contains(ev.target);
      const isCircle = ev.target === c;
      const isGroup = ev.target === g;
      console.log(`[NODE CLICK] Node ${n.id} - mouseup target: ${ev.target.tagName}/${ev.target.getAttribute?.('class') ?? 'none'}, isCircle: ${isCircle}, isGroup: ${isGroup}, withinGroup: ${isWithinGroup}, linkMode: ${linkMode}, dragging: ${!!state.dragging}`);
      
      // Process if clicked on circle, group, or any child within the group
      if (isCircle || isGroup || isWithinGroup) {
        console.log(`[NODE CLICK] Node ${n.id} clicked (mouseup) - linkMode: ${linkMode}, linkSourceNode: ${linkSourceNode}`);
        
        // Handle link mode clicks - these take priority over drag detection
        if (linkMode) {
          ev.stopPropagation(); // Only stop propagation in link mode
          if (linkSourceNode === null) {
            // First click - set source node
            linkSourceNode = n.id;
            console.log(`[LINK MODE] Node ${n.id} set as SOURCE - waiting for target click`);
            select({type:'node', id:n.id});
            render(); // Show the orange highlight for the source node
            showToast(`Link source selected: ${n.name || `N${n.id}`} ‚Üí Now click target node`);
            return;
          } else {
            // Second click - create link
            if (linkSourceNode === n.id) {
              console.log(`[LINK MODE] Node ${n.id} - ERROR: Cannot link to itself`);
              showToast('‚ùå Cannot link node to itself - click a different target node');
              return;
            }
            console.log(`[LINK MODE] Node ${n.id} set as TARGET - Creating link from ${linkSourceNode} to ${n.id}`);
            const sourceId = linkSourceNode;
            linkSourceNode = null;  // Reset for next link - ready to select new source
            createEdge(sourceId, n.id, true); // Skip edge selection in link mode
            clearSelection(); // Clear any selection to show we're ready for next source
            render(); // Update display to show cleared selection
            showToast(`‚úì Link created! Click a node to be the source for the next link`);
            return;
          }
        }
        
        // Handle cable system add mode
        if (typeof handleAddModeClick === 'function' && handleAddModeClick('node', n.id)) {
          ev.stopPropagation();
          return;
        }
        
        // Handle calculation mode (Route Finder) - intercept clicks to set origin/destination
        if (window.routeFinderState && window.routeFinderState.active) {
          ev.stopPropagation();
          if (typeof handleCalculationModeNodeClick === 'function') {
            handleCalculationModeNodeClick(n.id);
          }
          return;
        }
        
        // Check if this was actually a drag operation (only matters outside link mode)
        if (state.dragging) {
          console.log(`[NODE CLICK] Node ${n.id} - Was dragging, letting global handler clear state`);
          // Don't stop propagation - let the global mouseup handler clear state.dragging
          return;
        }
        
        // Not in link mode and not dragging - regular selection click
        console.log(`[NODE CLICK] Node ${n.id} - Normal selection`);
        ev.stopPropagation();
        
        // Handle shift-click for multi-selection
        if (ev.shiftKey) {
          if (state.selection.nodes.has(n.id)) {
            state.selection.nodes.delete(n.id);
            state.selected = null;
          } else {
            state.selection.nodes.add(n.id);
            state.selected = null;
          }
          render();
          return;
        }
        
        // Normal click - select this node
        select({type:'node', id:n.id});
        render();
      }
    });

    g.addEventListener('mousedown', (ev) => {
      // In link mode, don't set up dragging or select - let mouseup handle everything
      if (linkMode) {
        ev.stopPropagation();
        console.log(`[NODE MOUSEDOWN] Node ${n.id} - in link mode, skipping drag setup`);
        return;
      }
      
      // In calculation mode (Route Finder), don't drag - let mouseup handle selection
      if (window.routeFinderState && window.routeFinderState.active) {
        ev.stopPropagation();
        return;
      }

      // Shift+click without Ctrl - let mouseup handle multi-selection, don't set up dragging
      if (ev.shiftKey && !(ev.ctrlKey || ev.metaKey)) {
        ev.stopPropagation();
        console.log(`[NODE MOUSEDOWN] Node ${n.id} - Shift+click, letting mouseup handle multi-select`);
        return;
      }

      // Normal mode - set up dragging
      ev.stopPropagation();
      const m = getMouse(ev);
      state.lastMouse = { x: m.x, y: m.y };

      // Ctrl+Shift+drag duplicates current selection and drags the copy
      if ((ev.ctrlKey || ev.metaKey) && ev.shiftKey) {
        if (!state.selection.nodes.has(n.id) && !state.selection.groups.size && !state.selection.edges.size) {
          setSingleSelection({type:'node', id:n.id});
        }
        copySelection();
        pasteSelection();
        // start dragging the pasted selection as a block
        const origNodes = [...state.selection.nodes].map(id => {
          const nn = findNode(id); return nn ? {id, x: nn.x, y: nn.y} : null;
        }).filter(Boolean);
        const origGroups = [...state.selection.groups].map(id => {
          const gg = findGroup(id); return gg ? {id, x: gg.x, y: gg.y} : null;
        }).filter(Boolean);
        state.dragging = { type:'selection', mx0: m.x, my0: m.y, origNodes, origGroups };
        state.connectFrom = null;
        render();
        return;
      }

      // Check BEFORE calling select() to preserve multi-selection if dragging
      // If the clicked node is part of a multi-selection, drag entire selection
      if (state.selection.nodes.has(n.id) && (state.selection.nodes.size > 1 || state.selection.groups.size > 0)) {
        console.log(`[MULTI-DRAG] Node ${n.id} is part of multi-selection (${state.selection.nodes.size} nodes, ${state.selection.groups.size} groups) - setting up multi-drag`);
        const origNodes = [...state.selection.nodes].map(id => {
          const nn = findNode(id); return nn ? {id, x: nn.x, y: nn.y} : null;
        }).filter(Boolean);
        const origGroups = [...state.selection.groups].map(id => {
          const gg = findGroup(id); return gg ? {id, x: gg.x, y: gg.y} : null;
        }).filter(Boolean);
        state.dragging = { type:'selection', mx0: m.x, my0: m.y, origNodes, origGroups };
        state.selected = null; // Clear single selection when dragging multiple
        console.log(`[MULTI-DRAG] Dragging ${origNodes.length} nodes and ${origGroups.length} groups`);
      } else {
        console.log(`[SINGLE-DRAG] Node ${n.id} - single selection drag setup`);
        // Don't call select() here - it triggers render() which recreates DOM and breaks drag
        // Just add to selection set for visual feedback
        if (!state.selection.nodes.has(n.id)) {
          setSingleSelection({type:'node', id:n.id});
        }
        state.dragging = { type:'node', id:n.id, dx: n.x - m.x, dy: n.y - m.y };
      }
      state.connectFrom = null;
    });

    t.addEventListener('mousedown', (ev) => {
      console.log(`[TEXT MOUSEDOWN] Node ${n.id} name label - Ctrl: ${ev.ctrlKey}, Meta: ${ev.metaKey}`);
      // Ctrl+drag to move the label
      if (ev.ctrlKey || ev.metaKey) {
        console.log(`[TEXT MOUSEDOWN] Node ${n.id} - Setting up name label drag`);
        ev.stopPropagation();
        const m = getMouse(ev);
        state.dragging = { type:'nodeNameLabel', id:n.id, dx: nameX - m.x, dy: nameY - m.y };
        select({type:'node', id:n.id});
        state.connectFrom = null;
        render();
        return;
      }
      // Normal click - don't handle it here, let it bubble to parent group
    });
    
    tags.addEventListener('mousedown', (ev) => {
      console.log(`[TAGS MOUSEDOWN] Node ${n.id} tags - Ctrl: ${ev.ctrlKey}, Meta: ${ev.metaKey}`);
      // Ctrl+drag to move the tags
      if (ev.ctrlKey || ev.metaKey) {
        console.log(`[TAGS MOUSEDOWN] Node ${n.id} - Setting up tags drag`);
        ev.stopPropagation();
        const m = getMouse(ev);
        state.dragging = { type:'nodeTagLabel', id:n.id, dx: tagX - m.x, dy: tagY - m.y };
        select({type:'node', id:n.id});
        state.connectFrom = null;
        render();
        return;
      }
      // Normal click - don't handle it here, let it bubble to parent group
    });

    // console.log(`[DRAW] Node ${n.id} fully created, appending to SVG`);
    svg.appendChild(g);
    // Verify circle is in DOM and has proper bounds
    const circles = g.querySelectorAll('circle, polygon');
    // console.log(`[DRAW] Node ${n.id} appended - found ${circles.length} circle(s) in group`, circles[0] ? {cx: circles[0].getAttribute('cx'), cy: circles[0].getAttribute('cy'), r: circles[0].getAttribute('r')} : 'none');
  }

  const noSel = document.getElementById('noSelection');
  const nodeIns = document.getElementById('nodeInspector');
  const edgeIns = document.getElementById('edgeInspector');
  const groupIns = document.getElementById('groupInspector');

  // UUID fields (read-only)
  const nodeUUID = document.getElementById('nodeUUID');
  const edgeUUID = document.getElementById('edgeUUID');
  const edgeSourceUUID = document.getElementById('edgeSourceUUID');
  const edgeTargetUUID = document.getElementById('edgeTargetUUID');
  const groupUUID = document.getElementById('groupUUID');

  const nodeName = document.getElementById('nodeName');
  const nodeTags = document.getElementById('nodeTags');
  const nodeGroup = document.getElementById('nodeGroup');
  const nodeExtraTags = document.getElementById('nodeExtraTags');
  const nodeCode = document.getElementById('nodeCode');
  const nodeShowCode = document.getElementById('nodeShowCode');
  const nodeNameFont = document.getElementById('nodeNameFont');
  const nodeTagFont = document.getElementById('nodeTagFont');
  const nodeNameColor = document.getElementById('nodeNameColor');
  const nodeTagColor = document.getElementById('nodeTagColor');
  const nodeFill = document.getElementById('nodeFill');
  const nodeStroke = document.getElementById('nodeStroke');
  const nodeStrokeW = document.getElementById('nodeStrokeW');
  const nodeAddress = document.getElementById('nodeAddress');
const nodeCity = document.getElementById('nodeCity');
const nodeCountry = document.getElementById('nodeCountry');
  const nodeSize = document.getElementById('nodeSize');
const edgeTag = document.getElementById('edgeTag');
  const edgeFilterTags = document.getElementById('edgeFilterTags');
  const edgeLatency = document.getElementById('edgeLatency');
  const edgeExtraTags = document.getElementById('edgeExtraTags');
  const edgeCode = document.getElementById('edgeCode');
  const edgeShowCode = document.getElementById('edgeShowCode');
  const edgeStyle = document.getElementById('edgeStyle');
  const edgeRoute = document.getElementById('edgeRoute');
  const edgeLabelFont = document.getElementById('edgeLabelFont');
  const edgeLabelColor = document.getElementById('edgeLabelColor');
  const edgeStrokeW = document.getElementById('edgeStrokeW');
  const edgeCapacity = document.getElementById('edgeCapacity');
  const edgePriority = document.getElementById('edgePriority');
  const edgeStrokeColor = document.getElementById('edgeStrokeColor');
const groupTitle = document.getElementById('groupTitle');
  const groupFilterTags = document.getElementById('groupFilterTags');
  const groupType = document.getElementById('groupType');
  const groupParent = document.getElementById('groupParent');
  const groupExtraTags = document.getElementById('groupExtraTags');
  const groupW = document.getElementById('groupW');
  const groupH = document.getElementById('groupH');
  const groupTitleFont = document.getElementById('groupTitleFont');
  const groupTitleColor = document.getElementById('groupTitleColor');
  const groupFill = document.getElementById('groupFill');
  const groupStroke = document.getElementById('groupStroke');
  const groupStrokeW = document.getElementById('groupStrokeW');

  // Preset controls
  const btnNodePresetSave = document.getElementById('btnNodePresetSave');
  const btnNodePresetApply = document.getElementById('btnNodePresetApply');
  const btnNodePresetDelete = document.getElementById('btnNodePresetDelete');

  const btnEdgePresetSave = document.getElementById('btnEdgePresetSave');
  const btnEdgePresetApply = document.getElementById('btnEdgePresetApply');
  const btnEdgePresetDelete = document.getElementById('btnEdgePresetDelete');

  const btnGroupPresetSave = document.getElementById('btnGroupPresetSave');
  const btnGroupPresetApply = document.getElementById('btnGroupPresetApply');
  const btnGroupPresetDelete = document.getElementById('btnGroupPresetDelete');


  
  function clearSelection(keepSingle=false) {
    state.selection.nodes.clear();
    state.selection.edges.clear();
    state.selection.groups.clear();
    if (!keepSingle) state.selected = null;
  }

  function setSingleSelection(sel) {
    clearSelection(true);
    state.selected = sel;
    if (sel) {
      console.log(`[SELECTION] ${sel.type.toUpperCase()} selected: id=${sel.id}`);
    }
    if (!sel) return;

    // Apply format painter if armed (single-click targets)
    if (state.styleBrush && state.styleBrush.type === sel.type) {
      if (sel.type === 'node') {
        const n = findNode(sel.id); if (n) applyStyle('node', n, state.styleBrush.style);
      } else if (sel.type === 'edge') {
        const e = findEdge(sel.id); if (e) applyStyle('edge', e, state.styleBrush.style);
      } else if (sel.type === 'group') {
        const g = findGroup(sel.id); if (g) applyStyle('group', g, state.styleBrush.style);
      }
      commit();
    }

    if (sel.type === 'node') state.selection.nodes.add(sel.id);
    if (sel.type === 'edge') state.selection.edges.add(sel.id);
    if (sel.type === 'group') state.selection.groups.add(sel.id);
  }

  function setMultiSelection({nodes=[], edges=[], groups=[]}) {
    state.selected = null;
    state.selection.nodes = new Set(nodes);
    state.selection.edges = new Set(edges);
    state.selection.groups = new Set(groups);
  }

  function deleteSelection() {
    const nIds = new Set(state.selection.nodes);
    const eIds = new Set(state.selection.edges);
    const gIds = new Set(state.selection.groups);
    if (nIds.size===0 && eIds.size===0 && gIds.size===0) return;

    // Delete edges explicitly selected
    if (eIds.size) state.edges = state.edges.filter(e => !eIds.has(e.id));

    // Delete nodes and any edges attached to them
    if (nIds.size) {
      state.nodes = state.nodes.filter(n => !nIds.has(n.id));
      state.edges = state.edges.filter(e => !nIds.has(e.a) && !nIds.has(e.b));
    }

    // Delete groups (country/region)
    if (gIds.size) {
      state.groups = state.groups.filter(g => !gIds.has(g.id));
      // Clear node membership to deleted groups
      state.nodes.forEach(n => { if (n.groupId && gIds.has(n.groupId)) n.groupId = null; });
      // Clear parentId links pointing to deleted regions
      state.groups.forEach(g => { if (g.parentId && gIds.has(g.parentId)) g.parentId = null; });
    }

    clearSelection();
    state.connectFrom = null;
    refreshAllMemberships();
    commit();
    render();
    showToast('Deleted selection.');
  }

  function select(sel) { setSingleSelection(sel); }


  function updateInspector() {
    refreshPresetSelects();
    noSel.style.display='none'; nodeIns.style.display='none'; edgeIns.style.display='none'; groupIns.style.display='none';
    noSel.textContent = 'Nothing selected.';
    
    // Update format toolbar indicators
    if (typeof updateFormatIndicators === 'function') updateFormatIndicators();
    
    if (!state.selected) {
      const c = state.selection.nodes.size + state.selection.edges.size + state.selection.groups.size;
      if (c === 0) { noSel.style.display='block'; return; }
      noSel.style.display='block';
      noSel.textContent = `Multiple selected: ${c} item(s). (Ctrl+C to copy, Ctrl+V to paste)`;
      return;
    }

    if (state.selected.type === 'node') {
      const n = findNode(state.selected.id); if (!n) return;
      nodeIns.style.display='block';
      // Show UUID (generate if missing for legacy data)
      if (!n.uuid) n.uuid = generateUUID();
      if (nodeUUID) nodeUUID.value = n.uuid;
      nodeName.value = n.name || '';
      // Ensure 'default' tag is shown in tags field
      let tagsArray = n.tags || [];
      if (!tagsArray.some(t => t.trim().toLowerCase() === 'default')) {
        tagsArray = ['default', ...tagsArray];
      }
      nodeTags.value = tagsArray.join(', ');
      nodeExtraTags.value = n.extraTags || '';
      nodeCode.value = n.code || '';
      if (nodeShowCode) nodeShowCode.value = (n.showCode !== false) ? '1' : '0';
      nodeNameFont.value = n.nameFont ?? 13;
      nodeTagFont.value = n.tagFont ?? 11;
      nodeNameColor.value = n.nameColor || "#333333";
      nodeTagColor.value = n.tagColor || "#666666";
      nodeFill.value = n.fill || "#dae8fc";
      nodeStroke.value = n.stroke || "#6c8ebf";
      // Update palette color swatches
      const nodeFillSwatch = document.getElementById('nodeFillSwatch');
      const nodeStrokeSwatch = document.getElementById('nodeStrokeSwatch');
      const nodeFillHex = document.getElementById('nodeFillHex');
      const nodeStrokeHex = document.getElementById('nodeStrokeHex');
      const nodeFillCustom = document.getElementById('nodeFillCustom');
      const nodeStrokeCustom = document.getElementById('nodeStrokeCustom');
      if (nodeFillSwatch) nodeFillSwatch.style.backgroundColor = n.fill || '#dae8fc';
      if (nodeStrokeSwatch) nodeStrokeSwatch.style.backgroundColor = n.stroke || '#6c8ebf';
      if (nodeFillHex) nodeFillHex.value = n.fill || '#dae8fc';
      if (nodeStrokeHex) nodeStrokeHex.value = n.stroke || '#6c8ebf';
      if (nodeFillCustom) nodeFillCustom.value = n.fill || '#dae8fc';
      if (nodeStrokeCustom) nodeStrokeCustom.value = n.stroke || '#6c8ebf';
      if (nodeStrokeW) nodeStrokeW.value = n.strokeW ?? 2;
      if (nodeSize) nodeSize.value = n.r ?? 24;
      if (nodeStrokeW) nodeStrokeW.value = n.strokeW ?? 2;
      const g = n.groupId ? findGroup(n.groupId) : null;
      nodeGroup.value = g ? g.title : '(none)';
      // Update cable systems checkboxes
      updateNodeCableSystemsCheckboxes(n.id);
      // Update color pickers
      if (window.updateColorPickers) window.updateColorPickers();
      
      // Sync inline controls
      const nodeNameColorSwatch = document.getElementById('nodeNameColorSwatch');
      const nodeNameColorInline = document.getElementById('nodeNameColorInline');
      const nodeNameVisibility = document.getElementById('nodeNameVisibility');
      const nodeNameFontInline = document.getElementById('nodeNameFontInline');
      if (nodeNameColorSwatch) nodeNameColorSwatch.style.backgroundColor = n.nameColor || '#eaeaea';
      if (nodeNameColorInline) nodeNameColorInline.value = n.nameColor || '#eaeaea';
      if (nodeNameFontInline) nodeNameFontInline.value = n.nameSize || 13;
      if (nodeNameVisibility) {
        nodeNameVisibility.classList.toggle('hidden', n.showName === false);
      }
      
      const nodeCodeColorSwatch = document.getElementById('nodeCodeColorSwatch');
      const nodeCodeColorInline = document.getElementById('nodeCodeColorInline');
      const nodeCodeVisibility = document.getElementById('nodeCodeVisibility');
      const nodeCodeFontInline = document.getElementById('nodeCodeFontInline');
      if (nodeCodeColorSwatch) nodeCodeColorSwatch.style.backgroundColor = n.codeColor || '#000000';
      if (nodeCodeColorInline) nodeCodeColorInline.value = n.codeColor || '#000000';
      if (nodeCodeFontInline) nodeCodeFontInline.value = n.codeSize || 13;
      if (nodeCodeVisibility) {
        nodeCodeVisibility.classList.toggle('hidden', n.showCode === false);
      }
      
      const nodeExtraTagsColorSwatch = document.getElementById('nodeExtraTagsColorSwatch');
      const nodeExtraTagsColorInline = document.getElementById('nodeExtraTagsColorInline');
      const nodeExtraTagsVisibility = document.getElementById('nodeExtraTagsVisibility');
      const nodeExtraTagsFontInline = document.getElementById('nodeExtraTagsFontInline');
      if (nodeExtraTagsColorSwatch) nodeExtraTagsColorSwatch.style.backgroundColor = n.extraTagsColor || '#b7c0df';
      if (nodeExtraTagsColorInline) nodeExtraTagsColorInline.value = n.extraTagsColor || '#b7c0df';
      if (nodeExtraTagsFontInline) nodeExtraTagsFontInline.value = n.extraTagsSize || 11;
      if (nodeExtraTagsVisibility) {
        nodeExtraTagsVisibility.classList.toggle('hidden', n.showExtraTags === false);
      }
      
      // Update GPS coordinate fields
      if (typeof updateGpsFields === 'function') {
        updateGpsFields(n);
      }
      
      return;
    }

    if (state.selected.type === 'edge') {
      const e = findEdge(state.selected.id); if (!e) return;
      edgeIns.style.display='block';
      // Show UUIDs (generate if missing for legacy data)
      if (!e.uuid) e.uuid = generateUUID();
      if (edgeUUID) edgeUUID.value = e.uuid;
      // Show source and target node UUIDs
      const sourceNode = findNode(e.a);
      const targetNode = findNode(e.b);
      if (edgeSourceUUID) {
        if (sourceNode) {
          if (!sourceNode.uuid) sourceNode.uuid = generateUUID();
          edgeSourceUUID.value = sourceNode.uuid;
        } else {
          edgeSourceUUID.value = '(unknown)';
        }
      }
      if (edgeTargetUUID) {
        if (targetNode) {
          if (!targetNode.uuid) targetNode.uuid = generateUUID();
          edgeTargetUUID.value = targetNode.uuid;
        } else {
          edgeTargetUUID.value = '(unknown)';
        }
      }
      
      // Update cable system dropdown
      updateEdgeCableSystemDropdown();
      const edgeCableSystemEl = document.getElementById('edgeCableSystem');
      if (edgeCableSystemEl) {
        edgeCableSystemEl.value = e.cableSystemId || '';
        const infoEl = document.getElementById('edgeCableSystemInfo');
        if (infoEl) {
          if (e.cableSystemId) {
            const cs = findCableSystem(e.cableSystemId);
            infoEl.textContent = cs ? cs.name : '';
          } else {
            infoEl.textContent = '';
          }
        }
      }
      
      edgeTag.value = e.tag || '';
      // Ensure 'default' tag is shown in filter tags field
      let edgeTagsArray = e.filterTags || [];
      if (!edgeTagsArray.some(t => t.trim().toLowerCase() === 'default')) {
        edgeTagsArray = ['default', ...edgeTagsArray];
      }
      if (edgeFilterTags) edgeFilterTags.value = edgeTagsArray.join(', ');
      edgeLatency.value = (typeof e.latencyMs === "number" && isFinite(e.latencyMs)) ? e.latencyMs : '';
      if (edgePriority) edgePriority.value = (typeof e.priority === "number" && isFinite(e.priority)) ? e.priority : 0;
      edgeExtraTags.value = e.extraTags || '';
      edgeCode.value = e.code || '';
      edgeStyle.value = e.style || 'straight';
      edgeRoute.value = e.route || 'hv';
      edgeLabelFont.value = e.labelFont ?? 12;
      edgeLabelColor.value = e.labelColor || "#333333";
      if (edgeStrokeW) edgeStrokeW.value = e.strokeW ?? 2;
      if (edgeStrokeColor) edgeStrokeColor.value = e.strokeColor || "#666666";
      // Update edge stroke color palette swatch
      const edgeStrokeColorSwatch = document.getElementById('edgeStrokeColorSwatch');
      const edgeStrokeColorHex = document.getElementById('edgeStrokeColorHex');
      const edgeStrokeColorCustom = document.getElementById('edgeStrokeColorCustom');
      if (edgeStrokeColorSwatch) edgeStrokeColorSwatch.style.backgroundColor = e.strokeColor || '#666666';
      if (edgeStrokeColorHex) edgeStrokeColorHex.value = e.strokeColor || '#666666';
      if (edgeStrokeColorCustom) edgeStrokeColorCustom.value = e.strokeColor || '#666666';
      // Update color pickers
      if (window.updateColorPickers) window.updateColorPickers();
      
      // Sync inline controls
      const edgeTagColorSwatch = document.getElementById('edgeTagColorSwatch');
      const edgeTagColorInline = document.getElementById('edgeTagColorInline');
      const edgeTagVisibility = document.getElementById('edgeTagVisibility');
      const edgeLabelFontInline = document.getElementById('edgeLabelFontInline');
      if (edgeTagColorSwatch) edgeTagColorSwatch.style.backgroundColor = e.tagColor || '#333333';
      if (edgeTagColorInline) edgeTagColorInline.value = e.tagColor || '#333333';
      if (edgeLabelFontInline) edgeLabelFontInline.value = e.labelFont || 12;
      if (edgeTagVisibility) {
        edgeTagVisibility.classList.toggle('hidden', e.showTag === false);
      }
      
      const edgeLatencyVisibility = document.getElementById('edgeLatencyVisibility');
      if (edgeLatencyVisibility) {
        edgeLatencyVisibility.classList.toggle('hidden', e.showLatency === false);
      }
      
      const edgeCodeVisibility = document.getElementById('edgeCodeVisibility');
      if (edgeCodeVisibility) {
        edgeCodeVisibility.classList.toggle('hidden', e.showCode === false);
      }
      
      // Show/hide curve arch control based on style
      const curveArchControl = document.getElementById('curveArchControl');
      if (e.style === 'curve') {
        curveArchControl.style.display = 'block';
        edgeCurveArch.value = (e.curveArch || 0.3);
        document.getElementById('curveArchValue').textContent = (e.curveArch || 0.3).toFixed(2);
      } else {
        curveArchControl.style.display = 'none';
      }
      return;
    }

    if (state.selected.type === 'group') {
      const g = findGroup(state.selected.id); if (!g) return;
      groupIns.style.display='block';
      // Show UUID (generate if missing for legacy data)
      if (!g.uuid) g.uuid = generateUUID();
      if (groupUUID) groupUUID.value = g.uuid;
      groupTitle.value = g.title || '';
      // Ensure 'default' tag is shown in filter tags field
      let groupTagsArray = g.filterTags || [];
      if (!groupTagsArray.some(t => t.trim().toLowerCase() === 'default')) {
        groupTagsArray = ['default', ...groupTagsArray];
      }
      if (groupFilterTags) groupFilterTags.value = groupTagsArray.join(', ');
      groupType.value = g.type || 'country';
      // Parent Region dropdown
      while (groupParent.firstChild) groupParent.removeChild(groupParent.firstChild);
      const optNone = document.createElement('option');
      optNone.value = '';
      optNone.textContent = '(none)';
      groupParent.appendChild(optNone);
      state.groups.filter(r => r.type === 'region').forEach(r => {
        const opt = document.createElement('option');
        opt.value = String(r.id);
        opt.textContent = r.title || `Group${r.id}`;
        groupParent.appendChild(opt);
      });
      groupParent.value = g.parentId ? String(g.parentId) : '';
      groupParent.disabled = (g.type !== 'country');

      groupExtraTags.value = g.extraTags || '';
      groupW.value = Math.round(g.w);
      groupH.value = Math.round(g.h);
      
      // Transit latency
      const groupTransitLatency = document.getElementById('groupTransitLatency');
      if (groupTransitLatency) {
        groupTransitLatency.value = g.transitLatency !== undefined && g.transitLatency !== null ? g.transitLatency : '';
      }
      
      groupTitleFont.value = g.titleFont ?? 14;
      groupTitleColor.value = g.titleColor || "#333333";
      groupFill.value = g.fill || "#ffffff";
      groupStroke.value = g.stroke || "#666666";
      if (groupStrokeW) groupStrokeW.value = g.strokeW ?? 1;
      // Update color pickers
      if (window.updateColorPickers) window.updateColorPickers();
      
      // Sync fill color picker and opacity slider
      const groupFillColor = document.getElementById('groupFillColor');
      const groupFillOpacity = document.getElementById('groupFillOpacity');
      const groupFillOpacityValue = document.getElementById('groupFillOpacityValue');
      const groupFillColorSwatch = document.getElementById('groupFillColorSwatch');
      const groupFillColorHex = document.getElementById('groupFillColorHex');
      const groupFillColorCustom = document.getElementById('groupFillColorCustom');
      if (groupFillColor && groupFillOpacity) {
        const parsed = parseColorWithOpacity(g.fill || '#ffffff');
        groupFillColor.value = parsed.color;
        groupFillOpacity.value = Math.round(parsed.opacity * 100);
        if (groupFillOpacityValue) groupFillOpacityValue.textContent = Math.round(parsed.opacity * 100) + '%';
        // Update palette swatch
        if (groupFillColorSwatch) groupFillColorSwatch.style.backgroundColor = parsed.color;
        if (groupFillColorHex) groupFillColorHex.value = parsed.color;
        if (groupFillColorCustom) groupFillColorCustom.value = parsed.color;
      }
      
      // Update group stroke palette swatch
      const groupStrokeSwatch = document.getElementById('groupStrokeSwatch');
      const groupStrokeHex = document.getElementById('groupStrokeHex');
      const groupStrokeCustom = document.getElementById('groupStrokeCustom');
      if (groupStrokeSwatch) groupStrokeSwatch.style.backgroundColor = g.stroke || '#666666';
      if (groupStrokeHex) groupStrokeHex.value = g.stroke || '#666666';
      if (groupStrokeCustom) groupStrokeCustom.value = g.stroke || '#666666';
      
      // Sync inline controls
      const groupTitleColorSwatch = document.getElementById('groupTitleColorSwatch');
      const groupTitleColorInline = document.getElementById('groupTitleColorInline');
      const groupTitleVisibility = document.getElementById('groupTitleVisibility');
      const groupTitleFontInline = document.getElementById('groupTitleFontInline');
      if (groupTitleColorSwatch) groupTitleColorSwatch.style.backgroundColor = g.titleColor || '#333333';
      if (groupTitleColorInline) groupTitleColorInline.value = g.titleColor || '#333333';
      if (groupTitleFontInline) groupTitleFontInline.value = g.titleFont || 14;
      if (groupTitleVisibility) {
        groupTitleVisibility.classList.toggle('hidden', g.showTitle === false);
      }
      
      // Update container shape info
      const groupShapeInfo = document.getElementById('groupShapeInfo');
      const btnRemoveGroupShape = document.getElementById('btnRemoveGroupShape');
      if (groupShapeInfo) {
        if (g.shapeContainer && g.decorativeShape && g.decorativeShape.name) {
          // This is a shape-based container
          groupShapeInfo.innerHTML = `
            <div style="display:flex; align-items:center; gap:8px;">
              <div style="width:32px; height:32px; background:#e8f4ff; border:1px solid #2563eb; border-radius:4px; display:flex; align-items:center; justify-content:center; overflow:hidden;">
                ${g.decorativeShape.svgData || 'üó∫Ô∏è'}
              </div>
              <div>
                <div style="font-weight:600; font-size:11px; color:#2563eb;">${g.decorativeShape.name}</div>
                <div style="font-size:10px; color:#666;">Shape container</div>
              </div>
            </div>
          `;
          if (btnRemoveGroupShape) btnRemoveGroupShape.disabled = false;
        } else if (g.decorativeShape && g.decorativeShape.name) {
          // Decorative overlay on rectangular container
          groupShapeInfo.innerHTML = `
            <div style="display:flex; align-items:center; gap:8px;">
              <div style="width:32px; height:32px; background:#f0f0ff; border-radius:4px; display:flex; align-items:center; justify-content:center; overflow:hidden;">
                ${g.decorativeShape.svgData || 'üó∫Ô∏è'}
              </div>
              <div>
                <div style="font-weight:600; font-size:11px;">${g.decorativeShape.name}</div>
                <div style="font-size:10px; color:#888;">Decorative overlay</div>
              </div>
            </div>
          `;
          if (btnRemoveGroupShape) btnRemoveGroupShape.disabled = false;
        } else {
          groupShapeInfo.innerHTML = '<div style="font-size:11px; color:#666;">Standard rectangular container</div>';
          if (btnRemoveGroupShape) btnRemoveGroupShape.disabled = true;
        }
      }
    }
  }

  nodeName.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.name = nodeName.value; commit(); render();
  });
  nodeTags.addEventListener('change', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    let tags = nodeTags.value.split(',').map(s=>s.trim()).filter(Boolean);
    // Ensure 'default' is always present
    if (!tags.some(t => t.toLowerCase() === 'default')) {
      tags = ['default', ...tags];
    }
    n.tags = tags;
    commit(); render();
  });
  nodeExtraTags.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.extraTags = nodeExtraTags.value; commit(); render();
  });
  nodeCode.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.code = nodeCode.value; commit(); render();
  });
  if (nodeShowCode) nodeShowCode.addEventListener('change', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.showCode = nodeShowCode.value === '1'; commit(); render();
  });

  nodeNameFont.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.nameFont = clamp(Number(nodeNameFont.value||13),6,72); commit(); render();
  });
  nodeTagFont.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.tagFont = clamp(Number(nodeTagFont.value||11),6,72); commit(); render();
  });
  nodeNameColor.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.nameColor = nodeNameColor.value; commit(); render();
  });
  nodeTagColor.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.tagColor = nodeTagColor.value; commit(); render();
  });
  nodeFill.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.fill = nodeFill.value; commit(); render();
  });
  nodeStroke.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.stroke = nodeStroke.value; commit(); render();
  });
  if (nodeStrokeW) nodeStrokeW.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.strokeW = clamp(Number(nodeStrokeW.value||2),0.5,12);
    commit(); render();
  });

if (edgeStrokeColor) edgeStrokeColor.addEventListener('input', () => {
  if (state.selected?.type!=='edge') return;
  const e = findEdge(state.selected.id); if (!e) return;
  e.strokeColor = edgeStrokeColor.value;
  commit(); render();
});

  if (nodeSize) nodeSize.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.r = clamp(Number(nodeSize.value||24),10,80);
    commit(); render();
  });

// Node address/city/country listeners
if (nodeAddress) nodeAddress.addEventListener('input', () => {
  if (state.selected?.type!=='node') return;
  const n = findNode(state.selected.id); if (!n) return;
  n.address = nodeAddress.value; commit(); render();
});

if (nodeCity) nodeCity.addEventListener('input', () => {
  if (state.selected?.type!=='node') return;
  const n = findNode(state.selected.id); if (!n) return;
  n.city = nodeCity.value; commit(); render();
});

if (nodeCountry) nodeCountry.addEventListener('input', () => {
  if (state.selected?.type!=='node') return;
  const n = findNode(state.selected.id); if (!n) return;
  n.country = nodeCountry.value; commit(); render();
});

// Edge capacity listener
if (edgeCapacity) edgeCapacity.addEventListener('input', () => {
  if (state.selected?.type!=='edge') return;
  const e = findEdge(state.selected.id); if (!e) return;
  e.capacity = edgeCapacity.value; commit(); render();
});

// Edge priority listener
if (edgePriority) edgePriority.addEventListener('input', () => {
  if (state.selected?.type!=='edge') return;
  const e = findEdge(state.selected.id); if (!e) return;
  const val = parseFloat(edgePriority.value);
  e.priority = isNaN(val) ? 0 : val;
  commit(); render();
});

// ============== INLINE CONTROL HANDLERS ==============

// Node Name inline controls
const nodeNameColorInline = document.getElementById('nodeNameColorInline');
const nodeNameVisibility = document.getElementById('nodeNameVisibility');
if (nodeNameColorInline) {
  nodeNameColorInline.addEventListener('input', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.nameColor = nodeNameColorInline.value;
    const swatch = document.getElementById('nodeNameColorSwatch');
    if (swatch) swatch.style.backgroundColor = nodeNameColorInline.value;
    commit(); render();
  });
}
if (nodeNameVisibility) {
  nodeNameVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.showName = n.showName === false ? true : false;
    nodeNameVisibility.classList.toggle('hidden', n.showName === false);
    commit(); render();
  });
}

// Node Code inline controls
const nodeCodeColorInline = document.getElementById('nodeCodeColorInline');
const nodeCodeVisibility = document.getElementById('nodeCodeVisibility');
if (nodeCodeColorInline) {
  nodeCodeColorInline.addEventListener('input', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.codeColor = nodeCodeColorInline.value;
    const swatch = document.getElementById('nodeCodeColorSwatch');
    if (swatch) swatch.style.backgroundColor = nodeCodeColorInline.value;
    commit(); render();
  });
}
if (nodeCodeVisibility) {
  nodeCodeVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.showCode = n.showCode === false ? true : false;
    nodeCodeVisibility.classList.toggle('hidden', n.showCode === false);
    commit(); render();
  });
}

// Node Extra Tags inline controls
const nodeExtraTagsColorInline = document.getElementById('nodeExtraTagsColorInline');
const nodeExtraTagsVisibility = document.getElementById('nodeExtraTagsVisibility');
if (nodeExtraTagsColorInline) {
  nodeExtraTagsColorInline.addEventListener('input', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.extraTagsColor = nodeExtraTagsColorInline.value;
    const swatch = document.getElementById('nodeExtraTagsColorSwatch');
    if (swatch) swatch.style.backgroundColor = nodeExtraTagsColorInline.value;
    commit(); render();
  });
}
if (nodeExtraTagsVisibility) {
  nodeExtraTagsVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.showExtraTags = !n.showExtraTags;
    nodeExtraTagsVisibility.classList.toggle('hidden', !n.showExtraTags);
    commit(); render();
  });
}

// Edge Tag inline controls
const edgeTagColorInline = document.getElementById('edgeTagColorInline');
const edgeTagVisibility = document.getElementById('edgeTagVisibility');
if (edgeTagColorInline) {
  edgeTagColorInline.addEventListener('input', () => {
    if (state.selected?.type !== 'edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.tagColor = edgeTagColorInline.value;
    const swatch = document.getElementById('edgeTagColorSwatch');
    if (swatch) swatch.style.backgroundColor = edgeTagColorInline.value;
    commit(); render();
  });
}
if (edgeTagVisibility) {
  edgeTagVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.showTag = e.showTag === false ? true : false;
    edgeTagVisibility.classList.toggle('hidden', e.showTag === false);
    commit(); render();
  });
}

// Edge Latency inline controls
const edgeLatencyVisibility = document.getElementById('edgeLatencyVisibility');
if (edgeLatencyVisibility) {
  edgeLatencyVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.showLatency = e.showLatency === false ? true : false;
    edgeLatencyVisibility.classList.toggle('hidden', e.showLatency === false);
    commit(); render();
  });
}

// Edge Code inline controls
const edgeCodeVisibility = document.getElementById('edgeCodeVisibility');
if (edgeCodeVisibility) {
  edgeCodeVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.showCode = e.showCode === false ? true : false;
    edgeCodeVisibility.classList.toggle('hidden', e.showCode === false);
    commit(); render();
  });
}

// Group Title inline controls
const groupTitleColorInline = document.getElementById('groupTitleColorInline');
const groupTitleVisibility = document.getElementById('groupTitleVisibility');
if (groupTitleColorInline) {
  groupTitleColorInline.addEventListener('input', () => {
    if (state.selected?.type !== 'group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.titleColor = groupTitleColorInline.value;
    const swatch = document.getElementById('groupTitleColorSwatch');
    if (swatch) swatch.style.backgroundColor = groupTitleColorInline.value;
    commit(); render();
  });
}
if (groupTitleVisibility) {
  groupTitleVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.showTitle = g.showTitle === false ? true : false;
    groupTitleVisibility.classList.toggle('hidden', g.showTitle === false);
    commit(); render();
  });
}

// ============== INLINE FONT SIZE HANDLERS ==============

// Node Name Font Size
const nodeNameFontInline = document.getElementById('nodeNameFontInline');
if (nodeNameFontInline) {
  nodeNameFontInline.addEventListener('change', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.nameSize = parseInt(nodeNameFontInline.value) || 13;
    commit(); render();
  });
}

// Node Code Font Size
const nodeCodeFontInline = document.getElementById('nodeCodeFontInline');
if (nodeCodeFontInline) {
  nodeCodeFontInline.addEventListener('change', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.codeSize = parseInt(nodeCodeFontInline.value) || 13;
    commit(); render();
  });
}

// Node Extra Tags Font Size
const nodeExtraTagsFontInline = document.getElementById('nodeExtraTagsFontInline');
if (nodeExtraTagsFontInline) {
  nodeExtraTagsFontInline.addEventListener('change', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.extraTagsSize = parseInt(nodeExtraTagsFontInline.value) || 11;
    commit(); render();
  });
}

// Edge Label Font Size
const edgeLabelFontInline = document.getElementById('edgeLabelFontInline');
if (edgeLabelFontInline) {
  edgeLabelFontInline.addEventListener('change', () => {
    if (state.selected?.type !== 'edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.labelFont = parseInt(edgeLabelFontInline.value) || 12;
    commit(); render();
  });
}

// Group Title Font Size
const groupTitleFontInline = document.getElementById('groupTitleFontInline');
if (groupTitleFontInline) {
  groupTitleFontInline.addEventListener('change', () => {
    if (state.selected?.type !== 'group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.titleFont = parseInt(groupTitleFontInline.value) || 14;
    commit(); render();
  });
}

// ============== END INLINE CONTROL HANDLERS ==============

  edgeTag.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.tag = edgeTag.value; commit(); render();
  });
  if (edgeFilterTags) {
    edgeFilterTags.addEventListener('change', () => {
      if (state.selected?.type!=='edge') return;
      const e = findEdge(state.selected.id); if (!e) return;
      let tags = edgeFilterTags.value.split(',').map(s=>s.trim()).filter(Boolean);
      // Ensure 'default' is always present
      if (!tags.some(t => t.toLowerCase() === 'default')) {
        tags = ['default', ...tags];
      }
      e.filterTags = tags;
      commit(); render();
    });
  }
  edgeLatency.addEventListener('change', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    const raw = String(edgeLatency.value ?? '').trim();
    if (raw === '') { e.latencyMs = null; commit(); render(); return; }
    // Replace comma with period for locales that use comma as decimal separator
    const v = parseFloat(raw.replace(',', '.'));
    if (Number.isFinite(v) && v >= 0) { 
      e.latencyMs = v; 
      edgeLatency.value = v; // Normalize the display
      commit(); 
      render(); 
    } else {
      // Invalid input - revert to previous value
      edgeLatency.value = (typeof e.latencyMs === "number" && isFinite(e.latencyMs)) ? e.latencyMs : '';
    }
  });
  edgeExtraTags.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.extraTags = edgeExtraTags.value; commit(); render();
  });
  edgeCode.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.code = edgeCode.value; commit(); render();
  });
  if (edgeShowCode) edgeShowCode.addEventListener('change', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.showCode = edgeShowCode.value === '1'; commit(); render();
  });

  edgeStyle.addEventListener('change', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.style = edgeStyle.value; 
    // Show/hide curve arch control
    const curveArchControl = document.getElementById('curveArchControl');
    if (e.style === 'curve') {
      curveArchControl.style.display = 'block';
      if (!e.curveArch) e.curveArch = 0.3;
      edgeCurveArch.value = e.curveArch;
      document.getElementById('curveArchValue').textContent = e.curveArch.toFixed(2);
    } else {
      curveArchControl.style.display = 'none';
    }
    commit(); render();
  });
  edgeRoute.addEventListener('change', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.route = edgeRoute.value; commit(); render();
  });
  edgeCurveArch.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.curveArch = clamp(Number(edgeCurveArch.value||0.3), 0, 0.6);
    document.getElementById('curveArchValue').textContent = e.curveArch.toFixed(2);
    commit(); render();
  });
  edgeLabelFont.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.labelFont = clamp(Number(edgeLabelFont.value||12),6,72); commit(); render();
  });
  edgeLabelColor.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.labelColor = edgeLabelColor.value; commit(); render();
  });
  if (edgeStrokeW) edgeStrokeW.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.strokeW = clamp(Number(edgeStrokeW.value||2),0.5,12);
    commit(); render();
  });

  groupTitle.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.title = groupTitle.value; commit(); render();
  });
  if (groupFilterTags) {
    groupFilterTags.addEventListener('change', () => {
      if (state.selected?.type!=='group') return;
      const g = findGroup(state.selected.id); if (!g) return;
      let tags = groupFilterTags.value.split(',').map(s=>s.trim()).filter(Boolean);
      // Ensure 'default' is always present
      if (!tags.some(t => t.toLowerCase() === 'default')) {
        tags = ['default', ...tags];
      }
      g.filterTags = tags;
      commit(); render();
    });
  }
  groupType.addEventListener('change', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.type = groupType.value;
    // If switching away from country, clear parent + node memberships will recompute
    if (g.type !== 'country') g.parentId = null;
    refreshAllMemberships();
    commit(); render();
  });

  groupParent.addEventListener('change', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g || g.type !== 'country') return;
    g.parentId = groupParent.value ? Number(groupParent.value) : null;
    commit(); render();
  });

  groupExtraTags.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.extraTags = groupExtraTags.value; commit(); render();
  });
  
  // Transit latency
  const groupTransitLatency = document.getElementById('groupTransitLatency');
  if (groupTransitLatency) {
    groupTransitLatency.addEventListener('input', () => {
      if (state.selected?.type!=='group') return;
      const g = findGroup(state.selected.id); if (!g) return;
      const val = groupTransitLatency.value.trim();
      if (val === '') {
        delete g.transitLatency; // Use global default
      } else {
        g.transitLatency = parseFloat(val) || 0;
      }
      commit();
    });
  }
  
  groupW.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.w = clamp(Number(groupW.value||g.w),120,1600); refreshAllMemberships(); commit(); render();
  });
  groupH.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.h = clamp(Number(groupH.value||g.h),90,900); refreshAllMemberships(); commit(); render();
  });
  
  // Decorative shape buttons
  const btnOpenLibraryForShape = document.getElementById('btnOpenLibraryForShape');
  const btnRemoveGroupShape = document.getElementById('btnRemoveGroupShape');
  
  if (btnOpenLibraryForShape) {
    btnOpenLibraryForShape.addEventListener('click', () => {
      // Open library and switch to containers tab
      state.libraryTab = 'containers';
      const panel = document.getElementById('shapeLibraryPanel');
      if (panel) {
        panel.classList.add('visible');
        if (btnToggleLibrary) btnToggleLibrary.classList.add('active');
        localStorage.setItem('netmap-library-visible', 'true');
      }
      renderLibraryPanel();
    });
  }
  
  if (btnRemoveGroupShape) {
    btnRemoveGroupShape.addEventListener('click', () => {
      if (state.selected?.type !== 'group') return;
      const g = findGroup(state.selected.id);
      if (g && (g.decorativeShape || g.shapeContainer)) {
        const wasShapeContainer = g.shapeContainer;
        delete g.decorativeShape;
        delete g.shapeContainer;
        
        // Restore default fill/stroke if it was a shape container
        if (wasShapeContainer) {
          g.fill = g.fill || 'rgba(54, 76, 140, 0.12)';
          g.stroke = g.stroke || '#6073b8';
        }
        
        refreshAllMemberships();
        commit();
        render();
        showToast(wasShapeContainer ? 'Converted to rectangular container' : 'Shape removed');
      }
    });
  }
  
  groupTitleFont.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.titleFont = clamp(Number(groupTitleFont.value||14),6,72); commit(); render();
  });
  groupTitleColor.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.titleColor = groupTitleColor.value; commit(); render();
  });
  
  // Group Fill Color and Opacity handlers
  const groupFillColor = document.getElementById('groupFillColor');
  const groupFillOpacity = document.getElementById('groupFillOpacity');
  const groupFillOpacityValue = document.getElementById('groupFillOpacityValue');
  
  function updateGroupFill() {
    if (state.selected?.type !== 'group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    const color = groupFillColor ? groupFillColor.value : '#ffffff';
    const opacity = groupFillOpacity ? parseInt(groupFillOpacity.value) / 100 : 1;
    g.fill = combineColorWithOpacity(color, opacity);
    if (groupFill) groupFill.value = g.fill;
    commit(); render();
  }
  
  if (groupFillColor) {
    groupFillColor.addEventListener('input', updateGroupFill);
  }
  if (groupFillOpacity) {
    groupFillOpacity.addEventListener('input', () => {
      if (groupFillOpacityValue) {
        groupFillOpacityValue.textContent = groupFillOpacity.value + '%';
      }
      updateGroupFill();
    });
  }
  // Keep legacy handler for compatibility
  groupFill.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.fill = groupFill.value; commit(); render();
  });
  
  groupStroke.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.stroke = groupStroke.value; commit(); render();
  });
  if (groupStrokeW) groupStrokeW.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.strokeW = clamp(Number(groupStrokeW.value||2),0.5,12);
    commit(); render();
  });


  // Preset buttons
  btnNodePresetSave.addEventListener('click', () => {
    console.log(`[PRESET SAVE] Button clicked - state.selected:`, state.selected);
    console.log(`[PRESET SAVE] state.selected?.type:`, state.selected?.type);
    if (state.selected?.type!=='node') { 
      showToast("Select a node first."); 
      console.log(`[PRESET SAVE] FAILED - not a node or no selection`);
      return; 
    }
    const n = findNode(state.selected.id); 
    console.log(`[PRESET SAVE] Found node:`, n);
    if (!n) return;
    savePreset('node', n);
  });
  btnNodePresetApply.addEventListener('click', () => {
    if (state.selected?.type!=='node') { showToast("Select a node first."); return; }
    const n = findNode(state.selected.id); if (!n) return;
    applyPreset('node', n, nodePresetSel.value);
  });
  btnNodePresetDelete.addEventListener('click', () => deletePreset('node', nodePresetSel.value));

  btnEdgePresetSave.addEventListener('click', () => {
    if (state.selected?.type!=='edge') { showToast("Select a link first."); return; }
    const e = findEdge(state.selected.id); if (!e) return;
    savePreset('edge', e);
  });
  btnEdgePresetApply.addEventListener('click', () => {
    if (state.selected?.type!=='edge') { showToast("Select a link first."); return; }
    const e = findEdge(state.selected.id); if (!e) return;
    applyPreset('edge', e, edgePresetSel.value);
  });
  btnEdgePresetDelete.addEventListener('click', () => deletePreset('edge', edgePresetSel.value));

  btnGroupPresetSave.addEventListener('click', () => {
    if (state.selected?.type!=='group') { showToast("Select a box first."); return; }
    const g = findGroup(state.selected.id); if (!g) return;
    savePreset('group', g);
  });
  btnGroupPresetApply.addEventListener('click', () => {
    if (state.selected?.type!=='group') { showToast("Select a box first."); return; }
    const g = findGroup(state.selected.id); if (!g) return;
    applyPreset('group', g, groupPresetSel.value);
  });
  btnGroupPresetDelete.addEventListener('click', () => deletePreset('group', groupPresetSel.value));

  function makeNode(id, x, y) {
    return {
      id,
      uuid: generateUUID(),
      x: x,
      y: y,
      shape: state.defaultNodeShape || 'circle', r:24, strokeW:2,
      address:'', city:'', country:'',
      name: `Node${id}`,
      code: `N-${id}`,
      showCode: true,
      tags: ['default'],
      extraTags:"",
      groupId:null,
      cableSystemIds: [],  // Array of cable system IDs (node can belong to multiple)
      fill:"#dae8fc", stroke:"#6c8ebf",
      nameColor:"#333333", tagColor:"#666666",
      nameFont:13, tagFont:11,
      nameDx:0, nameDy:0, tagDx:0, tagDy:0
    };
  }

  function makeCableSystem(id) {
    return {
      id,
      uuid: generateUUID(),
      shortName: `CS${id}`,
      name: `Cable System ${id}`,
      type: 'wet',              // 'wet' | 'terrestrial'
      rfsYear: new Date().getFullYear(),
      fiberPairs: 1,
      status: 'planned',        // 'planned' | 'operational'
      capacityTbps: 0,
      owners: '',
      notes: '',
      filterTags: ['default']
    };
  }

  function findCableSystem(id) {
    return state.cableSystems.find(cs => cs.id === id);
  }

  function getCableSystemByUUID(uuid) {
    return state.cableSystems.find(cs => cs.uuid === uuid);
  }

  function makeEdge(id, a, b) {
    return {
      id, a, b,
      uuid: generateUUID(),
      tag:'',
      filterTags: ['default'],
      latencyMs:null,
      strokeW:2,
      strokeColor:"#666666",
      capacity:'Up to 10G WL',
      priority: 0,
      cableSystemId: null,  // ID of associated cable system (null = unmapped)
      code: `L-${id}`,
      showCode: true,
      extraTags:"",
      style:'straight',
      route:'hv',
      curveArch:0.3,
      labelDx:0, labelDy:0, labelFont:12, labelColor:"#333333"
    };
  }

  function makeGroup(id, x, y, type) {
    const isRegion = type === 'region';
    return {
      id,
      uuid: generateUUID(),
      type: isRegion ? 'region' : 'country',
      parentId: null,
      x: clamp(x,20,1400),
      y: clamp(y,20,760),
      w: isRegion ? 520 : 320,
      h: isRegion ? 320 : 220,
      title: isRegion ? `Group${id}` : "Container",
      filterTags: ['default'],
      extraTags:"",
      fill: isRegion ? "rgba(245, 245, 245, 0.9)" : "rgba(255, 255, 255, 0.95)",
      stroke: isRegion ? "#999999" : "#666666",
      strokeW: 1,
      titleColor:"#333333",
      titleFont: isRegion ? 15 : 14,
      titleDx:0, titleDy:0
    };
  }

  function makeCableSystem(id) {
    return {
      id,
      uuid: generateUUID(),
      shortName: `CS${id}`,
      name: `Cable System ${id}`,
      type: 'wet',              // 'wet' or 'terrestrial'
      rfsYear: new Date().getFullYear() + 1,
      fiberPairs: 8,
      status: 'planned',        // 'planned' or 'operational'
      capacityTbps: 100,
      owners: '',
      filterTags: ['default'],
      notes: ''
    };
  }

  function createCableSystem() {
    const id = state.nextCableSystem++;
    const cs = makeCableSystem(id);
    state.cableSystems.push(cs);
    commit();
    updateCableNavigatorList();
    selectCableSystem(cs.id);
    showToast(`Created cable system "${cs.shortName}".`);
    return cs;
  }

  function findCableSystem(id) {
    return state.cableSystems.find(cs => cs.id === id);
  }

  function deleteCableSystem(id, mode = 'cancel') {
    // mode: 'deleteAll' - delete CS and all its links/nodes
    //       'unmapOnly' - delete CS but keep links/nodes (unmapped)
    //       'cancel' - don't delete
    if (mode === 'cancel') return;
    
    const cs = findCableSystem(id);
    if (!cs) return;
    
    if (mode === 'deleteAll') {
      // Delete all links belonging to this cable system
      state.edges = state.edges.filter(e => e.cableSystemId !== id);
      // Remove this cable system from all nodes and delete nodes that only belonged to this system
      state.nodes.forEach(n => {
        if (n.cableSystemIds) {
          n.cableSystemIds = n.cableSystemIds.filter(csId => csId !== id);
        }
      });
    } else if (mode === 'unmapOnly') {
      // Just unmap - set links' cableSystemId to null
      state.edges.forEach(e => {
        if (e.cableSystemId === id) e.cableSystemId = null;
      });
      // Remove from nodes' cableSystemIds
      state.nodes.forEach(n => {
        if (n.cableSystemIds) {
          n.cableSystemIds = n.cableSystemIds.filter(csId => csId !== id);
        }
      });
    }
    
    // Remove the cable system
    state.cableSystems = state.cableSystems.filter(c => c.id !== id);
    
    // Clear selection if this was selected
    if (state.selectedCableSystem === id) {
      state.selectedCableSystem = null;
    }
    
    commit();
    render();
    updateCableNavigatorList();
    updateInspector();
    showToast(`Deleted cable system "${cs.shortName}".`);
  }

  // Get links belonging to a cable system
  function getCableSystemLinks(csId) {
    return state.edges.filter(e => e.cableSystemId === csId);
  }

  // Get nodes belonging to a cable system
  function getCableSystemNodes(csId) {
    return state.nodes.filter(n => n.cableSystemIds && n.cableSystemIds.includes(csId));
  }

  function createNode(x, y) {
    const id = state.nextNode++;
    const node = makeNode(id, x, y);
    state.nodes.push(node);
    updateNodeGroupMembership(node);
    select({type:'node', id});
    commit(); render();
    showToast(`Created node ${node.name}.`);
  }

  function createEdge(a, b, skipSelection = false) {
    // Allow multiple links between same nodes - no uniqueness check
    console.log(`[CREATE EDGE] Creating edge from node ${a} to node ${b}`);
    const id = state.nextEdge++;
    const newEdge = makeEdge(id, a, b);
    console.log(`[CREATE EDGE] Edge ${id} created, adding to state.edges. Total edges: ${state.edges.length + 1}`);
    state.edges.push(newEdge);
    if (!skipSelection) {
      select({type:'edge', id});
    }
    commit(); render();
    if (!skipSelection) {
      showToast('Created link. Edit fields in Inspector.');
    }
  }

  function createGroup(x, y, type='country') {
    const id = state.nextGroup++;
    const g = makeGroup(id, x, y, type);
    state.groups.push(g);

    if (g.type === 'country') updateCountryRegionMembership(g);
    refreshAllMemberships();

    select({type:'group', id});
    commit(); render();
    showToast(g.type === 'region' ? 'Created group box. Rename in Inspector.' : 'Created container box. Rename in Inspector.');
  }

    function deleteSelected() {
    const hasMulti = (state.selection.nodes.size + state.selection.edges.size + state.selection.groups.size) > 0;
    if (!state.selected && !hasMulti) return;

    // If single selection exists, ensure it's in sets
    if (state.selected) {
      if (state.selected.type==='node') state.selection.nodes.add(state.selected.id);
      if (state.selected.type==='edge') state.selection.edges.add(state.selected.id);
      if (state.selected.type==='group') state.selection.groups.add(state.selected.id);
      state.selected = null;
    }

    const nodeIds = new Set(state.selection.nodes);
    const edgeIds = new Set(state.selection.edges);
    const groupIds = new Set(state.selection.groups);

    // If deleting groups: remove them and clear node memberships
    if (groupIds.size) {
      state.groups = state.groups.filter(g => !groupIds.has(g.id));
      state.nodes.forEach(n => { if (groupIds.has(n.groupId)) n.groupId = null; });
    }

    // Delete nodes and any edges connected to them
    if (nodeIds.size) {
      state.nodes = state.nodes.filter(n => !nodeIds.has(n.id));
      state.edges = state.edges.filter(e => !nodeIds.has(e.a) && !nodeIds.has(e.b));
    }

    // Delete explicitly selected edges (if still present)
    if (edgeIds.size) {
      state.edges = state.edges.filter(e => !edgeIds.has(e.id));
    }

    refreshAllMemberships();
    clearSelection();
    commit();
    render();
    showToast('Deleted selected item(s).');
  }


  // Track if spacebar is held for pan mode
  let spacebarHeld = false;
  
  window.addEventListener('keydown', (ev) => {
    if (ev.code === 'Space' && !ev.repeat && !spacebarHeld) {
      // Don't activate space-pan if focus is in a text input
      const tag = document.activeElement?.tagName?.toLowerCase();
      if (tag === 'input' || tag === 'textarea') return;
      
      spacebarHeld = true;
      svg.style.cursor = 'grab';
      ev.preventDefault(); // Prevent page scroll
    }
  });
  
  window.addEventListener('keyup', (ev) => {
    if (ev.code === 'Space') {
      spacebarHeld = false;
      if (!state.dragging || state.dragging.type !== 'canvasPan') {
        svg.style.cursor = '';
      }
    }
  });

  svg.addEventListener('mousedown', (ev) => {
    // Middle mouse button for panning
    if (ev.button === 1) {
      ev.preventDefault();
      const wrap = document.getElementById('wrap');
      state.dragging = { 
        type: 'canvasPan', 
        startScrollX: wrap.scrollLeft, 
        startScrollY: wrap.scrollTop,
        startMouseX: ev.clientX,
        startMouseY: ev.clientY
      };
      svg.style.cursor = 'grabbing';
      return;
    }
    
    // Space+drag for panning from anywhere on the canvas
    if (spacebarHeld && ev.button === 0) {
      ev.preventDefault();
      ev.stopPropagation();
      const wrap = document.getElementById('wrap');
      state.dragging = { 
        type: 'canvasPan', 
        startScrollX: wrap.scrollLeft, 
        startScrollY: wrap.scrollTop,
        startMouseX: ev.clientX,
        startMouseY: ev.clientY
      };
      svg.style.cursor = 'grabbing';
      return;
    }

    // Only left button from here on
    if (ev.button !== 0) return;
    if (state.placingGroup) return;
    if (ev.target !== svg) return; // only empty space

    const m = getMouse(ev);
    state.lastMouse = { x: m.x, y: m.y };

    // Alt+drag for marquee selection (disabled in calculation mode)
    if (ev.altKey && !(window.routeFinderState && window.routeFinderState.active)) {
      state.marquee = { x0: m.x, y0: m.y, x: m.x, y: m.y, w: 0, h: 0, additive: ev.shiftKey };
      if (!state.marquee.additive) clearSelection();
      state.connectFrom = null;
      render();
      return;
    }

    // Default: click and drag to pan the canvas
    const wrap = document.getElementById('wrap');
    state.dragging = { 
      type: 'canvasPan', 
      startScrollX: wrap.scrollLeft, 
      startScrollY: wrap.scrollTop,
      startMouseX: ev.clientX,
      startMouseY: ev.clientY
    };
    svg.style.cursor = 'grabbing';
  });

  svg.addEventListener('dblclick', (ev) => {
    const m = getMouse(ev);
    if (state.placingGroup) return;
    // Skip if we just placed a group (prevents node creation on double-click when placing container)
    if (state._justPlacedGroup) {
      state._justPlacedGroup = false;
      return;
    }
    createNode(m.x, m.y);
  });

  // Consolidated SVG canvas click handler: group placement + selection clearing + debug alt+click
  svg.addEventListener('click', (ev) => {
    const target = ev.target;
    const tagName = target?.tagName ?? 'unknown';
    const className = target?.getAttribute?.('class') ?? 'none';
    const isDirectSvg = ev.target === svg;
    console.log(`[CANVAS CLICK] target: ${tagName}/${className}, directSVG: ${isDirectSvg}, linkMode: ${linkMode}`);
    
    // Handle group placement
    if (state.placingGroup) {
      const m = getMouse(ev);
      createGroup(m.x, m.y, state.placingGroupType || 'country');
      state.placingGroup = false;
      state.placingGroupType = 'country';
      state._justPlacedGroup = true; // Flag to prevent dblclick from creating node
      state.stylePresets = state.stylePresets || { node: {}, edge: {}, group: {} };
      state.styleBrush = null;
      document.getElementById('btnAddGroup').classList.remove('primary');
      document.getElementById('btnAddRegion').classList.remove('primary');
      render();
      return;
    }
    
    // Debug: Alt+click on canvas shows coordinates (helps confirm handlers are active)
    if (ev.altKey) {
      const m = getMouse(ev);
      showToast(`Canvas click @ ${Math.round(m.x)}, ${Math.round(m.y)}`);
    }
    
    // Only clear selection if clicking directly on the SVG background, not on child elements
    if (ev.target === svg) {
      console.log(`[CANVAS CLICK] Clearing selection (clicked empty canvas)`);
      clearSelection(); state.connectFrom=null; render();
    }
  });

  svg.addEventListener('mousemove', (ev) => {
    const m = getMouse(ev);
    state.lastMouse = { x: m.x, y: m.y };

    // Handle canvas panning
    if (state.dragging && state.dragging.type === 'canvasPan') {
      const wrap = document.getElementById('wrap');
      const dx = ev.clientX - state.dragging.startMouseX;
      const dy = ev.clientY - state.dragging.startMouseY;
      wrap.scrollLeft = state.dragging.startScrollX - dx;
      wrap.scrollTop = state.dragging.startScrollY - dy;
      return;
    }

    if (state.marquee) {
      const x1 = state.marquee.x0, y1 = state.marquee.y0;
      const x2 = m.x, y2 = m.y;
      const x = Math.min(x1, x2);
      const y = Math.min(y1, y2);
      const w = Math.abs(x2 - x1);
      const h = Math.abs(y2 - y1);
      state.marquee.x = x; state.marquee.y = y; state.marquee.w = w; state.marquee.h = h;
      render();
      return;
    }


    if (state.resizingGroup) {
      const g = findGroup(state.resizingGroup.id);
      if (!g) return;
      const dx = m.x - state.resizingGroup.mx0;
      const dy = m.y - state.resizingGroup.my0;
      const corner = state.resizingGroup.corner || 'se';
      const minW = 120;
      const minH = 90;
      
      switch (corner) {
        case 'se': // Bottom-right: just resize width and height
          g.w = Math.max(minW, state.resizingGroup.startW + dx);
          g.h = Math.max(minH, state.resizingGroup.startH + dy);
          break;
        case 'sw': // Bottom-left: move x, resize width inversely, resize height
          {
            const newW = Math.max(minW, state.resizingGroup.startW - dx);
            const newX = state.resizingGroup.startX + state.resizingGroup.startW - newW;
            g.x = newX;
            g.w = newW;
            g.h = Math.max(minH, state.resizingGroup.startH + dy);
          }
          break;
        case 'ne': // Top-right: move y, resize width, resize height inversely
          {
            const newH = Math.max(minH, state.resizingGroup.startH - dy);
            const newY = state.resizingGroup.startY + state.resizingGroup.startH - newH;
            g.y = newY;
            g.h = newH;
            g.w = Math.max(minW, state.resizingGroup.startW + dx);
          }
          break;
        case 'nw': // Top-left: move both x and y, resize both inversely
          {
            const newW = Math.max(minW, state.resizingGroup.startW - dx);
            const newH = Math.max(minH, state.resizingGroup.startH - dy);
            const newX = state.resizingGroup.startX + state.resizingGroup.startW - newW;
            const newY = state.resizingGroup.startY + state.resizingGroup.startH - newH;
            g.x = newX;
            g.y = newY;
            g.w = newW;
            g.h = newH;
          }
          break;
      }
      refreshAllMemberships();
      render();
      return;
    }

    // Handle node resizing
    if (state.resizingNode) {
      const n = findNode(state.resizingNode.id);
      if (!n) return;
      const dx = m.x - state.resizingNode.mx0;
      const dy = m.y - state.resizingNode.my0;
      const corner = state.resizingNode.corner || 'se';
      const minR = 10;
      const maxR = 80;
      
      // Calculate the distance moved (use the larger of dx or dy for uniform scaling)
      let delta;
      switch (corner) {
        case 'se':
          delta = Math.max(dx, dy);
          break;
        case 'sw':
          delta = Math.max(-dx, dy);
          break;
        case 'ne':
          delta = Math.max(dx, -dy);
          break;
        case 'nw':
          delta = Math.max(-dx, -dy);
          break;
      }
      
      // Scale the radius based on the drag distance
      const newR = Math.min(maxR, Math.max(minR, state.resizingNode.startR + delta / 2));
      n.r = newR;
      
      render();
      return;
    }

    if (!state.dragging) return;

    if (state.dragging.type === 'selection') {
      const dx = m.x - state.dragging.mx0;
      const dy = m.y - state.dragging.my0;
      state.dragging.origGroups.forEach(o => {
        const g = findGroup(o.id); if (!g) return;
        g.x = o.x + dx;
        g.y = o.y + dy;
      });
      state.dragging.origNodes.forEach(o => {
        const n = findNode(o.id); if (!n) return;
        n.x = o.x + dx;
        n.y = o.y + dy;
      });
      refreshAllMemberships();
      render();
      return;
    }

    if (state.dragging.type === 'edgeLabel') {
      const e = findEdge(state.dragging.id); if (!e) return;
      const a = findNode(e.a), b = findNode(e.b); if (!a || !b) return;
      let base = (e.style==='orthogonal') ? orthogonalBaseLabelPoint(a.x,a.y,b.x,b.y,e.route||'hv') : {x:(a.x+b.x)/2,y:(a.y+b.y)/2};
      const targetX = m.x + state.dragging.dx;
      const targetY = m.y + state.dragging.dy;
      e.labelDx = targetX - base.x;
      e.labelDy = targetY - base.y;
      render();
      return;
    }

    if (state.dragging.type === 'curveHandle') {
      const e = findEdge(state.dragging.edgeId); if (!e) return;
      const a = findNode(e.a), b = findNode(e.b); if (!a || !b) return;
      // Calculate perpendicular distance from line AB
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist === 0) return;
      // Vector from A to current mouse
      const mx = m.x - a.x;
      const my = m.y - a.y;
      // Project onto perpendicular to AB
      const perpDist = (mx * (-dy) + my * dx) / dist;
      // Convert perpendicular distance to arch value
      // arch = perpDist / (dist * 0.5)
      e.curveArch = clamp(perpDist / (dist * 0.5), -0.6, 0.6);
      // Update slider to match
      edgeCurveArch.value = e.curveArch;
      document.getElementById('curveArchValue').textContent = e.curveArch.toFixed(2);
      render();
      return;
    }

    if (state.dragging.type === 'nodeNameLabel') {
      const n = findNode(state.dragging.id); if (!n) return;
      const targetX = m.x + state.dragging.dx;
      const targetY = m.y + state.dragging.dy;
      n.nameDx = targetX - n.x;
      n.nameDy = targetY - n.y;
      render();
      return;
    }

    if (state.dragging.type === 'nodeTagLabel') {
      const n = findNode(state.dragging.id); if (!n) return;
      const targetX = m.x + state.dragging.dx;
      const targetY = m.y + state.dragging.dy;
      n.tagDx = targetX - n.x;
      n.tagDy = targetY - (n.y + 26);
      render();
      return;
    }

    if (state.dragging.type === 'groupTitleLabel') {
      const g = findGroup(state.dragging.id); if (!g) return;
      const targetX = m.x + state.dragging.dx;
      const targetY = m.y + state.dragging.dy;
      g.titleDx = targetX - (g.x + 14);
      g.titleDy = targetY - (g.y + 22);
      render();
      return;
    }

    if (state.dragging.type === 'node') {
      const n = findNode(state.dragging.id); if (!n) return;
      n.x = m.x + state.dragging.dx;
      n.y = m.y + state.dragging.dy;
      updateNodeGroupMembership(n);
      render();
      return;
    }

    if (state.dragging.type === 'group') {
      const g = findGroup(state.dragging.id); if (!g) return;
      const oldX = g.x, oldY = g.y;
      g.x = m.x + state.dragging.dx;
      g.y = m.y + state.dragging.dy;
      const dx = g.x - oldX;
      const dy = g.y - oldY;

      if (g.type === 'region') {
        // Move all child countries (and their nodes) along with the region
        state.groups.forEach(c => {
          if (c.type === 'country' && c.parentId === g.id) {
            c.x = c.x + dx;
            c.y = c.y + dy;
          }
        });
        state.nodes.forEach(n => {
          const country = n.groupId ? findGroup(n.groupId) : null;
          if (country && country.type === 'country' && country.parentId === g.id) {
            n.x = n.x + dx;
            n.y = n.y + dy;
          }
        });
      } else {
        // Move nodes inside the country box along with it
        state.nodes.forEach(n => {
          if (n.groupId === g.id) {
            n.x = n.x + dx;
            n.y = n.y + dy;
          }
        });
      }

      refreshAllMemberships();
      render();
    }
  });

  window.addEventListener('mouseup', () => {
    // finalize marquee selection
    if (state.marquee) {
      const box = { x: state.marquee.x, y: state.marquee.y, w: state.marquee.w, h: state.marquee.h };
      const insideNode = (n) => n.x >= box.x && n.x <= box.x + box.w && n.y >= box.y && n.y <= box.y + box.h;
      const rectsIntersect = (a, b) => !(a.x+a.w < b.x || b.x+b.w < a.x || a.y+a.h < b.y || b.y+b.h < a.y);

      const nodes = state.nodes.filter(insideNode).map(n=>n.id);
      const groups = state.groups.filter(g => rectsIntersect({x:g.x,y:g.y,w:g.w,h:g.h}, box)).map(g=>g.id);

      // edges where both endpoints are selected (node selection)
      const nodeSet = new Set([...state.selection.nodes, ...nodes]);
      const edges = state.edges.filter(e => nodeSet.has(e.a) && nodeSet.has(e.b)).map(e=>e.id);

      // apply selection (additive if shift held at start)
      if (state.marquee.additive) {
        nodes.forEach(id => state.selection.nodes.add(id));
        groups.forEach(id => state.selection.groups.add(id));
        edges.forEach(id => state.selection.edges.add(id));
      } else {
        setMultiSelection({ nodes, groups, edges });
      }

      state.marquee = null;
      state.dragging = null;
      state.resizingGroup = null;
      state.resizingNode = null;
      render();
      return;
    }

    // Commit changes if we were dragging
    const wasDragging = state.dragging !== null;
    
    // Restore cursor after canvas panning
    if (state.dragging?.type === 'canvasPan') {
      // If spacebar is still held, show grab cursor; otherwise reset
      svg.style.cursor = spacebarHeld ? 'grab' : '';
    }
    
    // Commit changes if we were dragging curve handle
    if (state.dragging?.type === 'curveHandle') {
      commit();
    }
    
    // Commit changes if we were resizing a node
    if (state.resizingNode) {
      commit();
    }
    
    state.dragging = null;
    state.resizingGroup = null;
    state.resizingNode = null;
    
    // Check if canvas needs to expand to fit elements
    if (wasDragging && typeof checkAndAutoExpandCanvas === 'function') {
      checkAndAutoExpandCanvas();
    }
    
    // Render if we were dragging to update cursor/state
    if (wasDragging) {
      render();
    }
  });

  window.addEventListener('keydown', (ev) => {
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'z') {
      ev.preventDefault();
      if (ev.shiftKey) redo(); else undo();
      return;
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'y') {
      ev.preventDefault(); redo(); return;
    }

    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'c') {
      ev.preventDefault();
      copySelection();
      return;
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'x') {
      ev.preventDefault();
      copySelection();
      deleteSelected();
      return;
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'v') {
      ev.preventDefault();
      pasteSelection();
      return;
    }

    if ((ev.key === 'Backspace' || ev.key === 'Delete') && !['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) {
      ev.preventDefault(); deleteSelected();
    }
    if (ev.key === 'Escape') {
      clearBrush();
      clearLinkMode();
      state.placingGroup=false;
      document.getElementById('btnAddGroup').classList.remove('primary');
      document.getElementById('btnAddRegion').classList.remove('primary');
      render();
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 's') {
      ev.preventDefault(); saveProject(false);
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'o') {
      ev.preventDefault(); openProjectWithFilePicker();
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'n') {
      ev.preventDefault(); newDiagram();
    }
  });

  document.getElementById('btnAddGroup').addEventListener('click', (ev) => {
    state.placingGroupType = 'country';
    state.placingGroup = !state.placingGroup;
    document.getElementById('btnAddGroup').classList.toggle('primary', state.placingGroup && state.placingGroupType==='country');
    document.getElementById('btnAddRegion').classList.toggle('primary', state.placingGroup && state.placingGroupType==='region');
    showToast(state.placingGroup ? 'Click the canvas to place a container box.' : 'Placement cancelled.');
  });

  document.getElementById('btnAddRegion').addEventListener('click', (ev) => {
    state.placingGroupType = 'region';
    state.placingGroup = !state.placingGroup;
    document.getElementById('btnAddRegion').classList.toggle('primary', state.placingGroup && state.placingGroupType==='region');
    document.getElementById('btnAddGroup').classList.remove('primary');
    showToast(state.placingGroup ? 'Click the canvas to place a group box.' : 'Placement cancelled.');
  });

document.getElementById('btnExportLinks').addEventListener('click', () => {
  // Create header row
  const headers = [
    'Link UUID',
    'A-End Node UUID',
    'A-End Node tag',
    'A-End node code',
    'B-End Node UUID',
    'B-End Node tag',
    'B-End Node code',
    'Link tag',
    'Link code',
    'Link latency',
    'Link Capacity Options',
    'Link Priority',
    'Link Additional tags/Notes'
  ];
  
  // Use semicolon as delimiter for European Excel compatibility
  let csv = headers.join(';') + '\r\n';
  
  // Add data rows
  for (const e of state.edges) {
    const a = findNode(e.a);
    const b = findNode(e.b);
    
    if (!a || !b) continue; // Skip if nodes don't exist
    
    // Ensure UUIDs exist
    if (!e.uuid) e.uuid = generateUUID();
    if (!a.uuid) a.uuid = generateUUID();
    if (!b.uuid) b.uuid = generateUUID();
    
    const row = [
      escapeCSV(e.uuid || ''),
      escapeCSV(a.uuid || ''),
      escapeCSV(a.name || ''),
      escapeCSV(a.code || ''),
      escapeCSV(b.uuid || ''),
      escapeCSV(b.name || ''),
      escapeCSV(b.code || ''),
      escapeCSV(e.tag || ''),
      escapeCSV(e.code || ''),
      escapeCSV((typeof e.latencyMs === "number" && isFinite(e.latencyMs)) ? e.latencyMs : ''),
      escapeCSV(e.capacity || ''),
      escapeCSV((typeof e.priority === "number" && isFinite(e.priority)) ? e.priority : 0),
      escapeCSV(e.extraTags || '')
    ];
    
    csv += row.join(';') + '\r\n';
  }
  
  downloadText('links.csv', csv, 'text/csv;charset=utf-8');
  showToast('Exported links.csv');
});

  document.getElementById('btnExportNodes').addEventListener('click', () => {
  const headers = [
    'Node UUID',
    'Node Name',
    'Node Code',
    'Tags',
    'Additional Tags',
    'Address',
    'City',
    'Container Box',
    'Container Box UUID',
    'X',
    'Y'
  ];
  
  // Use semicolon as delimiter for European Excel compatibility
  let csv = headers.join(';') + '\r\n';
  
  for (const n of state.nodes) {
    // Ensure UUID exists
    if (!n.uuid) n.uuid = generateUUID();
    
    const g = n.groupId ? findGroup(n.groupId) : null;
    if (g && !g.uuid) g.uuid = generateUUID();
    
    const row = [
      escapeCSV(n.uuid || ''),
      escapeCSV(n.name || ''),
      escapeCSV(n.code || ''),
      escapeCSV((n.tags||[]).join('|')),
      escapeCSV(n.extraTags || ''),
      escapeCSV(n.address || ''),
      escapeCSV(n.city || ''),
      escapeCSV(g?.title || ''),
      escapeCSV(g?.uuid || ''),
      escapeCSV(Math.round(n.x)),
      escapeCSV(Math.round(n.y))
    ];
    
    csv += row.join(';') + '\r\n';
  }
  
  downloadText('nodes.csv', csv, 'text/csv;charset=utf-8');
  showToast('Exported nodes.csv');
});

  const NDG_FILETYPE = "NDG_PROJECT";
  const NDG_VERSION = 2;
  const LS_AUTOSAVE_KEY = "ndg_autosave_v2";
  const LS_LASTNAME_KEY = "ndg_last_filename_v2";
  const AUTOSAVE_INTERVAL_MS = 5000;

  function buildProjectObject() {
    return {
      fileType: NDG_FILETYPE,
      version: NDG_VERSION,
      savedAt: new Date().toISOString(),
      nodes: state.nodes,
      edges: state.edges,
      groups: state.groups,
      cableSystems: state.cableSystems,
      nextNode: state.nextNode,
      nextEdge: state.nextEdge,
      nextGroup: state.nextGroup,
      nextCableSystem: state.nextCableSystem,
      stylePresets: state.stylePresets,
      canvasWidth: state.canvasWidth,
      canvasHeight: state.canvasHeight,
      showCanvasBorder: state.showCanvasBorder,
      gridEnabled: state.gridEnabled,
      gridSize: state.gridSize,
      tagFilter: {
        mode: state.tagFilter.mode,
        selectedTags: Array.from(state.tagFilter.selectedTags)
      },
      cableSystemFilter: {
        mode: state.cableSystemFilter.mode,
        selectedSystems: Array.from(state.cableSystemFilter.selectedSystems),
        showUnmapped: state.cableSystemFilter.showUnmapped
      },
      nodeFilter: {
        mode: state.nodeFilter.mode,
        selectedNodes: Array.from(state.nodeFilter.selectedNodes),
        displayMode: state.nodeFilter.displayMode
      },
      containerFilter: {
        mode: state.containerFilter.mode,
        selectedBoxes: Array.from(state.containerFilter.selectedBoxes),
        selectedGroups: Array.from(state.containerFilter.selectedGroups)
      },
      ui: state.ui
    };
  }

  function sanitizeBaseName(name) {
    let trimmed = (name || "").trim();
    if (!trimmed) return null;

    // Remove leading dots (".", "..") to avoid browser/OS normalization to underscores
    trimmed = trimmed.replace(/^\.+/, "");

    // Replace invalid filename characters
    trimmed = trimmed.replace(/[<>:"/\\|?*\x00-\x1F]/g, "_");

    // Avoid empty or underscore-only names
    if (!trimmed || /^_+$/.test(trimmed)) return "project";

    return trimmed.slice(0, 80);
  }
  function getLastFilename() { return localStorage.getItem(LS_LASTNAME_KEY) || ""; }
  function setLastFilename(filename) { localStorage.setItem(LS_LASTNAME_KEY, filename); }

  // File System Access API support for true save-in-place
  let currentFileHandle = null;
  
  // Check if File System Access API is supported
  const hasFileSystemAccess = 'showSaveFilePicker' in window && 'showOpenFilePicker' in window;

  async function saveProject(forcePrompt) {
    const project = buildProjectObject();
    const jsonContent = JSON.stringify(project, null, 2);
    
    // If File System Access API is supported
    if (hasFileSystemAccess) {
      try {
        // If Save As requested OR no existing file handle, prompt for new location
        if (forcePrompt || !currentFileHandle) {
          const suggestedName = getLastFilename() || 'project.ndg';
          currentFileHandle = await window.showSaveFilePicker({
            suggestedName: suggestedName,
            types: [{
              description: 'NDG Project Files',
              accept: { 'application/x-ndg+json': ['.ndg'] }
            }]
          });
        }
        
        // Write to the file handle (overwrites existing content)
        const writable = await currentFileHandle.createWritable();
        await writable.write(jsonContent);
        await writable.close();
        
        // Update stored filename
        const filename = currentFileHandle.name;
        setLastFilename(filename);
        dirty = false;
        showToast(`Saved ${filename}`);
        
      } catch (err) {
        if (err.name === 'AbortError') {
          showToast('Save cancelled.');
        } else {
          console.error('Save error:', err);
          showToast('Save failed: ' + err.message);
        }
      }
    } else {
      // Fallback for browsers without File System Access API (Firefox, Safari)
      let filename = getLastFilename();
      if (forcePrompt || !filename) {
        const base = sanitizeBaseName(prompt("Save project as (without extension):", filename.replace(/\.ndg$/i, "") || "project"));
        if (!base) { showToast("Save cancelled."); return; }
        filename = base.toLowerCase().endsWith(".ndg") ? base : `${base}.ndg`;
        setLastFilename(filename);
      }
      downloadText(filename, jsonContent, "application/x-ndg+json");
      dirty = false;
      showToast(`Saved ${filename} (download)`);
    }
  }
  
  async function openProjectWithFilePicker() {
    if (hasFileSystemAccess) {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'NDG Project Files',
            accept: { 'application/x-ndg+json': ['.ndg'], 'application/json': ['.json'] }
          }],
          multiple: false
        });
        
        currentFileHandle = handle;
        const file = await handle.getFile();
        const text = await file.text();
        loadProjectObject(JSON.parse(text));
        setLastFilename(file.name);
        showToast(`Opened ${file.name}`);
        
      } catch (err) {
        if (err.name === 'AbortError') {
          // User cancelled - do nothing
        } else {
          console.error('Open error:', err);
          showToast('Open failed: ' + err.message);
        }
      }
    } else {
      // Fallback: trigger the hidden file input
      document.getElementById('fileLoad').click();
    }
  }

  
function loadProjectObject(obj) {
  if (!obj) throw new Error('Empty project');
  if (obj.fileType && obj.fileType !== 'NDG_PROJECT') throw new Error('Not an NDG project');

  const nn = Array.isArray(obj.nodes) ? obj.nodes : [];
  const ee = Array.isArray(obj.edges) ? obj.edges : [];
  const gg = Array.isArray(obj.groups) ? obj.groups : [];

  state.nodes = nn.map(n => ({
    id: n.id,
    x: n.x, y: n.y,
    shape: n.shape || 'circle',
    r: (typeof n.r === 'number') ? n.r : 24,
    strokeW: (typeof n.strokeW === 'number') ? n.strokeW : 2,
    address: n.address || '',
    city: n.city || '',
    country: n.country || '',
    // GPS coordinates (stored as decimal degrees)
    gpsLat: (typeof n.gpsLat === 'number') ? n.gpsLat : null,
    gpsLon: (typeof n.gpsLon === 'number') ? n.gpsLon : null,
    name: n.name || ('Node' + n.id),
    code: n.code || ('N-' + n.id),
    showCode: (n.showCode !== false),
    tags: Array.isArray(n.tags) ? n.tags : [],
    extraTags: n.extraTags || '',
    groupId: (typeof n.groupId === 'number') ? n.groupId : null,
    cableSystemIds: Array.isArray(n.cableSystemIds) ? n.cableSystemIds : [],  // Backward compatible
    fill: n.fill || '#1b2030',
    stroke: n.stroke || '#9fb3ff',
    nameColor: n.nameColor || '#eaeaea',
    tagColor: n.tagColor || '#b7c0df',
    nameFont: (typeof n.nameFont === 'number') ? n.nameFont : 13,
    tagFont: (typeof n.tagFont === 'number') ? n.tagFont : 11,
    nameDx: (typeof n.nameDx === 'number') ? n.nameDx : 0,
    nameDy: (typeof n.nameDy === 'number') ? n.nameDy : 0,
    tagDx: (typeof n.tagDx === 'number') ? n.tagDx : 0,
    tagDy: (typeof n.tagDy === 'number') ? n.tagDy : 0,
    uuid: n.uuid || generateUUID(),
    // Custom SVG shape data - embedded for library independence
    customSvg: n.customSvg || null,
    libraryShapeId: n.libraryShapeId || null,
    // Additional properties
    lineStyle: n.lineStyle || 'solid',
    showName: n.showName !== false,
    showTag: n.showTag !== false
  }));

  state.edges = ee.map(e => ({
    id: e.id,
    a: e.a, b: e.b,
    tag: e.tag || '',
    latencyMs: (typeof e.latencyMs === 'number') ? e.latencyMs : null,
    code: e.code || ('L-' + e.id),
    showCode: (e.showCode !== false),
    extraTags: e.extraTags || '',
    style: e.style || 'straight',
    route: e.route || 'hv',
    labelDx: (typeof e.labelDx === 'number') ? e.labelDx : 0,
    labelDy: (typeof e.labelDy === 'number') ? e.labelDy : 0,
    labelFont: (typeof e.labelFont === 'number') ? e.labelFont : 12,
    labelColor: e.labelColor || '#eaeaea',
    strokeW: (typeof e.strokeW === 'number') ? e.strokeW : 2,
    strokeColor: e.strokeColor || '#7f8aa6',
    capacity: e.capacity || 'Up to 10G WL',
    priority: (typeof e.priority === 'number') ? e.priority : 0,
    cableSystemId: (e.cableSystemId !== undefined) ? e.cableSystemId : null,  // Backward compatible
    curveArch: (typeof e.curveArch === 'number') ? e.curveArch : 0.3,
    uuid: e.uuid || generateUUID(),
    filterTags: Array.isArray(e.filterTags) ? e.filterTags : ['default'],
    lineStyle: e.lineStyle || 'solid',
    // Additional label properties
    tagColor: e.tagColor || '#eaeaea',
    tagSize: (typeof e.tagSize === 'number') ? e.tagSize : 12,
    tagFont: e.tagFont || 'Arial',
    showLatency: e.showLatency !== false,
    showTag: e.showTag !== false
  }));

  // Load cable systems (backward compatible - empty array if not present)
  const cs = Array.isArray(obj.cableSystems) ? obj.cableSystems : [];
  state.cableSystems = cs.map(c => ({
    id: c.id,
    uuid: c.uuid || generateUUID(),
    shortName: c.shortName || `CS${c.id}`,
    name: c.name || `Cable System ${c.id}`,
    type: c.type || 'wet',
    rfsYear: (typeof c.rfsYear === 'number') ? c.rfsYear : new Date().getFullYear(),
    fiberPairs: (typeof c.fiberPairs === 'number') ? c.fiberPairs : 1,
    status: c.status || 'planned',
    capacityTbps: (typeof c.capacityTbps === 'number') ? c.capacityTbps : 0,
    owners: c.owners || '',
    notes: c.notes || '',
    filterTags: Array.isArray(c.filterTags) ? c.filterTags : ['default']
  }));

  state.groups = gg.map(g => ({
    id: g.id,
    type: g.type || 'country',
    parentId: g.parentId ?? null,
    x: g.x, y: g.y, w: g.w, h: g.h,
    title: g.title || ((g.type==='region') ? ('Group' + g.id) : 'Container'),
    extraTags: g.extraTags || '',
    fill: g.fill || (g.type==='region' ? 'rgba(120, 140, 180, 0.10)' : 'rgba(54, 76, 140, 0.12)'),
    stroke: g.stroke || (g.type==='region' ? '#7f8aa6' : '#6073b8'),
    strokeW: (typeof g.strokeW === 'number') ? g.strokeW : 2,
    titleColor: g.titleColor || '#eaeaea',
    titleFont: (typeof g.titleFont === 'number') ? g.titleFont : (g.type==='region' ? 15 : 14),
    titleDx: (typeof g.titleDx === 'number') ? g.titleDx : 0,
    titleDy: (typeof g.titleDy === 'number') ? g.titleDy : 0,
    // Shape container properties - embedded shape data for library independence
    shapeContainer: g.shapeContainer || false,
    decorativeShape: g.decorativeShape ? {
      id: g.decorativeShape.id,
      svgData: g.decorativeShape.svgData,
      pathData: g.decorativeShape.pathData,
      viewBox: g.decorativeShape.viewBox,
      name: g.decorativeShape.name,
      aspectRatio: g.decorativeShape.aspectRatio
    } : null,
    // Additional properties
    filterTags: Array.isArray(g.filterTags) ? g.filterTags : ['default'],
    showTitle: g.showTitle !== false,
    lineStyle: g.lineStyle || 'solid',
    transitLatency: (typeof g.transitLatency === 'number') ? g.transitLatency : null
  }));

  state.nextNode = (typeof obj.nextNode === 'number') ? obj.nextNode : (Math.max(0, ...state.nodes.map(n=>n.id)) + 1);
  state.nextEdge = (typeof obj.nextEdge === 'number') ? obj.nextEdge : (Math.max(0, ...state.edges.map(e=>e.id)) + 1);
  state.nextGroup = (typeof obj.nextGroup === 'number') ? obj.nextGroup : (Math.max(0, ...state.groups.map(g=>g.id)) + 1);
  state.nextCableSystem = (typeof obj.nextCableSystem === 'number') ? obj.nextCableSystem : (Math.max(0, ...state.cableSystems.map(cs=>cs.id)) + 1);
  
  // Restore canvas dimensions
  if (typeof obj.canvasWidth === 'number') state.canvasWidth = obj.canvasWidth;
  if (typeof obj.canvasHeight === 'number') state.canvasHeight = obj.canvasHeight;
  if (typeof obj.showCanvasBorder === 'boolean') state.showCanvasBorder = obj.showCanvasBorder;
  
  // Restore grid settings
  if (typeof obj.gridEnabled === 'boolean') state.gridEnabled = obj.gridEnabled;
  if (typeof obj.gridSize === 'number') state.gridSize = obj.gridSize;
  // Update grid UI
  const gridEnabledCb = document.getElementById('gridEnabled');
  const btnGridToggle = document.getElementById('btnGridToggle');
  const gridMenu = document.getElementById('gridMenu');
  if (gridEnabledCb) gridEnabledCb.checked = state.gridEnabled;
  if (btnGridToggle) btnGridToggle.classList.toggle('active', state.gridEnabled);
  if (gridMenu) {
    gridMenu.querySelectorAll('.grid-size').forEach(item => {
      item.classList.toggle('active', parseInt(item.dataset.size) === state.gridSize);
    });
  }
  
  // Restore tag filter settings
  if (obj.tagFilter) {
    state.tagFilter.mode = obj.tagFilter.mode || 'all';
    state.tagFilter.selectedTags = new Set(obj.tagFilter.selectedTags || []);
  } else {
    state.tagFilter.mode = 'all';
    state.tagFilter.selectedTags = new Set();
  }
  // Update tag filter UI
  const tagFilterMenu = document.getElementById('tagFilterMenu');
  const btnTagFilter = document.getElementById('btnTagFilter');
  if (tagFilterMenu) {
    const modeRadio = tagFilterMenu.querySelector(`input[name="filterMode"][value="${state.tagFilter.mode}"]`);
    if (modeRadio) modeRadio.checked = true;
  }
  if (btnTagFilter) {
    const isFiltering = state.tagFilter.mode !== 'all' && state.tagFilter.selectedTags.size > 0;
    btnTagFilter.classList.toggle('filtering', isFiltering);
  }
  
  // Restore UI settings
  if (obj.ui) {
    state.ui = { ...state.ui, ...obj.ui };
  }
  // Sync UI toggles
  const tglShowNodeTags = document.getElementById('tglShowNodeTags');
  const tglShowExtraTags = document.getElementById('tglShowExtraTags');
  const tglShowLatency = document.getElementById('tglShowLatency');
  const tglShowNodeCode = document.getElementById('tglShowNodeCode');
  const tglShowLinkCode = document.getElementById('tglShowLinkCode');
  const tglShowNodeName = document.getElementById('tglShowNodeName');
  const tglShowLinkTag = document.getElementById('tglShowLinkTag');
  const tglShowContainerTitle = document.getElementById('tglShowContainerTitle');
  if (tglShowLatency) tglShowLatency.checked = !!state.ui.showLatency;
  if (tglShowNodeCode) tglShowNodeCode.checked = !!state.ui.showNodeCode;
  if (tglShowLinkCode) tglShowLinkCode.checked = !!state.ui.showLinkCode;
  if (tglShowNodeTags) tglShowNodeTags.checked = !!state.ui.showNodeTags;
  if (tglShowExtraTags) tglShowExtraTags.checked = !!state.ui.showExtraTags;
  if (tglShowNodeName) tglShowNodeName.checked = state.ui.showNodeName !== false;
  if (tglShowLinkTag) tglShowLinkTag.checked = state.ui.showLinkTag !== false;
  if (tglShowContainerTitle) tglShowContainerTitle.checked = state.ui.showContainerTitle !== false;
  
  svg.setAttribute('viewBox', `0 0 ${state.canvasWidth} ${state.canvasHeight}`);
  
  // Restore style presets
  state.stylePresets = obj.stylePresets || { node:{}, edge:{}, group:{} };
  
  // Clear transient state
  state.selected = null;
  state.connectFrom = null;
  state.dragging = null;
  state.resizingGroup = null;
  state.resizingNode = null;
  state.placingGroup = false;
  state.placingGroupType = 'country';
  state.styleBrush = null;
  clearSelection();
  
  // CRITICAL: Refresh all memberships
  refreshAllMemberships();
  
  // Reset history
  history.stack = [];
  history.index = -1;
  pushHistory();
  
  // Sync UI toggles
  syncGlobalToggles();
  
  // Render and update UI
  render();
  dirty = false;
}


  function autosaveNow() {
    try {
      localStorage.setItem(LS_AUTOSAVE_KEY, JSON.stringify(buildProjectObject()));
      dirty = false;
    } catch (e) { console.warn("Autosave failed:", e); }
  }
  setInterval(() => { if (dirty) autosaveNow(); }, AUTOSAVE_INTERVAL_MS);

  function recoverAutosave() {
    const raw = localStorage.getItem(LS_AUTOSAVE_KEY);
    if (!raw) { showToast("No autosave found."); return; }
    try { loadProjectObject(JSON.parse(raw)); showToast("Recovered autosave."); }
    catch (e) { showToast("Autosave recovery failed: " + e.message); }
  }
  function clearAutosave() { localStorage.removeItem(LS_AUTOSAVE_KEY); showToast("Autosave cleared."); }

  document.getElementById('fileLoad').addEventListener('change', async (ev) => {
    const f = ev.target.files?.[0];
    if (!f) return;
    try {
      const text = await f.text();
      loadProjectObject(JSON.parse(text));
      setLastFilename(f.name);
      // Clear file handle since we can't save back to this file via fallback method
      currentFileHandle = null;
      showToast(`Opened ${f.name}`);
    } catch (e) {
      showToast('Open failed: ' + e.message);
    } finally {
      ev.target.value = '';
    }
  });

  function clearDiagram() {
    state.nodes=[]; state.edges=[]; state.groups=[];
    state.nextNode=1; state.nextEdge=1; state.nextGroup=1;
    state.selected=null; state.connectFrom=null; state.placingGroup=false; state.placingGroupType='country';
    state.selection.nodes.clear(); state.selection.edges.clear(); state.selection.groups.clear();
    history.stack=[]; history.index=-1; pushHistory();
    // Clear file handle so next save prompts for new location
    currentFileHandle = null;
    setLastFilename('');
    commit(); render();
    showToast('Cleared.');
  }
  
  function newDiagram() {
    if (dirty && !confirm('You have unsaved changes. Create a new diagram anyway?')) {
      return;
    }
    clearDiagram();
    showToast('New diagram created.');
  }

  // (legacy button) 
  document.getElementById('btnClear')?.addEventListener('click', () => { clearDiagram(); });
  (function autosaveStartupHint(){
    const raw = localStorage.getItem(LS_AUTOSAVE_KEY);
    if (raw) showToast("Autosave available ‚Äî click ‚ÄúRecover Autosave‚Äù if needed.");
  })();

  // Inspector panel controls (draggable, minimizable, closeable)
  const inspector = document.getElementById('inspector');
  const inspectorHeader = document.getElementById('inspectorHeader');
  const btnMinimizeInspector = document.getElementById('btnMinimizeInspector');
  const btnCloseInspector = document.getElementById('btnCloseInspector');
  const btnToggleInspector = document.getElementById('btnToggleInspector');

  let inspectorDragging = false;
  let inspectorDragOffset = { x: 0, y: 0 };
  let inspectorMinimized = false;

  // Toggle inspector from header button
  if (btnToggleInspector) {
    btnToggleInspector.addEventListener('click', () => {
      if (inspector.style.display === 'none') {
        inspector.style.display = 'flex';
        btnToggleInspector.classList.add('primary');
      } else {
        inspector.style.display = 'none';
        btnToggleInspector.classList.remove('primary');
      }
    });
  }

  // Make inspector draggable
  inspectorHeader.addEventListener('mousedown', (ev) => {
    if (ev.target.tagName === 'BUTTON' || ev.target.closest('button')) return;
    inspectorDragging = true;
    const rect = inspector.getBoundingClientRect();
    inspectorDragOffset.x = ev.clientX - rect.left;
    inspectorDragOffset.y = ev.clientY - rect.top;
    inspector.style.cursor = 'grabbing';
    ev.preventDefault();
  });

  window.addEventListener('mousemove', (ev) => {
    if (!inspectorDragging) return;
    const layout = document.getElementById('layout');
    const layoutRect = layout.getBoundingClientRect();
    
    let newLeft = ev.clientX - layoutRect.left - inspectorDragOffset.x;
    let newTop = ev.clientY - layoutRect.top - inspectorDragOffset.y;
    
    // Keep inspector within bounds
    const maxLeft = layoutRect.width - inspector.offsetWidth;
    const maxTop = layoutRect.height - 44; // At least show header
    
    newLeft = Math.max(0, Math.min(newLeft, maxLeft));
    newTop = Math.max(0, Math.min(newTop, maxTop));
    
    inspector.style.left = newLeft + 'px';
    inspector.style.top = newTop + 'px';
    inspector.style.right = 'auto'; // Remove right positioning
  });

  window.addEventListener('mouseup', () => {
    if (inspectorDragging) {
      inspectorDragging = false;
      inspector.style.cursor = '';
    }
  });

  // Minimize/Maximize toggle
  btnMinimizeInspector.addEventListener('click', () => {
    inspectorMinimized = !inspectorMinimized;
    inspector.classList.toggle('minimized', inspectorMinimized);
    btnMinimizeInspector.textContent = inspectorMinimized ? '+' : '‚àí';
    btnMinimizeInspector.title = inspectorMinimized ? 'Maximize' : 'Minimize';
  });

  // Close inspector
  btnCloseInspector.addEventListener('click', () => {
    inspector.style.display = 'none';
    if (btnToggleInspector) btnToggleInspector.classList.remove('primary');
    showToast('Inspector hidden. Press "I" to show it again.');
  });

  // Keyboard shortcut to toggle inspector visibility
  window.addEventListener('keydown', (ev) => {
    if (ev.key.toLowerCase() === 'i' && !['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) {
      if (inspector.style.display === 'none') {
        inspector.style.display = 'flex';
        if (btnToggleInspector) btnToggleInspector.classList.add('primary');
        showToast('Inspector shown.');
      } else {
        inspector.style.display = 'none';
        if (btnToggleInspector) btnToggleInspector.classList.remove('primary');
        showToast('Inspector hidden. Press "I" to show it again.');
      }
    }
  });

  refreshPresetSelects();
  syncGlobalToggles();
  pushHistory();
  updateViewBox(); // Initialize pan and zoom
  render();

  // Initialize color pickers with palette
  const colorInputs = [
    'nodeFill', 'nodeStroke', 'nodeNameColor', 'nodeTagColor',
    'edgeStrokeColor', 'edgeLabelColor',
    'groupFill', 'groupStroke', 'groupTitleColor'
  ];
  const colorPickers = {};
  colorInputs.forEach(id => {
    const input = document.getElementById(id);
    if (input && input.type === 'color') {
      colorPickers[id] = createColorPicker(input);
    }
  });

  // Update color pickers when inspector is populated
  const originalSyncInspector = window.syncInspector || (() => {});
  window.updateColorPickers = function() {
    Object.values(colorPickers).forEach(cp => {
      if (cp && cp.update) cp.update();
    });
  };

  // ===== CABLE SYSTEM NAVIGATOR & INSPECTOR UI =====
  
  const cableNavigator = document.getElementById('cableNavigator');
  const cableNavigatorHeader = document.getElementById('cableNavigatorHeader');
  const cableInspectorPanel = document.getElementById('cableSystemInspectorPanel');
  const cableInspectorHeader = document.getElementById('cableInspectorHeader');
  const btnToggleCableNavigator = document.getElementById('btnToggleCableNavigator');
  const btnToggleCableInspector = document.getElementById('btnToggleCableInspector');
  const btnNewCableSystem = document.getElementById('btnNewCableSystem');
  const btnDeleteCableSystem = document.getElementById('btnDeleteCableSystem');
  const cableNavSearch = document.getElementById('cableNavSearch');
  const cableSystemList = document.getElementById('cableSystemList');

  // Add mode state
  let csAddMode = null; // null, 'links', or 'nodes'
  let csPendingItems = new Set(); // IDs of items to add

  // Make cable navigator draggable
  if (cableNavigatorHeader && cableNavigator) {
    let isDragging = false;
    let offsetX, offsetY;
    
    cableNavigatorHeader.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'BUTTON') return;
      isDragging = true;
      offsetX = e.clientX - cableNavigator.offsetLeft;
      offsetY = e.clientY - cableNavigator.offsetTop;
      cableNavigator.style.cursor = 'move';
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      cableNavigator.style.left = (e.clientX - offsetX) + 'px';
      cableNavigator.style.top = (e.clientY - offsetY) + 'px';
      cableNavigator.style.right = 'auto';
    });
    
    document.addEventListener('mouseup', () => {
      isDragging = false;
      cableNavigator.style.cursor = '';
    });
  }

  // Make cable inspector draggable
  if (cableInspectorHeader && cableInspectorPanel) {
    let isDragging = false;
    let offsetX, offsetY;
    
    cableInspectorHeader.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'BUTTON') return;
      isDragging = true;
      offsetX = e.clientX - cableInspectorPanel.offsetLeft;
      offsetY = e.clientY - cableInspectorPanel.offsetTop;
      cableInspectorPanel.style.cursor = 'move';
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      cableInspectorPanel.style.left = (e.clientX - offsetX) + 'px';
      cableInspectorPanel.style.top = (e.clientY - offsetY) + 'px';
      cableInspectorPanel.style.right = 'auto';
    });
    
    document.addEventListener('mouseup', () => {
      isDragging = false;
      cableInspectorPanel.style.cursor = '';
    });
  }

  // Toggle cable navigator visibility
  if (btnToggleCableNavigator) {
    btnToggleCableNavigator.addEventListener('click', () => {
      if (cableNavigator.style.display === 'none' || !cableNavigator.style.display) {
        cableNavigator.style.display = 'flex';
        btnToggleCableNavigator.classList.add('active');
        updateCableNavigatorList();
      } else {
        cableNavigator.style.display = 'none';
        btnToggleCableNavigator.classList.remove('active');
        // Clear cable system selection when hiding the list
        state.selectedCableSystem = null;
        updateCableSystemInspector();
        render();
      }
    });
  }

  // Toggle cable system inspector visibility
  if (btnToggleCableInspector) {
    btnToggleCableInspector.addEventListener('click', () => {
      if (cableInspectorPanel.style.display === 'none' || !cableInspectorPanel.style.display) {
        cableInspectorPanel.style.display = 'flex';
        btnToggleCableInspector.classList.add('active');
        updateCableSystemInspector();
      } else {
        cableInspectorPanel.style.display = 'none';
        btnToggleCableInspector.classList.remove('active');
      }
    });
  }

  // Minimize/close cable navigator
  const btnMinimizeCableNav = document.getElementById('btnMinimizeCableNav');
  const btnCloseCableNav = document.getElementById('btnCloseCableNav');
  
  if (btnMinimizeCableNav) {
    btnMinimizeCableNav.addEventListener('click', () => {
      cableNavigator.classList.toggle('minimized');
      btnMinimizeCableNav.textContent = cableNavigator.classList.contains('minimized') ? '+' : '‚àí';
    });
  }
  
  if (btnCloseCableNav) {
    btnCloseCableNav.addEventListener('click', () => {
      cableNavigator.style.display = 'none';
      btnToggleCableNavigator.classList.remove('active');
      // Clear cable system selection when closing the list
      state.selectedCableSystem = null;
      updateCableSystemInspector();
      render();
    });
  }

  // Minimize/close cable inspector
  const btnMinimizeCableInspector = document.getElementById('btnMinimizeCableInspector');
  const btnCloseCableInspector = document.getElementById('btnCloseCableInspector');
  
  if (btnMinimizeCableInspector) {
    btnMinimizeCableInspector.addEventListener('click', () => {
      cableInspectorPanel.classList.toggle('minimized');
      btnMinimizeCableInspector.textContent = cableInspectorPanel.classList.contains('minimized') ? '+' : '‚àí';
    });
  }
  
  if (btnCloseCableInspector) {
    btnCloseCableInspector.addEventListener('click', () => {
      cableInspectorPanel.style.display = 'none';
      btnToggleCableInspector.classList.remove('active');
      cancelAddMode();
    });
  }

  // New cable system button
  if (btnNewCableSystem) {
    btnNewCableSystem.addEventListener('click', () => {
      createCableSystem();
    });
  }

  // Delete cable system button
  if (btnDeleteCableSystem) {
    btnDeleteCableSystem.addEventListener('click', () => {
      if (!state.selectedCableSystem) {
        showToast('Select a cable system first.');
        return;
      }
      showDeleteCableSystemDialog(state.selectedCableSystem);
    });
  }

  // Search filter for cable navigator
  if (cableNavSearch) {
    cableNavSearch.addEventListener('input', () => {
      updateCableNavigatorList();
    });
  }

  function updateCableNavigatorList() {
    if (!cableSystemList) return;
    
    const searchTerm = (cableNavSearch?.value || '').toLowerCase();
    const filtered = state.cableSystems.filter(cs => {
      if (!searchTerm) return true;
      return cs.shortName.toLowerCase().includes(searchTerm) ||
             cs.name.toLowerCase().includes(searchTerm);
    });
    
    if (filtered.length === 0) {
      cableSystemList.innerHTML = '<div class="muted" style="padding:12px; text-align:center;">No cable systems found.</div>';
      return;
    }
    
    cableSystemList.innerHTML = filtered.map(cs => {
      const linkCount = getCableSystemLinks(cs.id).length;
      const nodeCount = getCableSystemNodes(cs.id).length;
      const isSelected = state.selectedCableSystem === cs.id;
      return `
        <div class="cable-system-item ${isSelected ? 'selected' : ''}" data-cs-id="${cs.id}">
          <div>
            <div class="cs-name">${cs.shortName}</div>
            <div class="cs-fullname">${cs.name}</div>
          </div>
          <div class="cs-count">${linkCount}L / ${nodeCount}N</div>
        </div>
      `;
    }).join('');
    
    // Add click handlers
    cableSystemList.querySelectorAll('.cable-system-item').forEach(item => {
      item.addEventListener('click', () => {
        const csId = parseInt(item.dataset.csId);
        selectCableSystem(csId);
      });
    });
  }

  function selectCableSystem(csId) {
    state.selectedCableSystem = csId;
    updateCableNavigatorList();
    updateCableSystemInspector();
    render();
  }

  function showDeleteCableSystemDialog(csId) {
    const cs = findCableSystem(csId);
    if (!cs) return;
    
    const links = getCableSystemLinks(csId);
    const nodes = getCableSystemNodes(csId);
    
    // Highlight associated items on canvas
    highlightCableSystemItems(csId);
    
    // Create modal dialog
    const modal = document.createElement('div');
    modal.id = 'deleteCableSystemModal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 10001;
      display: flex; justify-content: center; align-items: center;
    `;
    
    modal.innerHTML = `
      <div style="background: #fff; border-radius: 8px; padding: 24px; max-width: 400px; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
        <h3 style="margin: 0 0 16px;">Delete Cable System "${cs.shortName}"?</h3>
        <p style="margin: 0 0 12px; color: #666;">This cable system has:</p>
        <ul style="margin: 0 0 16px; padding-left: 20px; color: #666;">
          <li>${links.length} link(s)</li>
          <li>${nodes.length} node(s)</li>
        </ul>
        <p style="margin: 0 0 20px; font-size: 13px; color: #888;">
          These items are highlighted on the canvas.
        </p>
        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
          <button class="btn" id="btnDeleteAll" style="background: #d32f2f; color: #fff; border-color: #d32f2f;">Delete All</button>
          <button class="btn" id="btnUnmapOnly">Unmap Only</button>
          <button class="btn" id="btnCancelDelete">Cancel</button>
        </div>
        <p style="margin: 12px 0 0; font-size: 11px; color: #888;">
          <strong>Delete All:</strong> Remove cable system AND all its links/nodes<br/>
          <strong>Unmap Only:</strong> Remove cable system but keep links/nodes
        </p>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    modal.querySelector('#btnDeleteAll').addEventListener('click', () => {
      deleteCableSystem(csId, 'deleteAll');
      clearHighlights();
      modal.remove();
    });
    
    modal.querySelector('#btnUnmapOnly').addEventListener('click', () => {
      deleteCableSystem(csId, 'unmapOnly');
      clearHighlights();
      modal.remove();
    });
    
    modal.querySelector('#btnCancelDelete').addEventListener('click', () => {
      clearHighlights();
      modal.remove();
    });
  }

  function highlightCableSystemItems(csId) {
    // Add temporary highlight class to associated items
    const links = getCableSystemLinks(csId);
    const nodes = getCableSystemNodes(csId);
    
    // Visual highlight via render - store temporarily
    state._highlightedLinks = new Set(links.map(l => l.id));
    state._highlightedNodes = new Set(nodes.map(n => n.id));
    render();
  }

  function clearHighlights() {
    state._highlightedLinks = null;
    state._highlightedNodes = null;
    render();
  }

  // Update inspector to show cable system details
  function updateCableSystemInspector() {
    const csNoSel = document.getElementById('csNoSelection');
    const csDetails = document.getElementById('csDetails');
    
    if (!csNoSel || !csDetails) return;
    
    if (!state.selectedCableSystem) {
      csNoSel.style.display = 'block';
      csDetails.style.display = 'none';
      return;
    }
    
    const cs = findCableSystem(state.selectedCableSystem);
    if (!cs) {
      csNoSel.style.display = 'block';
      csDetails.style.display = 'none';
      return;
    }
    
    csNoSel.style.display = 'none';
    csDetails.style.display = 'block';
    
    // Populate fields
    document.getElementById('csUUID').value = cs.uuid || '';
    document.getElementById('csShortName').value = cs.shortName || '';
    document.getElementById('csName').value = cs.name || '';
    document.getElementById('csType').value = cs.type || 'wet';
    document.getElementById('csStatus').value = cs.status || 'planned';
    document.getElementById('csRfsYear').value = cs.rfsYear || '';
    document.getElementById('csFiberPairs').value = cs.fiberPairs || '';
    document.getElementById('csCapacity').value = cs.capacityTbps || '';
    document.getElementById('csOwners').value = cs.owners || '';
    document.getElementById('csFilterTags').value = (cs.filterTags || []).join(', ');
    document.getElementById('csNotes').value = cs.notes || '';
    
    // Update member lists
    const links = getCableSystemLinks(cs.id);
    const nodes = getCableSystemNodes(cs.id);
    
    document.getElementById('csMemberLinksCount').textContent = links.length;
    document.getElementById('csMemberNodesCount').textContent = nodes.length;
    
    const linksContainer = document.getElementById('csMemberLinks');
    if (links.length === 0) {
      linksContainer.innerHTML = '<div class="muted">No links assigned</div>';
    } else {
      linksContainer.innerHTML = links.map(l => {
        const nodeA = findNode(l.a);
        const nodeB = findNode(l.b);
        return `<div class="member-item" data-type="edge" data-id="${l.id}" style="padding:4px; cursor:pointer; border-radius:3px; display:flex; justify-content:space-between; align-items:center;">
          <span>${l.code || 'L-' + l.id}: ${nodeA?.name || '?'} ‚Üî ${nodeB?.name || '?'}</span>
          <button class="remove-member-btn" data-type="edge" data-id="${l.id}" style="background:none; border:none; color:#d32f2f; cursor:pointer; font-size:14px;" title="Remove from cable system">√ó</button>
        </div>`;
      }).join('');
    }
    
    const nodesContainer = document.getElementById('csMemberNodes');
    if (nodes.length === 0) {
      nodesContainer.innerHTML = '<div class="muted">No nodes assigned</div>';
    } else {
      nodesContainer.innerHTML = nodes.map(n => {
        return `<div class="member-item" data-type="node" data-id="${n.id}" style="padding:4px; cursor:pointer; border-radius:3px; display:flex; justify-content:space-between; align-items:center;">
          <span>${n.code || 'N-' + n.id}: ${n.name || 'Unnamed'}</span>
          <button class="remove-member-btn" data-type="node" data-id="${n.id}" style="background:none; border:none; color:#d32f2f; cursor:pointer; font-size:14px;" title="Remove from cable system">√ó</button>
        </div>`;
      }).join('');
    }
    
    // Add click handlers for member items
    document.querySelectorAll('#csMemberLinks .member-item, #csMemberNodes .member-item').forEach(item => {
      let clickCount = 0;
      let clickTimer = null;
      
      item.addEventListener('click', (e) => {
        // Ignore if clicking remove button
        if (e.target.classList.contains('remove-member-btn')) return;
        
        clickCount++;
        if (clickCount === 1) {
          clickTimer = setTimeout(() => {
            // Single click - highlight on canvas
            const type = item.dataset.type;
            const id = parseInt(item.dataset.id);
            highlightItemOnCanvas(type, id);
            clickCount = 0;
          }, 300);
        } else if (clickCount === 2) {
          // Double click - show in main inspector
          clearTimeout(clickTimer);
          const type = item.dataset.type;
          const id = parseInt(item.dataset.id);
          select({ type, id });
          // Show main inspector if hidden
          if (inspector.style.display === 'none') {
            inspector.style.display = 'flex';
            btnToggleInspector.classList.add('active');
          }
          clickCount = 0;
        }
      });
      
      item.addEventListener('mouseenter', () => {
        item.style.background = '#e3f2fd';
      });
      item.addEventListener('mouseleave', () => {
        item.style.background = '';
      });
    });
    
    // Add click handlers for remove buttons
    document.querySelectorAll('.remove-member-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const type = btn.dataset.type;
        const id = parseInt(btn.dataset.id);
        
        if (type === 'edge') {
          const edge = findEdge(id);
          if (edge) {
            edge.cableSystemId = null;
            commit();
            updateCableSystemInspector();
            updateCableNavigatorList();
            render();
            showToast('Link removed from cable system.');
          }
        } else if (type === 'node') {
          const node = findNode(id);
          if (node && node.cableSystemIds) {
            node.cableSystemIds = node.cableSystemIds.filter(csId => csId !== state.selectedCableSystem);
            commit();
            updateCableSystemInspector();
            updateCableNavigatorList();
            render();
            showToast('Node removed from cable system.');
          }
        }
      });
    });
  }

  // Add mode functions
  function startAddMode(type) {
    if (!state.selectedCableSystem) {
      showToast('Select a cable system first.');
      return;
    }
    
    csAddMode = type; // 'links' or 'nodes'
    csPendingItems = new Set();
    
    const addModeBar = document.getElementById('csAddModeBar');
    const addModeText = document.getElementById('csAddModeText');
    
    if (addModeBar && addModeText) {
      addModeBar.style.display = 'block';
      addModeText.textContent = type === 'links' 
        ? 'Click links on canvas to add them...' 
        : 'Click nodes on canvas to add them...';
    }
    
    showToast(`Click ${type} on canvas to add. Click Accept when done.`);
    render(); // Re-render to show visual feedback
  }

  function cancelAddMode() {
    csAddMode = null;
    csPendingItems = new Set();
    
    const addModeBar = document.getElementById('csAddModeBar');
    if (addModeBar) addModeBar.style.display = 'none';
    
    clearHighlights();
    render();
  }

  function acceptAddMode() {
    if (!csAddMode || !state.selectedCableSystem) {
      cancelAddMode();
      return;
    }
    
    const cs = findCableSystem(state.selectedCableSystem);
    if (!cs) {
      cancelAddMode();
      return;
    }
    
    let count = 0;
    
    if (csAddMode === 'links') {
      csPendingItems.forEach(linkId => {
        const edge = findEdge(linkId);
        if (edge) {
          edge.cableSystemId = state.selectedCableSystem;
          count++;
        }
      });
    } else if (csAddMode === 'nodes') {
      csPendingItems.forEach(nodeId => {
        const node = findNode(nodeId);
        if (node) {
          if (!node.cableSystemIds) node.cableSystemIds = [];
          if (!node.cableSystemIds.includes(state.selectedCableSystem)) {
            node.cableSystemIds.push(state.selectedCableSystem);
            count++;
          }
        }
      });
    }
    
    if (count > 0) {
      commit();
      showToast(`Added ${count} ${csAddMode} to "${cs.shortName}".`);
    }
    
    cancelAddMode();
    updateCableSystemInspector();
    updateCableNavigatorList();
    render();
  }

  // Handle canvas clicks during add mode
  function handleAddModeClick(type, id) {
    if (!csAddMode) return false;
    
    if (csAddMode === 'links' && type === 'edge') {
      if (csPendingItems.has(id)) {
        csPendingItems.delete(id);
      } else {
        csPendingItems.add(id);
      }
      // Update highlights
      state._highlightedLinks = new Set(csPendingItems);
      render();
      return true;
    } else if (csAddMode === 'nodes' && type === 'node') {
      if (csPendingItems.has(id)) {
        csPendingItems.delete(id);
      } else {
        csPendingItems.add(id);
      }
      // Update highlights
      state._highlightedNodes = new Set(csPendingItems);
      render();
      return true;
    }
    
    return false;
  }

  // Button handlers for add mode
  const btnAddLinksToCS = document.getElementById('btnAddLinksToCS');
  const btnAddNodesToCS = document.getElementById('btnAddNodesToCS');
  const btnAcceptAddToCS = document.getElementById('btnAcceptAddToCS');
  const btnCancelAddToCS = document.getElementById('btnCancelAddToCS');

  if (btnAddLinksToCS) {
    btnAddLinksToCS.addEventListener('click', () => startAddMode('links'));
  }
  if (btnAddNodesToCS) {
    btnAddNodesToCS.addEventListener('click', () => startAddMode('nodes'));
  }
  if (btnAcceptAddToCS) {
    btnAcceptAddToCS.addEventListener('click', acceptAddMode);
  }
  if (btnCancelAddToCS) {
    btnCancelAddToCS.addEventListener('click', cancelAddMode);
  }

  function highlightItemOnCanvas(type, id) {
    // Temporarily highlight an item
    if (type === 'edge') {
      state._highlightedLinks = new Set([id]);
      state._highlightedNodes = null;
    } else if (type === 'node') {
      state._highlightedNodes = new Set([id]);
      state._highlightedLinks = null;
    }
    render();
    
    // Clear after 2 seconds
    setTimeout(() => {
      clearHighlights();
    }, 2000);
  }

  // Add event listeners for cable system inspector fields
  const csFields = ['csShortName', 'csName', 'csType', 'csStatus', 'csRfsYear', 
                    'csFiberPairs', 'csCapacity', 'csOwners', 'csFilterTags', 'csNotes'];
  
  csFields.forEach(fieldId => {
    const el = document.getElementById(fieldId);
    if (!el) return;
    
    el.addEventListener('input', () => {
      if (!state.selectedCableSystem) return;
      const cs = findCableSystem(state.selectedCableSystem);
      if (!cs) return;
      
      switch(fieldId) {
        case 'csShortName': cs.shortName = el.value; break;
        case 'csName': cs.name = el.value; break;
        case 'csType': cs.type = el.value; break;
        case 'csStatus': cs.status = el.value; break;
        case 'csRfsYear': cs.rfsYear = parseInt(el.value) || null; break;
        case 'csFiberPairs': cs.fiberPairs = parseInt(el.value) || null; break;
        case 'csCapacity': cs.capacityTbps = parseFloat(el.value) || null; break;
        case 'csOwners': cs.owners = el.value; break;
        case 'csFilterTags': 
          cs.filterTags = el.value.split(',').map(t => t.trim()).filter(Boolean);
          if (!cs.filterTags.some(t => t.toLowerCase() === 'default')) {
            cs.filterTags.unshift('default');
          }
          break;
        case 'csNotes': cs.notes = el.value; break;
      }
      
      commit();
      updateCableNavigatorList();
    });
  });

  // Update edge cable system dropdown
  function updateEdgeCableSystemDropdown() {
    const dropdown = document.getElementById('edgeCableSystem');
    if (!dropdown) return;
    
    const currentValue = dropdown.value;
    dropdown.innerHTML = '<option value="">(None)</option>';
    
    state.cableSystems.forEach(cs => {
      const opt = document.createElement('option');
      opt.value = cs.id;
      opt.textContent = cs.shortName;
      dropdown.appendChild(opt);
    });
    
    dropdown.value = currentValue;
  }

  // Update node cable systems checkboxes
  function updateNodeCableSystemsCheckboxes(nodeId) {
    const container = document.getElementById('nodeCableSystems');
    if (!container) return;
    
    const node = findNode(nodeId);
    if (!node) {
      container.innerHTML = '<div class="muted" style="font-size:11px;">No node selected</div>';
      return;
    }
    
    // Get cable systems from connected edges (auto-detected)
    const connectedEdges = state.edges.filter(e => e.a === nodeId || e.b === nodeId);
    const edgeCableSystemIds = new Set();
    connectedEdges.forEach(e => {
      if (e.cableSystemId) edgeCableSystemIds.add(e.cableSystemId);
    });
    
    // Also include manually assigned cable systems
    const nodeCSIds = node.cableSystemIds || [];
    const allCSIds = new Set([...edgeCableSystemIds, ...nodeCSIds]);
    
    if (allCSIds.size === 0 && state.cableSystems.length === 0) {
      container.innerHTML = '<div class="muted" style="font-size:11px;">No cable systems</div>';
      return;
    }
    
    if (allCSIds.size === 0) {
      container.innerHTML = '<div class="muted" style="font-size:11px;">No connections</div>';
      return;
    }
    
    // Show cable systems connected to this node
    let html = '';
    
    // Show auto-detected cable systems from edges
    if (edgeCableSystemIds.size > 0) {
      html += '<div style="font-size:10px; color:#666; margin-bottom:4px; font-weight:600;">üì° Connected Cable Systems:</div>';
      edgeCableSystemIds.forEach(csId => {
        const cs = findCableSystem(csId);
        if (cs) {
          const edgeCount = connectedEdges.filter(e => e.cableSystemId === csId).length;
          html += `
            <div style="display:flex; align-items:center; gap:6px; padding:4px; font-size:11px; background:#f0f9ff; border-radius:4px; margin-bottom:2px;">
              <span style="width:10px; height:10px; border-radius:50%; background:${cs.color || '#666'}; flex-shrink:0;"></span>
              <span style="flex:1;"><strong>${cs.shortName}</strong></span>
              <span style="font-size:10px; color:#666;">${edgeCount} link${edgeCount > 1 ? 's' : ''}</span>
            </div>
          `;
        }
      });
    }
    
    // Show manually assigned cable systems (if any that aren't from edges)
    const manualOnlyCSIds = nodeCSIds.filter(id => !edgeCableSystemIds.has(id));
    if (manualOnlyCSIds.length > 0) {
      html += '<div style="font-size:10px; color:#666; margin-top:6px; margin-bottom:4px; font-weight:600;">üìå Additional:</div>';
      manualOnlyCSIds.forEach(csId => {
        const cs = findCableSystem(csId);
        if (cs) {
          html += `
            <div style="display:flex; align-items:center; gap:6px; padding:4px; font-size:11px; background:#fff8e6; border-radius:4px; margin-bottom:2px;">
              <span style="width:10px; height:10px; border-radius:50%; background:${cs.color || '#666'}; flex-shrink:0;"></span>
              <span style="flex:1;"><strong>${cs.shortName}</strong></span>
              <button onclick="removeManualCableSystem(${nodeId}, ${csId})" style="font-size:9px; padding:2px 6px; cursor:pointer;">‚úï</button>
            </div>
          `;
        }
      });
    }
    
    // Add option to manually add more cable systems
    if (state.cableSystems.length > allCSIds.size) {
      const availableCS = state.cableSystems.filter(cs => !allCSIds.has(cs.id));
      if (availableCS.length > 0) {
        html += `
          <div style="margin-top:6px; padding-top:6px; border-top:1px solid #e0e0e0;">
            <select id="addNodeCableSystem" style="width:100%; font-size:11px; padding:4px;">
              <option value="">+ Add cable system...</option>
              ${availableCS.map(cs => `<option value="${cs.id}">${cs.shortName} - ${cs.name}</option>`).join('')}
            </select>
          </div>
        `;
      }
    }
    
    container.innerHTML = html || '<div class="muted" style="font-size:11px;">No cable systems</div>';
    
    // Add handler for adding cable systems
    const addSelect = document.getElementById('addNodeCableSystem');
    if (addSelect) {
      addSelect.addEventListener('change', () => {
        const csId = parseInt(addSelect.value);
        if (csId && node) {
          if (!node.cableSystemIds) node.cableSystemIds = [];
          if (!node.cableSystemIds.includes(csId)) {
            node.cableSystemIds.push(csId);
            commit();
            updateNodeCableSystemsCheckboxes(nodeId);
            render();
          }
        }
      });
    }
  }
  
  // Remove manually assigned cable system from node
  window.removeManualCableSystem = function(nodeId, csId) {
    const node = findNode(nodeId);
    if (node && node.cableSystemIds) {
      node.cableSystemIds = node.cableSystemIds.filter(id => id !== csId);
      commit();
      updateNodeCableSystemsCheckboxes(nodeId);
      render();
    }
  };

  // Edge cable system change handler
  const edgeCableSystem = document.getElementById('edgeCableSystem');
  if (edgeCableSystem) {
    edgeCableSystem.addEventListener('change', () => {
      if (state.selected?.type !== 'edge') return;
      const e = findEdge(state.selected.id);
      if (!e) return;
      
      const val = edgeCableSystem.value;
      e.cableSystemId = val ? parseInt(val) : null;
      
      // Update info display
      const infoEl = document.getElementById('edgeCableSystemInfo');
      if (infoEl) {
        if (e.cableSystemId) {
          const cs = findCableSystem(e.cableSystemId);
          infoEl.textContent = cs ? cs.name : '';
        } else {
          infoEl.textContent = '';
        }
      }
      
      commit();
      render();
    });
  }

  // Initialize inspector button state
  if (btnToggleInspector) btnToggleInspector.classList.add('active');

  // ============== CANVAS SIZE CONTROLS ==============
  
  // Canvas Width handler
  if (canvasWidth) {
    canvasWidth.addEventListener('change', () => {
      const val = parseInt(canvasWidth.value, 10);
      if (val >= 400) {
        state.canvasWidth = val;
        updateViewBox();
        commit();
        render();
      }
    });
  }

  // Canvas Height handler
  if (canvasHeight) {
    canvasHeight.addEventListener('change', () => {
      const val = parseInt(canvasHeight.value, 10);
      if (val >= 300) {
        state.canvasHeight = val;
        updateViewBox();
        commit();
        render();
      }
    });
  }

  // Canvas Border toggle handler
  if (tglCanvasBorder) {
    tglCanvasBorder.addEventListener('change', () => {
      state.showCanvasBorder = !!tglCanvasBorder.checked;
      commit();
      render();
    });
  }

  // Auto-fit Canvas button
  const btnAutoFitCanvas = document.getElementById('btnAutoFitCanvas');
  if (btnAutoFitCanvas) {
    btnAutoFitCanvas.addEventListener('click', autoFitCanvas);
  }

  // Center Elements button
  const btnCenterElements = document.getElementById('btnCenterElements');
  if (btnCenterElements) {
    btnCenterElements.addEventListener('click', centerElements);
  }

  // Auto-expand canvas toggle - stored in state
  const tglAutoExpandCanvas = document.getElementById('tglAutoExpandCanvas');
  if (tglAutoExpandCanvas) {
    // Default to checked
    tglAutoExpandCanvas.checked = true;
  }

  // ============== SHAPE LIBRARY SYSTEM ==============
  
  const shapeLibraryPanel = document.getElementById('shapeLibraryPanel');
  const btnToggleLibrary = document.getElementById('btnToggleLibrary');
  const btnLibraryClose = document.getElementById('btnLibraryClose');
  const libraryContent = document.getElementById('libraryContent');
  const librarySearch = document.getElementById('librarySearch');
  const btnSaveNodeToLibrary = document.getElementById('btnSaveNodeToLibrary');
  const btnImportSVGToLibrary = document.getElementById('btnImportSVGToLibrary');
  const btnExportLibrary = document.getElementById('btnExportLibrary');
  const btnLibraryImport = document.getElementById('btnLibraryImport');
  const btnLibraryMenu = document.getElementById('btnLibraryMenu');
  const svgImportInput = document.getElementById('svgImportInput');
  const libraryImportInput = document.getElementById('libraryImportInput');

  // Load library from localStorage
  // Default container shapes - detailed continental silhouettes
  function getDefaultContainerShapes() {
    return {
      'region-north-america': {
        id: 'region-north-america',
        name: 'North America',
        category: 'Regions',
        viewBox: '0 0 300 350',
        pathData: 'M45,15 L55,12 L65,8 L75,5 L85,8 L95,5 L105,10 L115,8 L125,12 L135,10 L145,15 L155,12 L165,18 L172,22 L178,28 L182,35 L176,42 L182,48 L188,55 L182,62 L188,68 L195,75 L200,82 L205,90 L210,98 L215,106 L212,115 L218,122 L225,130 L230,138 L228,146 L222,154 L228,162 L235,170 L230,178 L224,172 L218,180 L224,188 L218,196 L212,190 L206,198 L212,206 L206,214 L200,208 L194,216 L200,224 L194,232 L188,226 L182,234 L176,242 L170,250 L164,258 L158,266 L152,274 L146,282 L140,288 L134,294 L128,300 L122,306 L116,312 L110,318 L104,322 L98,318 L92,310 L98,302 L92,294 L86,286 L80,278 L74,270 L68,262 L74,254 L68,246 L62,238 L56,230 L62,222 L56,214 L50,206 L44,198 L50,190 L44,182 L38,174 L32,166 L38,158 L32,150 L26,142 L20,134 L26,126 L20,118 L14,110 L20,102 L14,94 L20,86 L26,78 L20,70 L14,62 L20,54 L26,46 L20,38 L26,30 L32,22 L38,18 Z M235,205 L245,200 L255,205 L262,215 L268,225 L275,235 L280,248 L275,260 L268,272 L260,280 L250,285 L240,282 L232,275 L225,265 L228,255 L235,245 L230,235 L235,225 L230,215 Z',
        svgData: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 350"><path d="M45,15 L55,12 L65,8 L75,5 L85,8 L95,5 L105,10 L115,8 L125,12 L135,10 L145,15 L155,12 L165,18 L172,22 L178,28 L182,35 L176,42 L182,48 L188,55 L182,62 L188,68 L195,75 L200,82 L205,90 L210,98 L215,106 L212,115 L218,122 L225,130 L230,138 L228,146 L222,154 L228,162 L235,170 L230,178 L224,172 L218,180 L224,188 L218,196 L212,190 L206,198 L212,206 L206,214 L200,208 L194,216 L200,224 L194,232 L188,226 L182,234 L176,242 L170,250 L164,258 L158,266 L152,274 L146,282 L140,288 L134,294 L128,300 L122,306 L116,312 L110,318 L104,322 L98,318 L92,310 L98,302 L92,294 L86,286 L80,278 L74,270 L68,262 L74,254 L68,246 L62,238 L56,230 L62,222 L56,214 L50,206 L44,198 L50,190 L44,182 L38,174 L32,166 L38,158 L32,150 L26,142 L20,134 L26,126 L20,118 L14,110 L20,102 L14,94 L20,86 L26,78 L20,70 L14,62 L20,54 L26,46 L20,38 L26,30 L32,22 L38,18 Z M235,205 L245,200 L255,205 L262,215 L268,225 L275,235 L280,248 L275,260 L268,272 L260,280 L250,285 L240,282 L232,275 L225,265 L228,255 L235,245 L230,235 L235,225 L230,215 Z" fill="currentColor" opacity="0.3"/></svg>'
      },
      'region-south-america': {
        id: 'region-south-america',
        name: 'South America',
        category: 'Regions',
        viewBox: '0 0 180 320',
        pathData: 'M75,5 L85,8 L95,5 L105,10 L115,15 L125,22 L135,30 L142,40 L148,52 L155,65 L160,78 L162,92 L158,105 L162,118 L168,132 L172,145 L168,158 L162,172 L165,185 L168,198 L165,212 L160,225 L155,238 L148,252 L140,265 L132,278 L122,290 L112,302 L100,312 L88,318 L78,312 L72,302 L78,292 L72,282 L68,272 L65,262 L62,252 L58,242 L55,232 L52,222 L48,212 L45,202 L42,192 L38,182 L35,172 L32,162 L28,152 L25,142 L22,132 L20,122 L22,112 L25,102 L28,92 L32,82 L38,72 L45,62 L52,52 L60,42 L68,32 L72,22 L70,12 Z',
        svgData: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 180 320"><path d="M75,5 L85,8 L95,5 L105,10 L115,15 L125,22 L135,30 L142,40 L148,52 L155,65 L160,78 L162,92 L158,105 L162,118 L168,132 L172,145 L168,158 L162,172 L165,185 L168,198 L165,212 L160,225 L155,238 L148,252 L140,265 L132,278 L122,290 L112,302 L100,312 L88,318 L78,312 L72,302 L78,292 L72,282 L68,272 L65,262 L62,252 L58,242 L55,232 L52,222 L48,212 L45,202 L42,192 L38,182 L35,172 L32,162 L28,152 L25,142 L22,132 L20,122 L22,112 L25,102 L28,92 L32,82 L38,72 L45,62 L52,52 L60,42 L68,32 L72,22 L70,12 Z" fill="currentColor" opacity="0.3"/></svg>'
      },
      'region-africa': {
        id: 'region-africa',
        name: 'Africa',
        category: 'Regions',
        viewBox: '0 0 220 300',
        pathData: 'M85,8 L95,5 L105,8 L115,5 L125,10 L135,8 L145,12 L155,15 L165,20 L172,28 L168,38 L175,48 L182,58 L188,70 L192,82 L195,95 L192,108 L195,120 L198,132 L195,145 L190,158 L195,170 L198,182 L195,195 L190,208 L185,220 L178,232 L170,245 L162,258 L152,270 L142,280 L130,288 L118,295 L105,298 L92,295 L80,288 L72,278 L78,268 L72,258 L68,248 L65,238 L62,228 L58,218 L55,208 L52,198 L48,188 L45,178 L42,168 L38,158 L35,148 L32,138 L28,128 L25,118 L28,108 L35,98 L42,88 L35,78 L28,68 L35,58 L42,48 L50,38 L58,28 L68,18 L78,12 Z M185,35 L195,32 L205,38 L212,48 L215,60 L218,72 L215,85 L210,98 L202,108 L192,115 L185,108 L188,98 L185,88 L188,78 L185,68 L188,58 L185,48 Z M180,268 L190,265 L200,272 L205,285 L200,298 L190,305 L180,300 L175,288 L178,278 Z',
        svgData: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 220 300"><path d="M85,8 L95,5 L105,8 L115,5 L125,10 L135,8 L145,12 L155,15 L165,20 L172,28 L168,38 L175,48 L182,58 L188,70 L192,82 L195,95 L192,108 L195,120 L198,132 L195,145 L190,158 L195,170 L198,182 L195,195 L190,208 L185,220 L178,232 L170,245 L162,258 L152,270 L142,280 L130,288 L118,295 L105,298 L92,295 L80,288 L72,278 L78,268 L72,258 L68,248 L65,238 L62,228 L58,218 L55,208 L52,198 L48,188 L45,178 L42,168 L38,158 L35,148 L32,138 L28,128 L25,118 L28,108 L35,98 L42,88 L35,78 L28,68 L35,58 L42,48 L50,38 L58,28 L68,18 L78,12 Z M185,35 L195,32 L205,38 L212,48 L215,60 L218,72 L215,85 L210,98 L202,108 L192,115 L185,108 L188,98 L185,88 L188,78 L185,68 L188,58 L185,48 Z M180,268 L190,265 L200,272 L205,285 L200,298 L190,305 L180,300 L175,288 L178,278 Z" fill="currentColor" opacity="0.3"/></svg>'
      },
      'region-europe': {
        id: 'region-europe',
        name: 'Europe',
        category: 'Regions',
        viewBox: '0 0 300 250',
        pathData: 'M55,45 L65,40 L72,48 L68,58 L75,65 L82,58 L88,68 L95,62 L102,72 L108,65 L115,75 L122,68 L128,78 L135,72 L142,82 L148,75 L155,85 L162,80 L168,90 L175,85 L182,95 L188,90 L195,100 L202,95 L208,105 L215,100 L222,110 L228,118 L235,128 L240,138 L245,148 L248,160 L245,172 L240,162 L232,172 L238,182 L232,192 L225,185 L218,195 L225,205 L218,215 L210,208 L202,218 L195,210 L188,220 L180,212 L172,222 L165,215 L158,225 L150,218 L142,228 L135,220 L128,230 L120,222 L112,232 L105,225 L98,235 L90,228 L82,238 L75,232 L68,238 L60,230 L52,238 L45,232 L40,222 L35,212 L30,200 L35,188 L30,178 L35,168 L30,158 L35,148 L30,138 L35,128 L40,118 L35,108 L40,98 L45,88 L40,78 L45,68 L50,58 Z M10,68 L20,62 L30,68 L38,78 L42,90 L38,102 L30,110 L22,105 L15,95 L12,85 L15,75 Z M8,115 L18,110 L28,118 L32,130 L28,142 L18,148 L8,142 L5,130 L8,120 Z M220,165 L230,160 L240,168 L248,180 L252,195 L255,210 L252,225 L248,238 L240,248 L230,252 L220,248 L212,238 L208,225 L212,210 L218,195 L215,182 L218,172 Z',
        svgData: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 250"><path d="M55,45 L65,40 L72,48 L68,58 L75,65 L82,58 L88,68 L95,62 L102,72 L108,65 L115,75 L122,68 L128,78 L135,72 L142,82 L148,75 L155,85 L162,80 L168,90 L175,85 L182,95 L188,90 L195,100 L202,95 L208,105 L215,100 L222,110 L228,118 L235,128 L240,138 L245,148 L248,160 L245,172 L240,162 L232,172 L238,182 L232,192 L225,185 L218,195 L225,205 L218,215 L210,208 L202,218 L195,210 L188,220 L180,212 L172,222 L165,215 L158,225 L150,218 L142,228 L135,220 L128,230 L120,222 L112,232 L105,225 L98,235 L90,228 L82,238 L75,232 L68,238 L60,230 L52,238 L45,232 L40,222 L35,212 L30,200 L35,188 L30,178 L35,168 L30,158 L35,148 L30,138 L35,128 L40,118 L35,108 L40,98 L45,88 L40,78 L45,68 L50,58 Z M10,68 L20,62 L30,68 L38,78 L42,90 L38,102 L30,110 L22,105 L15,95 L12,85 L15,75 Z M8,115 L18,110 L28,118 L32,130 L28,142 L18,148 L8,142 L5,130 L8,120 Z M220,165 L230,160 L240,168 L248,180 L252,195 L255,210 L252,225 L248,238 L240,248 L230,252 L220,248 L212,238 L208,225 L212,210 L218,195 L215,182 L218,172 Z" fill="currentColor" opacity="0.3"/></svg>'
      },
      'region-asia': {
        id: 'region-asia',
        name: 'Asia',
        category: 'Regions',
        viewBox: '0 0 400 320',
        pathData: 'M25,55 L35,50 L45,55 L55,48 L65,55 L75,50 L85,58 L95,52 L105,60 L115,55 L125,62 L135,58 L145,65 L155,60 L165,68 L175,62 L185,70 L195,65 L205,72 L215,68 L225,75 L235,70 L245,78 L255,72 L265,80 L275,75 L285,82 L295,78 L305,85 L315,90 L325,98 L335,108 L342,118 L348,130 L352,142 L348,155 L342,168 L348,180 L355,192 L360,205 L355,218 L348,230 L340,242 L330,252 L320,262 L308,270 L295,275 L282,278 L270,275 L258,280 L245,278 L232,282 L220,278 L208,285 L195,282 L182,288 L170,285 L158,290 L145,288 L132,292 L120,288 L108,292 L95,288 L82,292 L70,285 L60,278 L52,268 L45,258 L40,248 L35,238 L32,228 L30,218 L28,208 L32,198 L28,188 L25,178 L28,168 L32,158 L28,148 L25,138 L28,128 L32,118 L28,108 L25,98 L28,88 L32,78 L28,68 L30,60 Z M362,120 L372,115 L382,122 L388,135 L392,150 L388,165 L382,178 L372,188 L362,182 L358,168 L362,155 L358,142 L362,130 Z M365,200 L375,195 L385,202 L390,215 L385,228 L375,235 L365,230 L360,218 L362,208 Z M340,280 L350,275 L360,282 L368,295 L365,310 L355,318 L345,315 L338,302 L340,290 Z M300,295 L310,290 L320,298 L328,312 L325,325 L315,332 L305,328 L298,315 L300,302 Z',
        svgData: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 320"><path d="M25,55 L35,50 L45,55 L55,48 L65,55 L75,50 L85,58 L95,52 L105,60 L115,55 L125,62 L135,58 L145,65 L155,60 L165,68 L175,62 L185,70 L195,65 L205,72 L215,68 L225,75 L235,70 L245,78 L255,72 L265,80 L275,75 L285,82 L295,78 L305,85 L315,90 L325,98 L335,108 L342,118 L348,130 L352,142 L348,155 L342,168 L348,180 L355,192 L360,205 L355,218 L348,230 L340,242 L330,252 L320,262 L308,270 L295,275 L282,278 L270,275 L258,280 L245,278 L232,282 L220,278 L208,285 L195,282 L182,288 L170,285 L158,290 L145,288 L132,292 L120,288 L108,292 L95,288 L82,292 L70,285 L60,278 L52,268 L45,258 L40,248 L35,238 L32,228 L30,218 L28,208 L32,198 L28,188 L25,178 L28,168 L32,158 L28,148 L25,138 L28,128 L32,118 L28,108 L25,98 L28,88 L32,78 L28,68 L30,60 Z M362,120 L372,115 L382,122 L388,135 L392,150 L388,165 L382,178 L372,188 L362,182 L358,168 L362,155 L358,142 L362,130 Z M365,200 L375,195 L385,202 L390,215 L385,228 L375,235 L365,230 L360,218 L362,208 Z M340,280 L350,275 L360,282 L368,295 L365,310 L355,318 L345,315 L338,302 L340,290 Z M300,295 L310,290 L320,298 L328,312 L325,325 L315,332 L305,328 L298,315 L300,302 Z" fill="currentColor" opacity="0.3"/></svg>'
      },
      'region-australia': {
        id: 'region-australia',
        name: 'Australia',
        category: 'Regions',
        viewBox: '0 0 280 220',
        pathData: 'M30,65 L42,58 L55,62 L68,55 L80,60 L92,55 L105,62 L118,58 L130,65 L142,60 L155,68 L168,62 L180,70 L192,65 L205,72 L218,68 L230,78 L242,85 L252,95 L260,108 L265,122 L262,135 L255,125 L248,138 L255,150 L262,162 L265,175 L260,188 L252,198 L242,205 L230,210 L218,208 L205,212 L192,208 L180,215 L168,210 L155,215 L142,210 L130,215 L118,208 L105,212 L92,205 L80,198 L68,188 L58,178 L48,168 L40,155 L35,142 L32,128 L28,115 L25,102 L28,88 L32,75 Z M5,45 L18,40 L30,48 L38,62 L35,78 L25,88 L12,85 L5,72 L8,58 Z M232,175 L245,170 L258,178 L265,192 L262,208 L252,218 L238,215 L230,202 L232,188 Z',
        svgData: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 280 220"><path d="M30,65 L42,58 L55,62 L68,55 L80,60 L92,55 L105,62 L118,58 L130,65 L142,60 L155,68 L168,62 L180,70 L192,65 L205,72 L218,68 L230,78 L242,85 L252,95 L260,108 L265,122 L262,135 L255,125 L248,138 L255,150 L262,162 L265,175 L260,188 L252,198 L242,205 L230,210 L218,208 L205,212 L192,208 L180,215 L168,210 L155,215 L142,210 L130,215 L118,208 L105,212 L92,205 L80,198 L68,188 L58,178 L48,168 L40,155 L35,142 L32,128 L28,115 L25,102 L28,88 L32,75 Z M5,45 L18,40 L30,48 L38,62 L35,78 L25,88 L12,85 L5,72 L8,58 Z M232,175 L245,170 L258,178 L265,192 L262,208 L252,218 L238,215 L230,202 L232,188 Z" fill="currentColor" opacity="0.3"/></svg>'
      }
    };
  }

  function loadShapeLibrary() {
    try {
      const saved = localStorage.getItem('netmap-shape-library');
      if (saved) {
        const parsed = JSON.parse(saved);
        state.shapeLibrary.shapes = parsed.shapes || {};
        state.shapeLibrary.categories = parsed.categories || ['Network Devices', 'Cloud Services', 'Custom'];
        state.shapeLibrary.containerShapes = parsed.containerShapes || {};
        state.shapeLibrary.containerCategories = parsed.containerCategories || ['Regions', 'Countries', 'Custom'];
      }
      
      // Initialize default container shapes if empty
      if (!state.shapeLibrary.containerShapes || Object.keys(state.shapeLibrary.containerShapes).length === 0) {
        state.shapeLibrary.containerShapes = getDefaultContainerShapes();
        state.shapeLibrary.containerCategories = ['Regions', 'Countries', 'Custom'];
        saveShapeLibrary();
      }
    } catch (e) {
      console.warn('Failed to load shape library:', e);
    }
    renderLibraryPanel();
  }

  // Save library to localStorage
  function saveShapeLibrary() {
    try {
      localStorage.setItem('netmap-shape-library', JSON.stringify(state.shapeLibrary));
    } catch (e) {
      console.warn('Failed to save shape library:', e);
    }
  }

  // Generate a thumbnail SVG for a library shape
  function generateShapeThumbnail(shape) {
    if (shape.type === 'svg' && shape.svgData) {
      return shape.svgData;
    }
    
    // Generate built-in shape thumbnail
    const shapeType = shape.shape || 'circle';
    const fill = shape.fill || '#667eea';
    const stroke = shape.stroke || '#4a5568';
    const sw = shape.strokeW || 2;
    
    let shapeEl = '';
    switch (shapeType) {
      case 'square':
        shapeEl = `<rect x="6" y="6" width="20" height="20" rx="2" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/>`;
        break;
      case 'rectangle':
        shapeEl = `<rect x="3" y="8" width="26" height="16" rx="2" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/>`;
        break;
      case 'ellipse':
        shapeEl = `<ellipse cx="16" cy="16" rx="13" ry="9" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/>`;
        break;
      case 'triangle':
        shapeEl = `<polygon points="16,4 28,28 4,28" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/>`;
        break;
      case 'hexagon':
        shapeEl = `<polygon points="16,3 27,9 27,21 16,27 5,21 5,9" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/>`;
        break;
      default: // circle
        shapeEl = `<circle cx="16" cy="16" r="12" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/>`;
    }
    
    return `<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">${shapeEl}</svg>`;
  }

  // Render the library panel
  function renderLibraryPanel() {
    if (!libraryContent) return;
    
    const searchTerm = (librarySearch?.value || '').toLowerCase();
    const isContainerTab = state.libraryTab === 'containers';
    
    // Update tab buttons
    document.querySelectorAll('.library-tab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.tab === state.libraryTab);
    });
    
    // Update action buttons visibility
    const nodesActions = document.getElementById('libraryActionsNodes');
    const containerActions = document.getElementById('libraryActionsContainers');
    if (nodesActions) nodesActions.style.display = isContainerTab ? 'none' : 'block';
    if (containerActions) containerActions.style.display = isContainerTab ? 'block' : 'none';
    
    if (isContainerTab) {
      renderContainerShapesLibrary(searchTerm);
    } else {
      renderNodeShapesLibrary(searchTerm);
    }
  }
  
  // Render node shapes library
  function renderNodeShapesLibrary(searchTerm) {
    const shapes = state.shapeLibrary.shapes;
    const categories = state.shapeLibrary.categories;
    
    // Group shapes by category
    const byCategory = {};
    categories.forEach(cat => byCategory[cat] = []);
    
    Object.entries(shapes).forEach(([id, shape]) => {
      if (searchTerm && !shape.name.toLowerCase().includes(searchTerm)) return;
      const cat = shape.category || 'Custom';
      if (!byCategory[cat]) byCategory[cat] = [];
      byCategory[cat].push({ id, ...shape });
    });
    
    // Check if library is empty
    const totalShapes = Object.keys(shapes).length;
    
    if (totalShapes === 0) {
      libraryContent.innerHTML = `
        <div class="library-empty">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="3" y="3" width="18" height="18" rx="2"/>
            <circle cx="12" cy="10" r="3"/>
            <path d="M6 21v-2a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v2"/>
          </svg>
          <div>No node shapes in library</div>
          <div style="font-size:10px; margin-top:4px;">Import SVGs or save nodes to build your library</div>
        </div>
      `;
      return;
    }
    
    let html = '';
    categories.forEach(cat => {
      const items = byCategory[cat];
      if (items.length === 0 && !searchTerm) return; // Hide empty categories unless searching
      
      html += `
        <div class="library-category" data-category="${cat}">
          <div class="library-category-header" onclick="this.parentElement.classList.toggle('collapsed')">
            <span class="arrow">‚ñº</span>
            <span>${cat}</span>
            <span style="margin-left:auto; opacity:0.6; font-size:10px;">${items.length}</span>
          </div>
          <div class="library-items">
      `;
      
      items.forEach(item => {
        const thumb = generateShapeThumbnail(item);
        html += `
          <div class="library-item" draggable="true" data-library-id="${item.id}" data-library-type="node" title="${item.name}">
            <div class="library-item-preview">${thumb}</div>
            <div class="library-item-name">${item.name}</div>
            <div class="library-item-menu" onclick="event.stopPropagation(); showLibraryItemMenu('${item.id}', event)">‚ãÆ</div>
          </div>
        `;
      });
      
      html += '</div></div>';
    });
    
    libraryContent.innerHTML = html;
    
    // Add drag handlers
    libraryContent.querySelectorAll('.library-item').forEach(item => {
      item.addEventListener('dragstart', handleLibraryDragStart);
      item.addEventListener('dblclick', handleLibraryDoubleClick);
    });
  }
  
  // Render container shapes library
  function renderContainerShapesLibrary(searchTerm) {
    const shapes = state.shapeLibrary.containerShapes || {};
    const categories = state.shapeLibrary.containerCategories || ['Regions', 'Countries', 'Custom'];
    
    // Group shapes by category
    const byCategory = {};
    categories.forEach(cat => byCategory[cat] = []);
    
    Object.entries(shapes).forEach(([id, shape]) => {
      if (searchTerm && !shape.name.toLowerCase().includes(searchTerm)) return;
      const cat = shape.category || 'Custom';
      if (!byCategory[cat]) byCategory[cat] = [];
      byCategory[cat].push({ id, ...shape });
    });
    
    // Check if library is empty
    const totalShapes = Object.keys(shapes).length;
    
    if (totalShapes === 0) {
      libraryContent.innerHTML = `
        <div class="library-empty">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="2" y="4" width="20" height="16" rx="2"/>
            <path d="M2 8h20"/>
            <path d="M8 4v4"/>
          </svg>
          <div>No container shapes</div>
          <div style="font-size:10px; margin-top:4px;">Import country or region SVGs to create shaped containers</div>
        </div>
      `;
      return;
    }
    
    let html = '';
    categories.forEach(cat => {
      const items = byCategory[cat];
      if (items.length === 0 && !searchTerm) return;
      
      html += `
        <div class="library-category" data-category="${cat}">
          <div class="library-category-header" onclick="this.parentElement.classList.toggle('collapsed')">
            <span class="arrow">‚ñº</span>
            <span>${cat}</span>
            <span style="margin-left:auto; opacity:0.6; font-size:10px;">${items.length}</span>
          </div>
          <div class="library-items">
      `;
      
      items.forEach(item => {
        // Generate thumbnail - for container shapes, show the SVG
        const thumb = item.svgData || '<svg viewBox="0 0 24 24"><rect x="2" y="2" width="20" height="20" fill="none" stroke="currentColor"/></svg>';
        html += `
          <div class="library-item" draggable="true" data-container-shape-id="${item.id}" data-library-type="container" title="${item.name} - Drag to canvas to create container">
            <div class="library-item-preview" style="opacity:0.7;">${thumb}</div>
            <div class="library-item-name">${item.name}</div>
            <div class="library-item-menu" onclick="event.stopPropagation(); showContainerShapeMenu('${item.id}', event)">‚ãÆ</div>
          </div>
        `;
      });
      
      html += '</div></div>';
    });
    
    libraryContent.innerHTML = html;
    
    // Add drag and click handlers for container shapes
    libraryContent.querySelectorAll('.library-item[data-container-shape-id]').forEach(item => {
      // Enable dragging
      item.addEventListener('dragstart', (e) => {
        const shapeId = item.dataset.containerShapeId;
        e.dataTransfer.setData('application/x-container-shape', shapeId);
        e.dataTransfer.effectAllowed = 'copy';
      });
      
      // Double-click to apply to selected container (legacy behavior)
      item.addEventListener('dblclick', (e) => {
        const shapeId = item.dataset.containerShapeId;
        // If a container is selected, apply shape to it
        if (state.selected?.type === 'group' || state.selection.groups.size > 0) {
          applyContainerShapeToSelected(shapeId);
        } else {
          showToast('Drag to canvas to create container, or select a container first');
        }
      });
    });
  }

  // Handle drag start from library
  function handleLibraryDragStart(e) {
    const libraryId = e.currentTarget.dataset.libraryId;
    e.dataTransfer.setData('application/x-library-shape', libraryId);
    e.dataTransfer.effectAllowed = 'copy';
  }

  // Handle double-click on library item (create at center of visible view)
  function handleLibraryDoubleClick(e) {
    const libraryId = e.currentTarget.dataset.libraryId;
    const wrap = document.getElementById('wrap');
    if (wrap) {
      // Calculate center of visible area in canvas coordinates
      const centerScreenX = wrap.scrollLeft + wrap.clientWidth / 2;
      const centerScreenY = wrap.scrollTop + wrap.clientHeight / 2;
      const centerX = centerScreenX / state.zoom;
      const centerY = centerScreenY / state.zoom;
      createNodeFromLibrary(libraryId, centerX, centerY);
    } else {
      // Fallback: center of canvas
      createNodeFromLibrary(libraryId, state.canvasWidth / 2, state.canvasHeight / 2);
    }
  }

  // Create node from library shape
  function createNodeFromLibrary(libraryId, x, y) {
    const libShape = state.shapeLibrary.shapes[libraryId];
    if (!libShape) {
      showToast('Library shape not found');
      return;
    }
    
    const node = {
      id: state.nextNode++,
      x: Math.round(x),
      y: Math.round(y),
      name: libShape.defaultName || libShape.name || 'Node',
      tag: libShape.defaultCode || '',
      r: libShape.r || 24,
      fill: libShape.fill || '#1b2030',
      stroke: libShape.stroke || '#9fb3ff',
      strokeW: libShape.strokeW || 2,
      shape: libShape.shape || 'circle',
      nameColor: libShape.nameColor,
      nameFont: libShape.nameFont,
      tagColor: libShape.tagColor,
      tagFont: libShape.tagFont,
      // For custom SVG shapes
      libraryShapeId: libShape.type === 'svg' ? libraryId : null,
      customSvg: libShape.type === 'svg' ? libShape.svgData : null
    };
    
    state.nodes.push(node);
    state.selected = { type: 'node', id: node.id };
    commit();
    render();
    showToast(`Created: ${node.name}`);
  }

  // Save current node to library
  function saveNodeToLibrary(node) {
    if (!node) {
      showToast('No node selected');
      return;
    }
    
    const name = prompt('Enter a name for this library shape:', node.name || 'My Shape');
    if (!name) return;
    
    const category = prompt('Enter category:', 'Custom') || 'Custom';
    
    // Add category if new
    if (!state.shapeLibrary.categories.includes(category)) {
      state.shapeLibrary.categories.push(category);
    }
    
    const libShape = {
      id: 'lib-' + Date.now(),
      name: name,
      category: category,
      type: node.customSvg ? 'svg' : 'builtin',
      shape: node.shape || 'circle',
      r: node.r || 24,
      fill: node.fill,
      stroke: node.stroke,
      strokeW: node.strokeW,
      nameColor: node.nameColor,
      nameFont: node.nameFont,
      tagColor: node.tagColor,
      tagFont: node.tagFont,
      defaultName: node.name,
      defaultCode: node.tag,
      svgData: node.customSvg || null
    };
    
    state.shapeLibrary.shapes[libShape.id] = libShape;
    saveShapeLibrary();
    renderLibraryPanel();
    showToast(`Saved "${name}" to library`);
  }

  // Import SVG file to library
  function importSVGToLibrary(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      let svgContent = e.target.result;
      
      // Parse and clean SVG
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgContent, 'image/svg+xml');
      const svgEl = doc.querySelector('svg');
      
      if (!svgEl) {
        showToast('Invalid SVG file');
        return;
      }
      
      // Ensure viewBox exists
      if (!svgEl.getAttribute('viewBox')) {
        const w = svgEl.getAttribute('width') || 64;
        const h = svgEl.getAttribute('height') || 64;
        svgEl.setAttribute('viewBox', `0 0 ${parseFloat(w)} ${parseFloat(h)}`);
      }
      
      // Remove width/height to make scalable
      svgEl.removeAttribute('width');
      svgEl.removeAttribute('height');
      
      const cleanSvg = svgEl.outerHTML;
      
      const name = prompt('Enter a name for this shape:', file.name.replace('.svg', ''));
      if (!name) return;
      
      const category = prompt('Enter category:', 'Custom') || 'Custom';
      
      // Add category if new
      if (!state.shapeLibrary.categories.includes(category)) {
        state.shapeLibrary.categories.push(category);
      }
      
      const libShape = {
        id: 'lib-' + Date.now(),
        name: name,
        category: category,
        type: 'svg',
        svgData: cleanSvg,
        r: 24,
        fill: '#667eea',
        stroke: '#4a5568',
        strokeW: 2
      };
      
      state.shapeLibrary.shapes[libShape.id] = libShape;
      saveShapeLibrary();
      renderLibraryPanel();
      showToast(`Imported "${name}" to library`);
    };
    reader.readAsText(file);
  }

  // Import SVG as container shape (decorative)
  function importContainerShapeSVG(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      let svgContent = e.target.result;
      
      // Parse SVG
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgContent, 'image/svg+xml');
      const svgEl = doc.querySelector('svg');
      
      if (!svgEl) {
        showToast('Invalid SVG file');
        return;
      }
      
      // Get or compute viewBox
      let viewBox = svgEl.getAttribute('viewBox');
      if (!viewBox) {
        const w = parseFloat(svgEl.getAttribute('width')) || 100;
        const h = parseFloat(svgEl.getAttribute('height')) || 100;
        viewBox = `0 0 ${w} ${h}`;
      }
      
      // Simplify complex SVGs by combining all paths
      const allPaths = svgEl.querySelectorAll('path');
      let combinedPathD = '';
      
      if (allPaths.length > 0) {
        // Combine all path d attributes
        allPaths.forEach(path => {
          const d = path.getAttribute('d');
          if (d) combinedPathD += d + ' ';
        });
      }
      
      // Create a simplified SVG with just the outline
      const [vbX, vbY, vbW, vbH] = viewBox.split(/\s+/).map(parseFloat);
      const simplifiedSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}" preserveAspectRatio="xMidYMid meet">
        <path d="${combinedPathD.trim()}" fill="currentColor" stroke="none" opacity="0.15"/>
      </svg>`;
      
      const name = prompt('Enter a name for this container shape:', file.name.replace('.svg', ''));
      if (!name) return;
      
      const category = prompt('Enter category:', 'Countries') || 'Countries';
      
      // Add category if new
      if (!state.shapeLibrary.containerCategories) {
        state.shapeLibrary.containerCategories = ['Regions', 'Countries', 'Custom'];
      }
      if (!state.shapeLibrary.containerCategories.includes(category)) {
        state.shapeLibrary.containerCategories.push(category);
      }
      
      const shapeId = 'container-' + Date.now();
      if (!state.shapeLibrary.containerShapes) {
        state.shapeLibrary.containerShapes = {};
      }
      
      state.shapeLibrary.containerShapes[shapeId] = {
        id: shapeId,
        name: name,
        category: category,
        svgData: simplifiedSvg,
        viewBox: viewBox,
        pathData: combinedPathD.trim()
      };
      
      saveShapeLibrary();
      renderLibraryPanel();
      showToast(`Imported "${name}" as container shape`);
    };
    reader.readAsText(file);
  }

  // Apply container shape to selected container
  function applyContainerShapeToSelected(shapeId) {
    const shape = state.shapeLibrary.containerShapes?.[shapeId];
    if (!shape) {
      showToast('Shape not found');
      return;
    }
    
    // Find selected container(s)
    const selectedGroups = [];
    if (state.selected?.type === 'group') {
      selectedGroups.push(state.selected.id);
    }
    state.selection.groups.forEach(id => selectedGroups.push(id));
    
    if (selectedGroups.length === 0) {
      showToast('Select a container first');
      return;
    }
    
    selectedGroups.forEach(groupId => {
      const group = findGroup(groupId);
      if (group) {
        group.decorativeShape = {
          id: shapeId,
          svgData: shape.svgData,
          pathData: shape.pathData,
          viewBox: shape.viewBox,
          name: shape.name
        };
      }
    });
    
    commit();
    render();
    showToast(`Applied "${shape.name}" to ${selectedGroups.length} container(s)`);
  }

  // Remove decorative shape from selected container(s)
  function removeContainerShapeFromSelected() {
    const selectedGroups = [];
    if (state.selected?.type === 'group') {
      selectedGroups.push(state.selected.id);
    }
    state.selection.groups.forEach(id => selectedGroups.push(id));
    
    if (selectedGroups.length === 0) {
      showToast('Select a container first');
      return;
    }
    
    let removed = 0;
    selectedGroups.forEach(groupId => {
      const group = findGroup(groupId);
      if (group && group.decorativeShape) {
        delete group.decorativeShape;
        removed++;
      }
    });
    
    if (removed > 0) {
      commit();
      render();
      showToast(`Removed shape from ${removed} container(s)`);
    } else {
      showToast('Selected containers have no decorative shape');
    }
  }

  // Show context menu for container shape library item
  window.showContainerShapeMenu = function(shapeId, event) {
    // Remove any existing menu
    const existingMenu = document.querySelector('.library-context-menu');
    if (existingMenu) existingMenu.remove();
    
    const menu = document.createElement('div');
    menu.className = 'library-context-menu';
    menu.style.cssText = `
      position: fixed;
      left: ${event.clientX}px;
      top: ${event.clientY}px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10000;
      min-width: 140px;
      padding: 4px 0;
    `;
    
    const items = [
      { label: '‚úèÔ∏è Rename', action: () => renameContainerShape(shapeId) },
      { label: 'üóëÔ∏è Delete', action: () => deleteContainerShape(shapeId) }
    ];
    
    items.forEach(item => {
      const btn = document.createElement('button');
      btn.textContent = item.label;
      btn.style.cssText = `
        display: block;
        width: 100%;
        padding: 8px 12px;
        border: none;
        background: none;
        text-align: left;
        cursor: pointer;
        font-size: 12px;
      `;
      btn.onmouseenter = () => btn.style.background = '#f0f0f0';
      btn.onmouseleave = () => btn.style.background = 'none';
      btn.onclick = () => {
        menu.remove();
        item.action();
      };
      menu.appendChild(btn);
    });
    
    document.body.appendChild(menu);
    
    // Close on click outside
    setTimeout(() => {
      document.addEventListener('click', () => menu.remove(), { once: true });
    }, 0);
  };

  // Rename container shape
  function renameContainerShape(shapeId) {
    const shape = state.shapeLibrary.containerShapes?.[shapeId];
    if (!shape) return;
    
    const newName = prompt('Enter new name:', shape.name);
    if (newName && newName !== shape.name) {
      shape.name = newName;
      saveShapeLibrary();
      renderLibraryPanel();
      showToast(`Renamed to "${newName}"`);
    }
  }

  // Delete container shape from library
  function deleteContainerShape(shapeId) {
    const shape = state.shapeLibrary.containerShapes?.[shapeId];
    if (!shape) return;
    
    if (confirm(`Delete "${shape.name}" from library?`)) {
      delete state.shapeLibrary.containerShapes[shapeId];
      saveShapeLibrary();
      renderLibraryPanel();
      showToast(`Deleted "${shape.name}"`);
    }
  }

  // Export library to file
  function exportShapeLibrary() {
    const data = JSON.stringify(state.shapeLibrary, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'netmap-library.ndl';
    a.click();
    URL.revokeObjectURL(url);
    showToast('Library exported');
  }

  // Import library from file
  function importLibraryFromFile(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const imported = JSON.parse(e.target.result);
        
        // Merge with existing library
        const mergeMode = confirm('Merge with existing library? (Cancel to replace)');
        
        if (mergeMode) {
          // Merge node shapes
          Object.assign(state.shapeLibrary.shapes, imported.shapes || {});
          // Merge node categories
          (imported.categories || []).forEach(cat => {
            if (!state.shapeLibrary.categories.includes(cat)) {
              state.shapeLibrary.categories.push(cat);
            }
          });
          // Merge container shapes
          if (imported.containerShapes) {
            if (!state.shapeLibrary.containerShapes) state.shapeLibrary.containerShapes = {};
            Object.assign(state.shapeLibrary.containerShapes, imported.containerShapes);
          }
          // Merge container categories
          (imported.containerCategories || []).forEach(cat => {
            if (!state.shapeLibrary.containerCategories) {
              state.shapeLibrary.containerCategories = ['Regions', 'Countries', 'Custom'];
            }
            if (!state.shapeLibrary.containerCategories.includes(cat)) {
              state.shapeLibrary.containerCategories.push(cat);
            }
          });
        } else {
          state.shapeLibrary = imported;
          // Ensure container arrays exist
          if (!state.shapeLibrary.containerShapes) state.shapeLibrary.containerShapes = {};
          if (!state.shapeLibrary.containerCategories) {
            state.shapeLibrary.containerCategories = ['Regions', 'Countries', 'Custom'];
          }
        }
        
        saveShapeLibrary();
        renderLibraryPanel();
        showToast('Library imported');
      } catch (err) {
        showToast('Invalid library file');
      }
    };
    reader.readAsText(file);
  }

  // Show context menu for library item
  window.showLibraryItemMenu = function(libraryId, event) {
    // Remove existing menu
    document.querySelectorAll('.context-menu').forEach(m => m.remove());
    
    const menu = document.createElement('div');
    menu.className = 'context-menu';
    menu.innerHTML = `
      <div class="context-menu-item" data-action="rename">‚úèÔ∏è Rename</div>
      <div class="context-menu-item" data-action="duplicate">üìã Duplicate</div>
      <div class="context-menu-item" data-action="category">üìÅ Change Category</div>
      <div class="context-menu-sep"></div>
      <div class="context-menu-item danger" data-action="delete">üóëÔ∏è Delete</div>
    `;
    
    menu.style.left = event.clientX + 'px';
    menu.style.top = event.clientY + 'px';
    document.body.appendChild(menu);
    
    menu.addEventListener('click', (e) => {
      const action = e.target.dataset.action;
      if (!action) return;
      
      const shape = state.shapeLibrary.shapes[libraryId];
      if (!shape) return;
      
      switch (action) {
        case 'rename':
          const newName = prompt('New name:', shape.name);
          if (newName) {
            shape.name = newName;
            saveShapeLibrary();
            renderLibraryPanel();
          }
          break;
        case 'duplicate':
          const dupShape = { ...shape, id: 'lib-' + Date.now(), name: shape.name + ' Copy' };
          state.shapeLibrary.shapes[dupShape.id] = dupShape;
          saveShapeLibrary();
          renderLibraryPanel();
          showToast('Shape duplicated');
          break;
        case 'category':
          const newCat = prompt('New category:', shape.category);
          if (newCat) {
            shape.category = newCat;
            if (!state.shapeLibrary.categories.includes(newCat)) {
              state.shapeLibrary.categories.push(newCat);
            }
            saveShapeLibrary();
            renderLibraryPanel();
          }
          break;
        case 'delete':
          if (confirm(`Delete "${shape.name}" from library?`)) {
            delete state.shapeLibrary.shapes[libraryId];
            saveShapeLibrary();
            renderLibraryPanel();
            showToast('Shape deleted');
          }
          break;
      }
      
      menu.remove();
    });
    
    // Close on click outside
    setTimeout(() => {
      document.addEventListener('click', function closeMenu() {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }, { once: true });
    }, 0);
  };

  // Toggle library panel from toolbar button
  if (btnToggleLibrary && shapeLibraryPanel) {
    btnToggleLibrary.addEventListener('click', () => {
      const isVisible = shapeLibraryPanel.classList.contains('visible');
      shapeLibraryPanel.classList.toggle('visible');
      btnToggleLibrary.classList.toggle('active', !isVisible);
      localStorage.setItem('netmap-library-visible', !isVisible);
    });
    
    // Restore visibility state (default: hidden)
    if (localStorage.getItem('netmap-library-visible') === 'true') {
      shapeLibraryPanel.classList.add('visible');
      btnToggleLibrary.classList.add('active');
    }
  }
  
  // Close button in library header
  if (btnLibraryClose && shapeLibraryPanel) {
    btnLibraryClose.addEventListener('click', () => {
      shapeLibraryPanel.classList.remove('visible');
      if (btnToggleLibrary) btnToggleLibrary.classList.remove('active');
      localStorage.setItem('netmap-library-visible', 'false');
    });
  }

  // Tab switching for library
  document.querySelectorAll('.library-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      state.libraryTab = tab.dataset.tab;
      renderLibraryPanel();
    });
  });

  // Container shape action buttons
  const btnApplyContainerShape = document.getElementById('btnApplyContainerShape');
  const btnImportContainerShape = document.getElementById('btnImportContainerShape');
  const btnRemoveContainerShape = document.getElementById('btnRemoveContainerShape');
  
  if (btnApplyContainerShape) {
    btnApplyContainerShape.addEventListener('click', () => {
      const selected = libraryContent?.querySelector('.library-item.selected[data-container-shape-id]');
      if (selected) {
        applyContainerShapeToSelected(selected.dataset.containerShapeId);
      } else {
        showToast('Select a shape first, then select a container');
      }
    });
  }
  
  if (btnImportContainerShape) {
    btnImportContainerShape.addEventListener('click', () => {
      // Trigger file input for container shape import
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.svg,image/svg+xml';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (file) importContainerShapeSVG(file);
      };
      input.click();
    });
  }
  
  if (btnRemoveContainerShape) {
    btnRemoveContainerShape.addEventListener('click', () => {
      removeContainerShapeFromSelected();
    });
  }

  // Draggable library panel
  if (shapeLibraryPanel) {
    const libraryHeader = shapeLibraryPanel.querySelector('.library-header');
    let isDragging = false;
    let dragStartX, dragStartY, panelStartX, panelStartY;
    
    // Restore saved position
    const savedPos = localStorage.getItem('netmap-library-position');
    if (savedPos) {
      try {
        const pos = JSON.parse(savedPos);
        shapeLibraryPanel.style.left = pos.x + 'px';
        shapeLibraryPanel.style.top = pos.y + 'px';
        // Remove default positioning if custom position exists
        shapeLibraryPanel.style.right = 'auto';
      } catch (e) {}
    }
    
    if (libraryHeader) {
      libraryHeader.addEventListener('mousedown', (e) => {
        // Don't start drag if clicking on buttons
        if (e.target.closest('.library-header-btn')) return;
        
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        
        const rect = shapeLibraryPanel.getBoundingClientRect();
        panelStartX = rect.left;
        panelStartY = rect.top;
        
        shapeLibraryPanel.style.transition = 'none';
        shapeLibraryPanel.style.cursor = 'grabbing';
        document.body.style.userSelect = 'none';
        
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;
        
        let newX = panelStartX + dx;
        let newY = panelStartY + dy;
        
        // Keep panel within viewport bounds
        const panelRect = shapeLibraryPanel.getBoundingClientRect();
        const maxX = window.innerWidth - 50; // Leave some visible
        const maxY = window.innerHeight - 50;
        
        newX = Math.max(-panelRect.width + 50, Math.min(newX, maxX));
        newY = Math.max(0, Math.min(newY, maxY));
        
        shapeLibraryPanel.style.left = newX + 'px';
        shapeLibraryPanel.style.top = newY + 'px';
        shapeLibraryPanel.style.right = 'auto';
      });
      
      document.addEventListener('mouseup', () => {
        if (!isDragging) return;
        
        isDragging = false;
        shapeLibraryPanel.style.transition = '';
        shapeLibraryPanel.style.cursor = '';
        document.body.style.userSelect = '';
        
        // Save position
        const rect = shapeLibraryPanel.getBoundingClientRect();
        localStorage.setItem('netmap-library-position', JSON.stringify({
          x: rect.left,
          y: rect.top
        }));
      });
    }
    
    // Reset position button (double-click on header)
    if (libraryHeader) {
      libraryHeader.addEventListener('dblclick', (e) => {
        if (e.target.closest('.library-header-btn')) return;
        
        // Reset to default position
        shapeLibraryPanel.style.left = '0px';
        shapeLibraryPanel.style.top = '120px';
        shapeLibraryPanel.style.right = 'auto';
        localStorage.removeItem('netmap-library-position');
        showToast('Library position reset');
      });
    }
  }

  // Library search
  if (librarySearch) {
    librarySearch.addEventListener('input', () => {
      renderLibraryPanel();
    });
  }

  // Save node to library button
  if (btnSaveNodeToLibrary) {
    btnSaveNodeToLibrary.addEventListener('click', () => {
      if (state.selected?.type === 'node') {
        const node = findNode(state.selected.id);
        saveNodeToLibrary(node);
      } else {
        showToast('Select a node first');
      }
    });
  }

  // Import SVG button
  if (btnImportSVGToLibrary) {
    btnImportSVGToLibrary.addEventListener('click', () => {
      svgImportInput?.click();
    });
  }
  
  if (btnLibraryImport) {
    btnLibraryImport.addEventListener('click', () => {
      svgImportInput?.click();
    });
  }

  // SVG file input handler
  if (svgImportInput) {
    svgImportInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        importSVGToLibrary(file);
        svgImportInput.value = '';
      }
    });
  }

  // Export library button
  if (btnExportLibrary) {
    btnExportLibrary.addEventListener('click', exportShapeLibrary);
  }

  // Library menu button
  if (btnLibraryMenu) {
    btnLibraryMenu.addEventListener('click', (e) => {
      e.stopPropagation();
      
      // Remove existing menu
      document.querySelectorAll('.context-menu').forEach(m => m.remove());
      
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.innerHTML = `
        <div class="context-menu-item" data-action="import-lib">üì• Import Library File</div>
        <div class="context-menu-item" data-action="export-lib">üì§ Export Library</div>
        <div class="context-menu-sep"></div>
        <div class="context-menu-item" data-action="add-category">üìÅ Add Category</div>
        <div class="context-menu-sep"></div>
        <div class="context-menu-item danger" data-action="clear-lib">üóëÔ∏è Clear Library</div>
      `;
      
      const rect = btnLibraryMenu.getBoundingClientRect();
      menu.style.left = rect.left + 'px';
      menu.style.top = rect.bottom + 4 + 'px';
      document.body.appendChild(menu);
      
      menu.addEventListener('click', (ev) => {
        const action = ev.target.dataset.action;
        
        switch (action) {
          case 'import-lib':
            libraryImportInput?.click();
            break;
          case 'export-lib':
            exportShapeLibrary();
            break;
          case 'add-category':
            const newCat = prompt('New category name:');
            if (newCat && !state.shapeLibrary.categories.includes(newCat)) {
              state.shapeLibrary.categories.push(newCat);
              saveShapeLibrary();
              renderLibraryPanel();
              showToast(`Added category: ${newCat}`);
            }
            break;
          case 'clear-lib':
            if (confirm('Clear entire library? This cannot be undone.')) {
              state.shapeLibrary.shapes = {};
              saveShapeLibrary();
              renderLibraryPanel();
              showToast('Library cleared');
            }
            break;
        }
        
        menu.remove();
      });
      
      setTimeout(() => {
        document.addEventListener('click', function closeMenu() {
          menu.remove();
          document.removeEventListener('click', closeMenu);
        }, { once: true });
      }, 0);
    });
  }

  // Library import file handler
  if (libraryImportInput) {
    libraryImportInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        importLibraryFromFile(file);
        libraryImportInput.value = '';
      }
    });
  }

  // Handle drop on canvas from library
  const svgContainer = document.getElementById('svgContainer');
  if (svgContainer) {
    svgContainer.addEventListener('dragover', (e) => {
      if (e.dataTransfer.types.includes('application/x-library-shape') ||
          e.dataTransfer.types.includes('application/x-container-shape')) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
      }
    });
    
    svgContainer.addEventListener('drop', (e) => {
      // Handle node shape drop
      const libraryId = e.dataTransfer.getData('application/x-library-shape');
      if (libraryId) {
        e.preventDefault();
        // Use SVG coordinate transform (same as getMouse)
        const pt = svg.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
        createNodeFromLibrary(libraryId, svgPt.x, svgPt.y);
        return;
      }
      
      // Handle container shape drop
      const containerShapeId = e.dataTransfer.getData('application/x-container-shape');
      if (containerShapeId) {
        e.preventDefault();
        const pt = svg.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
        createContainerFromShape(containerShapeId, svgPt.x, svgPt.y);
      }
    });
  }

  // Create container from library shape
  function createContainerFromShape(shapeId, x, y) {
    const shape = state.shapeLibrary.containerShapes?.[shapeId];
    if (!shape) {
      showToast('Shape not found in library');
      return;
    }
    
    // Parse viewBox to get aspect ratio
    const vbParts = (shape.viewBox || '0 0 100 100').split(/\s+/).map(parseFloat);
    const origW = vbParts[2] || 100;
    const origH = vbParts[3] || 100;
    const aspectRatio = origW / origH;
    
    // Default container size, respecting aspect ratio
    let containerW = 300;
    let containerH = containerW / aspectRatio;
    
    // Ensure minimum size
    if (containerH < 150) {
      containerH = 150;
      containerW = containerH * aspectRatio;
    }
    if (containerW < 200) {
      containerW = 200;
      containerH = containerW / aspectRatio;
    }
    
    // Center on drop point
    const groupX = x - containerW / 2;
    const groupY = y - containerH / 2;
    
    // Create the container
    const newGroup = {
      id: Date.now(),
      uuid: generateUUID(),
      type: 'country',
      title: shape.name,
      x: groupX,
      y: groupY,
      w: Math.round(containerW),
      h: Math.round(containerH),
      fill: 'rgba(54, 76, 140, 0.08)',
      stroke: '#6073b8',
      strokeW: 2,
      titleColor: '#eaeaea',
      titleFont: 14,
      filterTags: ['default'],
      // Shape as the visual container
      shapeContainer: true,
      decorativeShape: {
        id: shapeId,
        svgData: shape.svgData,
        pathData: shape.pathData,
        viewBox: shape.viewBox,
        name: shape.name,
        aspectRatio: aspectRatio
      }
    };
    
    state.groups.push(newGroup);
    select({ type: 'group', id: newGroup.id });
    commit();
    render();
    showToast(`Created "${shape.name}" container`);
  }

  // Right-click context menu on nodes for "Add to Library"
  svg.addEventListener('contextmenu', (e) => {
    // Check if right-clicked on a node
    const target = e.target.closest('.node-circle');
    if (!target) return;
    
    e.preventDefault();
    
    const nodeId = parseInt(target.closest('g')?.dataset?.nodeId);
    const node = findNode(nodeId);
    if (!node) return;
    
    // Remove existing menu
    document.querySelectorAll('.context-menu').forEach(m => m.remove());
    
    const menu = document.createElement('div');
    menu.className = 'context-menu';
    menu.innerHTML = `
      <div class="context-menu-item" data-action="add-to-library">üìö Add to Library</div>
      <div class="context-menu-sep"></div>
      <div class="context-menu-item" data-action="duplicate">üìã Duplicate</div>
      <div class="context-menu-item danger" data-action="delete">üóëÔ∏è Delete</div>
    `;
    
    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
    document.body.appendChild(menu);
    
    menu.addEventListener('click', (ev) => {
      const action = ev.target.dataset.action;
      
      switch (action) {
        case 'add-to-library':
          saveNodeToLibrary(node);
          break;
        case 'duplicate':
          const newNode = { ...node, id: state.nextNode++, x: node.x + 30, y: node.y + 30 };
          state.nodes.push(newNode);
          state.selected = { type: 'node', id: newNode.id };
          commit(); render();
          showToast('Node duplicated');
          break;
        case 'delete':
          deleteNode(node.id);
          break;
      }
      
      menu.remove();
    });
    
    setTimeout(() => {
      document.addEventListener('click', function closeMenu() {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }, { once: true });
    }, 0);
  });

  // Load library on startup
  loadShapeLibrary();

  // ============== END SHAPE LIBRARY SYSTEM ==============

  // ============== ROUTE FINDER / PATHFINDING SYSTEM ==============
  
  // Route finder state - includes calculation mode
  const routeFinderState = {
    active: false,            // Whether route finder (calculation mode) is active
    originNodeId: null,
    destNodeId: null,
    routes: [],               // Array of route objects
    activeRouteIndex: 0,      // Which route is currently highlighted
    
    // Default latencies for implicit connections (ms)
    containerLatency: 1,      // Nodes in same container
    regionLatency: 10,        // Containers in same region
    minLatency: 0.000001,     // Floor for zero/undefined latency
    
    // Transit options
    enableContainerTransit: true,  // Allow implicit connections within containers
    enableRegionTransit: true,     // Allow implicit connections between sibling containers
    
    // Filtering options
    visibleOnly: false,       // Only use visible elements
    excludedNodes: new Set(), // Node IDs to exclude from pathfinding
    excludedLinks: new Set(), // Link IDs to exclude from pathfinding
    
    // Must-use constraints
    mustUseNodes: new Set(),  // Node IDs that route must pass through
    mustUseLinks: new Set(),  // Link IDs that route must use
    
    // Pick mode for exclusions/must-use
    pickMode: null            // null, 'excludeNode', 'excludeLink', 'mustUseNode', 'mustUseLink'
  };
  
  // Expose globally for checking in event handlers
  window.routeFinderState = routeFinderState;

  // Cost calculation: latency √ó (1 - priority/200)
  // Priority ranges from -100 to +100
  // At priority 0: cost = latency (neutral)
  // At priority +100: cost = latency √ó 0.5 (half cost, preferred)
  // At priority -100: cost = latency √ó 1.5 (50% more cost, avoided)
  // Note: We divide by 200 instead of 100 to ensure cost never reaches zero
  function calculateEdgeCost(latency, priority) {
    const lat = (latency && latency > 0) ? latency : routeFinderState.minLatency;
    const pri = (typeof priority === 'number') ? Math.max(-100, Math.min(100, priority)) : 0;
    const cost = lat * (1 - pri / 200);  // Changed from /100 to /200
    return cost;
  }

  // Build pathfinding graph from current state
  function buildPathfindingGraph() {
    const adjacency = new Map();
    
    // Determine which nodes to include
    const validNodes = state.nodes.filter(n => {
      // Check if excluded
      if (routeFinderState.excludedNodes.has(n.id)) return false;
      // Check visibility if enabled
      if (routeFinderState.visibleOnly && !isNodeVisible(n)) return false;
      return true;
    });
    
    const nodeIds = new Set(validNodes.map(n => n.id));
    
    // Initialize adjacency lists
    nodeIds.forEach(id => adjacency.set(id, []));
    
    // 1. Add explicit edges (bidirectional)
    state.edges.forEach(edge => {
      // Check if edge is excluded
      if (routeFinderState.excludedLinks.has(edge.id)) return;
      
      // Check if both nodes are valid
      if (!nodeIds.has(edge.a) || !nodeIds.has(edge.b)) return;
      
      // Check edge visibility if enabled
      if (routeFinderState.visibleOnly && !isEdgeVisible(edge)) return;
      
      const nodeA = findNode(edge.a);
      const nodeB = findNode(edge.b);
      if (!nodeA || !nodeB) return;
      
      const cost = calculateEdgeCost(edge.latencyMs, edge.priority);
      const latencyDisplay = edge.latencyMs || routeFinderState.minLatency;
      
      adjacency.get(edge.a).push({
        to: edge.b,
        cost,
        edgeId: edge.id,
        implicit: false,
        latency: latencyDisplay,
        description: `${nodeA.name || 'N'+nodeA.id} ‚Üí ${nodeB.name || 'N'+nodeB.id}`
      });
      adjacency.get(edge.b).push({
        to: edge.a,
        cost,
        edgeId: edge.id,
        implicit: false,
        latency: latencyDisplay,
        description: `${nodeB.name || 'N'+nodeB.id} ‚Üí ${nodeA.name || 'N'+nodeA.id}`
      });
    });
    
    // 2. Build containerNodes map (needed for both container and region transit)
    const containerNodes = new Map();
    validNodes.forEach(n => {
      if (n.groupId) {
        if (!containerNodes.has(n.groupId)) containerNodes.set(n.groupId, []);
        containerNodes.get(n.groupId).push(n.id);
      }
    });
    
    // 2a. Add implicit edges within same container (if enabled)
    if (routeFinderState.enableContainerTransit) {
      containerNodes.forEach((nodeIdsInContainer, groupId) => {
        const group = findGroup(groupId);
        const containerName = group?.title || 'Container';
        // Use per-container transit latency if defined, otherwise use global default
        const latency = (group?.transitLatency !== undefined && group?.transitLatency !== null) 
          ? group.transitLatency 
          : routeFinderState.containerLatency;
        const cost = calculateEdgeCost(latency, 0);
        
        for (let i = 0; i < nodeIdsInContainer.length; i++) {
          for (let j = i + 1; j < nodeIdsInContainer.length; j++) {
            const a = nodeIdsInContainer[i];
            const b = nodeIdsInContainer[j];
            
            // Check if explicit edge exists (and is not excluded)
            const hasExplicit = state.edges.some(e => 
              ((e.a === a && e.b === b) || (e.a === b && e.b === a)) &&
              !routeFinderState.excludedLinks.has(e.id) &&
              (!routeFinderState.visibleOnly || isEdgeVisible(e))
            );
            
            if (!hasExplicit) {
              adjacency.get(a).push({
                to: b, cost, edgeId: null, implicit: true, containerId: groupId,
                latency, description: `via ${containerName}`
              });
              adjacency.get(b).push({
                to: a, cost, edgeId: null, implicit: true, containerId: groupId,
                latency, description: `via ${containerName}`
              });
            }
          }
        }
      });
    }
    
    // 3. Add implicit edges between sibling containers (same parent region) - if enabled
    if (routeFinderState.enableRegionTransit) {
      const regionContainers = new Map();
      state.groups.forEach(g => {
        if (g.type === 'country' && g.parentId) {
          if (!regionContainers.has(g.parentId)) regionContainers.set(g.parentId, []);
          regionContainers.get(g.parentId).push(g.id);
        }
      });
      
      regionContainers.forEach((containerIds, regionId) => {
        const region = findGroup(regionId);
        const regionName = region?.title || 'Region';
        // Use per-region transit latency if defined, otherwise use global default
        const latency = (region?.transitLatency !== undefined && region?.transitLatency !== null)
          ? region.transitLatency
          : routeFinderState.regionLatency;
        const cost = calculateEdgeCost(latency, 0);
        
        for (let i = 0; i < containerIds.length; i++) {
          for (let j = i + 1; j < containerIds.length; j++) {
            const containerA = containerIds[i];
            const containerB = containerIds[j];
            const nodesA = containerNodes.get(containerA) || [];
            const nodesB = containerNodes.get(containerB) || [];
            
            nodesA.forEach(a => {
              nodesB.forEach(b => {
                // Check if explicit edge exists (and is not excluded)
                const hasExplicit = state.edges.some(e => 
                  ((e.a === a && e.b === b) || (e.a === b && e.b === a)) &&
                  !routeFinderState.excludedLinks.has(e.id) &&
                  (!routeFinderState.visibleOnly || isEdgeVisible(e))
                );
                
                if (!hasExplicit) {
                  adjacency.get(a).push({
                    to: b, cost, edgeId: null, implicit: true, regionId,
                    latency, description: `via ${regionName}`
                  });
                  adjacency.get(b).push({
                    to: a, cost, edgeId: null, implicit: true, regionId,
                    latency, description: `via ${regionName}`
                  });
                }
              });
            });
          }
        }
      });
    }
    
    return { adjacency, nodeIds };
  }

  // Dijkstra's algorithm
  function dijkstra(adjacency, source, excludeEdges = new Set()) {
    const dist = new Map();
    const prev = new Map();
    const visited = new Set();
    const pq = [];
    
    adjacency.forEach((_, node) => {
      dist.set(node, Infinity);
      prev.set(node, null);
    });
    dist.set(source, 0);
    pq.push({ node: source, cost: 0 });
    
    while (pq.length > 0) {
      pq.sort((a, b) => a.cost - b.cost);
      const { node: u } = pq.shift();
      
      if (visited.has(u)) continue;
      visited.add(u);
      
      const neighbors = adjacency.get(u) || [];
      for (const edge of neighbors) {
        const edgeKey = `${Math.min(u, edge.to)}-${Math.max(u, edge.to)}-${edge.edgeId || 'implicit'}`;
        if (excludeEdges.has(edgeKey)) continue;
        
        const v = edge.to;
        const alt = dist.get(u) + edge.cost;
        
        if (alt < dist.get(v)) {
          dist.set(v, alt);
          prev.set(v, { from: u, edge });
          pq.push({ node: v, cost: alt });
        }
      }
    }
    
    return { dist, prev };
  }

  // Reconstruct path
  function reconstructPath(prev, source, target) {
    if (prev.get(target) === null && target !== source) return null;
    
    const path = [];
    const segments = [];
    let current = target;
    
    while (current !== null && current !== source) {
      const prevInfo = prev.get(current);
      if (!prevInfo) break;
      path.unshift(current);
      segments.unshift(prevInfo.edge);
      current = prevInfo.from;
    }
    
    if (current === source) {
      path.unshift(source);
      return { path, segments };
    }
    return null;
  }

  // Yen's K-Shortest Paths Algorithm
  function findKShortestPaths(source, target, k = 3) {
    const graph = buildPathfindingGraph();
    const { adjacency } = graph;
    
    if (!adjacency.has(source) || !adjacency.has(target)) return [];
    
    // Helper to check if a route satisfies must-use constraints
    function satisfiesMustUseConstraints(path, segments) {
      // Check must-use nodes
      for (const nodeId of routeFinderState.mustUseNodes) {
        if (!path.includes(nodeId)) return false;
      }
      
      // Check must-use links
      for (const edgeId of routeFinderState.mustUseLinks) {
        const hasLink = segments.some(seg => seg.edgeId === edgeId);
        if (!hasLink) return false;
      }
      
      return true;
    }
    
    const hasMustUseConstraints = routeFinderState.mustUseNodes.size > 0 || routeFinderState.mustUseLinks.size > 0;
    
    // Special handling for must-use constraints: route through waypoints
    if (hasMustUseConstraints) {
      const mustUseRoutes = findRoutesWithMustUseConstraints(adjacency, source, target, k);
      if (mustUseRoutes.length > 0) {
        return mustUseRoutes;
      }
      // If no routes found through must-use constraints, fall through to regular algorithm
    }
    
    const A = [];
    const B = [];
    
    // Find more paths if we have must-use constraints (we'll filter later)
    const maxPaths = hasMustUseConstraints ? k * 10 : k;
    
    const { dist, prev } = dijkstra(adjacency, source);
    const firstPath = reconstructPath(prev, source, target);
    
    if (!firstPath) return [];
    
    // Only add if satisfies constraints (or no constraints)
    if (!hasMustUseConstraints || satisfiesMustUseConstraints(firstPath.path, firstPath.segments)) {
      A.push({ path: firstPath.path, segments: firstPath.segments, totalCost: dist.get(target) });
    }
    
    // Find more candidate paths
    let candidatePaths = [{ path: firstPath.path, segments: firstPath.segments, totalCost: dist.get(target) }];
    
    for (let i = 1; i < maxPaths && A.length < k; i++) {
      const prevPath = candidatePaths[i - 1];
      if (!prevPath) break;
      
      for (let j = 0; j < prevPath.path.length - 1; j++) {
        const spurNode = prevPath.path[j];
        const rootPath = prevPath.path.slice(0, j + 1);
        const rootSegments = prevPath.segments.slice(0, j);
        
        let rootCost = 0;
        rootSegments.forEach(seg => rootCost += seg.cost);
        
        const excludeEdges = new Set();
        
        candidatePaths.forEach(path => {
          if (arraysEqual(path.path.slice(0, j + 1), rootPath)) {
            if (j < path.segments.length) {
              const seg = path.segments[j];
              const edgeKey = `${Math.min(spurNode, seg.to)}-${Math.max(spurNode, seg.to)}-${seg.edgeId || 'implicit'}`;
              excludeEdges.add(edgeKey);
            }
          }
        });
        
        rootPath.slice(0, -1).forEach(nodeInRoot => {
          adjacency.get(spurNode)?.forEach(edge => {
            if (edge.to === nodeInRoot) {
              const edgeKey = `${Math.min(spurNode, edge.to)}-${Math.max(spurNode, edge.to)}-${edge.edgeId || 'implicit'}`;
              excludeEdges.add(edgeKey);
            }
          });
        });
        
        const spurResult = dijkstra(adjacency, spurNode, excludeEdges);
        const spurPath = reconstructPath(spurResult.prev, spurNode, target);
        
        if (spurPath && spurPath.path.length > 1) {
          const totalPath = [...rootPath.slice(0, -1), ...spurPath.path];
          const totalSegments = [...rootSegments, ...spurPath.segments];
          const totalCost = rootCost + spurResult.dist.get(target);
          
          const pathStr = totalPath.join('-');
          const isDuplicate = B.some(p => p.path.join('-') === pathStr);
          
          if (!isDuplicate) {
            B.push({ path: totalPath, segments: totalSegments, totalCost });
          }
        }
      }
      
      if (B.length === 0) break;
      
      B.sort((a, b) => a.totalCost - b.totalCost);
      const best = B.shift();
      
      const bestPathStr = best.path.join('-');
      if (!candidatePaths.some(p => p.path.join('-') === bestPathStr)) {
        candidatePaths.push(best);
        
        // Check if this path satisfies must-use constraints
        if (!hasMustUseConstraints || satisfiesMustUseConstraints(best.path, best.segments)) {
          if (!A.some(p => p.path.join('-') === bestPathStr)) {
            A.push(best);
          }
        }
      }
      
      // Stop early if we have enough valid routes
      if (A.length >= k) break;
    }
    
    return A.slice(0, k);
  }
  
  // Find routes that pass through must-use nodes and links
  function findRoutesWithMustUseConstraints(adjacency, source, target, k) {
    const results = [];
    
    // Get must-use links with their edge info
    const mustUseLinks = [];
    for (const edgeId of routeFinderState.mustUseLinks) {
      const edge = state.edges.find(e => e.id === edgeId);
      if (edge) {
        // Find the adjacency entry for this edge to get cost/latency info
        const adjEntries = adjacency.get(edge.a) || [];
        const edgeInfo = adjEntries.find(e => e.edgeId === edgeId);
        mustUseLinks.push({ 
          a: edge.a, 
          b: edge.b, 
          edgeId,
          cost: edgeInfo?.cost || edge.latency || 1,
          latency: edgeInfo?.latency || edge.latency || 1
        });
      }
    }
    
    // Get must-use nodes (excluding source/target)
    const mustUseNodes = [...routeFinderState.mustUseNodes].filter(n => n !== source && n !== target);
    
    // If we have must-use links, we need to route through them explicitly
    if (mustUseLinks.length > 0) {
      // For each must-use link, try both directions and find paths
      // that go: source -> linkNodeA -> (via link) -> linkNodeB -> target
      
      // Generate all possible orderings of link traversals
      const linkOrderings = permuteLinkDirections(mustUseLinks);
      
      for (const linkOrdering of linkOrderings) {
        if (results.length >= k * 2) break; // Find more candidates, will filter to k
        
        // Build the route by forcing each must-use link
        // Route: source -> first link start -> (link) -> first link end -> ... -> target
        
        // Collect all stops including forced link traversals
        const segments = [];
        let stops = [source];
        
        // Add must-use nodes as intermediate stops
        for (const nodeId of mustUseNodes) {
          if (!stops.includes(nodeId)) {
            stops.push(nodeId);
          }
        }
        
        // For each must-use link, add both endpoints
        for (const link of linkOrdering) {
          if (!stops.includes(link.from)) stops.push(link.from);
          // Note: link.to will be added naturally in the path
        }
        
        stops.push(target);
        
        // Remove source and target from middle, ensure source is first and target is last
        stops = [source, ...stops.filter(s => s !== source && s !== target), target];
        
        // Now build the actual path, forcing must-use links
        const fullPath = [];
        const fullSegments = [];
        let totalCost = 0;
        let valid = true;
        let linksUsed = new Set();
        
        for (let i = 0; i < stops.length - 1; i++) {
          let from = stops[i];
          let to = stops[i + 1];
          
          // Check if there's a must-use link that should be used between these stops
          // or between 'from' and some intermediate point
          let forcedLink = null;
          for (const link of linkOrdering) {
            if (!linksUsed.has(link.edgeId)) {
              // Check if we should use this link now
              if (link.from === from || link.to === from) {
                forcedLink = link;
                break;
              }
            }
          }
          
          if (forcedLink && !linksUsed.has(forcedLink.edgeId)) {
            // Need to route to the start of this link first (if not already there)
            const linkStart = forcedLink.from === from ? forcedLink.from : forcedLink.to;
            const linkEnd = forcedLink.from === from ? forcedLink.to : forcedLink.from;
            
            if (from !== linkStart) {
              // Route from current position to link start
              const { dist, prev } = dijkstra(adjacency, from);
              const subPath = reconstructPath(prev, from, linkStart);
              if (!subPath) { valid = false; break; }
              
              if (fullPath.length === 0) {
                fullPath.push(...subPath.path);
              } else {
                fullPath.push(...subPath.path.slice(1));
              }
              fullSegments.push(...subPath.segments);
              totalCost += dist.get(linkStart);
              from = linkStart;
            }
            
            // Now use the forced link
            if (fullPath.length === 0) {
              fullPath.push(linkStart);
            }
            fullPath.push(linkEnd);
            
            // Create segment for the forced link
            const forcedSegment = {
              to: linkEnd,
              cost: forcedLink.cost,
              edgeId: forcedLink.edgeId,
              latency: forcedLink.latency
            };
            fullSegments.push(forcedSegment);
            totalCost += forcedLink.cost;
            linksUsed.add(forcedLink.edgeId);
            
            // Update 'from' for next iteration - continue from linkEnd to original 'to'
            from = linkEnd;
          }
          
          // Route from current position to next stop
          if (from !== to) {
            const { dist, prev } = dijkstra(adjacency, from);
            const subPath = reconstructPath(prev, from, to);
            if (!subPath) { valid = false; break; }
            
            if (fullPath.length === 0) {
              fullPath.push(...subPath.path);
            } else {
              fullPath.push(...subPath.path.slice(1));
            }
            fullSegments.push(...subPath.segments);
            totalCost += dist.get(to);
          }
        }
        
        if (!valid) continue;
        
        // Verify all must-use links were used
        let hasAllLinks = true;
        for (const edgeId of routeFinderState.mustUseLinks) {
          if (!linksUsed.has(edgeId)) {
            hasAllLinks = false;
            break;
          }
        }
        if (!hasAllLinks) continue;
        
        // Verify all must-use nodes are in path
        let hasAllNodes = true;
        for (const nodeId of routeFinderState.mustUseNodes) {
          if (!fullPath.includes(nodeId)) {
            hasAllNodes = false;
            break;
          }
        }
        if (!hasAllNodes) continue;
        
        // Check for duplicates
        const pathStr = fullPath.join('-');
        if (results.some(r => r.path.join('-') === pathStr)) continue;
        
        results.push({ path: fullPath, segments: fullSegments, totalCost });
      }
    } else if (mustUseNodes.length > 0) {
      // Only must-use nodes, no links - use waypoint routing
      const permutations = permute(mustUseNodes.slice(0, 6));
      
      for (const ordering of permutations) {
        if (results.length >= k) break;
        
        const stops = [source, ...ordering, target];
        const fullPath = [];
        const fullSegments = [];
        let totalCost = 0;
        let valid = true;
        
        for (let i = 0; i < stops.length - 1; i++) {
          const from = stops[i];
          const to = stops[i + 1];
          
          const { dist, prev } = dijkstra(adjacency, from);
          const subPath = reconstructPath(prev, from, to);
          
          if (!subPath) { valid = false; break; }
          
          if (i === 0) {
            fullPath.push(...subPath.path);
          } else {
            fullPath.push(...subPath.path.slice(1));
          }
          fullSegments.push(...subPath.segments);
          totalCost += dist.get(to);
        }
        
        if (!valid) continue;
        
        const pathStr = fullPath.join('-');
        if (results.some(r => r.path.join('-') === pathStr)) continue;
        
        results.push({ path: fullPath, segments: fullSegments, totalCost });
      }
    }
    
    // Sort by cost and return top k
    results.sort((a, b) => a.totalCost - b.totalCost);
    return results.slice(0, k);
  }
  
  // Generate permutations of link directions (each link can be traversed A->B or B->A)
  function permuteLinkDirections(links) {
    if (links.length === 0) return [[]];
    if (links.length === 1) {
      return [
        [{ ...links[0], from: links[0].a, to: links[0].b }],
        [{ ...links[0], from: links[0].b, to: links[0].a }]
      ];
    }
    
    const results = [];
    const [first, ...rest] = links;
    const restPerms = permuteLinkDirections(rest);
    
    // Try both directions for the first link
    for (const dir of [
      { ...first, from: first.a, to: first.b },
      { ...first, from: first.b, to: first.a }
    ]) {
      for (const restPerm of restPerms) {
        // Try this link at different positions
        for (let pos = 0; pos <= restPerm.length; pos++) {
          const combined = [...restPerm.slice(0, pos), dir, ...restPerm.slice(pos)];
          results.push(combined);
        }
      }
    }
    
    // Limit to avoid explosion
    return results.slice(0, 48);
  }
  
  // Generate permutations of an array (for must-use nodes)
  function permute(arr) {
    if (arr.length <= 1) return [arr];
    if (arr.length > 6) {
      // Limit permutations for large arrays
      arr = arr.slice(0, 6);
    }
    
    const result = [];
    for (let i = 0; i < arr.length; i++) {
      const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
      const restPerms = permute(rest);
      for (const perm of restPerms) {
        result.push([arr[i], ...perm]);
      }
    }
    return result;
  }
  
  function arraysEqual(a, b) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }

  // ============== ROUTE FINDER UI ==============
  
  const routeFinderPanel = document.getElementById('routeFinderPanel');
  const routeOriginSelect = document.getElementById('routeOriginSelect');
  const routeDestSelect = document.getElementById('routeDestSelect');
  const btnCalculateRoutes = document.getElementById('btnCalculateRoutes');
  const btnSwapEndpoints = document.getElementById('btnSwapEndpoints');
  const btnCloseRouteFinder = document.getElementById('btnCloseRouteFinder');
  const btnExitRouteFinder = document.getElementById('btnExitRouteFinder');
  const routeResultsSection = document.getElementById('routeResultsSection');
  const routeResultsContent = document.getElementById('routeResultsContent');
  const routeDetailsSection = document.getElementById('routeDetailsSection');
  const routeDetailsContent = document.getElementById('routeDetailsContent');
  const routeContainerLatency = document.getElementById('routeContainerLatency');
  const routeRegionLatency = document.getElementById('routeRegionLatency');
  const routeEnableContainerTransit = document.getElementById('routeEnableContainerTransit');
  const routeEnableRegionTransit = document.getElementById('routeEnableRegionTransit');
  const containerLatencyRow = document.getElementById('containerLatencyRow');
  const regionLatencyRow = document.getElementById('regionLatencyRow');
  
  // Must-use elements
  const routeMustUseNodeSelect = document.getElementById('routeMustUseNodeSelect');
  const routeMustUseLinkSelect = document.getElementById('routeMustUseLinkSelect');
  const btnAddMustUseNode = document.getElementById('btnAddMustUseNode');
  const btnPickMustUseNode = document.getElementById('btnPickMustUseNode');
  const btnAddMustUseLink = document.getElementById('btnAddMustUseLink');
  const btnPickMustUseLink = document.getElementById('btnPickMustUseLink');
  const btnClearAllMustUse = document.getElementById('btnClearAllMustUse');
  const mustUseNodesList = document.getElementById('mustUseNodesList');
  const mustUseLinksList = document.getElementById('mustUseLinksList');

  // Enter calculation mode (Route Finder)
  function enterCalculationMode() {
    console.log('[ROUTE FINDER] === ENTERING CALCULATION MODE ===');
    routeFinderState.active = true;
    routeFinderState.originNodeId = null;
    routeFinderState.destNodeId = null;
    routeFinderState.routes = [];
    routeFinderState.activeRouteIndex = 0;
    routeFinderState.pickMode = null;
    
    // Preserve exclusions between calculations (don't reset here)
    // routeFinderState.excludedNodes = new Set();
    // routeFinderState.excludedLinks = new Set();
    
    // Show panel
    const panel = document.getElementById('routeFinderPanel');
    console.log('[ROUTE FINDER] Panel element found:', !!panel);
    if (panel) {
      panel.classList.add('visible');
      console.log('[ROUTE FINDER] Panel should now be visible');
    } else {
      console.error('[ROUTE FINDER] ERROR: Panel element not found!');
      showToast('Error: Route Finder panel not found');
      return;
    }
    
    // Update button state
    const btn = document.getElementById('btnRouteFinder');
    if (btn) btn.classList.add('primary');
    
    // Clear any current selection
    clearSelection();
    render();
    
    // Populate node dropdowns
    populateNodeDropdowns();
    
    // Populate exclusion dropdowns
    populateExclusionDropdowns();
    
    // Populate must-use dropdowns
    populateMustUseDropdowns();
    
    // Render exclusion lists
    renderExcludedNodesList();
    renderExcludedLinksList();
    
    // Render must-use lists
    renderMustUseNodesList();
    renderMustUseLinksList();
    
    // Sync visibility checkbox
    const visibleOnlyCheckbox = document.getElementById('routeVisibleOnly');
    if (visibleOnlyCheckbox) {
      visibleOnlyCheckbox.checked = routeFinderState.visibleOnly;
    }
    
    // Sync transit checkboxes
    if (routeEnableContainerTransit) {
      routeEnableContainerTransit.checked = routeFinderState.enableContainerTransit;
    }
    if (routeEnableRegionTransit) {
      routeEnableRegionTransit.checked = routeFinderState.enableRegionTransit;
    }
    
    // Update latency row visibility based on transit settings
    updateTransitLatencyVisibility();
    
    // Update UI
    updateRouteFinderUI();
    
    console.log('[ROUTE FINDER] Calculation mode active, showing toast');
    showToast('üß≠ CALCULATION MODE - Select Origin and Destination nodes');
  }

  // Exit calculation mode
  function exitCalculationMode() {
    console.log('[ROUTE FINDER] Exiting calculation mode');
    routeFinderState.active = false;
    routeFinderState.pickMode = null;
    
    // Hide panel
    const panel = document.getElementById('routeFinderPanel');
    if (panel) {
      panel.classList.remove('visible');
    }
    
    // Update button state
    const btn = document.getElementById('btnRouteFinder');
    if (btn) btn.classList.remove('primary');
    
    // Clear highlights
    clearRouteHighlights();
    
    showToast('‚úèÔ∏è Edit Mode: Normal editing restored');
  }

  // Toggle Route Finder (calculation mode)
  function toggleRouteFinder() {
    console.log('[ROUTE FINDER] Toggle called');
    console.log('[ROUTE FINDER] Current state.active =', routeFinderState.active);
    console.log('[ROUTE FINDER] Panel element:', routeFinderPanel);
    console.log('[ROUTE FINDER] Panel has visible class:', routeFinderPanel?.classList.contains('visible'));
    
    if (routeFinderState.active) {
      console.log('[ROUTE FINDER] -> Calling exitCalculationMode');
      exitCalculationMode();
    } else {
      console.log('[ROUTE FINDER] -> Calling enterCalculationMode');
      enterCalculationMode();
    }
  }
  
  // Expose globally
  window.toggleRouteFinder = toggleRouteFinder;

  // Populate node dropdowns with all nodes
  function populateNodeDropdowns() {
    if (!routeOriginSelect || !routeDestSelect) return;
    
    // Sort nodes by name
    const sortedNodes = [...state.nodes].sort((a, b) => {
      const nameA = (a.name || '').toLowerCase();
      const nameB = (b.name || '').toLowerCase();
      return nameA.localeCompare(nameB);
    });
    
    // Build options HTML
    let optionsHtml = '<option value="">-- Click a node or select --</option>';
    sortedNodes.forEach(node => {
      const displayName = node.name || `Node ${node.id}`;
      const code = node.code ? ` [${node.code}]` : '';
      optionsHtml += `<option value="${node.id}">${displayName}${code}</option>`;
    });
    
    routeOriginSelect.innerHTML = optionsHtml;
    routeDestSelect.innerHTML = optionsHtml;
  }

  // Handle node click in calculation mode
  function handleCalculationModeNodeClick(nodeId) {
    if (!routeFinderState.active) return false;
    
    const node = findNode(nodeId);
    if (!node) return false;
    
    // Check if in node exclusion pick mode
    if (routeFinderState.pickMode === 'excludeNode') {
      addExcludedNode(nodeId);
      routeFinderState.pickMode = null;
      updatePickModeButtons();
      return true;
    }
    
    // Check if in must-use node pick mode
    if (routeFinderState.pickMode === 'mustUseNode') {
      addMustUseNode(nodeId);
      routeFinderState.pickMode = null;
      updatePickModeButtons();
      return true;
    }
    
    // If no origin set, set this as origin
    if (!routeFinderState.originNodeId) {
      routeFinderState.originNodeId = nodeId;
      showToast(`üü¢ Origin: ${node.name || 'Node ' + nodeId}`);
    }
    // If origin set but no destination, set this as destination
    else if (!routeFinderState.destNodeId) {
      if (nodeId === routeFinderState.originNodeId) {
        showToast('‚ö†Ô∏è Destination cannot be same as origin');
        return true;
      }
      routeFinderState.destNodeId = nodeId;
      showToast(`üî¥ Destination: ${node.name || 'Node ' + nodeId}`);
    }
    // If both set, replace destination
    else {
      if (nodeId === routeFinderState.originNodeId) {
        showToast('‚ö†Ô∏è Cannot select origin as destination');
        return true;
      }
      routeFinderState.destNodeId = nodeId;
      showToast(`üî¥ New Destination: ${node.name || 'Node ' + nodeId}`);
    }
    
    // Clear previous routes
    routeFinderState.routes = [];
    routeFinderState.activeRouteIndex = 0;
    
    updateRouteFinderUI();
    highlightEndpoints();
    
    return true; // Handled
  }

  // Update Route Finder UI
  function updateRouteFinderUI() {
    // Update dropdowns
    if (routeOriginSelect) {
      routeOriginSelect.value = routeFinderState.originNodeId || '';
    }
    if (routeDestSelect) {
      routeDestSelect.value = routeFinderState.destNodeId || '';
    }
    
    // Update calculate button
    const canCalculate = routeFinderState.originNodeId && routeFinderState.destNodeId;
    if (btnCalculateRoutes) btnCalculateRoutes.disabled = !canCalculate;
    
    // Update routes section
    if (routeFinderState.routes.length > 0) {
      if (routeResultsSection) routeResultsSection.style.display = 'block';
      displayRouteResults();
    } else {
      if (routeResultsSection) routeResultsSection.style.display = 'none';
      if (routeDetailsSection) routeDetailsSection.style.display = 'none';
    }
  }

  // Populate exclusion dropdowns
  function populateExclusionDropdowns() {
    const nodeSelect = document.getElementById('routeExcludeNodeSelect');
    const linkSelect = document.getElementById('routeExcludeLinkSelect');
    
    if (nodeSelect) {
      nodeSelect.innerHTML = '<option value="">-- Select node to exclude --</option>';
      const sortedNodes = [...state.nodes].sort((a, b) => {
        const nameA = (a.name || a.code || '').toLowerCase();
        const nameB = (b.name || b.code || '').toLowerCase();
        return nameA.localeCompare(nameB);
      });
      sortedNodes.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n.id;
        const name = n.name || n.code || `Node ${n.id}`;
        opt.textContent = name;
        nodeSelect.appendChild(opt);
      });
    }
    
    if (linkSelect) {
      linkSelect.innerHTML = '<option value="">-- Select link to exclude --</option>';
      state.edges.forEach(e => {
        const nodeA = findNode(e.a);
        const nodeB = findNode(e.b);
        const opt = document.createElement('option');
        opt.value = e.id;
        const nameA = nodeA?.name || nodeA?.code || `N${e.a}`;
        const nameB = nodeB?.name || nodeB?.code || `N${e.b}`;
        opt.textContent = `${nameA} ‚Üî ${nameB}`;
        linkSelect.appendChild(opt);
      });
    }
  }

  // Render excluded nodes list
  function renderExcludedNodesList() {
    const container = document.getElementById('excludedNodesList');
    if (!container) return;
    
    container.innerHTML = '';
    
    if (routeFinderState.excludedNodes.size === 0) {
      container.innerHTML = '<span style="font-size:10px; color:#94a3b8; font-style:italic;">No nodes excluded</span>';
      return;
    }
    
    routeFinderState.excludedNodes.forEach(nodeId => {
      const node = findNode(nodeId);
      if (!node) return;
      
      const tag = document.createElement('span');
      tag.style.cssText = 'display:inline-flex; align-items:center; gap:4px; padding:3px 6px 3px 8px; background:#ede9fe; color:#6d28d9; border-radius:12px; font-size:10px; font-weight:500;';
      tag.innerHTML = `
        ${node.name || node.code || 'Node ' + nodeId}
        <button style="background:none; border:none; color:#8b5cf6; cursor:pointer; font-size:12px; line-height:1; padding:0;" 
                title="Remove from exclusions" data-node-id="${nodeId}">‚úï</button>
      `;
      tag.querySelector('button').addEventListener('click', (ev) => {
        ev.stopPropagation();
        removeExcludedNode(nodeId);
      });
      container.appendChild(tag);
    });
  }

  // Render excluded links list
  function renderExcludedLinksList() {
    const container = document.getElementById('excludedLinksList');
    if (!container) return;
    
    container.innerHTML = '';
    
    if (routeFinderState.excludedLinks.size === 0) {
      container.innerHTML = '<span style="font-size:10px; color:#94a3b8; font-style:italic;">No links excluded</span>';
      return;
    }
    
    routeFinderState.excludedLinks.forEach(edgeId => {
      const edge = state.edges.find(e => e.id === edgeId);
      if (!edge) return;
      
      const nodeA = findNode(edge.a);
      const nodeB = findNode(edge.b);
      const nameA = nodeA?.name || nodeA?.code || `N${edge.a}`;
      const nameB = nodeB?.name || nodeB?.code || `N${edge.b}`;
      
      const tag = document.createElement('span');
      tag.style.cssText = 'display:inline-flex; align-items:center; gap:4px; padding:3px 6px 3px 8px; background:#fee2e2; color:#dc2626; border-radius:12px; font-size:10px; font-weight:500;';
      tag.innerHTML = `
        ${nameA} ‚Üî ${nameB}
        <button style="background:none; border:none; color:#ef4444; cursor:pointer; font-size:12px; line-height:1; padding:0;" 
                title="Remove from exclusions" data-edge-id="${edgeId}">‚úï</button>
      `;
      tag.querySelector('button').addEventListener('click', (ev) => {
        ev.stopPropagation();
        removeExcludedLink(edgeId);
      });
      container.appendChild(tag);
    });
  }

  // Add excluded node
  function addExcludedNode(nodeId) {
    if (!nodeId || routeFinderState.excludedNodes.has(nodeId)) return;
    
    // Can't exclude origin or destination
    if (nodeId === routeFinderState.originNodeId || nodeId === routeFinderState.destNodeId) {
      showToast('‚ö†Ô∏è Cannot exclude origin or destination node');
      return;
    }
    
    routeFinderState.excludedNodes.add(nodeId);
    const node = findNode(nodeId);
    showToast(`üö´ Excluded node: ${node?.name || node?.code || 'Node ' + nodeId}`);
    renderExcludedNodesList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Remove excluded node
  function removeExcludedNode(nodeId) {
    routeFinderState.excludedNodes.delete(nodeId);
    renderExcludedNodesList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Add excluded link
  function addExcludedLink(edgeId) {
    if (!edgeId || routeFinderState.excludedLinks.has(edgeId)) return;
    
    routeFinderState.excludedLinks.add(edgeId);
    const edge = state.edges.find(e => e.id === edgeId);
    if (edge) {
      const nodeA = findNode(edge.a);
      const nodeB = findNode(edge.b);
      const nameA = nodeA?.name || nodeA?.code || `N${edge.a}`;
      const nameB = nodeB?.name || nodeB?.code || `N${edge.b}`;
      showToast(`üö´ Excluded link: ${nameA} ‚Üî ${nameB}`);
    }
    renderExcludedLinksList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Remove excluded link
  function removeExcludedLink(edgeId) {
    routeFinderState.excludedLinks.delete(edgeId);
    renderExcludedLinksList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Clear all restrictions
  function clearAllRestrictions() {
    routeFinderState.excludedNodes.clear();
    routeFinderState.excludedLinks.clear();
    routeFinderState.visibleOnly = false;
    
    const visibleOnlyCheckbox = document.getElementById('routeVisibleOnly');
    if (visibleOnlyCheckbox) visibleOnlyCheckbox.checked = false;
    
    renderExcludedNodesList();
    renderExcludedLinksList();
    routeFinderState.routes = [];
    updateRouteFinderUI();
    showToast('üóëÔ∏è All exclusions cleared');
  }

  // ========== MUST-USE FUNCTIONS ==========
  
  // Render must-use nodes list
  function renderMustUseNodesList() {
    const container = document.getElementById('mustUseNodesList');
    if (!container) return;
    
    container.innerHTML = '';
    
    if (routeFinderState.mustUseNodes.size === 0) {
      container.innerHTML = '<span style="font-size:10px; color:#94a3b8; font-style:italic;">No must-use nodes</span>';
      return;
    }
    
    routeFinderState.mustUseNodes.forEach(nodeId => {
      const node = findNode(nodeId);
      if (!node) return;
      
      const tag = document.createElement('span');
      tag.style.cssText = 'display:inline-flex; align-items:center; gap:4px; padding:3px 6px 3px 8px; background:#dcfce7; color:#16a34a; border-radius:12px; font-size:10px; font-weight:500;';
      tag.innerHTML = `
        ${node.name || node.code || 'Node ' + nodeId}
        <button style="background:none; border:none; color:#22c55e; cursor:pointer; font-size:12px; line-height:1; padding:0;" 
                title="Remove from must-use" data-node-id="${nodeId}">‚úï</button>
      `;
      tag.querySelector('button').addEventListener('click', (ev) => {
        ev.stopPropagation();
        removeMustUseNode(nodeId);
      });
      container.appendChild(tag);
    });
  }

  // Render must-use links list
  function renderMustUseLinksList() {
    const container = document.getElementById('mustUseLinksList');
    if (!container) return;
    
    container.innerHTML = '';
    
    if (routeFinderState.mustUseLinks.size === 0) {
      container.innerHTML = '<span style="font-size:10px; color:#94a3b8; font-style:italic;">No must-use links</span>';
      return;
    }
    
    routeFinderState.mustUseLinks.forEach(edgeId => {
      const edge = state.edges.find(e => e.id === edgeId);
      if (!edge) return;
      
      const nodeA = findNode(edge.a);
      const nodeB = findNode(edge.b);
      const nameA = nodeA?.name || nodeA?.code || `N${edge.a}`;
      const nameB = nodeB?.name || nodeB?.code || `N${edge.b}`;
      
      const tag = document.createElement('span');
      tag.style.cssText = 'display:inline-flex; align-items:center; gap:4px; padding:3px 6px 3px 8px; background:#dcfce7; color:#16a34a; border-radius:12px; font-size:10px; font-weight:500;';
      tag.innerHTML = `
        ${nameA} ‚Üî ${nameB}
        <button style="background:none; border:none; color:#22c55e; cursor:pointer; font-size:12px; line-height:1; padding:0;" 
                title="Remove from must-use" data-edge-id="${edgeId}">‚úï</button>
      `;
      tag.querySelector('button').addEventListener('click', (ev) => {
        ev.stopPropagation();
        removeMustUseLink(edgeId);
      });
      container.appendChild(tag);
    });
  }

  // Add must-use node
  function addMustUseNode(nodeId) {
    if (!nodeId || routeFinderState.mustUseNodes.has(nodeId)) return;
    
    // Can't be both excluded and must-use
    if (routeFinderState.excludedNodes.has(nodeId)) {
      showToast('‚ö†Ô∏è Node is currently excluded. Remove from exclusions first.');
      return;
    }
    
    routeFinderState.mustUseNodes.add(nodeId);
    const node = findNode(nodeId);
    showToast(`‚úÖ Must-use node: ${node?.name || node?.code || 'Node ' + nodeId}`);
    renderMustUseNodesList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Remove must-use node
  function removeMustUseNode(nodeId) {
    routeFinderState.mustUseNodes.delete(nodeId);
    renderMustUseNodesList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Add must-use link
  function addMustUseLink(edgeId) {
    if (!edgeId || routeFinderState.mustUseLinks.has(edgeId)) return;
    
    // Can't be both excluded and must-use
    if (routeFinderState.excludedLinks.has(edgeId)) {
      showToast('‚ö†Ô∏è Link is currently excluded. Remove from exclusions first.');
      return;
    }
    
    routeFinderState.mustUseLinks.add(edgeId);
    const edge = state.edges.find(e => e.id === edgeId);
    if (edge) {
      const nodeA = findNode(edge.a);
      const nodeB = findNode(edge.b);
      const nameA = nodeA?.name || nodeA?.code || `N${edge.a}`;
      const nameB = nodeB?.name || nodeB?.code || `N${edge.b}`;
      showToast(`‚úÖ Must-use link: ${nameA} ‚Üî ${nameB}`);
    }
    renderMustUseLinksList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Remove must-use link
  function removeMustUseLink(edgeId) {
    routeFinderState.mustUseLinks.delete(edgeId);
    renderMustUseLinksList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Clear all must-use constraints
  function clearAllMustUse() {
    routeFinderState.mustUseNodes.clear();
    routeFinderState.mustUseLinks.clear();
    
    renderMustUseNodesList();
    renderMustUseLinksList();
    routeFinderState.routes = [];
    updateRouteFinderUI();
    showToast('üóëÔ∏è All must-use constraints cleared');
  }

  // Update transit latency row visibility
  function updateTransitLatencyVisibility() {
    if (containerLatencyRow) {
      containerLatencyRow.style.opacity = routeFinderState.enableContainerTransit ? '1' : '0.5';
    }
    if (regionLatencyRow) {
      regionLatencyRow.style.opacity = routeFinderState.enableRegionTransit ? '1' : '0.5';
    }
  }

  // Populate must-use dropdowns
  function populateMustUseDropdowns() {
    if (routeMustUseNodeSelect) {
      routeMustUseNodeSelect.innerHTML = '<option value="">-- Select node (must pass through) --</option>';
      state.nodes.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n.id;
        opt.textContent = n.name || n.code || `Node ${n.id}`;
        routeMustUseNodeSelect.appendChild(opt);
      });
    }
    
    if (routeMustUseLinkSelect) {
      routeMustUseLinkSelect.innerHTML = '<option value="">-- Select link (must use) --</option>';
      state.edges.forEach(e => {
        const nodeA = findNode(e.a);
        const nodeB = findNode(e.b);
        const opt = document.createElement('option');
        opt.value = e.id;
        const nameA = nodeA?.name || nodeA?.code || `N${e.a}`;
        const nameB = nodeB?.name || nodeB?.code || `N${e.b}`;
        opt.textContent = `${nameA} ‚Üî ${nameB}`;
        routeMustUseLinkSelect.appendChild(opt);
      });
    }
  }

  // Handle exclusion pick mode click on node
  function handleExclusionNodeClick(nodeId) {
    if (!routeFinderState.active) return false;
    
    if (routeFinderState.pickMode === 'excludeNode') {
      addExcludedNode(nodeId);
      routeFinderState.pickMode = null;
      updatePickModeButtons();
      return true;
    }
    
    if (routeFinderState.pickMode === 'mustUseNode') {
      addMustUseNode(nodeId);
      routeFinderState.pickMode = null;
      updatePickModeButtons();
      return true;
    }
    
    return false;
  }

  // Handle exclusion pick mode click on link
  function handleExclusionLinkClick(edgeId) {
    if (!routeFinderState.active) return false;
    
    if (routeFinderState.pickMode === 'excludeLink') {
      addExcludedLink(edgeId);
      routeFinderState.pickMode = null;
      updatePickModeButtons();
      return true;
    }
    
    if (routeFinderState.pickMode === 'mustUseLink') {
      addMustUseLink(edgeId);
      routeFinderState.pickMode = null;
      updatePickModeButtons();
      return true;
    }
    
    return false;
  }

  // Update pick mode button styles
  function updatePickModeButtons() {
    const btnPickNode = document.getElementById('btnPickExcludeNode');
    const btnPickLink = document.getElementById('btnPickExcludeLink');
    const btnPickMustNode = document.getElementById('btnPickMustUseNode');
    const btnPickMustLink = document.getElementById('btnPickMustUseLink');
    
    // Reset all buttons first
    [btnPickNode, btnPickLink, btnPickMustNode, btnPickMustLink].forEach(btn => {
      if (btn) {
        btn.style.background = '';
        btn.style.color = '';
      }
    });
    
    // Highlight active pick mode
    if (routeFinderState.pickMode === 'excludeNode' && btnPickNode) {
      btnPickNode.style.background = '#7c3aed';
      btnPickNode.style.color = 'white';
    }
    if (routeFinderState.pickMode === 'excludeLink' && btnPickLink) {
      btnPickLink.style.background = '#dc2626';
      btnPickLink.style.color = 'white';
    }
    if (routeFinderState.pickMode === 'mustUseNode' && btnPickMustNode) {
      btnPickMustNode.style.background = '#16a34a';
      btnPickMustNode.style.color = 'white';
    }
    if (routeFinderState.pickMode === 'mustUseLink' && btnPickMustLink) {
      btnPickMustLink.style.background = '#16a34a';
      btnPickMustLink.style.color = 'white';
    }
  }

  // Calculate routes
  function calculateRoutes() {
    if (!routeFinderState.originNodeId || !routeFinderState.destNodeId) {
      showToast('Please select both origin and destination');
      return;
    }
    
    // Check if origin or destination is excluded
    if (routeFinderState.excludedNodes.has(routeFinderState.originNodeId)) {
      showToast('‚ö†Ô∏è Origin node is excluded - remove from restrictions first');
      return;
    }
    if (routeFinderState.excludedNodes.has(routeFinderState.destNodeId)) {
      showToast('‚ö†Ô∏è Destination node is excluded - remove from restrictions first');
      return;
    }
    
    // Update settings from inputs
    if (routeContainerLatency) {
      routeFinderState.containerLatency = parseFloat(routeContainerLatency.value) || 1;
    }
    if (routeRegionLatency) {
      routeFinderState.regionLatency = parseFloat(routeRegionLatency.value) || 10;
    }
    if (routeEnableContainerTransit) {
      routeFinderState.enableContainerTransit = routeEnableContainerTransit.checked;
    }
    if (routeEnableRegionTransit) {
      routeFinderState.enableRegionTransit = routeEnableRegionTransit.checked;
    }
    
    const routes = findKShortestPaths(
      routeFinderState.originNodeId,
      routeFinderState.destNodeId,
      3
    );
    
    routeFinderState.routes = routes;
    routeFinderState.activeRouteIndex = 0;
    
    updateRouteFinderUI();
    
    // Build restriction/constraint summary for toast
    const constraints = [];
    if (routeFinderState.visibleOnly) constraints.push('visible only');
    if (!routeFinderState.enableContainerTransit) constraints.push('no container transit');
    if (!routeFinderState.enableRegionTransit) constraints.push('no region transit');
    if (routeFinderState.excludedNodes.size > 0) constraints.push(`${routeFinderState.excludedNodes.size} node(s) excluded`);
    if (routeFinderState.excludedLinks.size > 0) constraints.push(`${routeFinderState.excludedLinks.size} link(s) excluded`);
    if (routeFinderState.mustUseNodes.size > 0) constraints.push(`${routeFinderState.mustUseNodes.size} must-use node(s)`);
    if (routeFinderState.mustUseLinks.size > 0) constraints.push(`${routeFinderState.mustUseLinks.size} must-use link(s)`);
    const constraintText = constraints.length > 0 ? ` (${constraints.join(', ')})` : '';
    
    if (routes.length > 0) {
      highlightActiveRoute();
      showToast(`‚úÖ Found ${routes.length} route${routes.length > 1 ? 's' : ''}${constraintText}`);
    } else {
      clearRouteHighlights();
      highlightEndpoints();
      showToast(`‚ùå No path found${constraintText}`);
    }
  }

  // Display route results
  function displayRouteResults() {
    if (!routeResultsContent) return;
    
    routeResultsContent.innerHTML = '';
    
    if (routeFinderState.routes.length === 0) {
      const hasRestrictions = routeFinderState.visibleOnly || 
                              routeFinderState.excludedNodes.size > 0 || 
                              routeFinderState.excludedLinks.size > 0;
      const hasMustUse = routeFinderState.mustUseNodes.size > 0 || 
                         routeFinderState.mustUseLinks.size > 0;
      const hasTransitDisabled = !routeFinderState.enableContainerTransit || 
                                 !routeFinderState.enableRegionTransit;
      
      let hint = 'Nodes are not connected';
      if (hasMustUse) {
        hint = 'No routes found passing through all must-use constraints';
      } else if (hasRestrictions) {
        hint = 'Try adjusting restrictions';
      } else if (hasTransitDisabled) {
        hint = 'Try enabling container/region transit';
      }
      
      routeResultsContent.innerHTML = `
        <div style="padding:20px; text-align:center; color:#666;">
          <div style="font-size:32px; margin-bottom:8px;">üö´</div>
          <div><strong>No path found</strong></div>
          <div style="font-size:11px; margin-top:4px;">${hint}</div>
        </div>
      `;
      return;
    }
    
    const routeLabels = ['Best Route', 'Alternative 1', 'Alternative 2'];
    const routeIcons = ['ü•á', 'ü•à', 'ü•â'];
    const routeColors = ['#22c55e', '#f59e0b', '#f97316'];
    
    routeFinderState.routes.forEach((route, index) => {
      const nodeNames = route.path.map(id => {
        const n = findNode(id);
        return n?.name || 'N' + id;
      });
      
      const hops = route.path.length - 1;
      const implicitCount = route.segments.filter(s => s.implicit).length;
      const isActive = index === routeFinderState.activeRouteIndex;
      
      const option = document.createElement('div');
      option.className = 'route-option' + (isActive ? ' active' : '');
      option.style.borderLeftColor = routeColors[index];
      option.style.borderLeftWidth = '4px';
      if (isActive) {
        option.style.background = index === 0 ? '#f0fdf4' : (index === 1 ? '#fffbeb' : '#fff7ed');
      }
      option.dataset.routeIndex = index;
      option.innerHTML = `
        <div class="route-option-header">
          <span class="route-option-title">
            <span style="font-size:16px;">${routeIcons[index]}</span> ${routeLabels[index]}
          </span>
          <span class="route-option-cost" style="background:${isActive ? routeColors[index] : '#e5e7eb'}; color:${isActive ? 'white' : '#374151'}; padding:3px 8px; border-radius:4px; font-weight:600;">
            ${route.totalCost.toFixed(3)} ms
          </span>
        </div>
        <div class="route-option-path" style="margin:6px 0; font-size:11px; color:#555; word-break:break-word;">
          ${nodeNames.join(' ‚Üí ')}
        </div>
        <div class="route-option-stats" style="display:flex; gap:12px; font-size:10px; color:#888;">
          <span>üìç ${hops} hop${hops !== 1 ? 's' : ''}</span>
          ${implicitCount > 0 ? `<span>‚ãØ ${implicitCount} implicit</span>` : ''}
        </div>
      `;
      
      option.addEventListener('click', () => selectRoute(index));
      routeResultsContent.appendChild(option);
    });
  }

  // Select and highlight a route
  function selectRoute(index) {
    routeFinderState.activeRouteIndex = index;
    
    // Update UI
    displayRouteResults();
    
    // Show route details
    showRouteDetails(routeFinderState.routes[index]);
    
    // Highlight on canvas
    highlightActiveRoute();
  }

  // Show detailed route info
  function showRouteDetails(route) {
    if (!routeDetailsSection || !routeDetailsContent) return;
    
    routeDetailsSection.style.display = 'block';
    routeDetailsSection.classList.remove('collapsed');
    
    let html = '<div style="font-size:11px;">';
    
    route.segments.forEach((seg, i) => {
      const fromNode = findNode(route.path[i]);
      const toNode = findNode(route.path[i + 1]);
      const fromName = fromNode?.name || 'N' + route.path[i];
      const toName = toNode?.name || 'N' + route.path[i + 1];
      
      const isImplicit = seg.implicit;
      const latency = seg.latency || routeFinderState.minLatency;
      
      html += `
        <div style="padding:6px 0; border-bottom:1px solid #f0f0f0; display:flex; align-items:center; gap:8px;">
          <span style="color:#888; font-size:10px; width:20px;">${i + 1}.</span>
          <span style="flex:1;">
            <strong>${fromName}</strong> ‚Üí <strong>${toName}</strong>
            ${isImplicit ? '<span style="color:#f59e0b; font-size:10px;"> (implicit)</span>' : ''}
          </span>
          <span style="color:#666; font-size:10px;">${latency.toFixed(3)} ms</span>
        </div>
      `;
    });
    
    html += `
      <div style="padding:8px 0; margin-top:4px; font-weight:600; display:flex; justify-content:space-between;">
        <span>Total Cost:</span>
        <span>${route.totalCost.toFixed(3)} ms</span>
      </div>
    </div>`;
    
    routeDetailsContent.innerHTML = html;
  }

  // Clear route highlights from SVG
  function clearRouteHighlights() {
    // Clear standard view highlights
    svg.querySelectorAll('.node.route-origin, .node.route-dest, .node.route-path-node').forEach(el => {
      el.classList.remove('route-origin', 'route-dest', 'route-path-node');
    });
    // Clear geo view highlights
    svg.querySelectorAll('.geo-node.route-origin, .geo-node.route-dest, .geo-node.route-path-node').forEach(el => {
      el.classList.remove('route-origin', 'route-dest', 'route-path-node');
    });
    svg.querySelectorAll('.edge.route-path-1, .edge.route-path-2, .edge.route-path-3').forEach(el => {
      el.classList.remove('route-path-1', 'route-path-2', 'route-path-3');
    });
    svg.querySelectorAll('.route-implicit-segment').forEach(el => el.remove());
  }

  // Highlight just the endpoints
  function highlightEndpoints() {
    clearRouteHighlights();
    
    // Check if we're in Geographic View
    const inGeoView = typeof geoViewState !== 'undefined' && geoViewState.active;
    
    if (routeFinderState.originNodeId) {
      let el = svg.querySelector(`g.node[data-node-id="${routeFinderState.originNodeId}"]`);
      if (!el && inGeoView) {
        el = svg.querySelector(`circle.geo-node[data-node-id="${routeFinderState.originNodeId}"]`);
      }
      if (el) el.classList.add('route-origin');
    }
    
    if (routeFinderState.destNodeId) {
      let el = svg.querySelector(`g.node[data-node-id="${routeFinderState.destNodeId}"]`);
      if (!el && inGeoView) {
        el = svg.querySelector(`circle.geo-node[data-node-id="${routeFinderState.destNodeId}"]`);
      }
      if (el) el.classList.add('route-dest');
    }
  }

  // Highlight active route on SVG
  function highlightActiveRoute() {
    clearRouteHighlights();
    highlightEndpoints();
    
    if (routeFinderState.routes.length === 0) return;
    
    const route = routeFinderState.routes[routeFinderState.activeRouteIndex];
    const routeClass = `route-path-${routeFinderState.activeRouteIndex + 1}`;
    const routeColors = ['#22c55e', '#f59e0b', '#f97316'];
    const color = routeColors[routeFinderState.activeRouteIndex];
    
    // Check if we're in Geographic View
    const inGeoView = typeof geoViewState !== 'undefined' && geoViewState.active;
    
    // Highlight intermediate nodes
    route.path.slice(1, -1).forEach(nodeId => {
      // Try standard view selector first, then geo view
      let el = svg.querySelector(`g.node[data-node-id="${nodeId}"]`);
      if (!el && inGeoView) {
        el = svg.querySelector(`circle.geo-node[data-node-id="${nodeId}"]`);
      }
      if (el) el.classList.add('route-path-node');
    });
    
    // Highlight edges
    route.segments.forEach((segment, i) => {
      if (segment.edgeId) {
        const edgeEl = svg.querySelector(`.edge[data-edge-id="${segment.edgeId}"]`);
        if (edgeEl) {
          edgeEl.classList.add(routeClass);
        }
      } else if (segment.implicit) {
        // Draw implicit edge
        const fromId = route.path[i];
        const toId = route.path[i + 1];
        const from = findNode(fromId);
        const to = findNode(toId);
        
        if (from && to) {
          let fromPos, toPos;
          
          if (inGeoView && from.gpsLat != null && from.gpsLon != null && to.gpsLat != null && to.gpsLon != null) {
            // Use GPS coordinates in geo view
            fromPos = gpsToCanvas(from.gpsLat, from.gpsLon);
            toPos = gpsToCanvas(to.gpsLat, to.gpsLon);
          } else {
            // Use canvas coordinates in standard view
            fromPos = { x: from.x, y: from.y };
            toPos = { x: to.x, y: to.y };
          }
          
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          line.setAttribute('d', `M${fromPos.x},${fromPos.y} L${toPos.x},${toPos.y}`);
          line.setAttribute('stroke', color);
          line.setAttribute('stroke-width', '5');
          line.setAttribute('stroke-dasharray', '10,5');
          line.setAttribute('fill', 'none');
          line.setAttribute('opacity', '0.9');
          line.classList.add('route-implicit-segment');
          line.style.filter = `drop-shadow(0 0 6px ${color})`;
          
          const gridEl = svg.querySelector('.grid');
          if (gridEl && gridEl.nextSibling) {
            svg.insertBefore(line, gridEl.nextSibling);
          } else {
            svg.appendChild(line);
          }
        }
      }
    });
  }

  // Swap endpoints
  function swapEndpoints() {
    const temp = routeFinderState.originNodeId;
    routeFinderState.originNodeId = routeFinderState.destNodeId;
    routeFinderState.destNodeId = temp;
    
    routeFinderState.routes = [];
    routeFinderState.activeRouteIndex = 0;
    
    updateRouteFinderUI();
    highlightEndpoints();
    showToast('‚áÑ Endpoints swapped');
  }

  // Event listeners
  const rfBtn = document.getElementById('btnRouteFinder');
  let rfBtnClickInProgress = false;
  if (rfBtn) {
    rfBtn.addEventListener('click', function(ev) {
      ev.stopPropagation();
      ev.preventDefault();
      
      // Prevent double-firing
      if (rfBtnClickInProgress) {
        console.log('[ROUTE FINDER] Click already in progress, ignoring');
        return;
      }
      rfBtnClickInProgress = true;
      
      console.log('[ROUTE FINDER] Button clicked');
      toggleRouteFinder();
      
      // Reset flag after a short delay
      setTimeout(() => { rfBtnClickInProgress = false; }, 100);
    });
  } else {
    console.error('[ROUTE FINDER] Button not found!');
  }

  if (btnCloseRouteFinder) {
    btnCloseRouteFinder.addEventListener('click', exitCalculationMode);
  }
  
  if (btnExitRouteFinder) {
    btnExitRouteFinder.addEventListener('click', exitCalculationMode);
  }

  if (routeOriginSelect) {
    routeOriginSelect.addEventListener('change', () => {
      const val = parseInt(routeOriginSelect.value, 10);
      if (!isNaN(val)) {
        if (val === routeFinderState.destNodeId) {
          showToast('‚ö†Ô∏è Origin cannot be same as destination');
          routeOriginSelect.value = routeFinderState.originNodeId || '';
          return;
        }
        routeFinderState.originNodeId = val;
        routeFinderState.routes = [];
        updateRouteFinderUI();
        highlightEndpoints();
      } else {
        routeFinderState.originNodeId = null;
        routeFinderState.routes = [];
        updateRouteFinderUI();
        highlightEndpoints();
      }
    });
  }
  
  if (routeDestSelect) {
    routeDestSelect.addEventListener('change', () => {
      const val = parseInt(routeDestSelect.value, 10);
      if (!isNaN(val)) {
        if (val === routeFinderState.originNodeId) {
          showToast('‚ö†Ô∏è Destination cannot be same as origin');
          routeDestSelect.value = routeFinderState.destNodeId || '';
          return;
        }
        routeFinderState.destNodeId = val;
        routeFinderState.routes = [];
        updateRouteFinderUI();
        highlightEndpoints();
      } else {
        routeFinderState.destNodeId = null;
        routeFinderState.routes = [];
        updateRouteFinderUI();
        highlightEndpoints();
      }
    });
  }

  if (btnCalculateRoutes) btnCalculateRoutes.addEventListener('click', calculateRoutes);
  if (btnSwapEndpoints) btnSwapEndpoints.addEventListener('click', swapEndpoints);

  // Restriction controls event handlers
  const routeVisibleOnlyCheckbox = document.getElementById('routeVisibleOnly');
  const routeExcludeNodeSelect = document.getElementById('routeExcludeNodeSelect');
  const routeExcludeLinkSelect = document.getElementById('routeExcludeLinkSelect');
  const btnAddExcludeNode = document.getElementById('btnAddExcludeNode');
  const btnPickExcludeNode = document.getElementById('btnPickExcludeNode');
  const btnAddExcludeLink = document.getElementById('btnAddExcludeLink');
  const btnPickExcludeLink = document.getElementById('btnPickExcludeLink');
  const btnClearAllRestrictions = document.getElementById('btnClearAllRestrictions');

  if (routeVisibleOnlyCheckbox) {
    routeVisibleOnlyCheckbox.addEventListener('change', () => {
      routeFinderState.visibleOnly = routeVisibleOnlyCheckbox.checked;
      routeFinderState.routes = []; // Clear routes
      updateRouteFinderUI();
      if (routeFinderState.visibleOnly) {
        showToast('üëÅÔ∏è Calculating using visible elements only');
      } else {
        showToast('üìä Calculating using all elements');
      }
    });
  }

  if (btnAddExcludeNode) {
    btnAddExcludeNode.addEventListener('click', () => {
      const val = parseInt(routeExcludeNodeSelect?.value, 10);
      if (!isNaN(val)) {
        addExcludedNode(val);
        routeExcludeNodeSelect.value = '';
      }
    });
  }

  if (btnPickExcludeNode) {
    btnPickExcludeNode.addEventListener('click', () => {
      if (routeFinderState.pickMode === 'excludeNode') {
        routeFinderState.pickMode = null;
        showToast('Node pick mode cancelled');
      } else {
        routeFinderState.pickMode = 'excludeNode';
        showToast('üéØ Click on a node to exclude it from calculations');
      }
      updatePickModeButtons();
    });
  }

  if (btnAddExcludeLink) {
    btnAddExcludeLink.addEventListener('click', () => {
      const val = parseInt(routeExcludeLinkSelect?.value, 10);
      if (!isNaN(val)) {
        addExcludedLink(val);
        routeExcludeLinkSelect.value = '';
      }
    });
  }

  if (btnPickExcludeLink) {
    btnPickExcludeLink.addEventListener('click', () => {
      if (routeFinderState.pickMode === 'excludeLink') {
        routeFinderState.pickMode = null;
        showToast('Link pick mode cancelled');
      } else {
        routeFinderState.pickMode = 'excludeLink';
        showToast('üéØ Click on a link to exclude it from calculations');
      }
      updatePickModeButtons();
    });
  }

  if (btnClearAllRestrictions) {
    btnClearAllRestrictions.addEventListener('click', clearAllRestrictions);
  }

  // Must-use node event listeners
  if (btnAddMustUseNode) {
    btnAddMustUseNode.addEventListener('click', () => {
      const val = parseInt(routeMustUseNodeSelect?.value, 10);
      if (!isNaN(val)) {
        addMustUseNode(val);
        routeMustUseNodeSelect.value = '';
      }
    });
  }

  if (btnPickMustUseNode) {
    btnPickMustUseNode.addEventListener('click', () => {
      if (routeFinderState.pickMode === 'mustUseNode') {
        routeFinderState.pickMode = null;
        showToast('Must-use node pick mode cancelled');
      } else {
        routeFinderState.pickMode = 'mustUseNode';
        showToast('‚úÖ Click on a node to add as must-use waypoint');
      }
      updatePickModeButtons();
    });
  }

  // Must-use link event listeners
  if (btnAddMustUseLink) {
    btnAddMustUseLink.addEventListener('click', () => {
      const val = parseInt(routeMustUseLinkSelect?.value, 10);
      if (!isNaN(val)) {
        addMustUseLink(val);
        routeMustUseLinkSelect.value = '';
      }
    });
  }

  if (btnPickMustUseLink) {
    btnPickMustUseLink.addEventListener('click', () => {
      if (routeFinderState.pickMode === 'mustUseLink') {
        routeFinderState.pickMode = null;
        showToast('Must-use link pick mode cancelled');
      } else {
        routeFinderState.pickMode = 'mustUseLink';
        showToast('‚úÖ Click on a link to add as must-use');
      }
      updatePickModeButtons();
    });
  }

  if (btnClearAllMustUse) {
    btnClearAllMustUse.addEventListener('click', clearAllMustUse);
  }

  // Transit toggle event listeners
  if (routeEnableContainerTransit) {
    routeEnableContainerTransit.addEventListener('change', () => {
      routeFinderState.enableContainerTransit = routeEnableContainerTransit.checked;
      updateTransitLatencyVisibility();
      routeFinderState.routes = [];
      updateRouteFinderUI();
      showToast(routeFinderState.enableContainerTransit ? '‚úÖ Container transit enabled' : 'üö´ Container transit disabled');
    });
  }

  if (routeEnableRegionTransit) {
    routeEnableRegionTransit.addEventListener('change', () => {
      routeFinderState.enableRegionTransit = routeEnableRegionTransit.checked;
      updateTransitLatencyVisibility();
      routeFinderState.routes = [];
      updateRouteFinderUI();
      showToast(routeFinderState.enableRegionTransit ? '‚úÖ Region transit enabled' : 'üö´ Region transit disabled');
    });
  }

  // Make Route Finder panel draggable
  const routeFinderHeader = document.getElementById('routeFinderHeader');
  let rfPanelDragging = false;
  let rfPanelDragOffset = { x: 0, y: 0 };
  
  if (routeFinderHeader && routeFinderPanel) {
    routeFinderHeader.style.cursor = 'move';
    
    routeFinderHeader.addEventListener('mousedown', (ev) => {
      // Don't drag if clicking on buttons
      if (ev.target.tagName === 'BUTTON' || ev.target.closest('button')) return;
      
      rfPanelDragging = true;
      const rect = routeFinderPanel.getBoundingClientRect();
      rfPanelDragOffset.x = ev.clientX - rect.left;
      rfPanelDragOffset.y = ev.clientY - rect.top;
      routeFinderPanel.style.cursor = 'grabbing';
      ev.preventDefault();
    });
    
    window.addEventListener('mousemove', (ev) => {
      if (!rfPanelDragging) return;
      
      const layout = document.getElementById('layout');
      const layoutRect = layout.getBoundingClientRect();
      
      let newLeft = ev.clientX - layoutRect.left - rfPanelDragOffset.x;
      let newTop = ev.clientY - layoutRect.top - rfPanelDragOffset.y;
      
      // Constrain to layout bounds
      newLeft = Math.max(0, Math.min(newLeft, layoutRect.width - routeFinderPanel.offsetWidth));
      newTop = Math.max(0, Math.min(newTop, layoutRect.height - 50));
      
      routeFinderPanel.style.left = newLeft + 'px';
      routeFinderPanel.style.top = newTop + 'px';
      routeFinderPanel.style.right = 'auto';
    });
    
    window.addEventListener('mouseup', () => {
      if (rfPanelDragging) {
        rfPanelDragging = false;
        routeFinderPanel.style.cursor = '';
      }
    });
  }

  // Keyboard shortcuts
  window.addEventListener('keydown', (ev) => {
    // Escape to exit calculation mode
    if (ev.key === 'Escape' && routeFinderState.active) {
      exitCalculationMode();
      return;
    }
    
    // R to toggle route finder
    if (ev.key.toLowerCase() === 'r' && !['INPUT','TEXTAREA','SELECT'].includes(document.activeElement.tagName)) {
      toggleRouteFinder();
    }
  });

  // ============== END ROUTE FINDER / PATHFINDING SYSTEM ==============

  // ============== LABEL MANAGER ==============
  
  const labelManagerPanel = document.getElementById('labelManagerPanel');
  const labelManagerHeader = document.getElementById('labelManagerHeader');
  const btnLabelManager = document.getElementById('btnLabelManager');
  const btnCloseLabelManager = document.getElementById('btnCloseLabelManager');
  
  // Label Manager state
  const labelManagerState = {
    visible: false,
    filterType: 'all', // 'all', 'nodes', 'links', 'containers'
    selectedProjectTags: new Set(),
    pickMode: false,
    pickedElements: { nodes: new Set(), links: new Set(), containers: new Set() },
    bulkTags: new Set()
  };
  
  // Open/close Label Manager
  function toggleLabelManager() {
    labelManagerState.visible = !labelManagerState.visible;
    if (labelManagerPanel) {
      labelManagerPanel.classList.toggle('visible', labelManagerState.visible);
    }
    if (labelManagerState.visible) {
      refreshLabelManager();
    }
  }
  
  function closeLabelManager() {
    labelManagerState.visible = false;
    labelManagerState.pickMode = false;
    if (labelManagerPanel) {
      labelManagerPanel.classList.remove('visible');
    }
  }
  
  // Get all unique tags from the project
  function getAllProjectTags() {
    const tagCounts = new Map(); // tag -> { nodes: count, links: count, containers: count }
    
    // Count node tags
    state.nodes.forEach(n => {
      const tags = n.tags || [];
      tags.forEach(tag => {
        if (!tagCounts.has(tag)) tagCounts.set(tag, { nodes: 0, links: 0, containers: 0 });
        tagCounts.get(tag).nodes++;
      });
      // Also check extraTags
      if (n.extraTags) {
        n.extraTags.split(',').map(t => t.trim()).filter(Boolean).forEach(tag => {
          if (!tagCounts.has(tag)) tagCounts.set(tag, { nodes: 0, links: 0, containers: 0 });
          tagCounts.get(tag).nodes++;
        });
      }
    });
    
    // Count edge/link tags (filterTags)
    state.edges.forEach(e => {
      const tags = e.filterTags || [];
      tags.forEach(tag => {
        if (!tagCounts.has(tag)) tagCounts.set(tag, { nodes: 0, links: 0, containers: 0 });
        tagCounts.get(tag).links++;
      });
      if (e.extraTags) {
        e.extraTags.split(',').map(t => t.trim()).filter(Boolean).forEach(tag => {
          if (!tagCounts.has(tag)) tagCounts.set(tag, { nodes: 0, links: 0, containers: 0 });
          tagCounts.get(tag).links++;
        });
      }
    });
    
    // Count container tags (filterTags)
    state.groups.forEach(g => {
      const tags = g.filterTags || [];
      tags.forEach(tag => {
        if (!tagCounts.has(tag)) tagCounts.set(tag, { nodes: 0, links: 0, containers: 0 });
        tagCounts.get(tag).containers++;
      });
      if (g.extraTags) {
        g.extraTags.split(',').map(t => t.trim()).filter(Boolean).forEach(tag => {
          if (!tagCounts.has(tag)) tagCounts.set(tag, { nodes: 0, links: 0, containers: 0 });
          tagCounts.get(tag).containers++;
        });
      }
    });
    
    return tagCounts;
  }
  
  // Get tags for a specific element
  function getElementTags(type, id) {
    const tags = new Set();
    if (type === 'node') {
      const n = findNode(id);
      if (n) {
        (n.tags || []).forEach(t => tags.add(t));
        if (n.extraTags) n.extraTags.split(',').map(t => t.trim()).filter(Boolean).forEach(t => tags.add(t));
      }
    } else if (type === 'edge') {
      const e = state.edges.find(e => e.id === id);
      if (e) {
        (e.filterTags || []).forEach(t => tags.add(t));
        if (e.extraTags) e.extraTags.split(',').map(t => t.trim()).filter(Boolean).forEach(t => tags.add(t));
      }
    } else if (type === 'group') {
      const g = findGroup(id);
      if (g) {
        (g.filterTags || []).forEach(t => tags.add(t));
        if (g.extraTags) g.extraTags.split(',').map(t => t.trim()).filter(Boolean).forEach(t => tags.add(t));
      }
    }
    return tags;
  }
  
  // Set tags on an element
  function setElementTags(type, id, tags) {
    const tagArray = Array.from(tags);
    if (type === 'node') {
      const n = findNode(id);
      if (n) {
        n.tags = tagArray;
        n.extraTags = '';
      }
    } else if (type === 'edge') {
      const e = state.edges.find(e => e.id === id);
      if (e) {
        e.filterTags = tagArray;
        e.extraTags = '';
      }
    } else if (type === 'group') {
      const g = findGroup(id);
      if (g) {
        g.filterTags = tagArray;
        g.extraTags = '';
      }
    }
  }
  
  // Get current selection summary
  function getSelectionSummary() {
    const nodeCount = state.selection.nodes.size + (state.selected?.type === 'node' ? 1 : 0);
    const linkCount = state.selection.edges.size + (state.selected?.type === 'edge' ? 1 : 0);
    const containerCount = state.selection.groups.size + (state.selected?.type === 'group' ? 1 : 0);
    return { nodeCount, linkCount, containerCount, total: nodeCount + linkCount + containerCount };
  }
  
  // Get all selected element IDs
  function getSelectedElements() {
    const nodes = new Set(state.selection.nodes);
    const edges = new Set(state.selection.edges);
    const groups = new Set(state.selection.groups);
    
    if (state.selected?.type === 'node') nodes.add(state.selected.id);
    if (state.selected?.type === 'edge') edges.add(state.selected.id);
    if (state.selected?.type === 'group') groups.add(state.selected.id);
    
    return { nodes, edges, groups };
  }
  
  // Get tags across all selected elements with counts
  function getSelectionTagsWithCounts() {
    const { nodes, edges, groups } = getSelectedElements();
    const totalCount = nodes.size + edges.size + groups.size;
    const tagCounts = new Map(); // tag -> count of elements that have it
    
    // Count from nodes
    nodes.forEach(id => {
      const tags = getElementTags('node', id);
      tags.forEach(tag => {
        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
      });
    });
    
    // Count from edges
    edges.forEach(id => {
      const tags = getElementTags('edge', id);
      tags.forEach(tag => {
        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
      });
    });
    
    // Count from groups
    groups.forEach(id => {
      const tags = getElementTags('group', id);
      tags.forEach(tag => {
        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
      });
    });
    
    return { tagCounts, totalCount };
  }
  
  // Refresh entire Label Manager UI
  function refreshLabelManager() {
    renderProjectTagsList();
    renderSelectionTags();
    renderBulkApplySection();
    updateSelectionStatus();
    updateRenameDropdown();
  }
  
  // Update selection status display
  function updateSelectionStatus() {
    const summary = getSelectionSummary();
    const summaryEl = document.getElementById('lmSelectionSummary');
    const bulkCountEl = document.getElementById('lmBulkSelectionCount');
    
    if (summary.total === 0) {
      if (summaryEl) summaryEl.textContent = 'Nothing selected';
      if (bulkCountEl) bulkCountEl.textContent = '0 items';
    } else {
      const parts = [];
      if (summary.nodeCount > 0) parts.push(`${summary.nodeCount} node${summary.nodeCount > 1 ? 's' : ''}`);
      if (summary.linkCount > 0) parts.push(`${summary.linkCount} link${summary.linkCount > 1 ? 's' : ''}`);
      if (summary.containerCount > 0) parts.push(`${summary.containerCount} container${summary.containerCount > 1 ? 's' : ''}`);
      if (summaryEl) summaryEl.textContent = parts.join(', ');
      if (bulkCountEl) bulkCountEl.textContent = `${summary.total} item${summary.total > 1 ? 's' : ''}`;
    }
  }
  
  // Render project tags list
  function renderProjectTagsList() {
    const container = document.getElementById('lmProjectTagsList');
    if (!container) return;
    
    const searchInput = document.getElementById('lmTagSearch');
    const searchTerm = (searchInput?.value || '').toLowerCase();
    
    const allTags = getAllProjectTags();
    const filterType = labelManagerState.filterType;
    
    // Filter and sort tags
    let filteredTags = [];
    allTags.forEach((counts, tag) => {
      if (searchTerm && !tag.toLowerCase().includes(searchTerm)) return;
      
      // Apply type filter
      if (filterType === 'nodes' && counts.nodes === 0) return;
      if (filterType === 'links' && counts.links === 0) return;
      if (filterType === 'containers' && counts.containers === 0) return;
      
      filteredTags.push({ tag, ...counts, total: counts.nodes + counts.links + counts.containers });
    });
    
    filteredTags.sort((a, b) => a.tag.localeCompare(b.tag));
    
    if (filteredTags.length === 0) {
      container.innerHTML = `<div style="padding:20px; text-align:center; color:#9ca3af; font-size:11px;">
        ${searchTerm ? 'No tags matching search' : 'No tags in project'}
      </div>`;
      return;
    }
    
    let html = '';
    filteredTags.forEach(({ tag, nodes, links, containers }) => {
      const isChecked = labelManagerState.selectedProjectTags.has(tag);
      html += `
        <div class="lm-tag-item ${isChecked ? 'selected' : ''}" data-tag="${escapeHtml(tag)}">
          <input type="checkbox" class="lm-tag-checkbox" ${isChecked ? 'checked' : ''} />
          <span class="lm-tag-name">${escapeHtml(tag)}</span>
          <div class="lm-tag-counts">
            ${nodes > 0 ? `<span class="lm-tag-count nodes" title="Nodes">${nodes}N</span>` : ''}
            ${links > 0 ? `<span class="lm-tag-count links" title="Links">${links}L</span>` : ''}
            ${containers > 0 ? `<span class="lm-tag-count containers" title="Containers">${containers}C</span>` : ''}
          </div>
          <span class="lm-tag-menu" onclick="event.stopPropagation(); showLMTagMenu('${escapeHtml(tag)}', event)">‚ãÆ</span>
        </div>
      `;
    });
    
    container.innerHTML = html;
    
    // Add click handlers
    container.querySelectorAll('.lm-tag-item').forEach(item => {
      item.addEventListener('click', (e) => {
        if (e.target.classList.contains('lm-tag-menu')) return;
        const tag = item.dataset.tag;
        const checkbox = item.querySelector('.lm-tag-checkbox');
        
        if (labelManagerState.selectedProjectTags.has(tag)) {
          labelManagerState.selectedProjectTags.delete(tag);
          checkbox.checked = false;
          item.classList.remove('selected');
        } else {
          labelManagerState.selectedProjectTags.add(tag);
          checkbox.checked = true;
          item.classList.add('selected');
        }
        
        updateSelectAllButton();
      });
    });
    
    updateSelectAllButton();
  }
  
  // Helper to escape HTML
  function escapeHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }
  
  // Update "Select All with Tag" button state
  function updateSelectAllButton() {
    const btn = document.getElementById('lmSelectAllWithTag');
    if (btn) {
      btn.disabled = labelManagerState.selectedProjectTags.size === 0;
    }
  }
  
  // Select all elements with checked tags
  function selectAllWithCheckedTags() {
    const tags = labelManagerState.selectedProjectTags;
    if (tags.size === 0) {
      showToast('No tags selected');
      return;
    }
    
    // Clear current selection
    state.selection.nodes.clear();
    state.selection.edges.clear();
    state.selection.groups.clear();
    state.selected = null;
    
    let count = 0;
    
    // Select nodes with any of the tags
    state.nodes.forEach(n => {
      const nodeTags = getElementTags('node', n.id);
      for (const tag of tags) {
        if (nodeTags.has(tag)) {
          state.selection.nodes.add(n.id);
          count++;
          break;
        }
      }
    });
    
    // Select edges with any of the tags
    state.edges.forEach(e => {
      const edgeTags = getElementTags('edge', e.id);
      for (const tag of tags) {
        if (edgeTags.has(tag)) {
          state.selection.edges.add(e.id);
          count++;
          break;
        }
      }
    });
    
    // Select containers with any of the tags
    state.groups.forEach(g => {
      const groupTags = getElementTags('group', g.id);
      for (const tag of tags) {
        if (groupTags.has(tag)) {
          state.selection.groups.add(g.id);
          count++;
          break;
        }
      }
    });
    
    render();
    refreshLabelManager();
    showToast(`üéØ Selected ${count} element${count !== 1 ? 's' : ''} with checked tags`);
  }
  
  // Render selection tags section
  function renderSelectionTags() {
    const noSelectionEl = document.getElementById('lmNoSelection');
    const selectionTagsEl = document.getElementById('lmSelectionTags');
    const listEl = document.getElementById('lmSelectionTagsList');
    
    const summary = getSelectionSummary();
    
    if (summary.total === 0) {
      if (noSelectionEl) noSelectionEl.style.display = 'block';
      if (selectionTagsEl) selectionTagsEl.style.display = 'none';
      return;
    }
    
    if (noSelectionEl) noSelectionEl.style.display = 'none';
    if (selectionTagsEl) selectionTagsEl.style.display = 'block';
    
    if (!listEl) return;
    
    const { tagCounts, totalCount } = getSelectionTagsWithCounts();
    const allTags = getAllProjectTags();
    
    // Merge all project tags with selection counts
    const mergedTags = new Map();
    allTags.forEach((counts, tag) => {
      mergedTags.set(tag, {
        inProject: true,
        inSelection: tagCounts.get(tag) || 0,
        total: totalCount
      });
    });
    
    // Sort: tags in selection first, then alphabetically
    const sortedTags = Array.from(mergedTags.entries())
      .sort((a, b) => {
        if (a[1].inSelection > 0 && b[1].inSelection === 0) return -1;
        if (a[1].inSelection === 0 && b[1].inSelection > 0) return 1;
        return a[0].localeCompare(b[0]);
      });
    
    let html = '';
    sortedTags.forEach(([tag, info]) => {
      const allHave = info.inSelection === info.total;
      const someHave = info.inSelection > 0 && info.inSelection < info.total;
      const noneHave = info.inSelection === 0;
      
      const checkState = allHave ? 'checked' : (someHave ? 'indeterminate' : '');
      const label = allHave ? '(all)' : (someHave ? `(${info.inSelection}/${info.total})` : '');
      
      html += `
        <div class="lm-tag-item" data-tag="${escapeHtml(tag)}">
          <input type="checkbox" class="lm-tag-checkbox" ${checkState} data-partial="${someHave}" />
          <span class="lm-tag-name">${escapeHtml(tag)}</span>
          <span style="font-size:10px; color:#9ca3af; margin-left:auto;">${label}</span>
        </div>
      `;
    });
    
    listEl.innerHTML = html || '<div style="padding:12px; text-align:center; color:#9ca3af; font-size:11px;">No tags in project</div>';
    
    // Set indeterminate state and add click handlers
    listEl.querySelectorAll('.lm-tag-item').forEach(item => {
      const checkbox = item.querySelector('.lm-tag-checkbox');
      if (checkbox.dataset.partial === 'true') {
        checkbox.indeterminate = true;
      }
      
      item.addEventListener('click', (e) => {
        if (e.target === checkbox) return; // Let checkbox handle its own click
        checkbox.checked = !checkbox.checked;
        checkbox.indeterminate = false;
      });
    });
  }
  
  // Apply checked tags to selection
  function applyCheckedTagsToSelection() {
    const listEl = document.getElementById('lmSelectionTagsList');
    if (!listEl) return;
    
    const { nodes, edges, groups } = getSelectedElements();
    if (nodes.size + edges.size + groups.size === 0) {
      showToast('Nothing selected');
      return;
    }
    
    const checkedTags = new Set();
    listEl.querySelectorAll('.lm-tag-checkbox:checked').forEach(cb => {
      const item = cb.closest('.lm-tag-item');
      if (item) checkedTags.add(item.dataset.tag);
    });
    
    let changed = 0;
    
    // Add checked tags to all selected elements
    nodes.forEach(id => {
      const current = getElementTags('node', id);
      checkedTags.forEach(tag => current.add(tag));
      setElementTags('node', id, current);
      changed++;
    });
    
    edges.forEach(id => {
      const current = getElementTags('edge', id);
      checkedTags.forEach(tag => current.add(tag));
      setElementTags('edge', id, current);
      changed++;
    });
    
    groups.forEach(id => {
      const current = getElementTags('group', id);
      checkedTags.forEach(tag => current.add(tag));
      setElementTags('group', id, current);
      changed++;
    });
    
    commit();
    render();
    refreshLabelManager();
    showToast(`‚úÖ Applied ${checkedTags.size} tag(s) to ${changed} element(s)`);
  }
  
  // Remove unchecked tags from selection
  function removeUncheckedTagsFromSelection() {
    const listEl = document.getElementById('lmSelectionTagsList');
    if (!listEl) return;
    
    const { nodes, edges, groups } = getSelectedElements();
    if (nodes.size + edges.size + groups.size === 0) {
      showToast('Nothing selected');
      return;
    }
    
    const uncheckedTags = new Set();
    listEl.querySelectorAll('.lm-tag-checkbox:not(:checked)').forEach(cb => {
      const item = cb.closest('.lm-tag-item');
      if (item) uncheckedTags.add(item.dataset.tag);
    });
    
    let changed = 0;
    
    // Remove unchecked tags from all selected elements
    nodes.forEach(id => {
      const current = getElementTags('node', id);
      uncheckedTags.forEach(tag => current.delete(tag));
      setElementTags('node', id, current);
      changed++;
    });
    
    edges.forEach(id => {
      const current = getElementTags('edge', id);
      uncheckedTags.forEach(tag => current.delete(tag));
      setElementTags('edge', id, current);
      changed++;
    });
    
    groups.forEach(id => {
      const current = getElementTags('group', id);
      uncheckedTags.forEach(tag => current.delete(tag));
      setElementTags('group', id, current);
      changed++;
    });
    
    commit();
    render();
    refreshLabelManager();
    showToast(`‚úó Removed ${uncheckedTags.size} tag(s) from ${changed} element(s)`);
  }
  
  // Render bulk apply section
  function renderBulkApplySection() {
    // Render selected tags for bulk operation
    const selectedContainer = document.getElementById('lmBulkTagsSelected');
    const availableContainer = document.getElementById('lmBulkAvailableTags');
    
    if (selectedContainer) {
      if (labelManagerState.bulkTags.size === 0) {
        selectedContainer.innerHTML = '<span style="color:#9ca3af; font-size:11px;">Click tags below to add</span>';
      } else {
        let html = '';
        labelManagerState.bulkTags.forEach(tag => {
          html += `<span class="lm-tag-pill" data-tag="${escapeHtml(tag)}">${escapeHtml(tag)} <span class="remove" onclick="removeBulkTag('${escapeHtml(tag)}')">√ó</span></span>`;
        });
        selectedContainer.innerHTML = html;
      }
    }
    
    if (availableContainer) {
      const allTags = getAllProjectTags();
      let html = '';
      const sortedTags = Array.from(allTags.keys()).sort();
      sortedTags.forEach(tag => {
        if (!labelManagerState.bulkTags.has(tag)) {
          html += `<span class="lm-tag-pill" style="background:#f3f4f6; color:#374151; cursor:pointer;" onclick="addBulkTag('${escapeHtml(tag)}')">${escapeHtml(tag)} +</span>`;
        }
      });
      availableContainer.innerHTML = html || '<span style="color:#9ca3af; font-size:11px;">All tags selected above</span>';
    }
    
    // Update pick list visibility
    const pickList = document.getElementById('lmBulkPickList');
    const pickTarget = document.querySelector('input[name="lmBulkTarget"]:checked')?.value;
    if (pickList) {
      pickList.style.display = pickTarget === 'pick' ? 'block' : 'none';
    }
    
    renderPickedItems();
  }
  
  // Add tag to bulk operation
  window.addBulkTag = function(tag) {
    labelManagerState.bulkTags.add(tag);
    renderBulkApplySection();
  };
  
  // Remove tag from bulk operation
  window.removeBulkTag = function(tag) {
    labelManagerState.bulkTags.delete(tag);
    renderBulkApplySection();
  };
  
  // Render picked items list
  function renderPickedItems() {
    const container = document.getElementById('lmBulkPickedItems');
    if (!container) return;
    
    const { nodes, links, containers } = labelManagerState.pickedElements;
    
    if (nodes.size + links.size + containers.size === 0) {
      container.innerHTML = '<span style="color:#9ca3af; font-size:11px;">No elements picked yet</span>';
      return;
    }
    
    let html = '';
    nodes.forEach(id => {
      const n = findNode(id);
      if (n) html += `<span class="lm-tag-pill" style="background:#dbeafe;">${n.name || n.code || 'Node ' + id} <span class="remove" onclick="removePickedElement('node', ${id})">√ó</span></span>`;
    });
    links.forEach(id => {
      const e = state.edges.find(e => e.id === id);
      if (e) {
        const nodeA = findNode(e.a);
        const nodeB = findNode(e.b);
        html += `<span class="lm-tag-pill" style="background:#fef3c7;">${nodeA?.code || 'N' + e.a}‚Üî${nodeB?.code || 'N' + e.b} <span class="remove" onclick="removePickedElement('link', ${id})">√ó</span></span>`;
      }
    });
    containers.forEach(id => {
      const g = findGroup(id);
      if (g) html += `<span class="lm-tag-pill" style="background:#d1fae5;">${g.title || 'Container ' + id} <span class="remove" onclick="removePickedElement('container', ${id})">√ó</span></span>`;
    });
    
    container.innerHTML = html;
  }
  
  // Remove picked element
  window.removePickedElement = function(type, id) {
    if (type === 'node') labelManagerState.pickedElements.nodes.delete(id);
    if (type === 'link') labelManagerState.pickedElements.links.delete(id);
    if (type === 'container') labelManagerState.pickedElements.containers.delete(id);
    renderPickedItems();
  };
  
  // Apply bulk tag operation
  function applyBulkOperation() {
    const action = document.querySelector('input[name="lmBulkAction"]:checked')?.value || 'add';
    const targetMode = document.querySelector('input[name="lmBulkTarget"]:checked')?.value || 'selection';
    
    const tags = labelManagerState.bulkTags;
    if (tags.size === 0) {
      showToast('No tags selected for bulk operation');
      return;
    }
    
    let targetNodes, targetEdges, targetGroups;
    
    if (targetMode === 'selection') {
      const selected = getSelectedElements();
      targetNodes = selected.nodes;
      targetEdges = selected.edges;
      targetGroups = selected.groups;
    } else {
      targetNodes = labelManagerState.pickedElements.nodes;
      targetEdges = labelManagerState.pickedElements.links;
      targetGroups = labelManagerState.pickedElements.containers;
    }
    
    const totalTargets = targetNodes.size + targetEdges.size + targetGroups.size;
    if (totalTargets === 0) {
      showToast('No target elements selected');
      return;
    }
    
    let changed = 0;
    
    // Apply to nodes
    targetNodes.forEach(id => {
      const current = getElementTags('node', id);
      if (action === 'add') {
        tags.forEach(tag => current.add(tag));
      } else if (action === 'remove') {
        tags.forEach(tag => current.delete(tag));
      } else if (action === 'set') {
        current.clear();
        tags.forEach(tag => current.add(tag));
      }
      setElementTags('node', id, current);
      changed++;
    });
    
    // Apply to edges
    targetEdges.forEach(id => {
      const current = getElementTags('edge', id);
      if (action === 'add') {
        tags.forEach(tag => current.add(tag));
      } else if (action === 'remove') {
        tags.forEach(tag => current.delete(tag));
      } else if (action === 'set') {
        current.clear();
        tags.forEach(tag => current.add(tag));
      }
      setElementTags('edge', id, current);
      changed++;
    });
    
    // Apply to groups
    targetGroups.forEach(id => {
      const current = getElementTags('group', id);
      if (action === 'add') {
        tags.forEach(tag => current.add(tag));
      } else if (action === 'remove') {
        tags.forEach(tag => current.delete(tag));
      } else if (action === 'set') {
        current.clear();
        tags.forEach(tag => current.add(tag));
      }
      setElementTags('group', id, current);
      changed++;
    });
    
    commit();
    render();
    refreshLabelManager();
    
    const actionLabel = action === 'add' ? 'Added' : (action === 'remove' ? 'Removed' : 'Set');
    showToast(`‚ö° ${actionLabel} ${tags.size} tag(s) on ${changed} element(s)`);
  }
  
  // Rename tag globally
  function renameTagGlobally() {
    const fromSelect = document.getElementById('lmRenameFrom');
    const toInput = document.getElementById('lmRenameTo');
    
    const fromTag = fromSelect?.value;
    const toTag = toInput?.value?.trim();
    
    if (!fromTag) {
      showToast('Select a tag to rename');
      return;
    }
    if (!toTag) {
      showToast('Enter a new name');
      return;
    }
    if (fromTag === toTag) {
      showToast('New name is same as old name');
      return;
    }
    
    let changed = 0;
    
    // Rename in nodes
    state.nodes.forEach(n => {
      const tags = getElementTags('node', n.id);
      if (tags.has(fromTag)) {
        tags.delete(fromTag);
        tags.add(toTag);
        setElementTags('node', n.id, tags);
        changed++;
      }
    });
    
    // Rename in edges
    state.edges.forEach(e => {
      const tags = getElementTags('edge', e.id);
      if (tags.has(fromTag)) {
        tags.delete(fromTag);
        tags.add(toTag);
        setElementTags('edge', e.id, tags);
        changed++;
      }
    });
    
    // Rename in groups
    state.groups.forEach(g => {
      const tags = getElementTags('group', g.id);
      if (tags.has(fromTag)) {
        tags.delete(fromTag);
        tags.add(toTag);
        setElementTags('group', g.id, tags);
        changed++;
      }
    });
    
    commit();
    render();
    refreshLabelManager();
    
    if (toInput) toInput.value = '';
    showToast(`‚úèÔ∏è Renamed "${fromTag}" to "${toTag}" in ${changed} element(s)`);
  }
  
  // Update rename dropdown
  function updateRenameDropdown() {
    const select = document.getElementById('lmRenameFrom');
    if (!select) return;
    
    const allTags = getAllProjectTags();
    const sortedTags = Array.from(allTags.keys()).sort();
    
    select.innerHTML = '<option value="">-- Select tag to rename --</option>';
    sortedTags.forEach(tag => {
      const opt = document.createElement('option');
      opt.value = tag;
      opt.textContent = tag;
      select.appendChild(opt);
    });
  }
  
  // Create new tag
  function createNewTag() {
    const tagName = prompt('Enter new tag name:');
    if (!tagName || !tagName.trim()) return;
    
    const tag = tagName.trim();
    
    // Add to bulk tags for easy application
    labelManagerState.bulkTags.add(tag);
    renderBulkApplySection();
    showToast(`Created tag "${tag}" - apply it using Bulk Apply section`);
  }
  
  // Delete unused tags (tags not on any element)
  function deleteUnusedTags() {
    const allTags = getAllProjectTags();
    const unusedTags = [];
    
    allTags.forEach((counts, tag) => {
      if (counts.nodes + counts.links + counts.containers === 0) {
        unusedTags.push(tag);
      }
    });
    
    if (unusedTags.length === 0) {
      showToast('No unused tags found');
      return;
    }
    
    // Remove from bulk tags
    unusedTags.forEach(tag => labelManagerState.bulkTags.delete(tag));
    
    refreshLabelManager();
    showToast(`üóëÔ∏è Removed ${unusedTags.length} unused tag(s)`);
  }
  
  // Show tag context menu
  window.showLMTagMenu = function(tag, event) {
    event.stopPropagation();
    
    // Remove existing menu
    document.querySelectorAll('.lm-context-menu').forEach(m => m.remove());
    
    const menu = document.createElement('div');
    menu.className = 'lm-context-menu';
    menu.style.cssText = `
      position: fixed;
      left: ${event.clientX}px;
      top: ${event.clientY}px;
      background: white;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      padding: 4px 0;
      z-index: 1000;
      min-width: 160px;
    `;
    
    menu.innerHTML = `
      <div class="lm-menu-item" onclick="selectAllWithTag('${escapeHtml(tag)}')" style="padding:8px 12px; cursor:pointer; font-size:12px;">üéØ Select all with "${escapeHtml(tag)}"</div>
      <div class="lm-menu-item" onclick="addBulkTag('${escapeHtml(tag)}')" style="padding:8px 12px; cursor:pointer; font-size:12px;">‚ö° Add to bulk operation</div>
      <div style="border-top:1px solid #e5e7eb; margin:4px 0;"></div>
      <div class="lm-menu-item" onclick="renameTagPrompt('${escapeHtml(tag)}')" style="padding:8px 12px; cursor:pointer; font-size:12px;">‚úèÔ∏è Rename...</div>
      <div class="lm-menu-item" onclick="deleteTagGlobally('${escapeHtml(tag)}')" style="padding:8px 12px; cursor:pointer; font-size:12px; color:#dc2626;">üóëÔ∏è Delete from all elements</div>
    `;
    
    // Add hover styles
    menu.querySelectorAll('.lm-menu-item').forEach(item => {
      item.addEventListener('mouseenter', () => item.style.background = '#f3f4f6');
      item.addEventListener('mouseleave', () => item.style.background = '');
    });
    
    document.body.appendChild(menu);
    
    // Close on click outside
    setTimeout(() => {
      document.addEventListener('click', function closeMenu() {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }, { once: true });
    }, 0);
  };
  
  // Select all elements with a specific tag
  window.selectAllWithTag = function(tag) {
    state.selection.nodes.clear();
    state.selection.edges.clear();
    state.selection.groups.clear();
    state.selected = null;
    
    let count = 0;
    
    state.nodes.forEach(n => {
      if (getElementTags('node', n.id).has(tag)) {
        state.selection.nodes.add(n.id);
        count++;
      }
    });
    
    state.edges.forEach(e => {
      if (getElementTags('edge', e.id).has(tag)) {
        state.selection.edges.add(e.id);
        count++;
      }
    });
    
    state.groups.forEach(g => {
      if (getElementTags('group', g.id).has(tag)) {
        state.selection.groups.add(g.id);
        count++;
      }
    });
    
    render();
    refreshLabelManager();
    showToast(`üéØ Selected ${count} element(s) with tag "${tag}"`);
  };
  
  // Rename tag with prompt
  window.renameTagPrompt = function(tag) {
    const newName = prompt(`Rename tag "${tag}" to:`, tag);
    if (!newName || !newName.trim() || newName.trim() === tag) return;
    
    document.getElementById('lmRenameFrom').value = tag;
    document.getElementById('lmRenameTo').value = newName.trim();
    renameTagGlobally();
  };
  
  // Delete tag globally
  window.deleteTagGlobally = function(tag) {
    if (!confirm(`Delete tag "${tag}" from all elements?`)) return;
    
    let changed = 0;
    
    state.nodes.forEach(n => {
      const tags = getElementTags('node', n.id);
      if (tags.has(tag)) {
        tags.delete(tag);
        setElementTags('node', n.id, tags);
        changed++;
      }
    });
    
    state.edges.forEach(e => {
      const tags = getElementTags('edge', e.id);
      if (tags.has(tag)) {
        tags.delete(tag);
        setElementTags('edge', e.id, tags);
        changed++;
      }
    });
    
    state.groups.forEach(g => {
      const tags = getElementTags('group', g.id);
      if (tags.has(tag)) {
        tags.delete(tag);
        setElementTags('group', g.id, tags);
        changed++;
      }
    });
    
    commit();
    render();
    refreshLabelManager();
    showToast(`üóëÔ∏è Deleted tag "${tag}" from ${changed} element(s)`);
  };
  
  // Handle Label Manager pick mode for canvas clicks
  function handleLabelManagerCanvasClick(type, id) {
    if (!labelManagerState.pickMode) return false;
    
    if (type === 'node') {
      if (labelManagerState.pickedElements.nodes.has(id)) {
        labelManagerState.pickedElements.nodes.delete(id);
      } else {
        labelManagerState.pickedElements.nodes.add(id);
      }
    } else if (type === 'edge') {
      if (labelManagerState.pickedElements.links.has(id)) {
        labelManagerState.pickedElements.links.delete(id);
      } else {
        labelManagerState.pickedElements.links.add(id);
      }
    } else if (type === 'group') {
      if (labelManagerState.pickedElements.containers.has(id)) {
        labelManagerState.pickedElements.containers.delete(id);
      } else {
        labelManagerState.pickedElements.containers.add(id);
      }
    }
    
    renderPickedItems();
    const total = labelManagerState.pickedElements.nodes.size + labelManagerState.pickedElements.links.size + labelManagerState.pickedElements.containers.size;
    showToast(`üéØ Picked ${total} element(s)`);
    
    return true;
  }
  
  // Expose for external use
  window.handleLabelManagerCanvasClick = handleLabelManagerCanvasClick;
  window.labelManagerState = labelManagerState;
  
  // Event listeners
  if (btnLabelManager) {
    btnLabelManager.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleLabelManager();
    });
  }
  
  if (btnCloseLabelManager) {
    btnCloseLabelManager.addEventListener('click', closeLabelManager);
  }
  
  // Tag search
  const lmTagSearch = document.getElementById('lmTagSearch');
  if (lmTagSearch) {
    lmTagSearch.addEventListener('input', () => renderProjectTagsList());
  }
  
  // Filter buttons
  ['lmFilterAll', 'lmFilterNodes', 'lmFilterLinks', 'lmFilterContainers'].forEach(id => {
    const btn = document.getElementById(id);
    if (btn) {
      btn.addEventListener('click', () => {
        labelManagerState.filterType = id.replace('lmFilter', '').toLowerCase();
        // Update button styles
        document.querySelectorAll('#lmFilterAll, #lmFilterNodes, #lmFilterLinks, #lmFilterContainers').forEach(b => {
          b.style.background = '';
          b.style.color = '';
        });
        btn.style.background = '#8b5cf6';
        btn.style.color = 'white';
        renderProjectTagsList();
      });
    }
  });
  
  // Select all with checked tags
  const lmSelectAllWithTag = document.getElementById('lmSelectAllWithTag');
  if (lmSelectAllWithTag) {
    lmSelectAllWithTag.addEventListener('click', selectAllWithCheckedTags);
  }
  
  // New tag button
  const lmNewTag = document.getElementById('lmNewTag');
  if (lmNewTag) {
    lmNewTag.addEventListener('click', createNewTag);
  }
  
  // Delete unused tags
  const lmDeleteUnused = document.getElementById('lmDeleteUnused');
  if (lmDeleteUnused) {
    lmDeleteUnused.addEventListener('click', deleteUnusedTags);
  }
  
  // Apply/remove buttons for selection tags
  const lmApplyChecked = document.getElementById('lmApplyChecked');
  if (lmApplyChecked) {
    lmApplyChecked.addEventListener('click', applyCheckedTagsToSelection);
  }
  
  const lmRemoveUnchecked = document.getElementById('lmRemoveUnchecked');
  if (lmRemoveUnchecked) {
    lmRemoveUnchecked.addEventListener('click', removeUncheckedTagsFromSelection);
  }
  
  // Bulk apply new tag input
  const lmBulkAddNewTag = document.getElementById('lmBulkAddNewTag');
  const lmBulkNewTag = document.getElementById('lmBulkNewTag');
  if (lmBulkAddNewTag && lmBulkNewTag) {
    lmBulkAddNewTag.addEventListener('click', () => {
      const tag = lmBulkNewTag.value.trim();
      if (tag) {
        labelManagerState.bulkTags.add(tag);
        lmBulkNewTag.value = '';
        renderBulkApplySection();
      }
    });
    lmBulkNewTag.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const tag = lmBulkNewTag.value.trim();
        if (tag) {
          labelManagerState.bulkTags.add(tag);
          lmBulkNewTag.value = '';
          renderBulkApplySection();
        }
      }
    });
  }
  
  // Bulk target radio buttons
  document.querySelectorAll('input[name="lmBulkTarget"]').forEach(radio => {
    radio.addEventListener('change', renderBulkApplySection);
  });
  
  // Pick mode button
  const lmBulkPickMode = document.getElementById('lmBulkPickMode');
  if (lmBulkPickMode) {
    lmBulkPickMode.addEventListener('click', () => {
      labelManagerState.pickMode = !labelManagerState.pickMode;
      lmBulkPickMode.textContent = labelManagerState.pickMode ? 'üéØ Stop Pick' : 'üéØ Start Pick';
      lmBulkPickMode.style.background = labelManagerState.pickMode ? '#8b5cf6' : '';
      lmBulkPickMode.style.color = labelManagerState.pickMode ? 'white' : '';
      if (labelManagerState.pickMode) {
        showToast('üéØ Click on nodes, links, or containers to pick them');
      }
    });
  }
  
  // Clear picked button
  const lmBulkClearPicked = document.getElementById('lmBulkClearPicked');
  if (lmBulkClearPicked) {
    lmBulkClearPicked.addEventListener('click', () => {
      labelManagerState.pickedElements.nodes.clear();
      labelManagerState.pickedElements.links.clear();
      labelManagerState.pickedElements.containers.clear();
      renderPickedItems();
    });
  }
  
  // Bulk apply button
  const lmBulkApply = document.getElementById('lmBulkApply');
  if (lmBulkApply) {
    lmBulkApply.addEventListener('click', applyBulkOperation);
  }
  
  // Rename apply button
  const lmRenameApply = document.getElementById('lmRenameApply');
  if (lmRenameApply) {
    lmRenameApply.addEventListener('click', renameTagGlobally);
  }
  
  // Make Label Manager panel draggable
  if (labelManagerHeader && labelManagerPanel) {
    labelManagerHeader.style.cursor = 'move';
    let lmPanelDragging = false;
    let lmPanelDragOffset = { x: 0, y: 0 };
    
    labelManagerHeader.addEventListener('mousedown', (ev) => {
      if (ev.target.tagName === 'BUTTON' || ev.target.closest('button')) return;
      
      lmPanelDragging = true;
      const rect = labelManagerPanel.getBoundingClientRect();
      lmPanelDragOffset.x = ev.clientX - rect.left;
      lmPanelDragOffset.y = ev.clientY - rect.top;
      labelManagerPanel.style.cursor = 'grabbing';
      ev.preventDefault();
    });
    
    window.addEventListener('mousemove', (ev) => {
      if (!lmPanelDragging) return;
      
      const layout = document.getElementById('layout');
      const layoutRect = layout.getBoundingClientRect();
      
      let newLeft = ev.clientX - layoutRect.left - lmPanelDragOffset.x;
      let newTop = ev.clientY - layoutRect.top - lmPanelDragOffset.y;
      
      newLeft = Math.max(0, Math.min(newLeft, layoutRect.width - labelManagerPanel.offsetWidth));
      newTop = Math.max(0, Math.min(newTop, layoutRect.height - 50));
      
      labelManagerPanel.style.left = newLeft + 'px';
      labelManagerPanel.style.top = newTop + 'px';
      labelManagerPanel.style.right = 'auto';
    });
    
    window.addEventListener('mouseup', () => {
      if (lmPanelDragging) {
        lmPanelDragging = false;
        labelManagerPanel.style.cursor = '';
      }
    });
  }
  
  // Listen for selection changes to update Label Manager
  const originalRender = window.render || render;
  const renderWithLabelManager = function() {
    originalRender();
    if (labelManagerState.visible) {
      updateSelectionStatus();
      renderSelectionTags();
    }
  };
  // Override render in the window scope if available
  if (typeof window !== 'undefined') {
    window.refreshLabelManager = refreshLabelManager;
  }

  // ============== END LABEL MANAGER ==============

  // ============== GEOGRAPHIC VIEW & GPS COORDINATES ==============
  
  // World map SVG path (simplified continents outline)
  const worldMapPath = `
    M 52,28 L 58,26 L 64,28 L 68,32 L 72,30 L 78,32 L 82,36 L 78,42 L 82,48 L 78,54 L 72,58 L 66,54 L 60,58 L 54,54 L 48,58 L 42,54 L 38,58 L 32,54 L 28,50 L 32,44 L 28,38 L 34,32 L 40,28 L 46,32 Z
    M 18,42 L 24,38 L 30,40 L 34,46 L 30,52 L 26,56 L 22,60 L 18,64 L 14,68 L 10,72 L 6,68 L 8,62 L 6,56 L 10,50 L 14,46 Z
    M 24,72 L 30,68 L 36,70 L 40,76 L 38,82 L 34,88 L 30,92 L 26,88 L 22,82 L 20,76 Z
    M 56,42 L 62,40 L 68,42 L 74,46 L 78,52 L 74,58 L 68,62 L 62,66 L 56,70 L 50,74 L 44,70 L 40,64 L 44,58 L 50,54 L 48,48 Z
    M 80,34 L 86,32 L 92,34 L 96,38 L 92,44 L 88,48 L 84,44 L 80,40 Z
    M 78,62 L 84,58 L 90,60 L 94,66 L 90,72 L 84,76 L 78,72 L 74,66 Z
  `;
  
  // Geographic view state
  const geoViewState = {
    active: false,
    // Map bounds: The Wikimedia BlankMap-World-Equirectangular.svg covers exactly -180 to 180 longitude
    // and approximately -85.05 to 85.05 latitude (Web Mercator limits, though it's Equirectangular)
    // Using -90/90 causes a slight vertical stretch - the actual SVG viewBox is 2754x1398 (roughly 2:1)
    mapBounds: { minLat: -85.05, maxLat: 85.05, minLon: -180, maxLon: 180 },
    canvasWidth: 1800,
    canvasHeight: 918, // Maintain aspect ratio: 1800 * (170.1/360) ‚âà 850, but we add padding
    padding: 0, // No padding - draw map full bleed for accurate GPS alignment
    // Projection adjustment factors - calibrated for Wikimedia BlankMap-World-Equirectangular.svg
    // Scale: 1.0 = normal, <1 = shrink coordinates (nodes closer to center), >1 = expand
    // Offset: shifts all nodes by this many pixels
    projectionAdjust: {
      scaleX: 0.895,   // Horizontal scale factor (affects longitude mapping)
      scaleY: 0.815,   // Vertical scale factor (affects latitude mapping)
      offsetX: -61,    // Horizontal offset in pixels (positive = shift right)
      offsetY: -10     // Vertical offset in pixels (positive = shift down)
    },
    // Custom map image support
    customMapImage: null, // Base64 data URL or external URL
    customMapBounds: null, // { minLat, maxLat, minLon, maxLon } for custom image
    useCustomMap: true, // Default to using the map image
    mapSource: 'url', // 'url', 'upload', or 'builtin'
    // Default map URL (Wikimedia Equirectangular - public domain)
    defaultMapUrl: 'https://upload.wikimedia.org/wikipedia/commons/9/9f/BlankMap-World-Equirectangular.svg',
    mapUrl: 'https://upload.wikimedia.org/wikipedia/commons/9/9f/BlankMap-World-Equirectangular.svg'
  };
  
  // Load custom map settings from localStorage if available
  try {
    const savedMap = localStorage.getItem('neximap-geo-custom-map');
    if (savedMap) {
      const mapData = JSON.parse(savedMap);
      if (mapData.mapSource === 'upload' && mapData.image) {
        geoViewState.customMapImage = mapData.image;
        geoViewState.customMapBounds = mapData.bounds;
        geoViewState.mapSource = 'upload';
      } else if (mapData.mapSource === 'url' && mapData.mapUrl) {
        geoViewState.mapUrl = mapData.mapUrl;
        geoViewState.customMapBounds = mapData.bounds;
        geoViewState.mapSource = 'url';
      } else if (mapData.mapSource === 'builtin') {
        geoViewState.mapSource = 'builtin';
      }
      geoViewState.useCustomMap = mapData.useCustomMap !== false;
    }
  } catch (e) {
    console.log('No saved custom map found, using default');
  }
  
  // GPS format preference (stored per-session)
  let gpsDisplayFormat = 'DD'; // 'DD' or 'DMS'
  
  // Convert Decimal Degrees to DMS
  function ddToDms(dd, isLat) {
    const abs = Math.abs(dd);
    const deg = Math.floor(abs);
    const minFloat = (abs - deg) * 60;
    const min = Math.floor(minFloat);
    const sec = ((minFloat - min) * 60).toFixed(2);
    const dir = isLat ? (dd >= 0 ? 'N' : 'S') : (dd >= 0 ? 'E' : 'W');
    return { deg, min, sec: parseFloat(sec), dir };
  }
  
  // Convert DMS to Decimal Degrees
  function dmsToDd(deg, min, sec, dir) {
    let dd = Math.abs(parseFloat(deg) || 0) + 
             (parseFloat(min) || 0) / 60 + 
             (parseFloat(sec) || 0) / 3600;
    if (dir === 'S' || dir === 'W') dd = -dd;
    return dd;
  }
  
  // Validate and parse decimal degree input
  function parseDecimalDegree(str, isLat) {
    if (!str || str.trim() === '') return null;
    const val = parseFloat(str);
    if (isNaN(val)) return null;
    if (isLat && (val < -90 || val > 90)) return null;
    if (!isLat && (val < -180 || val > 180)) return null;
    return val;
  }
  
  // Format decimal degrees for display
  function formatDD(val, decimals = 6) {
    if (val === null || val === undefined || isNaN(val)) return '';
    return val.toFixed(decimals);
  }
  
  // Update GPS fields in inspector from node data
  function updateGpsFields(node) {
    const formatSelect = document.getElementById('nodeGpsFormat');
    const ddContainer = document.getElementById('gpsFormatDD');
    const dmsContainer = document.getElementById('gpsFormatDMS');
    
    // DD fields
    const latDD = document.getElementById('nodeLatDD');
    const lonDD = document.getElementById('nodeLonDD');
    
    // DMS fields
    const latDeg = document.getElementById('nodeLatDeg');
    const latMin = document.getElementById('nodeLatMin');
    const latSec = document.getElementById('nodeLatSec');
    const latDir = document.getElementById('nodeLatDir');
    const lonDeg = document.getElementById('nodeLonDeg');
    const lonMin = document.getElementById('nodeLonMin');
    const lonSec = document.getElementById('nodeLonSec');
    const lonDir = document.getElementById('nodeLonDir');
    
    if (!formatSelect) return;
    
    // Show/hide format containers
    const format = formatSelect.value || 'DD';
    if (ddContainer) ddContainer.style.display = format === 'DD' ? 'flex' : 'none';
    if (dmsContainer) dmsContainer.style.display = format === 'DMS' ? 'block' : 'none';
    
    // Get node GPS values (stored as decimal degrees internally)
    const lat = node?.gpsLat;
    const lon = node?.gpsLon;
    
    if (format === 'DD') {
      if (latDD) latDD.value = lat !== null && lat !== undefined ? formatDD(lat) : '';
      if (lonDD) lonDD.value = lon !== null && lon !== undefined ? formatDD(lon) : '';
    } else {
      // DMS format
      if (lat !== null && lat !== undefined) {
        const dmsLat = ddToDms(lat, true);
        if (latDeg) latDeg.value = dmsLat.deg;
        if (latMin) latMin.value = dmsLat.min;
        if (latSec) latSec.value = dmsLat.sec;
        if (latDir) latDir.value = dmsLat.dir;
      } else {
        if (latDeg) latDeg.value = '';
        if (latMin) latMin.value = '';
        if (latSec) latSec.value = '';
        if (latDir) latDir.value = 'N';
      }
      
      if (lon !== null && lon !== undefined) {
        const dmsLon = ddToDms(lon, false);
        if (lonDeg) lonDeg.value = dmsLon.deg;
        if (lonMin) lonMin.value = dmsLon.min;
        if (lonSec) lonSec.value = dmsLon.sec;
        if (lonDir) lonDir.value = dmsLon.dir;
      } else {
        if (lonDeg) lonDeg.value = '';
        if (lonMin) lonMin.value = '';
        if (lonSec) lonSec.value = '';
        if (lonDir) lonDir.value = 'E';
      }
    }
  }
  
  // Save GPS from DD fields
  function saveGpsFromDD() {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id);
    if (!n) return;
    
    const latDD = document.getElementById('nodeLatDD');
    const lonDD = document.getElementById('nodeLonDD');
    
    const lat = parseDecimalDegree(latDD?.value, true);
    const lon = parseDecimalDegree(lonDD?.value, false);
    
    n.gpsLat = lat;
    n.gpsLon = lon;
    
    commit();
    if (geoViewState.active) render();
  }
  
  // Save GPS from DMS fields
  function saveGpsFromDMS() {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id);
    if (!n) return;
    
    const latDeg = document.getElementById('nodeLatDeg');
    const latMin = document.getElementById('nodeLatMin');
    const latSec = document.getElementById('nodeLatSec');
    const latDir = document.getElementById('nodeLatDir');
    const lonDeg = document.getElementById('nodeLonDeg');
    const lonMin = document.getElementById('nodeLonMin');
    const lonSec = document.getElementById('nodeLonSec');
    const lonDir = document.getElementById('nodeLonDir');
    
    // Check if any lat fields have values
    if (latDeg?.value || latMin?.value || latSec?.value) {
      n.gpsLat = dmsToDd(latDeg?.value, latMin?.value, latSec?.value, latDir?.value || 'N');
    } else {
      n.gpsLat = null;
    }
    
    // Check if any lon fields have values
    if (lonDeg?.value || lonMin?.value || lonSec?.value) {
      n.gpsLon = dmsToDd(lonDeg?.value, lonMin?.value, lonSec?.value, lonDir?.value || 'E');
    } else {
      n.gpsLon = null;
    }
    
    commit();
    if (geoViewState.active) render();
  }
  
  // Convert GPS coordinates to canvas position (Equirectangular projection)
  // This maps GPS coordinates directly to canvas pixel positions
  // Applies adjustable scale and offset factors for fine-tuning alignment
  function gpsToCanvas(lat, lon, applyAdjustment = true) {
    // Use custom bounds if set, otherwise use default map bounds
    const bounds = geoViewState.customMapBounds || geoViewState.mapBounds;
    const { minLat, maxLat, minLon, maxLon } = bounds;
    
    const width = geoViewState.canvasWidth;
    const height = geoViewState.canvasHeight;
    
    // Calculate center point of the canvas
    const centerX = width / 2;
    const centerY = height / 2;
    
    // X: longitude range maps to [0, width]
    const lonRange = maxLon - minLon;
    let x = ((lon - minLon) / lonRange) * width;
    
    // Y: latitude range maps to [0, height], inverted (north at top)
    const latRange = maxLat - minLat;
    let y = ((maxLat - lat) / latRange) * height;
    
    // Apply projection adjustment if enabled (for node positioning, not map background)
    if (applyAdjustment && geoViewState.projectionAdjust) {
      const adj = geoViewState.projectionAdjust;
      
      // Scale from center point
      x = centerX + (x - centerX) * adj.scaleX;
      y = centerY + (y - centerY) * adj.scaleY;
      
      // Apply offset
      x += adj.offsetX;
      y += adj.offsetY;
    }
    
    return { x, y };
  }
  
  // Version without adjustment - used for drawing the map background and graticule
  function gpsToCanvasRaw(lat, lon) {
    return gpsToCanvas(lat, lon, false);
  }
  
  // Accurate world map coordinate data (simplified but geographically correct)
  // Each array is [lat, lon] pairs forming polygon outlines
  const worldMapData = {
    // North America (mainland)
    northAmerica: [
      [83, -70], [83, -80], [76, -90], [72, -96], [71, -104], [70, -128], [71, -156], [66, -168], [64, -167], [62, -164],
      [60, -162], [59, -157], [58, -153], [57, -155], [56, -158], [55, -160], [54, -164], [52, -169], [52, -175], [54, -178],
      [57, 179], [59, 178], [62, 175], [65, 174], [67, 171], [68, 167], [69, 164], [70, 158], [72, 156], [70, -168],
      [68, -164], [66, -162], [65, -168], [61, -166], [60, -147], [60, -141], [57, -136], [55, -132], [54, -130], [50, -127],
      [48, -123], [46, -124], [43, -124], [42, -124], [39, -123], [35, -120], [33, -117], [32, -117], [31, -114], [29, -112],
      [26, -110], [24, -108], [22, -105], [20, -105], [19, -104], [17, -100], [16, -96], [18, -91], [20, -87], [21, -87],
      [23, -88], [26, -90], [29, -89], [29, -85], [27, -82], [25, -80], [25, -79], [27, -77], [30, -81], [31, -81],
      [32, -79], [34, -77], [35, -75], [37, -76], [38, -75], [39, -74], [40, -74], [41, -72], [42, -70], [43, -70],
      [44, -68], [44, -66], [46, -64], [47, -61], [46, -59], [47, -56], [47, -53], [51, -56], [52, -56], [53, -59],
      [47, -63], [46, -67], [45, -73], [46, -78], [48, -85], [48, -88], [49, -95], [49, -101], [49, -110], [49, -123],
      [54, -130], [55, -130], [58, -136], [60, -140], [61, -150], [63, -165], [64, -167], [67, -164], [71, -156], [69, -140],
      [69, -130], [70, -117], [75, -95], [78, -80], [83, -70]
    ],
    
    // South America
    southAmerica: [
      [12, -72], [12, -68], [10, -64], [10, -61], [8, -60], [7, -56], [5, -52], [4, -51], [2, -50], [0, -50],
      [-3, -42], [-5, -35], [-8, -35], [-13, -39], [-18, -40], [-22, -41], [-23, -44], [-26, -48], [-30, -51],
      [-34, -54], [-38, -58], [-42, -63], [-46, -66], [-52, -68], [-55, -67], [-55, -68], [-54, -71], [-52, -74],
      [-48, -75], [-45, -74], [-41, -73], [-38, -73], [-35, -72], [-33, -71], [-30, -71], [-27, -71], [-24, -70],
      [-22, -70], [-20, -70], [-18, -70], [-15, -75], [-12, -77], [-8, -79], [-5, -81], [-2, -80], [0, -80],
      [2, -78], [5, -77], [8, -77], [10, -75], [12, -72]
    ],
    
    // Europe (mainland - excluding Iberia which is separate)
    europe: [
      // Scandinavia and Northern Europe
      [71, 28], [70, 32], [68, 28], [67, 24], [65, 22], [63, 20], [61, 18], [60, 16], [59, 14],
      [57, 10], [56, 8], [55, 9], [54, 8], [54, 10], [55, 12], [54, 14], [53, 14],
      // Germany, Netherlands, Belgium
      [54, 8], [53, 7], [52, 5], [51, 4], [51, 2],
      // France Atlantic coast
      [49, 0], [48, -2], [47, -3], [46, -2], [45, -1], [44, -1], [43.5, -2],
      // French-Spanish border (Pyrenees) - stop here, don't go into Spain
      [43, 0], [42.5, 1], [42.5, 3],
      // French Mediterranean & Riviera
      [43, 4], [43, 6], [43.5, 7],
      // Alps region
      [45, 7], [46, 8], [47, 10], [47, 13],
      // Balkans coastline
      [46, 14], [45, 14], [44, 15], [43, 16], [42, 17], [41, 19], [40, 20], [39, 20],
      [38, 22], [37, 23], [36, 23], [35, 25],
      // Turkey / Black Sea
      [37, 27], [39, 28], [41, 29], [42, 32], [43, 34], [42, 37], [41, 40],
      // Ukraine, Russia west
      [44, 40], [46, 38], [48, 35], [50, 32], [52, 28], [54, 24], [56, 22],
      // Baltic
      [58, 24], [60, 26], [62, 28], [64, 26], [66, 24], [68, 26], [70, 28], [71, 28]
    ],
    
    // Scandinavia (Norway, Sweden)
    scandinavia: [
      [71, 28], [70, 25], [69, 20], [67, 16], [65, 12], [63, 10], [61, 8], [59, 6],
      [58, 8], [57, 8], [56, 10], [55, 12], [56, 14], [57, 16], [58, 18],
      [60, 18], [62, 19], [64, 20], [66, 22], [68, 24], [70, 26], [71, 28]
    ],
    
    // British Isles (Great Britain)
    britain: [
      [58.5, -5], [58, -3], [57, -2], [56, -3], [55, -3], [54, -3], [53.5, -3],
      [53, -4], [52, -4], [51.5, -3], [51, -1], [51, 1], [51.5, 1], [52.5, 1],
      [53, 0], [54, -1], [55, -2], [56, -2], [57, -3], [58, -4], [58.5, -5]
    ],
    
    // Ireland
    ireland: [
      [55, -6], [54.5, -8], [54, -10], [53, -10], [52, -10], [51.5, -10], [51.5, -9],
      [52, -7], [53, -6], [54, -6], [55, -6]
    ],
    
    // Iberian Peninsula (Spain and Portugal) - accurate for Madrid at 40.4¬∞N, 3.7¬∞W
    iberia: [
      // Northern coast (Galicia to Basque)
      [43.8, -7.9], [43.5, -8], [43.3, -6], [43.5, -4], [43.4, -2], [43.3, -1.5],
      // Pyrenees to Mediterranean
      [42.7, -0.5], [42.5, 0.5], [42.5, 2], [42, 3.2], [41.5, 2.5], [41, 1.5],
      // East coast (Catalonia to Valencia to Murcia)
      [40.5, 0.8], [39.5, 0.2], [38.5, -0.2], [38, -0.5], [37.5, -1],
      // Southeast (Almer√≠a) to Gibraltar
      [37, -2], [36.8, -3], [36.5, -4.5], [36.1, -5.5], [36, -5.6],
      // Southwest coast (Cadiz, Huelva)
      [36.5, -6.3], [37, -7], [37.2, -7.5],
      // Portugal west coast
      [37.5, -8.8], [38.5, -9.2], [39, -9.4], [39.5, -9.3], [40, -8.9],
      [40.5, -8.8], [41, -8.8], [41.8, -8.8],
      // Northwest (back to Galicia)
      [42.2, -8.6], [42.8, -9.2], [43.2, -9], [43.8, -7.9]
    ],
    
    // Italy
    italy: [
      [46, 7], [45.5, 10], [45, 12], [44, 12.5], [43.5, 11], [42, 11.5], [41, 13.5], [40.5, 15],
      [40, 16], [39, 16.5], [38, 16], [37.5, 15], [38, 13], [39, 14], [40, 14.5], [41, 13],
      [42.5, 11], [43.5, 10], [44, 8], [45.5, 7], [46, 7]
    ],
    
    // Sardinia
    sardinia: [
      [41, 8.5], [40, 8], [39, 8.5], [39, 9.5], [40, 10], [41, 9.5], [41, 8.5]
    ],
    
    // Sicily
    sicily: [
      [38, 12.5], [37.5, 13], [37, 15], [37.5, 15.5], [38.5, 15], [38, 13], [38, 12.5]
    ],
    
    // Africa
    africa: [
      [37, -6], [36, -2], [35, 0], [33, 8], [32, 10], [31, 10], [30, 32], [27, 33], [22, 36], [15, 42],
      [12, 44], [11, 50], [5, 46], [2, 42], [-2, 41], [-5, 40], [-10, 40], [-15, 35], [-22, 35], [-26, 33],
      [-30, 31], [-33, 27], [-35, 22], [-34, 18], [-31, 17], [-29, 16], [-26, 15], [-22, 14], [-17, 12],
      [-14, 12], [-10, 9], [-6, 5], [-5, 0], [0, -2], [5, 1], [6, 2], [5, 5], [7, 10], [10, 8], [12, 5],
      [15, -5], [17, -12], [20, -17], [24, -17], [27, -15], [29, -13], [32, -9], [35, -8], [37, -6]
    ],
    
    // Madagascar
    madagascar: [
      [-12, 49], [-16, 50], [-20, 44], [-25, 47], [-26, 45], [-22, 43], [-18, 44], [-14, 48], [-12, 49]
    ],
    
    // Asia (mainland including Middle East)
    asia: [
      [77, 100], [76, 110], [73, 120], [71, 130], [69, 140], [68, 150], [66, 160], [65, 169], [63, 172],
      [60, 165], [58, 163], [56, 160], [54, 155], [52, 150], [50, 143], [47, 142], [45, 143], [43, 145],
      [43, 140], [40, 140], [38, 138], [36, 136], [35, 133], [32, 130], [30, 122], [27, 120], [22, 114],
      [20, 110], [18, 107], [15, 108], [11, 108], [8, 105], [6, 103], [5, 100], [8, 98], [10, 99], [14, 100],
      [18, 98], [20, 93], [22, 89], [24, 89], [26, 88], [26, 84], [23, 80], [20, 73], [22, 69], [25, 62],
      [27, 57], [26, 50], [23, 45], [20, 40], [18, 38], [15, 43], [13, 44], [12, 51], [16, 52], [20, 55],
      [25, 57], [28, 57], [30, 48], [32, 46], [35, 36], [37, 36], [39, 44], [41, 45], [42, 50], [44, 51],
      [46, 54], [48, 55], [50, 53], [52, 50], [54, 50], [56, 55], [58, 58], [60, 60], [62, 65], [64, 70],
      [66, 72], [68, 75], [70, 80], [72, 85], [74, 90], [76, 95], [77, 100]
    ],
    
    // Japan
    japan: [
      [45, 142], [43, 145], [42, 143], [40, 140], [38, 140], [36, 140], [35, 138], [34, 135], [33, 131],
      [32, 130], [33, 132], [34, 133], [35, 134], [36, 137], [38, 139], [40, 141], [42, 141], [43, 142], [45, 142]
    ],
    
    // Australia
    australia: [
      [-11, 143], [-14, 142], [-17, 141], [-20, 139], [-23, 134], [-26, 129], [-28, 124], [-30, 118],
      [-32, 115], [-34, 116], [-35, 118], [-35, 123], [-34, 129], [-33, 134], [-34, 138], [-36, 140],
      [-38, 145], [-39, 147], [-37, 150], [-34, 151], [-30, 153], [-26, 153], [-22, 150], [-18, 146],
      [-15, 145], [-12, 142], [-11, 143]
    ],
    
    // Tasmania
    tasmania: [
      [-40, 144], [-42, 145], [-44, 147], [-43, 148], [-41, 148], [-40, 146], [-40, 144]
    ],
    
    // New Zealand
    newZealandNorth: [
      [-35, 173], [-37, 175], [-39, 178], [-41, 175], [-39, 174], [-37, 175], [-35, 173]
    ],
    newZealandSouth: [
      [-41, 173], [-43, 171], [-46, 168], [-47, 167], [-46, 170], [-44, 172], [-42, 174], [-41, 173]
    ],
    
    // Indonesia (simplified main islands)
    sumatra: [
      [5, 95], [2, 99], [-1, 104], [-5, 105], [-6, 104], [-4, 101], [-1, 98], [2, 96], [5, 95]
    ],
    borneo: [
      [7, 117], [5, 119], [2, 118], [0, 117], [-2, 116], [-4, 115], [-3, 112], [-1, 110], [2, 110],
      [5, 115], [7, 117]
    ],
    java: [
      [-6, 105], [-7, 107], [-8, 112], [-8, 114], [-7, 114], [-6, 110], [-6, 105]
    ],
    
    // Philippines
    philippines: [
      [18, 121], [15, 120], [12, 124], [10, 126], [7, 126], [6, 122], [9, 118], [12, 119], [15, 120], [18, 121]
    ],
    
    // Greenland
    greenland: [
      [83, -35], [82, -20], [78, -18], [75, -20], [72, -22], [68, -26], [65, -38], [62, -43], [60, -45],
      [60, -48], [65, -53], [70, -55], [74, -58], [78, -65], [80, -68], [82, -50], [83, -35]
    ],
    
    // Iceland
    iceland: [
      [66, -18], [65, -14], [64, -14], [63, -18], [64, -22], [66, -24], [66, -18]
    ],
    
    // Sri Lanka
    sriLanka: [
      [10, 80], [8, 80], [6, 80], [6, 81], [8, 82], [10, 80]
    ],
    
    // Taiwan
    taiwan: [
      [25, 121], [23, 121], [22, 120], [23, 120], [25, 121]
    ]
  };
  
  // Draw world map background for geographic view
  function drawGeoBackground() {
    const bg = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    bg.setAttribute('class', 'geo-background');
    
    // Determine which map source to use
    const useUrlMap = geoViewState.mapSource === 'url' && geoViewState.mapUrl;
    const useUploadedMap = geoViewState.mapSource === 'upload' && geoViewState.customMapImage;
    
    // Check if using URL or uploaded image
    if (useUrlMap || useUploadedMap) {
      const imgSrc = useUrlMap ? geoViewState.mapUrl : geoViewState.customMapImage;
      
      // Draw the map image at full canvas size - the coordinate system is aligned
      const img = document.createElementNS('http://www.w3.org/2000/svg', 'image');
      img.setAttribute('x', 0);
      img.setAttribute('y', 0);
      img.setAttribute('width', geoViewState.canvasWidth);
      img.setAttribute('height', geoViewState.canvasHeight);
      img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', imgSrc);
      img.setAttribute('preserveAspectRatio', 'none');
      bg.appendChild(img);
      
      // Optional: Add subtle grid overlay on top of image
      const graticule = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      graticule.setAttribute('stroke', 'rgba(0,0,0,0.1)');
      graticule.setAttribute('stroke-width', '0.5');
      graticule.setAttribute('fill', 'none');
      
      // Use the current bounds for graticule
      const bounds = geoViewState.customMapBounds || geoViewState.mapBounds;
      
      for (let lon = -180; lon <= 180; lon += 30) {
        if (lon < bounds.minLon || lon > bounds.maxLon) continue;
        const p1 = gpsToCanvas(Math.min(85, bounds.maxLat), lon);
        const p2 = gpsToCanvas(Math.max(-85, bounds.minLat), lon);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', p1.x);
        line.setAttribute('y1', p1.y);
        line.setAttribute('x2', p2.x);
        line.setAttribute('y2', p2.y);
        graticule.appendChild(line);
      }
      
      for (let lat = -60; lat <= 90; lat += 30) {
        if (lat < bounds.minLat || lat > bounds.maxLat) continue;
        const p1 = gpsToCanvas(lat, bounds.minLon);
        const p2 = gpsToCanvas(lat, bounds.maxLon);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', p1.x);
        line.setAttribute('y1', p1.y);
        line.setAttribute('x2', p2.x);
        line.setAttribute('y2', p2.y);
        graticule.appendChild(line);
      }
      
      bg.appendChild(graticule);
      return bg;
    }
    
    // Default: Use SVG-drawn map
    // Ocean background
    const ocean = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    ocean.setAttribute('x', '0');
    ocean.setAttribute('y', '0');
    ocean.setAttribute('width', geoViewState.canvasWidth);
    ocean.setAttribute('height', geoViewState.canvasHeight);
    ocean.setAttribute('fill', '#e8f4fc');
    bg.appendChild(ocean);
    
    // Graticule (grid lines)
    const graticule = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    graticule.setAttribute('stroke', '#d4e4ed');
    graticule.setAttribute('stroke-width', '0.5');
    graticule.setAttribute('fill', 'none');
    
    const bounds = geoViewState.mapBounds;
    
    // Longitude lines (every 30 degrees)
    for (let lon = -180; lon <= 180; lon += 30) {
      const p1 = gpsToCanvas(Math.min(85, bounds.maxLat), lon);
      const p2 = gpsToCanvas(Math.max(-60, bounds.minLat), lon);
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', p1.x);
      line.setAttribute('y1', p1.y);
      line.setAttribute('x2', p2.x);
      line.setAttribute('y2', p2.y);
      graticule.appendChild(line);
    }
    
    // Latitude lines (every 30 degrees)
    for (let lat = -60; lat <= 90; lat += 30) {
      if (lat < bounds.minLat || lat > bounds.maxLat) continue;
      const p1 = gpsToCanvas(lat, -180);
      const p2 = gpsToCanvas(lat, 180);
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', p1.x);
      line.setAttribute('y1', p1.y);
      line.setAttribute('x2', p2.x);
      line.setAttribute('y2', p2.y);
      graticule.appendChild(line);
    }
    
    bg.appendChild(graticule);
    
    // Draw all landmasses
    const continents = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    continents.setAttribute('fill', '#c8d0d8');
    continents.setAttribute('stroke', '#9aa5b0');
    continents.setAttribute('stroke-width', '0.75');
    continents.setAttribute('stroke-linejoin', 'round');
    
    // Draw each landmass
    Object.values(worldMapData).forEach(coords => {
      drawLandmass(continents, coords);
    });
    
    bg.appendChild(continents);
    
    // Equator line (special highlight)
    const eqP1 = gpsToCanvas(0, -180);
    const eqP2 = gpsToCanvas(0, 180);
    const equator = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    equator.setAttribute('x1', eqP1.x);
    equator.setAttribute('y1', eqP1.y);
    equator.setAttribute('x2', eqP2.x);
    equator.setAttribute('y2', eqP2.y);
    equator.setAttribute('stroke', '#a0aab5');
    equator.setAttribute('stroke-width', '1');
    equator.setAttribute('stroke-dasharray', '8,4');
    bg.appendChild(equator);
    
    // Coordinate labels
    const labels = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    labels.setAttribute('fill', '#6b7280');
    labels.setAttribute('font-size', '10');
    labels.setAttribute('font-family', 'sans-serif');
    
    // Longitude labels
    for (let lon = -180; lon <= 180; lon += 60) {
      const p = gpsToCanvas(-60, lon);
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', p.x);
      text.setAttribute('y', p.y + 15);
      text.setAttribute('text-anchor', 'middle');
      text.textContent = lon + '¬∞';
      labels.appendChild(text);
    }
    
    // Latitude labels
    for (let lat = -60; lat <= 60; lat += 30) {
      const p = gpsToCanvas(lat, -180);
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', p.x - 5);
      text.setAttribute('y', p.y + 4);
      text.setAttribute('text-anchor', 'end');
      text.textContent = lat + '¬∞';
      labels.appendChild(text);
    }
    
    bg.appendChild(labels);
    
    return bg;
  }
  
  // Helper to draw landmass polygon from [lat, lon] coordinates
  function drawLandmass(parent, coords) {
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    let d = '';
    coords.forEach((coord, i) => {
      const p = gpsToCanvas(coord[0], coord[1]);
      d += (i === 0 ? 'M' : 'L') + p.x.toFixed(1) + ',' + p.y.toFixed(1) + ' ';
    });
    d += 'Z';
    path.setAttribute('d', d);
    parent.appendChild(path);
  }
  
  // Render geographic view
  function renderGeoView() {
    svg.innerHTML = '';
    
    // Set canvas size for geo view
    svg.setAttribute('viewBox', `0 0 ${geoViewState.canvasWidth} ${geoViewState.canvasHeight}`);
    
    // Draw world map background
    svg.appendChild(drawGeoBackground());
    
    // Get nodes with GPS data
    const geoNodes = state.nodes.filter(n => 
      n.gpsLat !== null && n.gpsLat !== undefined &&
      n.gpsLon !== null && n.gpsLon !== undefined
    );
    
    // Draw edges between geo nodes
    state.edges.forEach(e => {
      const nodeA = findNode(e.a);
      const nodeB = findNode(e.b);
      
      // Only draw if both nodes have GPS data
      if (nodeA?.gpsLat != null && nodeA?.gpsLon != null &&
          nodeB?.gpsLat != null && nodeB?.gpsLon != null) {
        
        const posA = gpsToCanvas(nodeA.gpsLat, nodeA.gpsLon);
        const posB = gpsToCanvas(nodeB.gpsLat, nodeB.gpsLon);
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', posA.x);
        line.setAttribute('y1', posA.y);
        line.setAttribute('x2', posB.x);
        line.setAttribute('y2', posB.y);
        line.setAttribute('stroke', e.strokeColor || '#666666');
        line.setAttribute('stroke-width', e.strokeW || 2);
        line.setAttribute('class', 'geo-edge edge');
        line.setAttribute('data-edge-id', e.id);
        
        const isSel = (state.selected?.type === 'edge' && state.selected?.id === e.id) || 
                      state.selection.edges.has(e.id);
        if (isSel) {
          line.setAttribute('stroke', '#0096D6');
          line.setAttribute('stroke-width', (e.strokeW || 2) + 2);
        }
        
        line.style.cursor = 'pointer';
        line.addEventListener('click', (ev) => {
          ev.stopPropagation();
          
          // Check if in Route Finder link exclusion mode
          if (typeof routeFinderState !== 'undefined' && routeFinderState.active && routeFinderState.pickMode === 'excludeLink') {
            addExcludedLink(e.id);
            routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          
          // Check if in Route Finder must-use link mode
          if (typeof routeFinderState !== 'undefined' && routeFinderState.active && routeFinderState.pickMode === 'mustUseLink') {
            addMustUseLink(e.id);
            routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          
          state.selected = { type: 'edge', id: e.id };
          state.selection.nodes.clear();
          state.selection.edges.clear();
          state.selection.groups.clear();
          renderGeoView();
          updateInspector();
        });
        
        svg.appendChild(line);
        
        // Draw latency label if enabled
        if (state.showLatency !== false && e.latency) {
          const midX = (posA.x + posB.x) / 2;
          const midY = (posA.y + posB.y) / 2;
          const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          label.setAttribute('x', midX);
          label.setAttribute('y', midY - 5);
          label.setAttribute('text-anchor', 'middle');
          label.setAttribute('font-size', '10');
          label.setAttribute('fill', '#666');
          label.textContent = e.latency + ' ms';
          svg.appendChild(label);
        }
      }
    });
    
    // Draw nodes
    geoNodes.forEach(n => {
      const pos = gpsToCanvas(n.gpsLat, n.gpsLon);
      const r = Math.max(8, (n.r || 24) / 2); // Smaller nodes in geo view
      
      const isSel = (state.selected?.type === 'node' && state.selected?.id === n.id) || 
                    state.selection.nodes.has(n.id);
      
      // Node circle
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', pos.x);
      circle.setAttribute('cy', pos.y);
      circle.setAttribute('r', r);
      circle.setAttribute('fill', n.fill || '#dae8fc');
      circle.setAttribute('stroke', isSel ? '#0096D6' : (n.stroke || '#6c8ebf'));
      circle.setAttribute('stroke-width', isSel ? 3 : 2);
      circle.setAttribute('class', 'geo-node');
      circle.setAttribute('data-node-id', n.id);
      circle.style.cursor = 'pointer';
      
      if (isSel) {
        circle.style.filter = 'drop-shadow(0 0 4px #0096D6)';
      }
      
      circle.addEventListener('click', (ev) => {
        ev.stopPropagation();
        
        // Check if in Route Finder calculation mode
        if (typeof routeFinderState !== 'undefined' && routeFinderState.active) {
          handleCalculationModeNodeClick(n.id);
          return;
        }
        
        if (ev.shiftKey) {
          if (state.selection.nodes.has(n.id)) {
            state.selection.nodes.delete(n.id);
          } else {
            state.selection.nodes.add(n.id);
          }
          state.selected = { type: 'node', id: n.id };
        } else {
          state.selected = { type: 'node', id: n.id };
          state.selection.nodes.clear();
          state.selection.edges.clear();
          state.selection.groups.clear();
        }
        renderGeoView();
        updateInspector();
      });
      
      svg.appendChild(circle);
      
      // Node label (code or name)
      const label = n.code || n.name;
      if (label) {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', pos.x);
        text.setAttribute('y', pos.y - r - 4);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', '11');
        text.setAttribute('font-weight', '600');
        text.setAttribute('fill', '#333');
        text.textContent = label;
        svg.appendChild(text);
      }
    });
    
    // Info text
    const info = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    info.setAttribute('x', '10');
    info.setAttribute('y', geoViewState.canvasHeight - 10);
    info.setAttribute('font-size', '11');
    info.setAttribute('fill', '#666');
    info.textContent = `üåç Geographic View ‚Äî ${geoNodes.length} node(s) with GPS | Drag to pan ‚Ä¢ Space+drag anywhere ‚Ä¢ Scroll to zoom`;
    svg.appendChild(info);
    
    updateInspector();
  }
  
  // Toggle geographic view
  function toggleGeoView(active) {
    geoViewState.active = active;
    
    // Update menu radio buttons and options visibility
    const stdRadio = document.getElementById('viewModeStandard');
    const geoRadio = document.getElementById('viewModeGeo');
    const geoOptionsEl = document.getElementById('geoViewOptions');
    if (stdRadio) stdRadio.checked = !active;
    if (geoRadio) geoRadio.checked = active;
    if (geoOptionsEl) geoOptionsEl.style.display = active ? '' : 'none';
    
    // Update toolbar button
    const btnGeoView = document.getElementById('btnGeoView');
    if (btnGeoView) {
      btnGeoView.classList.toggle('active', active);
    }
    
    // Show/hide floating projection panel
    const projPanel = document.getElementById('projectionPanel');
    if (projPanel) {
      projPanel.style.display = active ? 'block' : 'none';
    }
    
    if (active) {
      // Save current canvas settings
      geoViewState.savedCanvasWidth = state.canvasWidth;
      geoViewState.savedCanvasHeight = state.canvasHeight;
      geoViewState.savedZoom = state.zoom;
      
      // Set geo view canvas
      state.zoom = 1;
      updateViewBox();
      
      renderGeoView();
      showToast('üåç Geographic View ‚Äî showing nodes with GPS coordinates');
    } else {
      // Restore canvas settings
      if (geoViewState.savedCanvasWidth) {
        state.canvasWidth = geoViewState.savedCanvasWidth;
        state.canvasHeight = geoViewState.savedCanvasHeight;
        state.zoom = geoViewState.savedZoom || 1;
      }
      updateViewBox();
      render();
      showToast('üìã Standard Canvas View');
    }
  }
  
  // Override render when in geo view
  const originalRenderFunc = render;
  const geoAwareRender = function() {
    if (geoViewState.active) {
      renderGeoView();
    } else {
      originalRenderFunc();
    }
  };
  window.render = geoAwareRender;
  // Also reassign local render for direct calls
  render = geoAwareRender;
  
  // GPS format toggle event listener
  const nodeGpsFormat = document.getElementById('nodeGpsFormat');
  if (nodeGpsFormat) {
    nodeGpsFormat.addEventListener('change', () => {
      gpsDisplayFormat = nodeGpsFormat.value;
      if (state.selected?.type === 'node') {
        const n = findNode(state.selected.id);
        updateGpsFields(n);
      }
    });
  }
  
  // DD input listeners
  const nodeLatDD = document.getElementById('nodeLatDD');
  const nodeLonDD = document.getElementById('nodeLonDD');
  if (nodeLatDD) nodeLatDD.addEventListener('change', saveGpsFromDD);
  if (nodeLonDD) nodeLonDD.addEventListener('change', saveGpsFromDD);
  
  // DMS input listeners
  ['nodeLatDeg', 'nodeLatMin', 'nodeLatSec', 'nodeLatDir',
   'nodeLonDeg', 'nodeLonMin', 'nodeLonSec', 'nodeLonDir'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('change', saveGpsFromDMS);
  });
  
  // ============== LOCATION LOOKUP DATABASE ==============
  const locationDatabase = {
    // Major World Cities
    'new york': { lat: 40.7128, lon: -74.0060, name: 'New York, USA' },
    'nyc': { lat: 40.7128, lon: -74.0060, name: 'New York, USA' },
    'los angeles': { lat: 34.0522, lon: -118.2437, name: 'Los Angeles, USA' },
    'la': { lat: 34.0522, lon: -118.2437, name: 'Los Angeles, USA' },
    'chicago': { lat: 41.8781, lon: -87.6298, name: 'Chicago, USA' },
    'houston': { lat: 29.7604, lon: -95.3698, name: 'Houston, USA' },
    'phoenix': { lat: 33.4484, lon: -112.0740, name: 'Phoenix, USA' },
    'philadelphia': { lat: 39.9526, lon: -75.1652, name: 'Philadelphia, USA' },
    'san antonio': { lat: 29.4241, lon: -98.4936, name: 'San Antonio, USA' },
    'san diego': { lat: 32.7157, lon: -117.1611, name: 'San Diego, USA' },
    'dallas': { lat: 32.7767, lon: -96.7970, name: 'Dallas, USA' },
    'san jose': { lat: 37.3382, lon: -121.8863, name: 'San Jose, USA' },
    'austin': { lat: 30.2672, lon: -97.7431, name: 'Austin, USA' },
    'san francisco': { lat: 37.7749, lon: -122.4194, name: 'San Francisco, USA' },
    'seattle': { lat: 47.6062, lon: -122.3321, name: 'Seattle, USA' },
    'denver': { lat: 39.7392, lon: -104.9903, name: 'Denver, USA' },
    'washington': { lat: 38.9072, lon: -77.0369, name: 'Washington DC, USA' },
    'washington dc': { lat: 38.9072, lon: -77.0369, name: 'Washington DC, USA' },
    'boston': { lat: 42.3601, lon: -71.0589, name: 'Boston, USA' },
    'miami': { lat: 25.7617, lon: -80.1918, name: 'Miami, USA' },
    'atlanta': { lat: 33.7490, lon: -84.3880, name: 'Atlanta, USA' },
    'detroit': { lat: 42.3314, lon: -83.0458, name: 'Detroit, USA' },
    'minneapolis': { lat: 44.9778, lon: -93.2650, name: 'Minneapolis, USA' },
    'portland': { lat: 45.5152, lon: -122.6784, name: 'Portland, USA' },
    'las vegas': { lat: 36.1699, lon: -115.1398, name: 'Las Vegas, USA' },
    'ashburn': { lat: 39.0438, lon: -77.4874, name: 'Ashburn, Virginia, USA' },
    'silicon valley': { lat: 37.3875, lon: -122.0575, name: 'Silicon Valley, USA' },
    
    // Canada
    'toronto': { lat: 43.6532, lon: -79.3832, name: 'Toronto, Canada' },
    'vancouver': { lat: 49.2827, lon: -123.1207, name: 'Vancouver, Canada' },
    'montreal': { lat: 45.5017, lon: -73.5673, name: 'Montreal, Canada' },
    'calgary': { lat: 51.0447, lon: -114.0719, name: 'Calgary, Canada' },
    'ottawa': { lat: 45.4215, lon: -75.6972, name: 'Ottawa, Canada' },
    
    // Mexico & Central America
    'mexico city': { lat: 19.4326, lon: -99.1332, name: 'Mexico City, Mexico' },
    'guadalajara': { lat: 20.6597, lon: -103.3496, name: 'Guadalajara, Mexico' },
    'monterrey': { lat: 25.6866, lon: -100.3161, name: 'Monterrey, Mexico' },
    'panama city': { lat: 8.9824, lon: -79.5199, name: 'Panama City, Panama' },
    
    // South America
    'sao paulo': { lat: -23.5505, lon: -46.6333, name: 'S√£o Paulo, Brazil' },
    's√£o paulo': { lat: -23.5505, lon: -46.6333, name: 'S√£o Paulo, Brazil' },
    'rio de janeiro': { lat: -22.9068, lon: -43.1729, name: 'Rio de Janeiro, Brazil' },
    'rio': { lat: -22.9068, lon: -43.1729, name: 'Rio de Janeiro, Brazil' },
    'buenos aires': { lat: -34.6037, lon: -58.3816, name: 'Buenos Aires, Argentina' },
    'bogota': { lat: 4.7110, lon: -74.0721, name: 'Bogot√°, Colombia' },
    'bogot√°': { lat: 4.7110, lon: -74.0721, name: 'Bogot√°, Colombia' },
    'lima': { lat: -12.0464, lon: -77.0428, name: 'Lima, Peru' },
    'santiago': { lat: -33.4489, lon: -70.6693, name: 'Santiago, Chile' },
    'caracas': { lat: 10.4806, lon: -66.9036, name: 'Caracas, Venezuela' },
    'quito': { lat: -0.1807, lon: -78.4678, name: 'Quito, Ecuador' },
    'fortaleza': { lat: -3.7172, lon: -38.5433, name: 'Fortaleza, Brazil' },
    
    // UK & Ireland
    'london': { lat: 51.5074, lon: -0.1278, name: 'London, UK' },
    'manchester': { lat: 53.4808, lon: -2.2426, name: 'Manchester, UK' },
    'birmingham': { lat: 52.4862, lon: -1.8904, name: 'Birmingham, UK' },
    'glasgow': { lat: 55.8642, lon: -4.2518, name: 'Glasgow, UK' },
    'edinburgh': { lat: 55.9533, lon: -3.1883, name: 'Edinburgh, UK' },
    'dublin': { lat: 53.3498, lon: -6.2603, name: 'Dublin, Ireland' },
    'belfast': { lat: 54.5973, lon: -5.9301, name: 'Belfast, UK' },
    'slough': { lat: 51.5105, lon: -0.5950, name: 'Slough, UK' },
    
    // Western Europe
    'paris': { lat: 48.8566, lon: 2.3522, name: 'Paris, France' },
    'marseille': { lat: 43.2965, lon: 5.3698, name: 'Marseille, France' },
    'lyon': { lat: 45.7640, lon: 4.8357, name: 'Lyon, France' },
    'amsterdam': { lat: 52.3676, lon: 4.9041, name: 'Amsterdam, Netherlands' },
    'rotterdam': { lat: 51.9244, lon: 4.4777, name: 'Rotterdam, Netherlands' },
    'brussels': { lat: 50.8503, lon: 4.3517, name: 'Brussels, Belgium' },
    'luxembourg': { lat: 49.6116, lon: 6.1319, name: 'Luxembourg' },
    
    // Germany
    'berlin': { lat: 52.5200, lon: 13.4050, name: 'Berlin, Germany' },
    'munich': { lat: 48.1351, lon: 11.5820, name: 'Munich, Germany' },
    'frankfurt': { lat: 50.1109, lon: 8.6821, name: 'Frankfurt, Germany' },
    'hamburg': { lat: 53.5511, lon: 9.9937, name: 'Hamburg, Germany' },
    'cologne': { lat: 50.9375, lon: 6.9603, name: 'Cologne, Germany' },
    'd√ºsseldorf': { lat: 51.2277, lon: 6.7735, name: 'D√ºsseldorf, Germany' },
    'dusseldorf': { lat: 51.2277, lon: 6.7735, name: 'D√ºsseldorf, Germany' },
    'stuttgart': { lat: 48.7758, lon: 9.1829, name: 'Stuttgart, Germany' },
    
    // Iberian Peninsula
    'madrid': { lat: 40.4168, lon: -3.7038, name: 'Madrid, Spain' },
    'barcelona': { lat: 41.3851, lon: 2.1734, name: 'Barcelona, Spain' },
    'valencia': { lat: 39.4699, lon: -0.3763, name: 'Valencia, Spain' },
    'seville': { lat: 37.3891, lon: -5.9845, name: 'Seville, Spain' },
    'sevilla': { lat: 37.3891, lon: -5.9845, name: 'Seville, Spain' },
    'bilbao': { lat: 43.2630, lon: -2.9350, name: 'Bilbao, Spain' },
    'malaga': { lat: 36.7213, lon: -4.4214, name: 'Malaga, Spain' },
    'lisbon': { lat: 38.7223, lon: -9.1393, name: 'Lisbon, Portugal' },
    'porto': { lat: 41.1579, lon: -8.6291, name: 'Porto, Portugal' },
    
    // Italy
    'rome': { lat: 41.9028, lon: 12.4964, name: 'Rome, Italy' },
    'roma': { lat: 41.9028, lon: 12.4964, name: 'Rome, Italy' },
    'milan': { lat: 45.4642, lon: 9.1900, name: 'Milan, Italy' },
    'milano': { lat: 45.4642, lon: 9.1900, name: 'Milan, Italy' },
    'naples': { lat: 40.8518, lon: 14.2681, name: 'Naples, Italy' },
    'turin': { lat: 45.0703, lon: 7.6869, name: 'Turin, Italy' },
    'florence': { lat: 43.7696, lon: 11.2558, name: 'Florence, Italy' },
    'venice': { lat: 45.4408, lon: 12.3155, name: 'Venice, Italy' },
    
    // Scandinavia & Nordic
    'stockholm': { lat: 59.3293, lon: 18.0686, name: 'Stockholm, Sweden' },
    'oslo': { lat: 59.9139, lon: 10.7522, name: 'Oslo, Norway' },
    'copenhagen': { lat: 55.6761, lon: 12.5683, name: 'Copenhagen, Denmark' },
    'helsinki': { lat: 60.1699, lon: 24.9384, name: 'Helsinki, Finland' },
    'reykjavik': { lat: 64.1466, lon: -21.9426, name: 'Reykjavik, Iceland' },
    
    // Central & Eastern Europe
    'vienna': { lat: 48.2082, lon: 16.3738, name: 'Vienna, Austria' },
    'zurich': { lat: 47.3769, lon: 8.5417, name: 'Zurich, Switzerland' },
    'geneva': { lat: 46.2044, lon: 6.1432, name: 'Geneva, Switzerland' },
    'prague': { lat: 50.0755, lon: 14.4378, name: 'Prague, Czech Republic' },
    'warsaw': { lat: 52.2297, lon: 21.0122, name: 'Warsaw, Poland' },
    'krakow': { lat: 50.0647, lon: 19.9450, name: 'Krakow, Poland' },
    'budapest': { lat: 47.4979, lon: 19.0402, name: 'Budapest, Hungary' },
    'bucharest': { lat: 44.4268, lon: 26.1025, name: 'Bucharest, Romania' },
    'sofia': { lat: 42.6977, lon: 23.3219, name: 'Sofia, Bulgaria' },
    'athens': { lat: 37.9838, lon: 23.7275, name: 'Athens, Greece' },
    
    // Russia & CIS
    'moscow': { lat: 55.7558, lon: 37.6173, name: 'Moscow, Russia' },
    'st petersburg': { lat: 59.9311, lon: 30.3609, name: 'St Petersburg, Russia' },
    'saint petersburg': { lat: 59.9311, lon: 30.3609, name: 'St Petersburg, Russia' },
    'kiev': { lat: 50.4501, lon: 30.5234, name: 'Kyiv, Ukraine' },
    'kyiv': { lat: 50.4501, lon: 30.5234, name: 'Kyiv, Ukraine' },
    
    // Middle East
    'dubai': { lat: 25.2048, lon: 55.2708, name: 'Dubai, UAE' },
    'abu dhabi': { lat: 24.4539, lon: 54.3773, name: 'Abu Dhabi, UAE' },
    'doha': { lat: 25.2854, lon: 51.5310, name: 'Doha, Qatar' },
    'riyadh': { lat: 24.7136, lon: 46.6753, name: 'Riyadh, Saudi Arabia' },
    'jeddah': { lat: 21.5433, lon: 39.1728, name: 'Jeddah, Saudi Arabia' },
    'tel aviv': { lat: 32.0853, lon: 34.7818, name: 'Tel Aviv, Israel' },
    'jerusalem': { lat: 31.7683, lon: 35.2137, name: 'Jerusalem, Israel' },
    'amman': { lat: 31.9454, lon: 35.9284, name: 'Amman, Jordan' },
    'beirut': { lat: 33.8938, lon: 35.5018, name: 'Beirut, Lebanon' },
    'istanbul': { lat: 41.0082, lon: 28.9784, name: 'Istanbul, Turkey' },
    'ankara': { lat: 39.9334, lon: 32.8597, name: 'Ankara, Turkey' },
    'tehran': { lat: 35.6892, lon: 51.3890, name: 'Tehran, Iran' },
    'baghdad': { lat: 33.3152, lon: 44.3661, name: 'Baghdad, Iraq' },
    'muscat': { lat: 23.5880, lon: 58.3829, name: 'Muscat, Oman' },
    'manama': { lat: 26.2285, lon: 50.5860, name: 'Manama, Bahrain' },
    'kuwait city': { lat: 29.3759, lon: 47.9774, name: 'Kuwait City, Kuwait' },
    
    // South Asia
    'mumbai': { lat: 19.0760, lon: 72.8777, name: 'Mumbai, India' },
    'bombay': { lat: 19.0760, lon: 72.8777, name: 'Mumbai, India' },
    'delhi': { lat: 28.7041, lon: 77.1025, name: 'Delhi, India' },
    'new delhi': { lat: 28.6139, lon: 77.2090, name: 'New Delhi, India' },
    'bangalore': { lat: 12.9716, lon: 77.5946, name: 'Bangalore, India' },
    'bengaluru': { lat: 12.9716, lon: 77.5946, name: 'Bangalore, India' },
    'chennai': { lat: 13.0827, lon: 80.2707, name: 'Chennai, India' },
    'hyderabad': { lat: 17.3850, lon: 78.4867, name: 'Hyderabad, India' },
    'kolkata': { lat: 22.5726, lon: 88.3639, name: 'Kolkata, India' },
    'calcutta': { lat: 22.5726, lon: 88.3639, name: 'Kolkata, India' },
    'pune': { lat: 18.5204, lon: 73.8567, name: 'Pune, India' },
    'ahmedabad': { lat: 23.0225, lon: 72.5714, name: 'Ahmedabad, India' },
    'karachi': { lat: 24.8607, lon: 67.0011, name: 'Karachi, Pakistan' },
    'lahore': { lat: 31.5204, lon: 74.3587, name: 'Lahore, Pakistan' },
    'islamabad': { lat: 33.6844, lon: 73.0479, name: 'Islamabad, Pakistan' },
    'dhaka': { lat: 23.8103, lon: 90.4125, name: 'Dhaka, Bangladesh' },
    'colombo': { lat: 6.9271, lon: 79.8612, name: 'Colombo, Sri Lanka' },
    
    // East Asia
    'tokyo': { lat: 35.6762, lon: 139.6503, name: 'Tokyo, Japan' },
    'osaka': { lat: 34.6937, lon: 135.5023, name: 'Osaka, Japan' },
    'yokohama': { lat: 35.4437, lon: 139.6380, name: 'Yokohama, Japan' },
    'nagoya': { lat: 35.1815, lon: 136.9066, name: 'Nagoya, Japan' },
    'fukuoka': { lat: 33.5904, lon: 130.4017, name: 'Fukuoka, Japan' },
    'seoul': { lat: 37.5665, lon: 126.9780, name: 'Seoul, South Korea' },
    'busan': { lat: 35.1796, lon: 129.0756, name: 'Busan, South Korea' },
    'beijing': { lat: 39.9042, lon: 116.4074, name: 'Beijing, China' },
    'shanghai': { lat: 31.2304, lon: 121.4737, name: 'Shanghai, China' },
    'guangzhou': { lat: 23.1291, lon: 113.2644, name: 'Guangzhou, China' },
    'shenzhen': { lat: 22.5431, lon: 114.0579, name: 'Shenzhen, China' },
    'hong kong': { lat: 22.3193, lon: 114.1694, name: 'Hong Kong' },
    'taipei': { lat: 25.0330, lon: 121.5654, name: 'Taipei, Taiwan' },
    'kaohsiung': { lat: 22.6273, lon: 120.3014, name: 'Kaohsiung, Taiwan' },
    
    // Southeast Asia
    'singapore': { lat: 1.3521, lon: 103.8198, name: 'Singapore' },
    'kuala lumpur': { lat: 3.1390, lon: 101.6869, name: 'Kuala Lumpur, Malaysia' },
    'kl': { lat: 3.1390, lon: 101.6869, name: 'Kuala Lumpur, Malaysia' },
    'bangkok': { lat: 13.7563, lon: 100.5018, name: 'Bangkok, Thailand' },
    'jakarta': { lat: -6.2088, lon: 106.8456, name: 'Jakarta, Indonesia' },
    'surabaya': { lat: -7.2575, lon: 112.7521, name: 'Surabaya, Indonesia' },
    'manila': { lat: 14.5995, lon: 120.9842, name: 'Manila, Philippines' },
    'ho chi minh': { lat: 10.8231, lon: 106.6297, name: 'Ho Chi Minh City, Vietnam' },
    'ho chi minh city': { lat: 10.8231, lon: 106.6297, name: 'Ho Chi Minh City, Vietnam' },
    'saigon': { lat: 10.8231, lon: 106.6297, name: 'Ho Chi Minh City, Vietnam' },
    'hanoi': { lat: 21.0278, lon: 105.8342, name: 'Hanoi, Vietnam' },
    'phnom penh': { lat: 11.5564, lon: 104.9282, name: 'Phnom Penh, Cambodia' },
    
    // Australia & Oceania
    'sydney': { lat: -33.8688, lon: 151.2093, name: 'Sydney, Australia' },
    'melbourne': { lat: -37.8136, lon: 144.9631, name: 'Melbourne, Australia' },
    'brisbane': { lat: -27.4698, lon: 153.0251, name: 'Brisbane, Australia' },
    'perth': { lat: -31.9505, lon: 115.8605, name: 'Perth, Australia' },
    'adelaide': { lat: -34.9285, lon: 138.6007, name: 'Adelaide, Australia' },
    'auckland': { lat: -36.8485, lon: 174.7633, name: 'Auckland, New Zealand' },
    'wellington': { lat: -41.2866, lon: 174.7756, name: 'Wellington, New Zealand' },
    
    // Africa
    'cairo': { lat: 30.0444, lon: 31.2357, name: 'Cairo, Egypt' },
    'alexandria': { lat: 31.2001, lon: 29.9187, name: 'Alexandria, Egypt' },
    'johannesburg': { lat: -26.2041, lon: 28.0473, name: 'Johannesburg, South Africa' },
    'cape town': { lat: -33.9249, lon: 18.4241, name: 'Cape Town, South Africa' },
    'durban': { lat: -29.8587, lon: 31.0218, name: 'Durban, South Africa' },
    'lagos': { lat: 6.5244, lon: 3.3792, name: 'Lagos, Nigeria' },
    'nairobi': { lat: -1.2921, lon: 36.8219, name: 'Nairobi, Kenya' },
    'mombasa': { lat: -4.0435, lon: 39.6682, name: 'Mombasa, Kenya' },
    'casablanca': { lat: 33.5731, lon: -7.5898, name: 'Casablanca, Morocco' },
    'tunis': { lat: 36.8065, lon: 10.1815, name: 'Tunis, Tunisia' },
    'algiers': { lat: 36.7538, lon: 3.0588, name: 'Algiers, Algeria' },
    'accra': { lat: 5.6037, lon: -0.1870, name: 'Accra, Ghana' },
    'addis ababa': { lat: 9.0320, lon: 38.7469, name: 'Addis Ababa, Ethiopia' },
    'dar es salaam': { lat: -6.7924, lon: 39.2083, name: 'Dar es Salaam, Tanzania' },
    'djibouti': { lat: 11.5886, lon: 43.1456, name: 'Djibouti' },
    
    // Countries (capital/center coordinates)
    'usa': { lat: 39.8283, lon: -98.5795, name: 'United States (center)' },
    'united states': { lat: 39.8283, lon: -98.5795, name: 'United States (center)' },
    'canada': { lat: 56.1304, lon: -106.3468, name: 'Canada (center)' },
    'mexico': { lat: 23.6345, lon: -102.5528, name: 'Mexico (center)' },
    'brazil': { lat: -14.2350, lon: -51.9253, name: 'Brazil (center)' },
    'argentina': { lat: -38.4161, lon: -63.6167, name: 'Argentina (center)' },
    'uk': { lat: 55.3781, lon: -3.4360, name: 'United Kingdom (center)' },
    'united kingdom': { lat: 55.3781, lon: -3.4360, name: 'United Kingdom (center)' },
    'france': { lat: 46.2276, lon: 2.2137, name: 'France (center)' },
    'germany': { lat: 51.1657, lon: 10.4515, name: 'Germany (center)' },
    'spain': { lat: 40.4637, lon: -3.7492, name: 'Spain (center)' },
    'italy': { lat: 41.8719, lon: 12.5674, name: 'Italy (center)' },
    'netherlands': { lat: 52.1326, lon: 5.2913, name: 'Netherlands (center)' },
    'belgium': { lat: 50.5039, lon: 4.4699, name: 'Belgium (center)' },
    'switzerland': { lat: 46.8182, lon: 8.2275, name: 'Switzerland (center)' },
    'austria': { lat: 47.5162, lon: 14.5501, name: 'Austria (center)' },
    'poland': { lat: 51.9194, lon: 19.1451, name: 'Poland (center)' },
    'sweden': { lat: 60.1282, lon: 18.6435, name: 'Sweden (center)' },
    'norway': { lat: 60.4720, lon: 8.4689, name: 'Norway (center)' },
    'denmark': { lat: 56.2639, lon: 9.5018, name: 'Denmark (center)' },
    'finland': { lat: 61.9241, lon: 25.7482, name: 'Finland (center)' },
    'russia': { lat: 61.5240, lon: 105.3188, name: 'Russia (center)' },
    'china': { lat: 35.8617, lon: 104.1954, name: 'China (center)' },
    'japan': { lat: 36.2048, lon: 138.2529, name: 'Japan (center)' },
    'south korea': { lat: 35.9078, lon: 127.7669, name: 'South Korea (center)' },
    'korea': { lat: 35.9078, lon: 127.7669, name: 'South Korea (center)' },
    'india': { lat: 20.5937, lon: 78.9629, name: 'India (center)' },
    'australia': { lat: -25.2744, lon: 133.7751, name: 'Australia (center)' },
    'new zealand': { lat: -40.9006, lon: 174.8860, name: 'New Zealand (center)' },
    'south africa': { lat: -30.5595, lon: 22.9375, name: 'South Africa (center)' },
    'egypt': { lat: 26.8206, lon: 30.8025, name: 'Egypt (center)' },
    'nigeria': { lat: 9.0820, lon: 8.6753, name: 'Nigeria (center)' },
    'kenya': { lat: -0.0236, lon: 37.9062, name: 'Kenya (center)' },
    'uae': { lat: 23.4241, lon: 53.8478, name: 'UAE (center)' },
    'saudi arabia': { lat: 23.8859, lon: 45.0792, name: 'Saudi Arabia (center)' },
    'israel': { lat: 31.0461, lon: 34.8516, name: 'Israel (center)' },
    'turkey': { lat: 38.9637, lon: 35.2433, name: 'Turkey (center)' },
    'greece': { lat: 39.0742, lon: 21.8243, name: 'Greece (center)' },
    'portugal': { lat: 39.3999, lon: -8.2245, name: 'Portugal (center)' },
    'ireland': { lat: 53.1424, lon: -7.6921, name: 'Ireland (center)' },
    'taiwan': { lat: 23.6978, lon: 120.9605, name: 'Taiwan (center)' },
    'malaysia': { lat: 4.2105, lon: 101.9758, name: 'Malaysia (center)' },
    'thailand': { lat: 15.8700, lon: 100.9925, name: 'Thailand (center)' },
    'indonesia': { lat: -0.7893, lon: 113.9213, name: 'Indonesia (center)' },
    'philippines': { lat: 12.8797, lon: 121.7740, name: 'Philippines (center)' },
    'vietnam': { lat: 14.0583, lon: 108.2772, name: 'Vietnam (center)' }
  };
  
  // Location lookup dialog
  function showLocationLookupDialog() {
    if (state.selected?.type !== 'node') {
      showToast('‚ö†Ô∏è Please select a node first');
      return;
    }
    
    const modal = document.createElement('div');
    modal.id = 'locationLookupModal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); z-index: 10000;
      display: flex; align-items: center; justify-content: center;
    `;
    
    modal.innerHTML = `
      <div style="background: white; border-radius: 12px; padding: 24px; max-width: 500px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
        <h3 style="margin: 0 0 16px; color:#0369a1;">üèôÔ∏è Lookup GPS by Location</h3>
        <p style="color: #666; font-size: 13px; margin-bottom: 16px;">
          Enter a city name, region, or country to get approximate GPS coordinates.
        </p>
        
        <div style="margin-bottom: 16px;">
          <label style="font-size: 11px; font-weight: 600; color: #555; display:block; margin-bottom:4px;">City, Region, or Country</label>
          <input type="text" id="locationSearchInput" placeholder="e.g. Madrid, London, Singapore, Germany..."
                 style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; box-sizing: border-box;"
                 autocomplete="off" />
        </div>
        
        <div id="locationSearchResults" style="max-height: 200px; overflow-y: auto; margin-bottom: 16px; border: 1px solid #e0e0e0; border-radius: 6px; display: none;">
        </div>
        
        <div id="locationSelected" style="display: none; background: #f0f9ff; padding: 12px; border-radius: 6px; margin-bottom: 16px;">
          <div style="font-weight: 600; color: #0369a1;" id="selectedLocationName"></div>
          <div style="font-size: 12px; color: #666; font-family: monospace;" id="selectedLocationCoords"></div>
        </div>
        
        <div style="font-size: 11px; color: #888; margin-bottom: 16px; background: #fef3c7; padding: 8px; border-radius: 4px;">
          üí° <strong>Tip:</strong> Start typing and matching locations will appear. Click to select, then click "Apply".
        </div>
        
        <div style="display: flex; gap: 12px; justify-content: flex-end;">
          <button id="locationLookupCancel" style="padding: 10px 20px; border: 1px solid #ddd; background: #f5f5f5; border-radius: 6px; cursor: pointer;">Cancel</button>
          <button id="locationLookupApply" style="padding: 10px 20px; border: none; background: #0369a1; color: white; border-radius: 6px; cursor: pointer; font-weight: 600;" disabled>Apply Coordinates</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    const searchInput = document.getElementById('locationSearchInput');
    const resultsDiv = document.getElementById('locationSearchResults');
    const selectedDiv = document.getElementById('locationSelected');
    const selectedName = document.getElementById('selectedLocationName');
    const selectedCoords = document.getElementById('selectedLocationCoords');
    const applyBtn = document.getElementById('locationLookupApply');
    
    let selectedLocation = null;
    
    // Search as user types
    searchInput.addEventListener('input', () => {
      const query = searchInput.value.toLowerCase().trim();
      
      if (query.length < 2) {
        resultsDiv.style.display = 'none';
        return;
      }
      
      const matches = [];
      for (const [key, loc] of Object.entries(locationDatabase)) {
        if (key.includes(query) || loc.name.toLowerCase().includes(query)) {
          matches.push({ key, ...loc });
        }
      }
      
      if (matches.length === 0) {
        resultsDiv.innerHTML = '<div style="padding: 12px; color: #888; text-align: center;">No locations found. Try a different search.</div>';
        resultsDiv.style.display = 'block';
        return;
      }
      
      // Limit results and sort by relevance
      const sorted = matches
        .sort((a, b) => {
          // Exact matches first
          if (a.key === query) return -1;
          if (b.key === query) return 1;
          // Then starts with
          if (a.key.startsWith(query) && !b.key.startsWith(query)) return -1;
          if (b.key.startsWith(query) && !a.key.startsWith(query)) return 1;
          return a.name.localeCompare(b.name);
        })
        .slice(0, 15);
      
      resultsDiv.innerHTML = sorted.map(loc => `
        <div class="location-result" data-lat="${loc.lat}" data-lon="${loc.lon}" data-name="${loc.name}"
             style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.1s;">
          <div style="font-weight: 500;">${loc.name}</div>
          <div style="font-size: 11px; color: #888; font-family: monospace;">${loc.lat.toFixed(4)}¬∞, ${loc.lon.toFixed(4)}¬∞</div>
        </div>
      `).join('');
      
      resultsDiv.style.display = 'block';
      
      // Add hover effect
      resultsDiv.querySelectorAll('.location-result').forEach(el => {
        el.addEventListener('mouseenter', () => el.style.background = '#f0f9ff');
        el.addEventListener('mouseleave', () => el.style.background = '');
        el.addEventListener('click', () => {
          selectedLocation = {
            lat: parseFloat(el.dataset.lat),
            lon: parseFloat(el.dataset.lon),
            name: el.dataset.name
          };
          selectedName.textContent = selectedLocation.name;
          selectedCoords.textContent = `Lat: ${selectedLocation.lat.toFixed(4)}¬∞  Lon: ${selectedLocation.lon.toFixed(4)}¬∞`;
          selectedDiv.style.display = 'block';
          resultsDiv.style.display = 'none';
          searchInput.value = selectedLocation.name;
          applyBtn.disabled = false;
          applyBtn.style.background = '#0369a1';
        });
      });
    });
    
    // Cancel button
    document.getElementById('locationLookupCancel').onclick = () => modal.remove();
    
    // Apply button
    applyBtn.onclick = () => {
      if (!selectedLocation) return;
      
      const node = findNode(state.selected.id);
      if (!node) return;
      
      node.gpsLat = selectedLocation.lat;
      node.gpsLon = selectedLocation.lon;
      
      updateGpsFields(node);
      commit();
      render();
      modal.remove();
      showToast(`üìç GPS set to ${selectedLocation.name}`);
    };
    
    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
    
    // Focus input
    setTimeout(() => searchInput.focus(), 100);
  }
  
  // Use address to approximate GPS
  function useAddressForGps() {
    if (state.selected?.type !== 'node') {
      showToast('‚ö†Ô∏è Please select a node first');
      return;
    }
    
    const node = findNode(state.selected.id);
    if (!node) return;
    
    const address = node.address || '';
    if (!address.trim()) {
      showToast('‚ö†Ô∏è Node has no address. Please fill in the Address field first.');
      return;
    }
    
    // Try to find a city/country match in the address
    const addressLower = address.toLowerCase();
    let bestMatch = null;
    let bestMatchLength = 0;
    
    for (const [key, loc] of Object.entries(locationDatabase)) {
      if (addressLower.includes(key) && key.length > bestMatchLength) {
        bestMatch = { key, ...loc };
        bestMatchLength = key.length;
      }
    }
    
    if (bestMatch) {
      node.gpsLat = bestMatch.lat;
      node.gpsLon = bestMatch.lon;
      updateGpsFields(node);
      commit();
      render();
      showToast(`üìç GPS approximated from address: ${bestMatch.name}`);
    } else {
      showToast('‚ö†Ô∏è Could not find a known location in the address. Try the City/Country lookup instead.');
    }
  }
  
  // Button event handlers
  const btnLookupCity = document.getElementById('btnLookupCity');
  if (btnLookupCity) {
    btnLookupCity.addEventListener('click', showLocationLookupDialog);
  }
  
  const btnUseAddress = document.getElementById('btnUseAddress');
  if (btnUseAddress) {
    btnUseAddress.addEventListener('click', useAddressForGps);
  }
  
  // ============== END LOCATION LOOKUP ==============
  
  // Geo view button
  const btnGeoView = document.getElementById('btnGeoView');
  if (btnGeoView) {
    btnGeoView.addEventListener('click', () => {
      toggleGeoView(!geoViewState.active);
    });
  }
  
  // View menu radio buttons
  const viewModeStandard = document.getElementById('viewModeStandard');
  const viewModeGeo = document.getElementById('viewModeGeo');
  const geoViewOptions = document.getElementById('geoViewOptions');
  const mapSourceUrl = document.getElementById('mapSourceUrl');
  const mapSourceUpload = document.getElementById('mapSourceUpload');
  const mapSourceBuiltin = document.getElementById('mapSourceBuiltin');
  const miLoadMapUrl = document.getElementById('miLoadMapUrl');
  const miUploadGeoMap = document.getElementById('miUploadGeoMap');
  
  if (viewModeStandard) {
    viewModeStandard.addEventListener('change', () => {
      if (viewModeStandard.checked) {
        toggleGeoView(false);
        if (geoViewOptions) geoViewOptions.style.display = 'none';
      }
    });
  }
  if (viewModeGeo) {
    viewModeGeo.addEventListener('change', () => {
      if (viewModeGeo.checked) {
        toggleGeoView(true);
        if (geoViewOptions) geoViewOptions.style.display = '';
      }
    });
  }
  
  // Map source radio buttons
  function updateMapSourceRadios() {
    if (mapSourceUrl) mapSourceUrl.checked = geoViewState.mapSource === 'url';
    if (mapSourceUpload) mapSourceUpload.checked = geoViewState.mapSource === 'upload';
    if (mapSourceBuiltin) mapSourceBuiltin.checked = geoViewState.mapSource === 'builtin';
  }
  updateMapSourceRadios();
  
  // Projection adjustment controls
  const projScaleX = document.getElementById('projScaleX');
  const projScaleXVal = document.getElementById('projScaleXVal');
  const projScaleY = document.getElementById('projScaleY');
  const projScaleYVal = document.getElementById('projScaleYVal');
  const projOffsetX = document.getElementById('projOffsetX');
  const projOffsetXVal = document.getElementById('projOffsetXVal');
  const projOffsetY = document.getElementById('projOffsetY');
  const projOffsetYVal = document.getElementById('projOffsetYVal');
  const projResetBtn = document.getElementById('projResetBtn');
  const projShowValuesBtn = document.getElementById('projShowValuesBtn');
  
  function updateProjectionFromControls() {
    geoViewState.projectionAdjust.scaleX = parseFloat(projScaleX?.value) || 1.0;
    geoViewState.projectionAdjust.scaleY = parseFloat(projScaleY?.value) || 1.0;
    geoViewState.projectionAdjust.offsetX = parseFloat(projOffsetX?.value) || 0;
    geoViewState.projectionAdjust.offsetY = parseFloat(projOffsetY?.value) || 0;
    
    // Update number inputs
    if (projScaleXVal) projScaleXVal.value = geoViewState.projectionAdjust.scaleX;
    if (projScaleYVal) projScaleYVal.value = geoViewState.projectionAdjust.scaleY;
    if (projOffsetXVal) projOffsetXVal.value = geoViewState.projectionAdjust.offsetX;
    if (projOffsetYVal) projOffsetYVal.value = geoViewState.projectionAdjust.offsetY;
    
    // Save to localStorage
    try {
      localStorage.setItem('neximap-geo-projection-adjust', JSON.stringify(geoViewState.projectionAdjust));
    } catch(e) {}
    
    if (geoViewState.active) render();
  }
  
  function updateControlsFromProjection() {
    const adj = geoViewState.projectionAdjust;
    if (projScaleX) projScaleX.value = adj.scaleX;
    if (projScaleXVal) projScaleXVal.value = adj.scaleX;
    if (projScaleY) projScaleY.value = adj.scaleY;
    if (projScaleYVal) projScaleYVal.value = adj.scaleY;
    if (projOffsetX) projOffsetX.value = adj.offsetX;
    if (projOffsetXVal) projOffsetXVal.value = adj.offsetX;
    if (projOffsetY) projOffsetY.value = adj.offsetY;
    if (projOffsetYVal) projOffsetYVal.value = adj.offsetY;
  }
  
  // Load saved projection adjustment
  try {
    const savedAdj = localStorage.getItem('neximap-geo-projection-adjust');
    if (savedAdj) {
      const adj = JSON.parse(savedAdj);
      geoViewState.projectionAdjust = { ...geoViewState.projectionAdjust, ...adj };
      updateControlsFromProjection();
    }
  } catch(e) {}
  
  // Slider event handlers
  if (projScaleX) {
    projScaleX.addEventListener('input', updateProjectionFromControls);
  }
  if (projScaleY) {
    projScaleY.addEventListener('input', updateProjectionFromControls);
  }
  if (projOffsetX) {
    projOffsetX.addEventListener('input', updateProjectionFromControls);
  }
  if (projOffsetY) {
    projOffsetY.addEventListener('input', updateProjectionFromControls);
  }
  
  // Number input event handlers
  if (projScaleXVal) {
    projScaleXVal.addEventListener('change', () => {
      if (projScaleX) projScaleX.value = projScaleXVal.value;
      updateProjectionFromControls();
    });
  }
  if (projScaleYVal) {
    projScaleYVal.addEventListener('change', () => {
      if (projScaleY) projScaleY.value = projScaleYVal.value;
      updateProjectionFromControls();
    });
  }
  if (projOffsetXVal) {
    projOffsetXVal.addEventListener('change', () => {
      if (projOffsetX) projOffsetX.value = projOffsetXVal.value;
      updateProjectionFromControls();
    });
  }
  if (projOffsetYVal) {
    projOffsetYVal.addEventListener('change', () => {
      if (projOffsetY) projOffsetY.value = projOffsetYVal.value;
      updateProjectionFromControls();
    });
  }
  
  // Reset button
  if (projResetBtn) {
    projResetBtn.addEventListener('click', () => {
      geoViewState.projectionAdjust = { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 };
      updateControlsFromProjection();
      try {
        localStorage.removeItem('neximap-geo-projection-adjust');
      } catch(e) {}
      if (geoViewState.active) render();
      showToast('üîÑ Projection reset to defaults');
    });
  }
  
  // Copy values button
  if (projShowValuesBtn) {
    projShowValuesBtn.addEventListener('click', () => {
      const adj = geoViewState.projectionAdjust;
      const values = `scaleX: ${adj.scaleX}, scaleY: ${adj.scaleY}, offsetX: ${adj.offsetX}, offsetY: ${adj.offsetY}`;
      navigator.clipboard.writeText(values).then(() => {
        showToast('üìã Values copied: ' + values);
      }).catch(() => {
        showToast('üìã ' + values);
      });
    });
  }
  
  // ============ FLOATING PROJECTION PANEL ============
  const projectionPanel = document.getElementById('projectionPanel');
  const projPanelClose = document.getElementById('projPanelClose');
  const projScaleX2 = document.getElementById('projScaleX2');
  const projScaleXVal2 = document.getElementById('projScaleXVal2');
  const projScaleY2 = document.getElementById('projScaleY2');
  const projScaleYVal2 = document.getElementById('projScaleYVal2');
  const projOffsetX2 = document.getElementById('projOffsetX2');
  const projOffsetXVal2 = document.getElementById('projOffsetXVal2');
  const projOffsetY2 = document.getElementById('projOffsetY2');
  const projOffsetYVal2 = document.getElementById('projOffsetYVal2');
  const projResetBtn2 = document.getElementById('projResetBtn2');
  const projCopyBtn2 = document.getElementById('projCopyBtn2');
  
  // Show/hide floating panel based on geo view state
  function updateProjectionPanelVisibility() {
    if (projectionPanel) {
      projectionPanel.style.display = geoViewState.active ? 'block' : 'none';
    }
  }
  
  // Sync floating panel controls with geoViewState
  function syncFloatingPanelControls() {
    const adj = geoViewState.projectionAdjust;
    if (projScaleX2) projScaleX2.value = adj.scaleX;
    if (projScaleXVal2) projScaleXVal2.value = adj.scaleX;
    if (projScaleY2) projScaleY2.value = adj.scaleY;
    if (projScaleYVal2) projScaleYVal2.value = adj.scaleY;
    if (projOffsetX2) projOffsetX2.value = adj.offsetX;
    if (projOffsetXVal2) projOffsetXVal2.value = adj.offsetX;
    if (projOffsetY2) projOffsetY2.value = adj.offsetY;
    if (projOffsetYVal2) projOffsetYVal2.value = adj.offsetY;
  }
  
  // Update from floating panel controls
  function updateFromFloatingPanel() {
    geoViewState.projectionAdjust.scaleX = parseFloat(projScaleX2?.value) || 1.0;
    geoViewState.projectionAdjust.scaleY = parseFloat(projScaleY2?.value) || 1.0;
    geoViewState.projectionAdjust.offsetX = parseFloat(projOffsetX2?.value) || 0;
    geoViewState.projectionAdjust.offsetY = parseFloat(projOffsetY2?.value) || 0;
    
    // Sync number inputs
    if (projScaleXVal2) projScaleXVal2.value = geoViewState.projectionAdjust.scaleX;
    if (projScaleYVal2) projScaleYVal2.value = geoViewState.projectionAdjust.scaleY;
    if (projOffsetXVal2) projOffsetXVal2.value = geoViewState.projectionAdjust.offsetX;
    if (projOffsetYVal2) projOffsetYVal2.value = geoViewState.projectionAdjust.offsetY;
    
    // Also sync menu controls
    updateControlsFromProjection();
    
    // Save to localStorage
    try {
      localStorage.setItem('neximap-geo-projection-adjust', JSON.stringify(geoViewState.projectionAdjust));
    } catch(e) {}
    
    if (geoViewState.active) render();
  }
  
  // Close button
  if (projPanelClose) {
    projPanelClose.addEventListener('click', () => {
      if (projectionPanel) projectionPanel.style.display = 'none';
    });
  }
  
  // Slider event handlers for floating panel
  if (projScaleX2) projScaleX2.addEventListener('input', updateFromFloatingPanel);
  if (projScaleY2) projScaleY2.addEventListener('input', updateFromFloatingPanel);
  if (projOffsetX2) projOffsetX2.addEventListener('input', updateFromFloatingPanel);
  if (projOffsetY2) projOffsetY2.addEventListener('input', updateFromFloatingPanel);
  
  // Number input event handlers for floating panel
  if (projScaleXVal2) {
    projScaleXVal2.addEventListener('change', () => {
      if (projScaleX2) projScaleX2.value = projScaleXVal2.value;
      updateFromFloatingPanel();
    });
  }
  if (projScaleYVal2) {
    projScaleYVal2.addEventListener('change', () => {
      if (projScaleY2) projScaleY2.value = projScaleYVal2.value;
      updateFromFloatingPanel();
    });
  }
  if (projOffsetXVal2) {
    projOffsetXVal2.addEventListener('change', () => {
      if (projOffsetX2) projOffsetX2.value = projOffsetXVal2.value;
      updateFromFloatingPanel();
    });
  }
  if (projOffsetYVal2) {
    projOffsetYVal2.addEventListener('change', () => {
      if (projOffsetY2) projOffsetY2.value = projOffsetYVal2.value;
      updateFromFloatingPanel();
    });
  }
  
  // Reset button for floating panel
  if (projResetBtn2) {
    projResetBtn2.addEventListener('click', () => {
      geoViewState.projectionAdjust = { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 };
      syncFloatingPanelControls();
      updateControlsFromProjection();
      try {
        localStorage.removeItem('neximap-geo-projection-adjust');
      } catch(e) {}
      if (geoViewState.active) render();
      showToast('üîÑ Projection reset to defaults');
    });
  }
  
  // Copy button for floating panel
  if (projCopyBtn2) {
    projCopyBtn2.addEventListener('click', () => {
      const adj = geoViewState.projectionAdjust;
      const values = `scaleX: ${adj.scaleX}, scaleY: ${adj.scaleY}, offsetX: ${adj.offsetX}, offsetY: ${adj.offsetY}`;
      navigator.clipboard.writeText(values).then(() => {
        showToast('üìã Values copied: ' + values);
      }).catch(() => {
        showToast('üìã ' + values);
      });
    });
  }
  
  // Initialize floating panel state
  syncFloatingPanelControls();
  // ============ END FLOATING PROJECTION PANEL ============
  
  if (mapSourceUrl) {
    mapSourceUrl.addEventListener('change', () => {
      if (mapSourceUrl.checked) {
        geoViewState.mapSource = 'url';
        saveCustomMapSettings();
        if (geoViewState.active) render();
      }
    });
  }
  
  if (mapSourceUpload) {
    mapSourceUpload.addEventListener('change', () => {
      if (mapSourceUpload.checked) {
        if (!geoViewState.customMapImage) {
          showToast('‚ö†Ô∏è No uploaded map - please upload one first');
          updateMapSourceRadios();
          return;
        }
        geoViewState.mapSource = 'upload';
        saveCustomMapSettings();
        if (geoViewState.active) render();
      }
    });
  }
  
  if (mapSourceBuiltin) {
    mapSourceBuiltin.addEventListener('change', () => {
      if (mapSourceBuiltin.checked) {
        geoViewState.mapSource = 'builtin';
        saveCustomMapSettings();
        if (geoViewState.active) render();
      }
    });
  }
  
  // Load map from URL handler
  if (miLoadMapUrl) {
    miLoadMapUrl.addEventListener('click', () => {
      closeAllMenus();
      showMapUrlDialog();
    });
  }
  
  // Upload map image handler
  if (miUploadGeoMap) {
    miUploadGeoMap.addEventListener('click', () => {
      closeAllMenus();
      
      // Create file input
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (ev) => {
          const dataUrl = ev.target.result;
          
          // Show bounds configuration dialog
          showMapBoundsDialog(dataUrl, 'upload');
        };
        reader.readAsDataURL(file);
      };
      input.click();
    });
  }
  
  // Save custom map settings to localStorage
  function saveCustomMapSettings() {
    try {
      localStorage.setItem('neximap-geo-custom-map', JSON.stringify({
        mapSource: geoViewState.mapSource,
        image: geoViewState.customMapImage,
        mapUrl: geoViewState.mapUrl,
        bounds: geoViewState.customMapBounds,
        useCustomMap: geoViewState.mapSource !== 'builtin'
      }));
    } catch (e) {
      console.warn('Could not save custom map to localStorage:', e);
    }
  }
  
  // Show dialog to load map from URL
  function showMapUrlDialog() {
    const modal = document.createElement('div');
    modal.id = 'geoMapUrlModal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); z-index: 10000;
      display: flex; align-items: center; justify-content: center;
    `;
    
    modal.innerHTML = `
      <div style="background: white; border-radius: 12px; padding: 24px; max-width: 550px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
        <h3 style="margin: 0 0 16px; color: #1d4ed8;">üîó Load Map from URL</h3>
        <p style="color: #666; font-size: 13px; margin-bottom: 16px;">
          Enter the URL of an <strong>Equirectangular projection</strong> map image (PNG, JPG, or SVG).
        </p>
        
        <div style="margin-bottom: 16px;">
          <label style="font-size: 11px; font-weight: 600; color: #555;">Map URL</label>
          <input type="url" id="mapUrlInput" value="${geoViewState.mapUrl || geoViewState.defaultMapUrl}" 
                 placeholder="https://example.com/world-map.svg"
                 style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; box-sizing: border-box;">
        </div>
        
        <div style="background: #f0f9ff; padding: 12px; border-radius: 6px; margin-bottom: 16px;">
          <div style="font-size: 11px; font-weight: 600; color: #1e40af; margin-bottom: 8px;">üìã Preset Maps</div>
          <button class="preset-btn" data-url="https://upload.wikimedia.org/wikipedia/commons/9/9f/BlankMap-World-Equirectangular.svg" 
                  style="display: block; width: 100%; text-align: left; padding: 8px; margin-bottom: 4px; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 11px;">
            üåç Wikimedia Blank World Map (SVG)
          </button>
          <button class="preset-btn" data-url="https://upload.wikimedia.org/wikipedia/commons/e/e8/Equirectangular_projection_SW.jpg"
                  style="display: block; width: 100%; text-align: left; padding: 8px; margin-bottom: 4px; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 11px;">
            üó∫Ô∏è Wikimedia Physical Map (JPG)
          </button>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Min Latitude (South)</label>
            <input type="number" id="urlMapMinLat" value="-85.05" min="-90" max="90" step="0.01" 
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Max Latitude (North)</label>
            <input type="number" id="urlMapMaxLat" value="85.05" min="-90" max="90" step="0.01"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Min Longitude (West)</label>
            <input type="number" id="urlMapMinLon" value="-180" min="-180" max="180" step="0.1"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Max Longitude (East)</label>
            <input type="number" id="urlMapMaxLon" value="180" min="-180" max="180" step="0.1"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
        </div>
        
        <div style="display: flex; gap: 12px; justify-content: flex-end;">
          <button id="mapUrlCancel" style="padding: 10px 20px; border: 1px solid #ddd; background: #f5f5f5; border-radius: 6px; cursor: pointer;">Cancel</button>
          <button id="mapUrlApply" style="padding: 10px 20px; border: none; background: #1d4ed8; color: white; border-radius: 6px; cursor: pointer; font-weight: 600;">Load Map</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Preset button handlers
    modal.querySelectorAll('.preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.getElementById('mapUrlInput').value = btn.dataset.url;
        // Auto-set bounds for known maps
        const url = btn.dataset.url;
        if (url.includes('BlankMap-World-Equirectangular') || url.includes('Equirectangular_projection')) {
          document.getElementById('urlMapMinLat').value = '-85.05';
          document.getElementById('urlMapMaxLat').value = '85.05';
        }
      });
    });
    
    // Event handlers
    document.getElementById('mapUrlCancel').onclick = () => modal.remove();
    
    document.getElementById('mapUrlApply').onclick = () => {
      const url = document.getElementById('mapUrlInput').value.trim();
      if (!url) {
        showToast('‚ö†Ô∏è Please enter a URL');
        return;
      }
      
      const bounds = {
        minLat: parseFloat(document.getElementById('urlMapMinLat').value) || -85.05,
        maxLat: parseFloat(document.getElementById('urlMapMaxLat').value) || 85.05,
        minLon: parseFloat(document.getElementById('urlMapMinLon').value) || -180,
        maxLon: parseFloat(document.getElementById('urlMapMaxLon').value) || 180
      };
      
      geoViewState.mapUrl = url;
      geoViewState.mapBounds = { ...bounds };
      geoViewState.customMapBounds = bounds;
      geoViewState.mapSource = 'url';
      
      updateMapSourceRadios();
      saveCustomMapSettings();
      modal.remove();
      
      if (geoViewState.active) {
        render();
      } else {
        toggleGeoView(true);
        if (geoViewOptions) geoViewOptions.style.display = '';
        if (viewModeGeo) viewModeGeo.checked = true;
      }
      
      showToast('üó∫Ô∏è Map loaded from URL!');
    };
    
    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
  }
  
  // Show dialog to configure map bounds (for uploaded images)
  function showMapBoundsDialog(imageDataUrl, source = 'upload') {
    // Create modal dialog
    const modal = document.createElement('div');
    modal.id = 'geoMapBoundsModal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); z-index: 10000;
      display: flex; align-items: center; justify-content: center;
    `;
    
    modal.innerHTML = `
      <div style="background: white; border-radius: 12px; padding: 24px; max-width: 500px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
        <h3 style="margin: 0 0 16px; color: #1d4ed8;">üó∫Ô∏è Configure Map Bounds</h3>
        <p style="color: #666; font-size: 13px; margin-bottom: 16px;">
          Specify the geographic bounds of your map image. For a standard world map (Equirectangular/EPSG:4326), use the default values.
        </p>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Min Latitude (South)</label>
            <input type="number" id="mapBoundMinLat" value="-85.05" min="-90" max="90" step="0.01" 
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Max Latitude (North)</label>
            <input type="number" id="mapBoundMaxLat" value="85.05" min="-90" max="90" step="0.01"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Min Longitude (West)</label>
            <input type="number" id="mapBoundMinLon" value="-180" min="-180" max="180" step="0.1"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Max Longitude (East)</label>
            <input type="number" id="mapBoundMaxLon" value="180" min="-180" max="180" step="0.1"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
        </div>
        
        <div style="background: #f0f9ff; padding: 10px; border-radius: 6px; margin-bottom: 16px; font-size: 11px; color: #1e40af;">
          <strong>üí° Common projections:</strong><br>
          ‚Ä¢ <strong>Equirectangular (EPSG:4326)</strong>: Use -85 to 85 lat, -180 to 180 lon<br>
          ‚Ä¢ <strong>Web Mercator</strong>: Use -85.05 to 85.05 lat, -180 to 180 lon
        </div>
        
        <div style="display: flex; gap: 12px; justify-content: flex-end;">
          <button id="mapBoundsCancel" style="padding: 10px 20px; border: 1px solid #ddd; background: #f5f5f5; border-radius: 6px; cursor: pointer;">Cancel</button>
          <button id="mapBoundsApply" style="padding: 10px 20px; border: none; background: #1d4ed8; color: white; border-radius: 6px; cursor: pointer; font-weight: 600;">Apply Map</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Event handlers
    document.getElementById('mapBoundsCancel').onclick = () => modal.remove();
    
    document.getElementById('mapBoundsApply').onclick = () => {
      const bounds = {
        minLat: parseFloat(document.getElementById('mapBoundMinLat').value) || -85.05,
        maxLat: parseFloat(document.getElementById('mapBoundMaxLat').value) || 85.05,
        minLon: parseFloat(document.getElementById('mapBoundMinLon').value) || -180,
        maxLon: parseFloat(document.getElementById('mapBoundMaxLon').value) || 180
      };
      
      // Update geoViewState for uploaded image
      geoViewState.mapBounds = { ...bounds };
      geoViewState.customMapImage = imageDataUrl;
      geoViewState.customMapBounds = bounds;
      geoViewState.mapSource = 'upload';
      
      updateMapSourceRadios();
      saveCustomMapSettings();
      modal.remove();
      
      if (geoViewState.active) {
        render();
      } else {
        toggleGeoView(true);
        if (geoViewOptions) geoViewOptions.style.display = '';
        if (viewModeGeo) viewModeGeo.checked = true;
      }
      
      showToast('üó∫Ô∏è Uploaded map applied!');
    };
    
    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
  }
  
  // Update inspector to include GPS fields
  const origUpdateInspector = updateInspector;
  window.updateInspectorWithGps = function() {
    origUpdateInspector();
    if (state.selected?.type === 'node') {
      const n = findNode(state.selected.id);
      if (n) updateGpsFields(n);
    }
  };
  
  // Hook into inspector updates
  if (typeof updateInspector === 'function') {
    const hookedUpdateInspector = updateInspector;
    window.updateInspector = function() {
      hookedUpdateInspector();
      if (state.selected?.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) updateGpsFields(n);
      }
    };
  }
  
  // ============== END GEOGRAPHIC VIEW ==============



  showToast('Welcome to NexiMap Studio ‚Äî double-click to create a node.');
})();
</script>

<!-- Print Preview Modal -->
<div id="printPreviewModal">
  <div id="printPreviewContent">
    <div id="printPreviewHeader">
      <h3>Print Preview</h3>
      <div id="printPreviewControls">
        <label style="font-size:13px;">
          Page Size:
          <select id="printPageSize" style="margin-left:4px; padding:4px;">
            <option value="a4">A4</option>
            <option value="letter">Letter</option>
            <option value="a3">A3</option>
            <option value="fit">Fit Content</option>
          </select>
        </label>
        <label style="font-size:13px;">
          Orientation:
          <select id="printOrientation" style="margin-left:4px; padding:4px;">
            <option value="landscape">Landscape</option>
            <option value="portrait">Portrait</option>
          </select>
        </label>
        <label style="font-size:13px;">
          <input type="checkbox" id="printShowGrid" style="margin-right:4px;" />
          Show Grid
        </label>
        <button class="btn primary" id="btnDoPrint">Print</button>
        <button class="btn" id="btnClosePrintPreview">Close</button>
      </div>
    </div>
    <div id="printPreviewBody">
      <div id="printPreviewPage">
        <!-- SVG preview will be inserted here -->
      </div>
    </div>
  </div>
</div>

<script>
(function() {
  const printPreviewModal = document.getElementById('printPreviewModal');
  const printPreviewPage = document.getElementById('printPreviewPage');
  const printPageSize = document.getElementById('printPageSize');
  const printOrientation = document.getElementById('printOrientation');
  const printShowGrid = document.getElementById('printShowGrid');
  const btnDoPrint = document.getElementById('btnDoPrint');
  const btnClosePrintPreview = document.getElementById('btnClosePrintPreview');
  const miPrintPreview = document.getElementById('miPrintPreview');
  const miPrint = document.getElementById('miPrint');

  // Page sizes in mm (width x height for portrait)
  const pageSizes = {
    a4: { w: 297, h: 210 },      // landscape by default
    letter: { w: 279, h: 216 },  // landscape by default
    a3: { w: 420, h: 297 },      // landscape by default
    fit: { w: 0, h: 0 }          // will be calculated
  };

  function generatePrintSVG(showGrid = false) {
    const svg = document.getElementById('svg');
    const clone = svg.cloneNode(true);
    
    // Remove grid if not wanted
    if (!showGrid) {
      const gridElements = clone.querySelectorAll('.grid');
      gridElements.forEach(el => el.remove());
    }
    
    // Remove selection highlights
    clone.querySelectorAll('.node-selected, .edge.selected, .group-selected').forEach(el => {
      el.classList.remove('node-selected', 'selected', 'group-selected');
    });
    
    // Remove resize handles - they are editing aids, not part of the printed output
    clone.querySelectorAll('.group-handle').forEach(el => el.remove());
    clone.querySelectorAll('.node-resize-handle').forEach(el => el.remove());
    
    // Remove marquee if any
    const marquee = clone.querySelector('.marquee');
    if (marquee) marquee.remove();
    
    return clone;
  }

  function updatePrintPreview() {
    const size = printPageSize.value;
    const orientation = printOrientation.value;
    const showGrid = printShowGrid.checked;
    
    let pageW, pageH;
    
    if (size === 'fit') {
      // Calculate bounding box of content
      const svg = document.getElementById('svg');
      const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
      pageW = viewBox[2];
      pageH = viewBox[3];
    } else {
      const dims = pageSizes[size];
      if (orientation === 'landscape') {
        pageW = Math.max(dims.w, dims.h);
        pageH = Math.min(dims.w, dims.h);
      } else {
        pageW = Math.min(dims.w, dims.h);
        pageH = Math.max(dims.w, dims.h);
      }
    }
    
    // Scale for preview (mm to pixels, roughly)
    const scale = size === 'fit' ? 0.5 : 2;
    const previewW = pageW * scale;
    const previewH = pageH * scale;
    
    const printSVG = generatePrintSVG(showGrid);
    printSVG.setAttribute('width', previewW);
    printSVG.setAttribute('height', previewH);
    printSVG.style.background = '#fff';
    
    printPreviewPage.innerHTML = '';
    printPreviewPage.style.width = previewW + 'px';
    printPreviewPage.style.height = previewH + 'px';
    printPreviewPage.appendChild(printSVG);
  }

  function showPrintPreview() {
    printPreviewModal.classList.add('show');
    updatePrintPreview();
  }

  function closePrintPreview() {
    printPreviewModal.classList.remove('show');
  }

  function doPrint() {
    closePrintPreview();
    setTimeout(() => {
      window.print();
    }, 100);
  }

  // Event listeners
  if (miPrintPreview) {
    miPrintPreview.addEventListener('click', () => {
      showPrintPreview();
      // Close file menu
      const fileMenu = document.getElementById('fileMenu');
      if (fileMenu) fileMenu.hidden = true;
    });
  }

  if (miPrint) {
    miPrint.addEventListener('click', () => {
      // Close file menu
      const fileMenu = document.getElementById('fileMenu');
      if (fileMenu) fileMenu.hidden = true;
      window.print();
    });
  }

  if (btnDoPrint) btnDoPrint.addEventListener('click', doPrint);
  if (btnClosePrintPreview) btnClosePrintPreview.addEventListener('click', closePrintPreview);
  
  if (printPageSize) printPageSize.addEventListener('change', updatePrintPreview);
  if (printOrientation) printOrientation.addEventListener('change', updatePrintPreview);
  if (printShowGrid) printShowGrid.addEventListener('change', updatePrintPreview);

  // Close on escape
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && printPreviewModal.classList.contains('show')) {
      closePrintPreview();
    }
  });

  // Close on background click
  printPreviewModal.addEventListener('click', (e) => {
    if (e.target === printPreviewModal) {
      closePrintPreview();
    }
  });

  // Ctrl+P shortcut
  document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
      e.preventDefault();
      window.print();
    }
  });
})();
</script>
</body>
</html>
