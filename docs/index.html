<!doctype html>
<html lang="en">
<!--
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!                                                                 !!
  !!   THIS IS THE DEVELOPMENT WORKING COPY                          !!
  !!                                                                 !!
  !!   The live / production site is served from /index.html          !!
  !!   (repository root).  This docs/index.html is the development   !!
  !!   copy where changes are made, then merged into root/index.html !!
  !!   via Pull Request.                                             !!
  !!                                                                 !!
  !!   KNOWN "Failed to fetch" ERRORS DURING DEVELOPMENT:            !!
  !!   This file references data files at relative path "data/..."   !!
  !!   (e.g. data/telegeography_cables.json,                         !!
  !!   data/cable_stations_db.json, data/peeringdb_facilities.json). !!
  !!   Those files live at the REPOSITORY ROOT under /data/ and are  !!
  !!   NOT present in /docs/data/.                                   !!
  !!   When running this file directly, any feature that loads local  !!
  !!   data will show "Failed to load: Failed to fetch".             !!
  !!   This is expected and does NOT affect production.               !!
  !!                                                                 !!
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->
<!--
  ====================== ENCODING WARNING ======================
  This file has 448+ UTF-8 emoji chars that WILL BREAK if edited
  with text-mode tools (str_replace, sed, awk, Python text I/O).

  ONLY EDIT via Python raw bytes: open(path,'rb') / open(path,'wb')
  VALIDATE after every edit - see NEXIMAP_VERSION_SUMMARY.md
  If encoding breaks, start over from the clean source file.
  ===============================================================
-->
<!-- NexiMap Studio v62.2 - Ocean corridors, map styles, unified visor source - 2026-02-24 -->
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NexiMap Studio</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%23667eea'/%3E%3Cstop offset='100%25' stop-color='%23764ba2'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect x='2' y='2' width='28' height='28' rx='4' fill='url(%23g)'/%3E%3Cpath d='M8 8H24M8 16H24M8 24H24M8 8V24M16 8V24M24 8V24' stroke='white' stroke-width='0.8' opacity='0.2'/%3E%3Cpath d='M8 8L16 16L24 8M16 16L8 24M16 16L24 24' stroke='white' stroke-width='1.8' stroke-linecap='round'/%3E%3Ccircle cx='8' cy='8' r='2.5' fill='white'/%3E%3Ccircle cx='24' cy='8' r='2.5' fill='white'/%3E%3Ccircle cx='16' cy='16' r='3' fill='white'/%3E%3Ccircle cx='8' cy='24' r='2.5' fill='white'/%3E%3Ccircle cx='24' cy='24' r='2.5' fill='white'/%3E%3C/svg%3E" />
  <!-- MapLibre GL JS for interactive maps -->
  <link href="https://unpkg.com/maplibre-gl@4.1.0/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@4.1.0/dist/maplibre-gl.js"></script>
  <style>
    :root { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif; }
    body { margin: 0; background:#ffffff; color:#333; }
    header {
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      padding:0; border-bottom:1px solid #e0e0e0;
      position: sticky; top: 0; background:#fafafa; z-index: 10;
    }

    /* MapLibre container styles */
    #maplibreContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
    }
    #maplibreContainer.active {
      display: block;
    }
    /* When map is active, prevent parent scrollbars from interfering */
    #wrap:has(#maplibreContainer.active) {
      overflow: hidden !important;
    }
    /* Ensure maplibreMap fills container */
    #maplibreMap {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }

    /* Path Edit Mode Banner */
    #pathEditModeBanner {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      color: white;
      padding: 8px 16px;
      z-index: 10001;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    #pathEditModeBanner.active {
      display: block;
    }
    #pathEditModeBanner .banner-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-width: 100%;
      gap: 16px;
    }
    #pathEditModeBanner .banner-info {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    #pathEditModeBanner .banner-icon {
      font-size: 20px;
    }
    #pathEditModeBanner .banner-title {
      font-weight: 700;
      font-size: 14px;
    }
    #pathEditModeBanner .banner-subtitle {
      font-size: 12px;
      opacity: 0.9;
    }
    #pathEditModeBanner .banner-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 12px;
      background: rgba(255,255,255,0.2);
      border-radius: 20px;
      font-size: 12px;
    }
    #pathEditModeBanner .banner-status.unsaved {
      background: rgba(239, 68, 68, 0.4);
    }
    #pathEditModeBanner .banner-actions {
      display: flex;
      gap: 8px;
    }
    #pathEditModeBanner .banner-btn {
      padding: 6px 16px;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    #pathEditModeBanner .banner-btn.save {
      background: white;
      color: #d97706;
    }
    #pathEditModeBanner .banner-btn.save:hover {
      background: #fef3c7;
    }
    #pathEditModeBanner .banner-btn.exit {
      background: rgba(255,255,255,0.2);
      color: white;
    }
    #pathEditModeBanner .banner-btn.exit:hover {
      background: rgba(255,255,255,0.3);
    }

    /* Path Edit Mode Overlay - dims everything else */
    #pathEditModeOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.3);
      z-index: 9999;
      pointer-events: none;
    }
    #pathEditModeOverlay.active {
      display: block;
    }

    /* Path Edit Control Panel */
    #pathEditControlPanel {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.25);
      z-index: 10002;
      width: 320px;
      max-height: calc(100vh - 150px);
      overflow: hidden;
    }
    #pathEditControlPanel.active {
      display: block;
    }
    #pathEditControlPanel.minimized .control-body {
      display: none;
    }
    #pathEditControlPanel.minimized {
      width: auto;
    }
    #pathEditControlPanel .control-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: white;
      cursor: move;
      user-select: none;
    }
    #pathEditControlPanel .control-title {
      font-weight: 600;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #pathEditControlPanel .control-header-btns {
      display: flex;
      gap: 4px;
    }
    #pathEditControlPanel .control-header-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #pathEditControlPanel .control-header-btn:hover {
      background: rgba(255,255,255,0.3);
    }
    #pathEditControlPanel .waypoint-count {
      font-size: 11px;
      color: rgba(255,255,255,0.9);
      background: rgba(255,255,255,0.2);
      padding: 2px 8px;
      border-radius: 10px;
    }
    #pathEditControlPanel .control-body {
      padding: 16px;
      max-height: calc(100vh - 250px);
      overflow-y: auto;
    }
    #pathEditControlPanel .edit-methods {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    #pathEditControlPanel .method-btn {
      flex: 1;
      padding: 10px 8px;
      border: 2px solid #e5e7eb;
      border-radius: 8px;
      background: white;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }
    #pathEditControlPanel .method-btn:hover {
      border-color: #3b82f6;
      background: #eff6ff;
    }
    #pathEditControlPanel .method-btn.active {
      border-color: #3b82f6;
      background: #dbeafe;
    }
    #pathEditControlPanel .method-btn .method-icon {
      font-size: 18px;
      display: block;
      margin-bottom: 4px;
    }
    #pathEditControlPanel .method-btn .method-label {
      font-size: 10px;
      font-weight: 600;
      color: #374151;
    }
    #pathEditControlPanel .control-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #e5e7eb;
    }
    #pathEditControlPanel .control-btn {
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    #pathEditControlPanel .control-btn.secondary {
      background: #f3f4f6;
      border: 1px solid #d1d5db;
      color: #374151;
    }
    #pathEditControlPanel .control-btn.secondary:hover {
      background: #e5e7eb;
    }
    #pathEditControlPanel .control-btn.primary {
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      border: none;
      color: white;
    }
    #pathEditControlPanel .control-btn.primary:hover {
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
    }
    #pathEditControlPanel .control-btn.danger {
      background: #fef2f2;
      border: 1px solid #fecaca;
      color: #dc2626;
    }
    #pathEditControlPanel .control-btn.danger:hover {
      background: #fee2e2;
    }
    .maplibregl-map {
      width: 100%;
      height: 100%;
    }
    /* Custom marker styles for MapLibre */
    .maplibre-node-marker {
      cursor: pointer;
      transition: transform 0.15s ease;
    }
    .maplibre-node-marker:hover {
      transform: scale(1.15);
    }
    .maplibre-node-label {
      background: rgba(255,255,255,0.9);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
      font-weight: 500;
      white-space: nowrap;
      pointer-events: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    /* Menu Bar Items */
    .menu-item {
      background: transparent;
      border: none;
      color: #444;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 13px;
      border-radius: 4px;
    }
    .menu-item:hover { background: #e8e8e8; }

    /* Tool Buttons */
    .tool-btn {
      background: transparent;
      border: 1px solid transparent;
      color: #555;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 16px;
      border-radius: 4px;
      min-width: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .tool-btn:hover { background: #e8e8e8; border-color: #d0d0d0; }
    .tool-btn.active, .tool-btn.primary {
      background: #d0e8f5;
      color: #0066a0;
      border-color: #0096D6;
    }
    .tool-btn.shape-tool.active {
      background: #d0e8f5;
      color: #0066a0;
      border-color: #0096D6;
    }
    .tool-btn.active svg, .tool-btn.primary svg,
    .tool-btn.shape-tool.active svg {
      stroke: #0066a0;
    }

    .tool-sep { width: 1px; height: 24px; background: #d0d0d0; margin: 0 6px; }

    /* Toggle items in menu */
    .toggle-item { display: flex; align-items: center; gap: 8px; }
    .toggle-item input { accent-color: #0096D6; }

    /* Menu section headers */
    .menu-section-header {
      padding: 6px 12px 4px;
      font-size: 10px;
      font-weight: 600;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      background: #f8f8f8;
    }

    /* Inspector inline field controls */
    .field-with-controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .field-with-controls input,
    .field-with-controls textarea {
      flex: 1;
      min-width: 0;
    }
    .field-inline-controls {
      display: flex;
      align-items: center;
      gap: 3px;
      flex-shrink: 0;
    }
    .field-color-swatch {
      width: 20px;
      height: 20px;
      border: 1px solid #999;
      border-radius: 3px;
      cursor: pointer;
      position: relative;
    }
    .field-color-swatch:hover {
      border-color: #666;
    }
    .field-color-swatch input[type="color"] {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }
    .field-visibility-btn {
      width: 22px;
      height: 22px;
      border: 1px solid #ccc;
      border-radius: 3px;
      background: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      font-size: 12px;
      padding: 0;
    }
    .field-visibility-btn:hover {
      background: #f0f0f0;
      border-color: #999;
    }
    .field-visibility-btn.hidden {
      background: #f5f5f5;
      color: #bbb;
    }
    .field-visibility-btn svg {
      width: 14px;
      height: 14px;
    }
    .field-font-select {
      width: 52px;
      padding: 2px 4px;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 11px;
      background: #fff;
      cursor: pointer;
    }
    .field-font-select:hover {
      border-color: #999;
    }

    /* Inspector collapsible sections */
    .inspector-section {
      border-bottom: 1px solid #e8e8e8;
      margin-bottom: 0;
    }
    .inspector-section:last-child {
      border-bottom: none;
    }
    .inspector-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: #f8f9fa;
      cursor: pointer;
      user-select: none;
      font-size: 11px;
      font-weight: 600;
      color: #555;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    .inspector-section-header:hover {
      background: #f0f1f2;
    }
    .inspector-section-header .section-icon {
      font-size: 10px;
      color: #888;
      transition: transform 0.2s;
    }
    .inspector-section.collapsed .section-icon {
      transform: rotate(-90deg);
    }
    .inspector-section-content {
      padding: 10px 12px;
    }
    .inspector-section.collapsed .inspector-section-content {
      display: none;
    }
    .inspector-section-content .row {
      margin-bottom: 10px;
    }
    .inspector-section-content .row:last-child {
      margin-bottom: 0;
    }

    .btn {
      background:#fff; border:1px solid #d0d0d0; color:#333;
      padding:6px 10px; border-radius:6px; cursor:pointer; font-weight:500; font-size: 12px;
    }
    .btn:hover { background:#f5f5f5; border-color:#bbb; }
    .btn.primary { background:#0096D6; border-color:#0096D6; color:#fff; }
    .btn.primary:hover { background:#0080b8; }
    .mini-btn { padding:4px 8px; font-size:11px; }
    .hint { opacity:.7; font-size: 12px; color:#666; }
    input[type="file"]{ display:none; }

    #layout { display: flex; height: calc(100vh - 110px); position: relative; }
    #wrap {
      flex: 1;
      position: relative;
      overflow: auto;
      background: #f0f0f0;
      min-width: 0;
    }
    /* Ensure scrollbars are styled and visible */
    #wrap::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }
    #wrap::-webkit-scrollbar-track {
      background: #e0e0e0;
      border-radius: 6px;
    }
    #wrap::-webkit-scrollbar-thumb {
      background: #a0a0a0;
      border-radius: 6px;
      border: 2px solid #e0e0e0;
    }
    #wrap::-webkit-scrollbar-thumb:hover {
      background: #888;
    }
    #wrap::-webkit-scrollbar-corner {
      background: #e0e0e0;
    }
    #inspector {
      position: absolute;
      right: 20px;
      top: 20px;
      width: 340px;
      max-height: calc(100vh - 160px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 100;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      resize: horizontal;
      min-width: 280px;
      max-width: 500px;
    }
    #inspector.minimized {
      height: 40px !important;
      max-height: 40px;
      resize: none;
    }

    /* Cable System Navigator Panel */
    #cableNavigator {
      position: absolute;
      left: 20px;
      top: 20px;
      width: 280px;
      max-height: calc(100vh - 160px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 100;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      resize: both;
      min-width: 220px;
      max-width: 400px;
      min-height: 200px;
    }
    #cableNavigator.minimized {
      height: 40px !important;
      max-height: 40px;
      resize: none;
    }

    /* Cable System Inspector Panel */
    #cableSystemInspectorPanel {
      position: absolute;
      left: 320px;
      top: 20px;
      width: 340px;
      max-height: calc(100vh - 160px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 100;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      resize: both;
      min-width: 280px;
      max-width: 500px;
      min-height: 200px;
    }
    #cableSystemInspectorPanel.minimized {
      height: 40px !important;
      max-height: 40px;
      resize: none;
    }
    #cableInspectorHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: #e8f4e8;
      border-bottom: 1px solid #e0e0e0;
      cursor: move;
      user-select: none;
    }
    #cableInspectorHeader h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }
    #cableInspectorControls {
      display: flex;
      gap: 4px;
    }
    #cableInspectorControls button {
      background: transparent;
      border: 1px solid #d0d0d0;
      color: #666;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #cableInspectorControls button:hover { background: #e8e8e8; }
    #cableInspectorContent {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }
    #cableInspectorContent .row { margin-bottom: 10px; }
    #cableInspectorContent label { display: block; font-size: 11px; color: #555; margin-bottom: 4px; font-weight: 500; }
    #cableInspectorContent input, #cableInspectorContent select, #cableInspectorContent textarea {
      width: 100%; box-sizing: border-box;
      padding: 6px 8px; border: 1px solid #d0d0d0; border-radius: 4px; font-size: 12px;
    }
    #cableInspectorContent .inline { display: flex; gap: 8px; }
    #cableInspectorContent .inline > div { flex: 1; }

    #cableNavigatorHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: #f0f4f8;
      border-bottom: 1px solid #e0e0e0;
      cursor: move;
      user-select: none;
    }
    #cableNavigatorHeader h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }
    #cableNavigatorControls {
      display: flex;
      gap: 4px;
    }
    #cableNavigatorControls button {
      background: transparent;
      border: 1px solid #d0d0d0;
      color: #666;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #cableNavigatorControls button:hover { background: #e8e8e8; }
    #cableNavigatorContent {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .cable-system-item {
      padding: 8px 12px;
      border-bottom: 1px solid #f0f0f0;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .cable-system-item:hover { background: #f5f5f5; }
    .cable-system-item.selected { background: #e3f2fd; border-left: 3px solid #0096D6; }
    .cable-system-item.multi-selected { background: #fef3c7; border-left: 3px solid #f59e0b; }
    .cable-system-item.multi-selected.selected { background: #dbeafe; border-left: 3px solid #3b82f6; }
    .cable-system-item .cs-name { font-weight: 500; font-size: 12px; }
    .cable-system-item .cs-fullname { font-size: 10px; color: #666; }
    .cable-system-item .cs-count { font-size: 10px; color: #888; }

    /* Cable System Region Groups */
    .cs-region-group {
      margin-bottom: 4px;
    }
    .cs-region-header {
      padding: 6px 12px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-bottom: 1px solid #dee2e6;
      font-size: 11px;
      font-weight: 600;
      color: #495057;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 5;
    }
    .cs-region-header:hover { background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%); }
    .cs-region-header .region-toggle { font-size: 10px; color: #6c757d; }
    .cs-region-items { }
    .cs-region-items.collapsed { display: none; }

    /* RFS Status Badges (left dot - static lifecycle status) */
    .cs-status-badge {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 6px;
      flex-shrink: 0;
      background: #d1d5db;
    }
    .cs-status-badge.operational { background: #22c55e; box-shadow: 0 0 4px rgba(34, 197, 94, 0.5); }
    .cs-status-badge.planned { background: #3b82f6; box-shadow: 0 0 4px rgba(59, 130, 246, 0.5); }
    .cs-status-badge.under-construction { background: #f59e0b; box-shadow: 0 0 4px rgba(245, 158, 11, 0.5); }
    .cs-status-badge.decommissioned { background: #6b7280; }
    .cs-status-badge.unknown { background: #d1d5db; border: 1px dashed #9ca3af; }

    /* Live Status Badge (right side - real-time from FiberAtlantic) */
    .cs-live-badge {
      display: inline-flex; align-items: center; gap: 3px;
      font-size: 9px; font-weight: 600; padding: 1px 5px 1px 3px;
      border-radius: 3px; white-space: nowrap; cursor: help;
      line-height: 1.2;
    }
    .cs-live-badge .live-dot {
      display: inline-block; width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0;
    }
    /* Online / Active */
    .cs-live-badge.live-online {
      background: #f0fdf4; border: 1px solid #86efac; color: #166534;
    }
    .cs-live-badge.live-online .live-dot {
      background: #22c55e; box-shadow: 0 0 4px rgba(34,197,94,0.7);
      animation: pulse-green-dot 2s infinite;
    }
    /* Outage / Issue */
    .cs-live-badge.live-outage {
      background: #fef2f2; border: 1px solid #fca5a5; color: #991b1b;
    }
    .cs-live-badge.live-outage .live-dot {
      background: #ef4444; box-shadow: 0 0 4px rgba(239,68,68,0.7);
      animation: pulse-red-dot 1.5s infinite;
    }
    /* Degraded / Partial */
    .cs-live-badge.live-degraded {
      background: #fffbeb; border: 1px solid #fcd34d; color: #92400e;
    }
    .cs-live-badge.live-degraded .live-dot {
      background: #f59e0b; box-shadow: 0 0 4px rgba(245,158,11,0.7);
      animation: pulse-amber-dot 2s infinite;
    }
    /* Unknown / Loading / Unlinked */
    .cs-live-badge.live-unknown {
      background: #f8fafc; border: 1px solid #cbd5e1; color: #64748b;
    }
    .cs-live-badge.live-unknown .live-dot {
      background: #94a3b8;
    }
    /* Not linked (no FA) â€” subtle, doesn't distract */
    .cs-live-badge.live-none {
      background: #f9fafb; border: 1px solid #e5e7eb; color: #9ca3af;
    }
    .cs-live-badge.live-none .live-dot {
      background: #d1d5db;
    }

    @keyframes pulse-green-dot { 0%,100% { box-shadow: 0 0 3px rgba(34,197,94,0.4); } 50% { box-shadow: 0 0 7px rgba(34,197,94,0.9); } }
    @keyframes pulse-red-dot { 0%,100% { box-shadow: 0 0 3px rgba(239,68,68,0.4); } 50% { box-shadow: 0 0 8px rgba(239,68,68,1); } }
    @keyframes pulse-amber-dot { 0%,100% { box-shadow: 0 0 3px rgba(245,158,11,0.4); } 50% { box-shadow: 0 0 7px rgba(245,158,11,0.9); } }

    /* Legacy live classes kept for visor detail panel */
    .cs-status-badge.live-active { background: #22c55e; box-shadow: 0 0 6px rgba(34,197,94,0.7); animation: pulse-green-dot 2s infinite; }
    .cs-status-badge.live-issue { background: #ef4444; box-shadow: 0 0 6px rgba(239,68,68,0.7); animation: pulse-red-dot 1.5s infinite; }
    .cs-status-badge.live-unknown { background: #94a3b8; }

    /* FiberAtlantic link indicator in inspector */
    .fa-link-badge {
      font-size: 9px; padding: 1px 4px; border-radius: 3px;
      background: #f0fdf4; border: 1px solid #86efac; color: #166534;
      cursor: help; white-space: nowrap;
    }
    .fa-link-badge.unlinked { background: #f8fafc; border-color: #cbd5e1; color: #94a3b8; }

    /* Inline FA link button in navigator (for unlinked cables) */
    .btn-fa-inline-link:hover {
      background: #f0fdf4 !important; border-color: #86efac !important; color: #166534 !important;
    }

    /* Inline FA matching popover */
    .fa-inline-popover {
      position: absolute; z-index: 9999;
      background: white; border: 1px solid #d1d5db; border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15); width: 260px;
      font-size: 12px; overflow: hidden;
    }
    .fa-inline-popover-header {
      padding: 8px 10px; background: #f8fafc; border-bottom: 1px solid #e5e7eb;
      display: flex; justify-content: space-between; align-items: center;
    }
    .fa-inline-popover-header span { font-weight: 600; font-size: 11px; color: #374151; }
    .fa-inline-popover-search {
      width: 100%; padding: 6px 8px; border: none; border-bottom: 1px solid #e5e7eb;
      font-size: 11px; outline: none;
    }
    .fa-inline-popover-list {
      max-height: 180px; overflow-y: auto;
    }
    .fa-inline-popover-item {
      padding: 6px 10px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;
      border-bottom: 1px solid #f3f4f6; font-size: 11px;
    }
    .fa-inline-popover-item:hover { background: #f0fdf4; }
    .fa-inline-popover-item .fa-item-name { flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .fa-inline-popover-item .fa-item-status {
      font-size: 9px; padding: 1px 4px; border-radius: 3px; margin-left: 6px; flex-shrink: 0;
    }
    .fa-inline-popover-item .fa-item-status.online { background: #dcfce7; color: #166534; }
    .fa-inline-popover-item .fa-item-status.outage { background: #fee2e2; color: #991b1b; }
    .fa-inline-popover-item .fa-item-status.other { background: #f1f5f9; color: #475569; }

    /* Cable Visor Detail Panel (collapsible, below map, above list) */
    #cableVisorDetailPanel {
      background: linear-gradient(180deg, #f8fafc 0%, #ffffff 100%);
      border-top: 2px solid #0077b6;
      border-bottom: 1px solid #e0e0e0;
      display: none;
      font-size: 12px;
    }
    #cableVisorDetailPanel.show { display: block; }
    .visor-detail-header {
      display: flex; align-items: center; gap: 8px; padding: 10px 14px;
      cursor: pointer; user-select: none;
      background: linear-gradient(180deg, #e8f4f8 0%, #f0f7fa 100%);
      border-bottom: 1px solid #d0e4ed;
    }
    .visor-detail-header:hover { background: linear-gradient(180deg, #d9edf5 0%, #e4f0f6 100%); }
    .visor-detail-header h4 { margin: 0; font-size: 13px; font-weight: 600; color: #0077b6; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .visor-detail-toggle {
      font-size: 10px; color: #0077b6; transition: transform 0.2s; flex-shrink: 0;
      background: white; border: 1px solid #b8d8e8; border-radius: 3px; padding: 2px 5px;
    }
    .visor-detail-toggle.expanded { transform: rotate(180deg); }
    .visor-detail-expand-hint {
      font-size: 10px; color: #64748b; flex-shrink: 0;
    }
    .visor-detail-body {
      max-height: 0; overflow: hidden; transition: max-height 0.25s ease-out;
      padding: 0 14px;
    }
    .visor-detail-body.expanded {
      max-height: 300px; overflow-y: auto; padding: 4px 14px 12px;
    }
    #cableVisorDetailPanel.show .visor-detail-expand-hint.hidden { display: none; }
    .visor-detail-status {
      display: inline-flex; align-items: center; gap: 5px; padding: 3px 10px;
      border-radius: 12px; font-size: 11px; font-weight: 600;
    }
    .visor-detail-status.active { background: #dcfce7; color: #166534; }
    .visor-detail-status.issue { background: #fee2e2; color: #991b1b; }
    .visor-detail-status.unknown { background: #f1f5f9; color: #64748b; }
    .visor-detail-grid {
      display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
      gap: 8px; margin-bottom: 10px;
    }
    .visor-detail-item { background: #f8fafc; padding: 8px 10px; border-radius: 6px; border: 1px solid #e2e8f0; }
    .visor-detail-label { font-size: 10px; color: #64748b; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 3px; }
    .visor-detail-value { font-size: 13px; font-weight: 500; color: #1e293b; }
    .visor-landing-points { margin-top: 8px; }
    .visor-landing-points h5 { margin: 0 0 6px; font-size: 11px; color: #475569; text-transform: uppercase; letter-spacing: 0.5px; }
    .visor-lp-list { display: flex; flex-wrap: wrap; gap: 4px; }
    .visor-lp-tag {
      display: inline-flex; align-items: center; gap: 3px;
      padding: 3px 8px; background: #eff6ff; border: 1px solid #bfdbfe;
      border-radius: 4px; font-size: 10px; color: #1e40af;
    }
    .visor-lp-tag .lp-dot { width: 5px; height: 5px; border-radius: 50%; background: #3b82f6; }
    .visor-detail-close {
      background: none; border: none; color: #94a3b8; cursor: pointer;
      font-size: 16px; padding: 2px 6px; border-radius: 4px;
    }
    .visor-detail-close:hover { background: #f1f5f9; color: #475569; }

    /* Cable Visor Panel - Floating Draggable */
    #cableVisorPanel {
      position: absolute;
      left: 310px;
      top: 20px;
      width: 500px;
      height: 500px;
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      z-index: 150;
      display: none;
      flex-direction: column;
      overflow: hidden;
      resize: both;
      min-width: 350px;
      min-height: 300px;
      max-width: 90vw;
      max-height: calc(100vh - 100px);
    }
    #cableVisorPanel.maximized {
      position: fixed !important;
      width: 100vw !important;
      height: 100vh !important;
      left: 0 !important;
      top: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      border-radius: 0 !important;
      max-width: 100vw !important;
      max-height: 100vh !important;
      z-index: 99999 !important;
    }
    /* Presentation/fullscreen mode */
    #cableVisorPanel.presentation-mode {
      position: fixed !important;
      width: 100vw !important;
      height: 100vh !important;
      left: 0 !important;
      top: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      border-radius: 0 !important;
      max-width: 100vw !important;
      max-height: 100vh !important;
      z-index: 999999 !important;
      resize: none !important;
    }
    #cableVisorPanel.presentation-mode #cableVisorHeader {
      cursor: default;
    }
    .presentation-exit-btn {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 1000000;
      background: rgba(0,0,0,0.6);
      color: white;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      width: 36px;
      height: 36px;
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
      backdrop-filter: blur(4px);
    }
    .presentation-exit-btn:hover {
      background: rgba(220,38,38,0.8);
    }
    .presentation-esc-hint {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000000;
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 6px 16px;
      border-radius: 20px;
      font-size: 12px;
      pointer-events: none;
      backdrop-filter: blur(4px);
      opacity: 1;
      transition: opacity 1s ease-out;
    }
    #cableVisorPanel.show {
      display: flex;
    }
    #cableVisorHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      background: linear-gradient(135deg, #0077b6 0%, #0096c7 100%);
      border-bottom: 1px solid #0077b6;
      color: white;
      cursor: move;
      user-select: none;
      flex-shrink: 0;
    }
    #cableVisorHeader h3 {
      margin: 0;
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #cableVisorControls {
      display: flex;
      gap: 6px;
    }
    #cableVisorControls button {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 28px;
      height: 28px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }
    #cableVisorControls button:hover { background: rgba(255,255,255,0.3); }
    #cableVisorToolbar {
      padding: 10px 12px;
      background: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      flex-shrink: 0;
    }
    #cableVisorToolbar input[type="text"] {
      flex: 1;
      min-width: 120px;
      padding: 6px 10px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      font-size: 12px;
    }
    #cableVisorToolbar select {
      padding: 6px 10px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      font-size: 12px;
      background: white;
      max-width: 140px;
    }
    #cableVisorMap {
      flex: 1;
      min-height: 80px;
      background: #e0e7ef;
      position: relative;
    }
    #cableVisorMapResizeHandle {
      height: 7px;
      background: linear-gradient(180deg, #e0e0e0 0%, #d0d0d0 100%);
      cursor: ns-resize;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      user-select: none;
      border-top: 1px solid #ccc;
      border-bottom: 1px solid #ccc;
    }
    #cableVisorMapResizeHandle:hover, #cableVisorMapResizeHandle.dragging {
      background: linear-gradient(180deg, #b8d8e8 0%, #90c4d8 100%);
    }
    #cableVisorMapResizeHandle .resize-grip {
      width: 30px; height: 3px;
      border-top: 1px solid #999; border-bottom: 1px solid #999;
    }
    #cableVisorMapResizeHandle:hover .resize-grip, #cableVisorMapResizeHandle.dragging .resize-grip {
      border-color: #0077b6;
    }
    #cableVisorList {
      flex: 0 1 180px;
      min-height: 80px;
      overflow-y: auto;
      border-top: 1px solid #e0e0e0;
      background: white;
      resize: vertical;
    }
    .visor-cable-item {
      padding: 8px 12px;
      border-bottom: 1px solid #f0f0f0;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
    }
    .visor-cable-item:hover { background: #f5f5f5; }
    .visor-cable-item.selected { background: #e3f2fd; }
    .visor-cable-item input[type="checkbox"] {
      width: 14px;
      height: 14px;
      accent-color: #0077b6;
    }
    .visor-cable-item .cable-color {
      width: 12px;
      height: 3px;
      border-radius: 2px;
    }
    .visor-cable-info {
      flex: 1;
      min-width: 0;
    }
    .visor-cable-name {
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .visor-cable-meta {
      font-size: 10px;
      color: #666;
    }
    #cableVisorFooter {
      padding: 8px 12px;
      background: #f8f9fa;
      border-top: 1px solid #e0e0e0;
      font-size: 11px;
      color: #666;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    /* Visor Map Tooltip (hover over cables/stations) */
    .visor-map-tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(0,0,0,0.82);
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
      z-index: 200;
      transform: translate(-50%, -120%);
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      max-width: 280px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .visor-map-tooltip::after {
      content: '';
      position: absolute;
      bottom: -5px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 5px solid rgba(0,0,0,0.82);
    }
    /* Fixed/pinned cable name labels on visor map */
    .visor-fixed-label {
      background: rgba(255,255,255,0.92);
      color: #1a1a2e;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 600;
      white-space: nowrap;
      border: 1px solid rgba(0,0,0,0.15);
      box-shadow: 0 1px 3px rgba(0,0,0,0.12);
      pointer-events: auto;
      cursor: grab;
      transition: box-shadow 0.15s;
    }
    .visor-fixed-label:active {
      cursor: grabbing;
      box-shadow: 0 2px 8px rgba(0,0,0,0.25);
    }
    /* CLS Filter searchable dropdown */
    .cls-filter-wrap {
      position: relative;
      flex: 1;
      min-width: 140px;
    }
    .cls-filter-wrap input[type="text"] {
      width: 100%;
      padding: 5px 28px 5px 8px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      font-size: 11px;
      box-sizing: border-box;
      background: white;
    }
    .cls-filter-wrap input[type="text"]:focus {
      border-color: #0077b6;
      outline: none;
      box-shadow: 0 0 0 2px rgba(0,119,182,0.15);
    }
    .cls-filter-wrap .cls-search-icon {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 11px;
      color: #94a3b8;
      pointer-events: none;
    }
    .cls-filter-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 240px;
      overflow-y: auto;
      background: white;
      border: 1px solid #d0d0d0;
      border-top: none;
      border-radius: 0 0 6px 6px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.15);
      z-index: 1000;
    }
    .cls-filter-dropdown.open { display: block; }
    .cls-filter-dropdown-item {
      padding: 6px 10px;
      cursor: pointer;
      font-size: 11px;
      display: flex;
      align-items: center;
      gap: 6px;
      border-bottom: 1px solid #f5f5f5;
    }
    .cls-filter-dropdown-item:last-child { border-bottom: none; }
    .cls-filter-dropdown-item:hover,
    .cls-filter-dropdown-item.highlighted {
      background: #e3f2fd;
    }
    .cls-filter-dropdown-item .cls-item-name {
      flex: 1;
      font-weight: 500;
      color: #1a1a2e;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .cls-filter-dropdown-item .cls-item-sub {
      font-size: 10px;
      color: #64748b;
      white-space: nowrap;
    }
    .cls-filter-dropdown-item .cls-item-badge {
      font-size: 9px;
      background: #e3f2fd;
      color: #0077b6;
      padding: 1px 5px;
      border-radius: 8px;
      font-weight: 600;
      white-space: nowrap;
    }
    .cls-filter-dropdown-hint {
      padding: 8px 10px;
      font-size: 10px;
      color: #94a3b8;
      text-align: center;
      font-style: italic;
    }
    .cls-active-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: #0077b6;
      color: white;
      padding: 2px 8px 2px 6px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: 600;
      max-width: 200px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .cls-active-tag .cls-tag-close {
      cursor: pointer;
      font-size: 12px;
      margin-left: 2px;
      opacity: 0.8;
    }
    .cls-active-tag .cls-tag-close:hover { opacity: 1; }

    /* Visor toolbar toggle buttons */
    .visor-toggle-btn {
      padding: 3px 8px;
      font-size: 10px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      background: white;
      cursor: pointer;
      color: #495057;
      transition: all 0.15s;
    }
    .visor-toggle-btn:hover { background: #e3f2fd; border-color: #0077b6; }
    .visor-toggle-btn.active { background: #0077b6; color: white; border-color: #0077b6; }

    /* Datacenter Visor Panel - Floating Draggable (matches Cable Visor) */
    #dcVisorPanel {
      position: absolute;
      left: 420px;
      top: 40px;
      width: 500px;
      height: 500px;
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      z-index: 151;
      display: none;
      flex-direction: column;
      overflow: hidden;
      resize: both;
      min-width: 350px;
      min-height: 300px;
      max-width: 90vw;
      max-height: calc(100vh - 100px);
    }
    #dcVisorPanel.maximized {
      position: fixed !important;
      width: 100vw !important;
      height: 100vh !important;
      left: 0 !important;
      top: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      border-radius: 0 !important;
      max-width: 100vw !important;
      max-height: 100vh !important;
      z-index: 99999 !important;
    }
    #dcVisorPanel.show { display: flex; }
    #dcVisorPanel.presentation-mode {
      position: fixed !important;
      width: 100vw !important;
      height: 100vh !important;
      left: 0 !important;
      top: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      border-radius: 0 !important;
      max-width: 100vw !important;
      max-height: 100vh !important;
      z-index: 999999 !important;
      resize: none !important;
    }
    #dcVisorPanel.presentation-mode #dcVisorHeader {
      cursor: default;
    }
    #dcVisorHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      background: linear-gradient(135deg, #9333ea 0%, #a855f7 100%);
      border-bottom: 1px solid #9333ea;
      color: white;
      cursor: move;
      user-select: none;
    }
    #dcVisorHeader h3 {
      margin: 0;
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #dcVisorControls {
      display: flex;
      gap: 6px;
    }
    #dcVisorControls button {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 28px;
      height: 28px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }
    #dcVisorControls button:hover { background: rgba(255,255,255,0.3); }
    #dcVisorToolbar {
      padding: 10px 12px;
      background: #f8f9fa;
      border-bottom: 1px solid #e0e0e0;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    #dcVisorMap {
      flex: 1;
      min-height: 80px;
      background: #e0e7ef;
      position: relative;
    }
    #dcVisorMapResizeHandle {
      height: 7px;
      background: linear-gradient(180deg, #e0e0e0 0%, #d0d0d0 100%);
      cursor: ns-resize;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      user-select: none;
      border-top: 1px solid #ccc;
      border-bottom: 1px solid #ccc;
    }
    #dcVisorMapResizeHandle:hover, #dcVisorMapResizeHandle.dragging {
      background: linear-gradient(180deg, #e8d5f5 0%, #d4b8e8 100%);
    }
    #dcVisorMapResizeHandle .resize-grip {
      width: 30px; height: 3px;
      border-top: 1px solid #999; border-bottom: 1px solid #999;
    }
    #dcVisorMapResizeHandle:hover .resize-grip, #dcVisorMapResizeHandle.dragging .resize-grip {
      border-color: #9333ea;
    }
    #dcVisorList {
      flex: 0 1 180px;
      min-height: 80px;
      overflow-y: auto;
      border-top: 1px solid #e0e0e0;
      background: white;
      resize: vertical;
    }
    .dc-visor-item {
      padding: 8px 12px;
      border-bottom: 1px solid #f0f0f0;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
    }
    .dc-visor-item:hover { background: #faf5ff; }
    .dc-visor-item.selected { background: #f3e8ff; }
    .dc-visor-item input[type="checkbox"] {
      width: 14px;
      height: 14px;
      accent-color: #9333ea;
    }
    .dc-visor-info {
      flex: 1;
      min-width: 0;
    }
    .dc-visor-name {
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .dc-visor-meta {
      font-size: 10px;
      color: #666;
    }
    #dcVisorFooter {
      padding: 8px 12px;
      background: #f8f9fa;
      border-top: 1px solid #e0e0e0;
      font-size: 11px;
      color: #666;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    /* Visor toolbar action menus */
    .visor-action-menu {
      position: absolute;
      top: 100%;
      right: 0;
      background: white;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      min-width: 180px;
      padding: 4px 0;
      display: none;
    }
    .visor-action-menu.show { display: block; }
    .visor-action-menu button {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      padding: 7px 14px;
      border: none;
      background: none;
      font-size: 12px;
      cursor: pointer;
      color: #333;
      text-align: left;
    }
    .visor-action-menu button:hover { background: #f0f4ff; }
    .visor-action-menu .menu-sep { height: 1px; background: #e0e0e0; margin: 4px 0; }

    /* Multilink Group Manager Panel */
    #multilinkManager {
      position: absolute;
      left: 20px;
      top: 80px;
      width: 320px;
      max-height: calc(100vh - 160px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 100;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      resize: both;
      min-width: 280px;
      max-width: 500px;
      min-height: 200px;
    }
    #multilinkManager.minimized {
      height: 40px !important;
      max-height: 40px;
      resize: none;
    }
    #multilinkManagerHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      border-bottom: 1px solid #fbbf24;
      cursor: move;
      user-select: none;
    }
    #multilinkManagerHeader h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #92400e;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #multilinkManagerControls {
      display: flex;
      gap: 4px;
    }
    #multilinkManagerControls button {
      background: transparent;
      border: 1px solid #d97706;
      color: #92400e;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #multilinkManagerControls button:hover { background: #fef3c7; }
    #multilinkManagerContent {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .mlg-item {
      padding: 10px 12px;
      border-bottom: 1px solid #f0f0f0;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .mlg-item:hover { background: #fffbeb; }
    .mlg-item.selected { background: #fef3c7; border-left: 3px solid #f59e0b; }
    .mlg-item .mlg-header { display: flex; justify-content: space-between; align-items: center; }
    .mlg-item .mlg-name { font-weight: 600; font-size: 12px; color: #92400e; }
    .mlg-item .mlg-type {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .mlg-item .mlg-type.ring { background: #dcfce7; color: #166534; }
    .mlg-item .mlg-type.linear { background: #dbeafe; color: #1e40af; }
    .mlg-item .mlg-type.ring_linear { background: #f3e8ff; color: #6b21a8; }
    .mlg-item .mlg-info { font-size: 10px; color: #666; }
    .mlg-item .mlg-route { font-size: 10px; color: #888; }
    .mlg-item .mlg-warnings { font-size: 10px; color: #dc2626; margin-top: 2px; }

    /* Multilink Group Editor Panel */
    #multilinkEditor {
      position: absolute;
      left: 360px;
      top: 80px;
      width: 400px;
      max-height: calc(100vh - 160px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 100;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      resize: both;
      min-width: 350px;
      max-width: 600px;
      min-height: 300px;
    }
    #multilinkEditor.minimized {
      height: 40px !important;
      max-height: 40px;
      resize: none;
    }
    #multilinkEditorHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: linear-gradient(135deg, #fed7aa 0%, #fdba74 100%);
      border-bottom: 1px solid #f97316;
      cursor: move;
      user-select: none;
    }
    #multilinkEditorHeader h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #9a3412;
    }
    #multilinkEditorControls {
      display: flex;
      gap: 4px;
    }
    #multilinkEditorControls button {
      background: transparent;
      border: 1px solid #ea580c;
      color: #9a3412;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #multilinkEditorControls button:hover { background: #ffedd5; }
    #multilinkEditorContent {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }
    #multilinkEditorContent .row { margin-bottom: 12px; }
    #multilinkEditorContent label { display: block; font-size: 11px; color: #555; margin-bottom: 4px; font-weight: 500; }
    #multilinkEditorContent input, #multilinkEditorContent select, #multilinkEditorContent textarea {
      width: 100%; box-sizing: border-box;
      padding: 6px 8px; border: 1px solid #d0d0d0; border-radius: 4px; font-size: 12px;
    }
    .segment-card {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      margin-bottom: 10px;
      overflow: hidden;
    }
    .segment-card.has-warning {
      border-color: #fbbf24;
      background: #fffbeb;
    }
    .segment-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      background: #e2e8f0;
      font-size: 11px;
      font-weight: 600;
      color: #475569;
    }
    .segment-header .segment-title { display: flex; align-items: center; gap: 6px; }
    .segment-header .segment-latency { color: #0891b2; }
    .segment-header .segment-actions { display: flex; gap: 4px; }
    .segment-header .segment-actions button {
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 12px;
      padding: 2px 4px;
      border-radius: 3px;
      color: #64748b;
    }
    .segment-header .segment-actions button:hover { background: #cbd5e1; }
    .segment-content { padding: 10px; }
    .segment-nodes {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      font-size: 11px;
    }
    .segment-nodes select {
      flex: 1;
      padding: 4px 6px;
      font-size: 11px;
    }
    .segment-nodes .arrow { color: #94a3b8; font-weight: bold; }
    .path-card {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      margin-bottom: 6px;
      padding: 8px;
    }
    .path-card.primary { border-left: 3px solid #22c55e; }
    .path-card.secondary { border-left: 3px solid #3b82f6; }
    .path-card.tertiary { border-left: 3px solid #a855f7; }
    .path-card.quaternary { border-left: 3px solid #f97316; }
    .path-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      font-size: 10px;
    }
    .path-header .path-type { font-weight: 600; text-transform: uppercase; }
    .path-header .path-type.primary { color: #16a34a; }
    .path-header .path-type.secondary { color: #2563eb; }
    .path-header .path-type.tertiary { color: #9333ea; }
    .path-header .path-type.quaternary { color: #ea580c; }
    .path-header .path-latency { color: #0891b2; font-weight: 500; }
    .path-links {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      min-height: 24px;
      padding: 4px;
      background: #f9fafb;
      border-radius: 3px;
      border: 1px dashed #d1d5db;
    }
    .path-links.empty {
      justify-content: center;
      align-items: center;
      color: #9ca3af;
      font-size: 10px;
      font-style: italic;
    }
    .path-link-chip {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      padding: 2px 6px;
      background: #e0e7ff;
      border-radius: 10px;
      font-size: 10px;
      color: #3730a3;
    }
    .path-link-chip .remove-link {
      cursor: pointer;
      color: #6366f1;
      font-weight: bold;
    }
    .path-link-chip .remove-link:hover { color: #dc2626; }
    .path-actions {
      display: flex;
      gap: 4px;
      margin-top: 6px;
    }
    .path-actions button {
      flex: 1;
      padding: 4px 8px;
      font-size: 10px;
      border: 1px solid #d1d5db;
      background: #fff;
      border-radius: 3px;
      cursor: pointer;
    }
    .path-actions button:hover { background: #f3f4f6; }
    .path-actions button.picking { background: #fef3c7; border-color: #f59e0b; color: #92400e; }
    .mlg-computed {
      background: #f0fdf4;
      border: 1px solid #86efac;
      border-radius: 6px;
      padding: 10px;
      margin-top: 12px;
    }
    .mlg-computed-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      margin-bottom: 4px;
    }
    .mlg-computed-row:last-child { margin-bottom: 0; }
    .mlg-computed-row .label { color: #166534; }
    .mlg-computed-row .value { font-weight: 600; color: #15803d; }
    .mlg-warnings-box {
      background: #fef2f2;
      border: 1px solid #fecaca;
      border-radius: 6px;
      padding: 10px;
      margin-top: 12px;
    }
    .mlg-warnings-box .warning-title {
      font-size: 11px;
      font-weight: 600;
      color: #dc2626;
      margin-bottom: 6px;
    }
    .mlg-warnings-box .warning-item {
      font-size: 10px;
      color: #991b1b;
      padding: 2px 0;
    }

    #inspectorHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: #f8f8f8;
      border-bottom: 1px solid #e0e0e0;
      cursor: move;
      user-select: none;
    }
    #inspectorHeader h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }
    #inspectorControls {
      display: flex;
      gap: 4px;
    }
    #inspectorControls button {
      background: transparent;
      border: 1px solid #d0d0d0;
      color: #666;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    #inspectorControls button:hover {
      background: #e8e8e8;
      border-color: #bbb;
    }
    #inspectorContent {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 12px;
      background: #fff;
    }
    #inspector.minimized #inspectorContent {
      display: none;
    }
    #inspector h3 { margin:0 0 10px; font-size:14px; color:#333; }
    #inspector .muted { opacity:.8; font-size:11px; line-height:1.4; margin-bottom:10px; color:#666; }
    #inspector .row { margin:10px 0; }
    #inspector label { display:block; font-size:11px; color:#555; margin:0 0 4px; }
    #inspector input, #inspector textarea, #inspector select {
      width:100%; box-sizing:border-box;
      padding:8px 10px; border-radius:6px; border:1px solid #d0d0d0;
      background:#fff; color:#333; font-size: 13px;
    }
    #inspector input:focus, #inspector select:focus, #inspector textarea:focus {
      outline: none;
      border-color: #0096D6;
      box-shadow: 0 0 0 2px rgba(0,150,214,0.15);
    }
    #inspector textarea { min-height: 60px; resize: vertical; }
    #inspector .inline { display:flex; gap:8px; }
    #inspector .inline > * { flex:1; }
    #inspector h4 { color:#333; margin:16px 0 8px; font-size:11px; font-weight:600; text-transform:uppercase; letter-spacing:0.5px; }
    #inspector input[type="color"] { padding:2px; height:32px; }
    #inspector input[type="checkbox"] { width:auto; accent-color:#0096D6; }
    .muted kbd { background:#f0f0f0; padding:2px 5px; border-radius:3px; font-size:10px; border:1px solid #d0d0d0; }

    svg { display:block; user-select:none; background:#fff; }
    #svgContainer { display: block; min-width: max-content; min-height: max-content; }
    .grid { stroke:#e8e8e8; stroke-width:1; }

    .group-rect { rx:8; ry:8; }
    /* Group selection uses glow effect only - preserves original color */
    .group-selected .group-rect {
      filter: drop-shadow(0 0 4px rgba(0,150,214,0.7)) drop-shadow(0 0 8px rgba(0,150,214,0.4)) drop-shadow(0 0 12px rgba(0,150,214,0.2));
    }
    /* Selection glow ring overlay for containers */
    .group-selection-glow {
      fill: none;
      stroke: rgba(0,150,214,0.5);
      stroke-width: 3;
      pointer-events: none;
      animation: selectionPulse 2s ease-in-out infinite;
    }
    .group-label { font-weight:600; user-select:none; cursor: default; }
    .group-handle { fill:#888; opacity:.7; cursor:nwse-resize; }
    .group-handle.handle-nw { cursor:nwse-resize; }
    .group-handle.handle-ne { cursor:nesw-resize; }
    .group-handle.handle-sw { cursor:nesw-resize; }
    .group-handle.handle-se { cursor:nwse-resize; }
    .group-handle:hover { fill:#555; opacity:1; }

    /* Node resize handles - invisible but functional */
    .node-resize-handle {
      fill: transparent;
      stroke: none;
      cursor: nwse-resize;
      pointer-events: auto;
    }
    .node-resize-handle.handle-nw { cursor: nwse-resize; }
    .node-resize-handle.handle-ne { cursor: nesw-resize; }
    .node-resize-handle.handle-sw { cursor: nesw-resize; }
    .node-resize-handle.handle-se { cursor: nwse-resize; }
    .node.selected .node-resize-handle,
    .node:hover .node-resize-handle {
      fill: rgba(0, 150, 214, 0.15);
      stroke: rgba(0, 150, 214, 0.4);
      stroke-width: 1;
    }
    .node-resize-handle:hover {
      fill: rgba(0, 150, 214, 0.3) !important;
      stroke: #0096D6 !important;
      stroke-width: 1.5 !important;
    }

    .edge { fill:none; }
    /* Edge selection uses glow effect only - preserves original color */
    .edge.selected {
      filter: drop-shadow(0 0 4px rgba(0,150,214,0.9)) drop-shadow(0 0 8px rgba(0,150,214,0.6)) drop-shadow(0 0 12px rgba(0,150,214,0.3));
    }
    /* Selection glow line overlay - rendered separately to preserve original colors */
    .edge-selection-glow {
      fill: none;
      stroke: rgba(0,150,214,0.5);
      stroke-width: 6;
      pointer-events: none;
      animation: edgeSelectionPulse 2s ease-in-out infinite;
    }
    @keyframes edgeSelectionPulse {
      0%, 100% { stroke-opacity: 0.4; }
      50% { stroke-opacity: 0.7; }
    }
    /* Endpoint handles shown on selected edges for re-routing */
    .edge-endpoint-handle {
      fill: #ffffff;
      stroke: rgba(0,150,214,0.9);
      stroke-width: 2;
      cursor: grab;
      filter: drop-shadow(0 0 3px rgba(0,150,214,0.5));
    }
    .edge-endpoint-handle:hover {
      fill: rgba(0,150,214,0.2);
      stroke: rgba(0,150,214,1);
    }
    .endpoint-snap-ring {
      fill: none;
      stroke: rgba(0,150,214,0.7);
      stroke-width: 2;
      stroke-dasharray: 5 3;
      pointer-events: none;
      animation: snapRingPulse 0.8s ease-in-out infinite;
    }
    @keyframes snapRingPulse {
      0%, 100% { stroke-opacity: 0.4; r: attr(r); }
      50% { stroke-opacity: 1; }
    }
    .edge-label {
      fill:#333;
      paint-order: stroke; stroke:#ffffff; stroke-width:3px;
      cursor: default; user-select:none;
    }

    .node { cursor: grab; }
    .node:active { cursor: grabbing; }
    .node-circle { }
    /* Selection uses glow effect only - preserves original color */
    .node.selected .node-circle {
      filter: drop-shadow(0 0 6px rgba(0,150,214,0.8)) drop-shadow(0 0 10px rgba(0,150,214,0.5)) drop-shadow(0 0 14px rgba(0,150,214,0.3));
    }
    /* Selection glow ring overlay - rendered separately to preserve original colors */
    .node-selection-glow {
      fill: none;
      stroke: rgba(0,150,214,0.6);
      stroke-width: 3;
      pointer-events: none;
      animation: selectionPulse 2s ease-in-out infinite;
    }
    @keyframes selectionPulse {
      0%, 100% { stroke-opacity: 0.6; }
      50% { stroke-opacity: 0.9; }
    }
    .node.link-source .node-circle {
      stroke: #ff9800 !important;
      stroke-width: 4 !important;
      filter: drop-shadow(0 0 6px rgba(255,152,0,0.6));
      animation: pulse 1s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .node-text, .tag-text { text-anchor: middle; user-select:none; cursor: default; }
    .node-text { dominant-baseline: middle; }
    .tag-text { dominant-baseline: hanging; opacity:.8; }

    /* Route Finder Highlighting */
    .node.route-origin .node-circle {
      stroke: #22c55e !important;
      stroke-width: 4 !important;
      filter: drop-shadow(0 0 8px rgba(34,197,94,0.7));
    }
    .node.route-dest .node-circle {
      stroke: #ef4444 !important;
      stroke-width: 4 !important;
      filter: drop-shadow(0 0 8px rgba(239,68,68,0.7));
    }
    /* Geo View node highlighting */
    circle.geo-node.route-origin {
      stroke: #22c55e !important;
      stroke-width: 4 !important;
      filter: drop-shadow(0 0 8px rgba(34,197,94,0.7));
    }
    circle.geo-node.route-dest {
      stroke: #ef4444 !important;
      stroke-width: 4 !important;
      filter: drop-shadow(0 0 8px rgba(239,68,68,0.7));
    }
    circle.geo-node.route-path-node {
      stroke: #0ea5e9 !important;
      stroke-width: 3 !important;
      filter: drop-shadow(0 0 6px rgba(14,165,233,0.6));
    }
    .edge.route-path-1 {
      stroke: #22c55e !important;
      stroke-width: 5 !important;
      filter: drop-shadow(0 0 8px rgba(34,197,94,0.8));
    }
    .edge.route-path-2 {
      stroke: #f59e0b !important;
      stroke-width: 5 !important;
      filter: drop-shadow(0 0 8px rgba(245,158,11,0.8));
    }
    .edge.route-path-3 {
      stroke: #f97316 !important;
      stroke-width: 5 !important;
      filter: drop-shadow(0 0 8px rgba(249,115,22,0.8));
    }
    .node.route-path-node .node-circle {
      stroke: #0ea5e9 !important;
      stroke-width: 3 !important;
      filter: drop-shadow(0 0 6px rgba(14,165,233,0.6));
    }
    /* Implicit route segments (dashed) */
    .route-implicit-segment {
      stroke-dasharray: 8,4;
      opacity: 0.85;
    }

    /* Protection path styling (amber/orange) */
    /* Target path and line elements directly since they have class="edge" */
    path.edge.route-protection-path,
    line.edge.route-protection-path,
    path.route-protection-path,
    line.route-protection-path {
      stroke: #f59e0b !important;
      stroke-width: 5 !important;
      filter: drop-shadow(0 0 10px rgba(245,158,11,0.9));
    }
    /* Closure nodes (ring closure points) */
    .node.route-closure-node .node-circle {
      stroke: #f59e0b !important;
      stroke-width: 4 !important;
      filter: drop-shadow(0 0 8px rgba(245,158,11,0.8));
    }
    circle.geo-node.route-closure-node {
      stroke: #f59e0b !important;
      stroke-width: 4 !important;
      filter: drop-shadow(0 0 8px rgba(245,158,11,0.8));
    }
    /* Protection closure node checkbox styling */
    .protection-closure-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      transition: background-color 0.15s;
    }
    .protection-closure-item:hover {
      background: #fef9c3;
    }
    .protection-closure-item.selected {
      background: #fde68a;
    }
    .protection-closure-item.endpoint {
      background: #fef3c7;
      cursor: default;
    }
    .protection-closure-item input[type="checkbox"] {
      accent-color: #f59e0b;
      width: 16px;
      height: 16px;
    }
    .protection-closure-item .node-name {
      flex: 1;
      font-size: 12px;
      color: #78350f;
    }
    .protection-closure-item .node-badge {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
    }
    .protection-closure-item .node-badge.origin {
      background: #dcfce7;
      color: #166534;
    }
    .protection-closure-item .node-badge.dest {
      background: #fee2e2;
      color: #991b1b;
    }

    /* Protection Mode active - panel border glow */
    #routeFinderPanel.protection-mode-active {
      border-color: #f59e0b !important;
      box-shadow: 0 0 20px rgba(245, 158, 11, 0.4), inset 0 0 0 1px rgba(245, 158, 11, 0.2) !important;
    }
    #routeFinderPanel.protection-mode-active .inspector-section-header {
      border-left: 3px solid #f59e0b;
    }

    /* MLG route segments (Phase 1) - purple glow */
    .edge.route-mlg-segment path:not(.edge-hit) {
      stroke: #a855f7 !important;
      stroke-width: 5 !important;
      filter: drop-shadow(0 0 10px rgba(168,85,247,0.9));
    }
    .edge.route-mlg-segment {
      z-index: 100;
    }

    /* KML Studio Integration */
    #btnKMLStudio.kml-drop-active {
      background: #dbeafe !important;
      border: 2px dashed #3b82f6 !important;
      animation: kml-pulse 0.8s ease-in-out infinite alternate;
    }
    @keyframes kml-pulse {
      from { box-shadow: 0 0 4px rgba(59,130,246,0.3); }
      to   { box-shadow: 0 0 12px rgba(59,130,246,0.6); }
    }
    #kmlStudioConfirmDialog {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.45); z-index: 10000;
      display: flex; align-items: center; justify-content: center;
    }
    #kmlStudioConfirmDialog .kml-confirm-box {
      background: #fff; border-radius: 10px; box-shadow: 0 8px 30px rgba(0,0,0,0.2);
      width: 480px; max-width: 90vw; max-height: 80vh; overflow-y: auto;
    }
    #kmlStudioConfirmDialog .kml-confirm-header {
      padding: 16px 20px; border-bottom: 1px solid #e5e7eb;
      font-weight: 600; font-size: 15px; display: flex; align-items: center; gap: 8px;
    }
    #kmlStudioConfirmDialog .kml-confirm-body { padding: 16px 20px; font-size: 13px; }
    #kmlStudioConfirmDialog .kml-confirm-body table { width: 100%; border-collapse: collapse; margin: 8px 0; }
    #kmlStudioConfirmDialog .kml-confirm-body th { text-align: left; padding: 4px 8px; font-size: 11px; color: #6b7280; }
    #kmlStudioConfirmDialog .kml-confirm-body td { padding: 4px 8px; font-size: 12px; border-top: 1px solid #f3f4f6; }
    #kmlStudioConfirmDialog .kml-confirm-body select { width: 100%; padding: 4px 6px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px; }
    #kmlStudioConfirmDialog .kml-confirm-footer {
      padding: 12px 20px; border-top: 1px solid #e5e7eb;
      display: flex; justify-content: flex-end; gap: 8px;
    }
    #kmlStudioConfirmDialog .kml-confirm-footer button {
      padding: 6px 16px; border-radius: 6px; font-size: 13px; cursor: pointer; border: 1px solid #d1d5db;
      background: #f9fafb; color: #374151;
    }
    #kmlStudioConfirmDialog .kml-confirm-footer button.primary {
      background: #3b82f6; color: #fff; border-color: #2563eb;
    }

    /* Route Finder Panel - Inspector Style */
    #routeFinderPanel {
      position: absolute;
      left: 20px;
      top: 20px;
      width: 320px;
      max-height: calc(100vh - 160px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 99;
      flex-direction: column;
      overflow: hidden;
      resize: horizontal;
      min-width: 280px;
      max-width: 450px;
    }
    #routeFinderPanel.visible {
      display: flex !important;
    }
    #routeFinderPanel:not(.visible) {
      display: none !important;
    }
    #routeFinderPanel.minimized {
      height: 40px !important;
      max-height: 40px;
      resize: none;
    }
    #routeFinderHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      border-bottom: 1px solid #16a34a;
      cursor: move;
      user-select: none;
    }
    #routeFinderHeader h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #fff;
    }
    #routeFinderControls {
      display: flex;
      gap: 4px;
    }
    #routeFinderControls button {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: #fff;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #routeFinderControls button:hover { background: rgba(255,255,255,0.3); }
    #routeFinderContent {
      flex: 1;
      overflow-y: auto;
    }
    #routeFinderPanel.minimized #routeFinderContent {
      display: none;
    }

    /* Route option cards */
    .route-option {
      padding: 10px 12px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.15s ease;
      background: #fff;
    }
    .route-option:last-child {
      margin-bottom: 0;
    }
    .route-option:hover {
      border-color: #0096D6;
      background: #f8fbfd;
    }
    .route-option.active {
      border-color: #22c55e;
      background: #f0fdf4;
      box-shadow: 0 0 0 2px rgba(34,197,94,0.2);
    }
    .route-option.active.route-2 {
      border-color: #f59e0b;
      background: #fffbeb;
      box-shadow: 0 0 0 2px rgba(245,158,11,0.2);
    }
    .route-option.active.route-3 {
      border-color: #f97316;
      background: #fff7ed;
      box-shadow: 0 0 0 2px rgba(249,115,22,0.2);
    }
    .route-option-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .route-option-rank {
      font-size: 16px;
    }
    .route-option-title {
      font-weight: 600;
      font-size: 12px;
      color: #333;
    }
    .route-option-cost {
      font-size: 13px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 4px;
      background: #f0f0f0;
    }
    .route-option.active .route-option-cost {
      background: #dcfce7;
      color: #166534;
    }
    .route-option.active.route-2 .route-option-cost {
      background: #fef3c7;
      color: #92400e;
    }
    .route-option.active.route-3 .route-option-cost {
      background: #ffedd5;
      color: #9a3412;
    }
    .route-option-path {
      font-size: 11px;
      color: #666;
      line-height: 1.5;
      word-break: break-word;
    }
    .route-option-stats {
      display: flex;
      gap: 12px;
      margin-top: 6px;
      font-size: 10px;
      color: #888;
    }
    .route-no-path {
      padding: 20px;
      text-align: center;
      color: #666;
    }
    .route-no-path-icon {
      font-size: 32px;
      margin-bottom: 8px;
    }

    /* Label Manager Panel */
    #labelManagerPanel {
      position: absolute;
      left: 360px;
      top: 20px;
      width: 340px;
      max-height: calc(100vh - 160px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 99;
      flex-direction: column;
      overflow: hidden;
      resize: horizontal;
      min-width: 300px;
      max-width: 500px;
      display: none;
    }
    #labelManagerPanel.visible {
      display: flex !important;
    }
    #labelManagerHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      border-bottom: 1px solid #7c3aed;
      cursor: move;
      user-select: none;
    }
    #labelManagerHeader h3 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #fff;
    }
    #labelManagerControls {
      display: flex;
      gap: 4px;
    }
    #labelManagerControls button {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: #fff;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #labelManagerControls button:hover { background: rgba(255,255,255,0.3); }
    #labelManagerContent {
      flex: 1;
      overflow-y: auto;
    }

    /* Tag items in Label Manager */
    .lm-tag-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.15s;
    }
    .lm-tag-item:hover {
      background: #f3f4f6;
    }
    .lm-tag-item.selected {
      background: #ede9fe;
    }
    .lm-tag-checkbox {
      width: 16px;
      height: 16px;
      accent-color: #8b5cf6;
    }
    .lm-tag-name {
      flex: 1;
      font-size: 12px;
      color: #374151;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .lm-tag-counts {
      display: flex;
      gap: 6px;
      font-size: 10px;
      color: #9ca3af;
    }
    .lm-tag-count {
      padding: 1px 4px;
      background: #f3f4f6;
      border-radius: 3px;
    }
    .lm-tag-count.nodes { background: #dbeafe; color: #1d4ed8; }
    .lm-tag-count.links { background: #fef3c7; color: #92400e; }
    .lm-tag-count.containers { background: #d1fae5; color: #065f46; }
    .lm-tag-menu {
      opacity: 0;
      padding: 2px 6px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 3px;
    }
    .lm-tag-item:hover .lm-tag-menu {
      opacity: 1;
    }
    .lm-tag-menu:hover {
      background: #e5e7eb;
    }

    /* Selection status indicator */
    .lm-selection-status {
      padding: 10px 12px;
      background: linear-gradient(135deg, #f3e8ff 0%, #ede9fe 100%);
      border-bottom: 1px solid #c4b5fd;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .lm-selection-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      background: #8b5cf6;
      color: white;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }

    /* Checkbox states */
    .lm-checkbox-partial {
      position: relative;
    }
    .lm-checkbox-partial::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 8px;
      height: 2px;
      background: #8b5cf6;
    }

    /* Tag pill style for selection display */
    .lm-tag-pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      background: #ede9fe;
      color: #6d28d9;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
    }
    .lm-tag-pill .remove {
      cursor: pointer;
      opacity: 0.7;
    }
    .lm-tag-pill .remove:hover {
      opacity: 1;
    }

    .toast {
      position:absolute; right:14px; bottom:14px; background:#333; border:1px solid #222;
      color:#fff; padding:10px 16px; border-radius:8px; max-width: 520px; font-size: 13px; opacity:0;
      transform: translateY(8px); transition: all .2s ease; z-index: 20;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .toast.show { opacity:1; transform: translateY(0); }
    kbd{ padding:1px 6px; border:1px solid #d0d0d0; border-bottom-width:2px; border-radius:4px; background:#f5f5f5; font-size:11px; color:#333; }

    header { position: sticky; top: 0; }
    .menu {
      position:absolute;
      top: 28px;
      left: 0;
      background:#ffffff;
      border:1px solid #d0d0d0;
      border-radius:6px;
      padding:4px 0;
      min-width: 200px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.12);
      z-index: 30;
    }
    .menu[hidden]{ display:none; }
    .menu .item{
      display:flex; align-items:center; gap:10px;
      padding:8px 14px;
      cursor:pointer;
      user-select:none;
      font-size: 13px;
      color:#333;
    }
    .menu .item:hover{ background:#f5f5f5; }
    .menu .item.active { background:#e8f4fc; color:#0096D6; }
    .menu .sep{ height:1px; background:#e0e0e0; margin:4px 0; }

    /* Submenu styles */
    .menu .has-submenu {
      position: relative;
    }
    .menu .has-submenu::after {
      content: 'â–¶';
      font-size: 9px;
      margin-left: auto;
      opacity: 0.5;
    }
    .menu .submenu {
      display: none;
      position: absolute;
      left: 100%;
      top: 0;
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      padding: 4px 0;
      min-width: 220px;
      max-height: calc(100vh - 40px);
      overflow-y: auto;
      overflow-x: hidden;
      box-shadow: 0 4px 16px rgba(0,0,0,0.12);
      z-index: 31;
      margin-left: -5px; /* Overlap slightly with parent for easier hover */
      padding-left: 5px; /* Compensate for margin */
    }
    /* Flip submenu to open left when it would go off-screen */
    .menu .submenu.flip-left {
      left: auto;
      right: 100%;
      margin-left: 0;
      margin-right: -5px;
      padding-left: 0;
      padding-right: 5px;
    }
    /* Smart positioning - flip up if needed */
    .menu .submenu.flip-up {
      top: auto;
      bottom: 0;
    }
    .menu .has-submenu:hover > .submenu {
      display: block;
    }
    /* Increase hover target area for submenu parent */
    .menu .has-submenu {
      position: relative;
    }
    .menu .has-submenu::before {
      content: '';
      position: absolute;
      top: 0;
      right: -20px;
      width: 20px;
      height: 100%;
    }
    .menu .submenu .item {
      padding: 6px 14px;
      font-size: 12px;
    }
    .menu .submenu .menu-section-header {
      padding: 4px 14px;
      font-size: 10px;
    }
    .menu .submenu-content {
      padding: 8px 14px;
    }
    .menu .submenu-content label {
      font-size: 11px;
      color: #666;
    }
    /* Specific fix for Geo settings submenus - fixed position from top */
    #mapLibreSubmenu, #geoViewSubmenu {
      position: fixed;
      top: 60px;
      max-height: calc(100vh - 80px);
      overflow-y: auto;
    }
    /* Scrollbar styling for submenus */
    .menu .submenu::-webkit-scrollbar {
      width: 8px;
    }
    .menu .submenu::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    .menu .submenu::-webkit-scrollbar-thumb {
      background: #ccc;
      border-radius: 3px;
    }
    .menu .submenu::-webkit-scrollbar-thumb:hover {
      background: #aaa;
    }

    /* Draggable panel styles */
    .menu.draggable-panel {
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      border: 1px solid #ccc;
    }
    .menu.draggable-panel .draggable-handle {
      user-select: none;
    }
    .menu.draggable-panel .draggable-handle:hover {
      background: #e8f4fc !important;
    }
    .menu.draggable-panel .draggable-handle:active {
      cursor: grabbing;
    }

    .toggle{ display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:4px; font-size:12px; color:#555; }
    .toggle input{ accent-color:#0096D6; }

    /* Tag filter styles */
    .tag-filter-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 12px;
    }
    .tag-filter-item:hover { background: #f5f5f5; }
    .tag-filter-item input { accent-color: #0096D6; }
    .tag-filter-item .tag-name { flex: 1; }
    .tag-filter-item .tag-count {
      color: #999;
      font-size: 11px;
      background: #f0f0f0;
      padding: 1px 6px;
      border-radius: 10px;
    }
    /* Unified Filter Button */
    #btnUnifiedFilter.filtering {
      background: #e8f4fc;
      color: #0096D6;
      border-color: #0096D6;
    }
    #btnUnifiedFilter .filter-badge {
      display: none;
      background: #0096D6;
      color: #fff;
      font-size: 9px;
      font-weight: 700;
      min-width: 16px;
      height: 16px;
      line-height: 16px;
      text-align: center;
      border-radius: 8px;
      padding: 0 4px;
      margin-left: 4px;
    }
    #btnUnifiedFilter.filtering .filter-badge { display: inline-block; }

    /* Unified Filter Panel */
    #unifiedFilterPanel {
      position: fixed;
      z-index: 1001;
      background: #fff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.18);
      width: 340px;
      max-height: 80vh;
      overflow-y: auto;
      font-size: 12px;
    }
    .unified-filter-header {
      padding: 8px 12px;
      font-weight: 600;
      font-size: 13px;
      border-bottom: 1px solid #e0e0e0;
      cursor: move;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f8f9fa;
      border-radius: 8px 8px 0 0;
      user-select: none;
    }
    .filter-accordion-section {
      border-bottom: 1px solid #f0f0f0;
    }
    .filter-accordion-section:last-of-type {
      border-bottom: none;
    }
    .filter-accordion-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      cursor: pointer;
      user-select: none;
      background: #fafafa;
      transition: background 0.15s;
    }
    .filter-accordion-header:hover {
      background: #f0f4f8;
    }
    .filter-accordion-header .filter-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #d0d0d0;
      flex-shrink: 0;
      transition: background 0.2s;
    }
    .filter-accordion-header .filter-dot.active {
      background: #0096D6;
      box-shadow: 0 0 4px rgba(0,150,214,0.4);
    }
    .filter-accordion-header .filter-section-title {
      flex: 1;
      font-weight: 600;
      font-size: 12px;
    }
    .filter-accordion-header .filter-arrow {
      font-size: 10px;
      color: #999;
      transition: transform 0.2s;
    }
    .filter-accordion-section.expanded .filter-accordion-header .filter-arrow {
      transform: rotate(90deg);
    }
    .filter-accordion-section.expanded .filter-accordion-header {
      background: #e8f4fc;
    }
    .filter-accordion-content {
      display: none;
      border-top: 1px solid #e8e8e8;
    }
    .filter-accordion-section.expanded .filter-accordion-content {
      display: block;
    }
    .filter-clear-section {
      padding: 8px 12px;
      border-top: 1px solid #e0e0e0;
      background: #fafafa;
      border-radius: 0 0 8px 8px;
    }

    /* Apply Style Panel */
    .apply-style-section {
      border-bottom: 1px solid #e8e8e8;
    }
    .apply-style-section:last-child {
      border-bottom: none;
    }
    .apply-style-section-header {
      padding: 8px 12px;
      font-size: 10px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      background: #f5f5f5;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .apply-style-section-header .count {
      background: #e0e0e0;
      color: #555;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: normal;
    }
    .apply-style-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 12px;
      color: #333;
      transition: background 0.1s;
    }
    .apply-style-item:hover {
      background: #e8f4fc;
    }
    .apply-style-swatch {
      display: flex;
      align-items: center;
      gap: 2px;
      flex-shrink: 0;
    }
    .apply-style-swatch-fill {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.2);
    }
    .apply-style-swatch-stroke {
      width: 4px;
      height: 16px;
      border-radius: 1px;
      border: 1px solid rgba(0,0,0,0.15);
    }
    .apply-style-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .apply-style-empty-section {
      padding: 12px;
      text-align: center;
      color: #999;
      font-size: 11px;
      font-style: italic;
    }

    /* Inspector Palette Color Picker */
    .inspector-color-picker {
      position: relative;
      display: inline-block;
    }
    .inspector-color-swatch {
      width: 36px;
      height: 28px;
      border: 1px solid #aaa;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fff;
      transition: border-color 0.15s;
    }
    .inspector-color-swatch:hover {
      border-color: #666;
    }
    .inspector-color-swatch-inner {
      width: 28px;
      height: 20px;
      border-radius: 2px;
      border: 1px solid rgba(0,0,0,0.1);
    }
    .inspector-color-dropdown {
      position: absolute;
      top: 32px;
      left: 0;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 10px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      z-index: 1000;
      min-width: 200px;
    }
    .inspector-color-dropdown[hidden] {
      display: none;
    }
    .inspector-color-grid {
      display: grid;
      grid-template-columns: repeat(8, 22px);
      gap: 3px;
      margin-bottom: 10px;
    }
    .inspector-color-grid-item {
      width: 22px;
      height: 22px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.15);
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.1s;
    }
    .inspector-color-grid-item:hover {
      transform: scale(1.15);
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      z-index: 1;
      position: relative;
    }
    .inspector-color-custom {
      display: flex;
      align-items: center;
      gap: 8px;
      padding-top: 8px;
      border-top: 1px solid #e8e8e8;
    }
    .inspector-color-custom input[type="color"] {
      width: 32px;
      height: 28px;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 2px;
      cursor: pointer;
    }
    .inspector-color-custom input[type="text"] {
      width: 80px;
      padding: 4px 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 11px;
      font-family: monospace;
    }
    .inspector-color-custom span {
      font-size: 11px;
      color: #666;
    }

    /* Toolbar color grid */
    .color-grid {
      display: grid;
      grid-template-columns: repeat(8, 20px);
      gap: 3px;
    }
    .color-grid-item {
      width: 20px;
      height: 20px;
      border: 1px solid #ccc;
      border-radius: 2px;
      cursor: pointer;
    }
    .color-grid-item:hover {
      border-color: #0096D6;
      transform: scale(1.1);
    }
    .color-grid-item.selected {
      border: 2px solid #0096D6;
    }
    .link-style-item.active, .link-route-item.active {
      background: #e8f4fc;
      color: #0096D6;
    }

    .marquee { fill: rgba(0,150,214,0.1); stroke:#0096D6; stroke-width:1; stroke-dasharray:4 2; }

    /* Color Palette Picker */
    .color-picker-wrap { position: relative; }
    .color-swatch {
      width: 100%;
      height: 32px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      padding: 0 8px;
      gap: 8px;
    }
    .color-swatch:hover { border-color: #0096D6; }
    .color-swatch-preview {
      width: 20px;
      height: 20px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.1);
    }
    .color-swatch-label { font-size: 11px; color: #666; }
    .color-palette {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #fff;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      padding: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 50;
      display: none;
    }
    .color-palette.show { display: block; }
    .color-palette-row {
      display: flex;
      gap: 4px;
      margin-bottom: 4px;
    }
    .color-palette-row:last-child { margin-bottom: 0; }
    .color-palette-item {
      width: 24px;
      height: 24px;
      border-radius: 3px;
      cursor: pointer;
      border: 1px solid rgba(0,0,0,0.1);
      transition: transform 0.1s;
    }
    .color-palette-item:hover { transform: scale(1.15); border-color: #0096D6; }
    .color-palette-item.selected { outline: 2px solid #0096D6; outline-offset: 1px; }
    .color-palette-custom {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e0e0e0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .color-palette-custom input[type="color"] {
      width: 32px;
      height: 24px;
      padding: 0;
      border: 1px solid #d0d0d0;
      border-radius: 3px;
      cursor: pointer;
    }
    .color-palette-custom span { font-size: 11px; color: #666; }

    .shape-bar{ display:flex; gap:4px; align-items:center; padding:4px 6px; border:1px solid #d0d0d0; border-radius:6px; background:#fff; }
    .shape-btn{
      background:transparent;
      border:1px solid transparent;
      color:#555;
      padding:6px 10px;
      border-radius:4px;
      cursor:pointer;
      font-size:14px;
      min-width:36px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .shape-btn:hover{ background:#f0f0f0; }
    .shape-btn.active{ background:#0096D6; border-color:#0096D6; color:#fff; }

    /* Print Preview Modal */
    #printPreviewModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 10000;
      justify-content: center;
      align-items: center;
    }
    #printPreviewModal.show { display: flex; }
    #printPreviewContent {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      max-width: 90vw;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #printPreviewHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #e0e0e0;
      background: #fafafa;
    }
    #printPreviewHeader h3 { margin: 0; font-size: 16px; }
    #printPreviewControls { display: flex; gap: 8px; align-items: center; }
    #printPreviewBody {
      flex: 1;
      overflow: auto;
      padding: 20px;
      background: #e0e0e0;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    #printPreviewPage {
      background: #fff;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      padding: 20px;
    }
    #printPreviewPage svg {
      display: block;
      max-width: 100%;
      height: auto;
    }

    /* Data Table Modal */
    #dataTableModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.3);
      z-index: 10000;
      justify-content: center;
      align-items: center;
      pointer-events: none;
    }
    #dataTableModal.show { display: flex; }
    #dataTableContent {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      width: 85vw;
      min-width: 600px;
      max-width: 1400px;
      height: 70vh;
      min-height: 400px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      resize: both;
      position: absolute;
      pointer-events: auto;
    }
    #dataTableHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 20px;
      background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%);
      color: white;
      cursor: move;
      user-select: none;
    }
    #dataTableHeader h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #dataTableHeader h3::before {
      content: 'â‹®â‹®';
      font-size: 12px;
      opacity: 0.6;
      margin-right: 4px;
    }
    #dataTableControls {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    #dataTableControls select {
      padding: 6px 10px;
      border: none;
      border-radius: 6px;
      background: rgba(255,255,255,0.2);
      color: white;
      font-size: 13px;
      cursor: pointer;
    }
    #dataTableControls select option { color: #333; }
    #dataTableControls .close-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 28px;
      height: 28px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
    }
    #dataTableControls .close-btn:hover { background: rgba(255,255,255,0.3); }
    #dataTableToolbar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 16px;
      background: #f8fafc;
      border-bottom: 1px solid #e2e8f0;
    }
    #dataTableToolbar input[type="text"] {
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 13px;
      width: 250px;
    }
    #dataTableToolbar input[type="text"]:focus {
      outline: none;
      border-color: #6366f1;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
    #dataTableToolbar .toolbar-btn {
      padding: 8px 14px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: white;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #dataTableToolbar .toolbar-btn:hover { background: #f3f4f6; }
    #dataTableToolbar .toolbar-btn.primary {
      background: #4f46e5;
      border-color: #4f46e5;
      color: white;
    }
    #dataTableToolbar .toolbar-btn.primary:hover { background: #4338ca; }
    #dataTableBody {
      flex: 1;
      overflow: auto;
      padding: 0;
    }
    #dataTableContainer {
      width: 100%;
      border-collapse: collapse;
    }
    #dataTableContainer thead {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #f1f5f9;
    }
    #dataTableContainer th {
      padding: 10px 12px;
      text-align: left;
      font-size: 11px;
      font-weight: 600;
      color: #475569;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      border-bottom: 2px solid #e2e8f0;
      white-space: nowrap;
      cursor: pointer;
      user-select: none;
    }
    #dataTableContainer th:hover { background: #e2e8f0; }
    #dataTableContainer th.sorted-asc::after { content: ' â–²'; font-size: 9px; }
    #dataTableContainer th.sorted-desc::after { content: ' â–¼'; font-size: 9px; }
    #dataTableContainer td {
      padding: 8px 12px;
      font-size: 12px;
      border-bottom: 1px solid #f1f5f9;
      vertical-align: middle;
    }
    #dataTableContainer tr:hover { background: #f8fafc; }
    #dataTableContainer tr.selected { background: #e0e7ff; }
    #dataTableContainer input.cell-edit {
      width: 100%;
      padding: 4px 6px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 12px;
      text-align: inherit;
    }
    #dataTableContainer input.cell-edit:focus {
      outline: none;
      border-color: #6366f1;
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
    }
    #dataTableContainer input.cell-edit.number {
      text-align: right;
      font-family: 'SF Mono', Monaco, monospace;
    }
    #dataTableContainer input.cell-edit.tag-edit {
      font-size: 11px;
      color: #6366f1;
      min-width: 120px;
    }
    #dataTableContainer input.cell-edit.tag-edit::placeholder {
      color: #a5a5a5;
    }

    /* Bulk Edit Modal */
    #bulkEditModal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10001;
    }
    #bulkEditModal.show { display: flex; }
    #bulkEditContent {
      background: white;
      border-radius: 12px;
      width: 600px;
      max-width: 95%;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    #bulkEditHeader {
      padding: 16px 20px;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      color: white;
      border-radius: 12px 12px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #bulkEditHeader h3 { margin: 0; font-size: 16px; }
    #bulkEditHeader .close-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 28px;
      height: 28px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
    }
    #bulkEditBody {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    .bulk-edit-section {
      margin-bottom: 20px;
      padding: 16px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }
    .bulk-edit-section h4 {
      margin: 0 0 12px 0;
      font-size: 13px;
      color: #334155;
      font-weight: 600;
    }
    .bulk-edit-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
    }
    .bulk-edit-row:last-child { margin-bottom: 0; }
    .bulk-edit-row label {
      width: 140px;
      font-size: 12px;
      color: #64748b;
      flex-shrink: 0;
    }
    .bulk-edit-row input,
    .bulk-edit-row select {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 13px;
    }
    .bulk-edit-row input:focus,
    .bulk-edit-row select:focus {
      outline: none;
      border-color: #6366f1;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
    .bulk-edit-row .hint {
      font-size: 10px;
      color: #94a3b8;
      margin-left: 4px;
    }
    .bulk-edit-checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .bulk-edit-checkbox input[type="checkbox"] {
      width: 16px;
      height: 16px;
      flex: none;
    }
    #bulkEditFooter {
      padding: 16px 20px;
      background: #f1f5f9;
      border-radius: 0 0 12px 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #bulkEditFooter .target-info {
      font-size: 12px;
      color: #64748b;
    }
    #bulkEditFooter .btn-group {
      display: flex;
      gap: 10px;
    }
    #bulkEditFooter button {
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
    }
    #bulkEditFooter .btn-cancel {
      background: white;
      border: 1px solid #d1d5db;
      color: #64748b;
    }
    #bulkEditFooter .btn-apply {
      background: #6366f1;
      border: none;
      color: white;
    }
    #bulkEditFooter .btn-apply:hover { background: #4f46e5; }

    /* Settings Modals (Display Prefs, Node Defaults, Link Defaults) */
    .settings-modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10001;
      align-items: center;
      justify-content: center;
    }
    .settings-modal.show { display: flex; }
    .settings-modal-content {
      background: white;
      border-radius: 12px;
      width: 520px;
      max-width: 95%;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    .settings-modal-header {
      padding: 16px 20px;
      border-radius: 12px 12px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .settings-modal-header.display-prefs { background: linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%); color: white; }
    .settings-modal-header.node-defaults { background: linear-gradient(135deg, #10b981 0%, #34d399 100%); color: white; }
    .settings-modal-header.link-defaults { background: linear-gradient(135deg, #f59e0b 0%, #fbbf24 100%); color: #78350f; }
    .settings-modal-header h3 { margin: 0; font-size: 16px; }
    .settings-modal-header .close-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: inherit;
      width: 28px;
      height: 28px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
    }
    .settings-modal-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    .settings-section {
      margin-bottom: 20px;
      padding: 16px;
      background: #f8fafc;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }
    .settings-section:last-child { margin-bottom: 0; }
    .settings-section h4 {
      margin: 0 0 12px 0;
      font-size: 13px;
      color: #334155;
      font-weight: 600;
    }
    .settings-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
    }
    .settings-row:last-child { margin-bottom: 0; }
    .settings-row label {
      width: 140px;
      font-size: 12px;
      color: #64748b;
      flex-shrink: 0;
    }
    .settings-row input[type="text"],
    .settings-row input[type="number"],
    .settings-row select {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 13px;
    }
    .settings-row input[type="color"] {
      width: 40px;
      height: 32px;
      padding: 2px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      cursor: pointer;
    }
    .settings-row input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }
    .settings-row .color-preview {
      width: 24px;
      height: 24px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      margin-left: 8px;
    }
    .settings-row .hint {
      font-size: 10px;
      color: #94a3b8;
      margin-left: 4px;
    }
    .settings-modal-footer {
      padding: 16px 20px;
      background: #f1f5f9;
      border-radius: 0 0 12px 12px;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    .settings-modal-footer button {
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
    }
    .settings-modal-footer .btn-cancel {
      background: white;
      border: 1px solid #d1d5db;
      color: #64748b;
    }
    .settings-modal-footer .btn-save {
      background: #6366f1;
      border: none;
      color: white;
    }
    .settings-modal-footer .btn-save:hover { background: #4f46e5; }
    .shape-preview {
      width: 60px;
      height: 60px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
    }
    .shape-preview svg {
      max-width: 50px;
      max-height: 50px;
    }

    #dataTableFooter {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: #f8fafc;
      border-top: 1px solid #e2e8f0;
      font-size: 12px;
      color: #64748b;
    }
    #dataTableFooter .totals {
      display: flex;
      gap: 20px;
    }
    #dataTableFooter .total-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #dataTableFooter .total-item .label { color: #94a3b8; }
    #dataTableFooter .total-item .value { font-weight: 600; color: #1e293b; }

    @media print {
      body { background: #fff !important; margin: 0 !important; padding: 0 !important; }
      header, .toast, #inspector, #printPreviewModal { display: none !important; }
      #layout { height: auto !important; }
      #wrap { overflow: visible !important; background: #fff !important; }
      #svgContainer {
        width: 100% !important;
        height: auto !important;
      }
      svg {
        background: #fff !important;
        width: 100% !important;
        height: auto !important;
        max-width: 100%;
      }
      .grid { display: none !important; }
      .group-handle { display: none !important; }
      .node-resize-handle { display: none !important; }
    }

    /* Financial Settings Modal */
    #financialSettingsModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 10000;
      justify-content: center;
      align-items: center;
    }
    #financialSettingsModal.show { display: flex; }
    #financialSettingsContent {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      width: 520px;
      min-width: 400px;
      max-width: 95vw;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      resize: horizontal;
    }
    #financialSettingsHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      background: linear-gradient(135deg, #059669 0%, #047857 100%);
      color: white;
    }
    #financialSettingsHeader h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #financialSettingsHeader .close-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 28px;
      height: 28px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #financialSettingsHeader .close-btn:hover { background: rgba(255,255,255,0.3); }
    #financialSettingsBody {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }
    .fin-section {
      margin-bottom: 20px;
      padding: 16px;
      background: #f8fafb;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
    }
    .fin-section:last-child { margin-bottom: 0; }
    .fin-section-title {
      font-size: 11px;
      font-weight: 700;
      color: #059669;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .fin-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
    }
    .fin-row:last-child { margin-bottom: 0; }
    .fin-row label {
      flex: 0 0 140px;
      font-size: 12px;
      color: #4b5563;
      font-weight: 500;
    }
    .fin-row input, .fin-row select {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 13px;
    }
    .fin-row input:focus, .fin-row select:focus {
      outline: none;
      border-color: #059669;
      box-shadow: 0 0 0 3px rgba(5, 150, 105, 0.1);
    }
    .fin-row .unit {
      flex: 0 0 auto;
      font-size: 12px;
      color: #6b7280;
      font-weight: 500;
    }
    .fin-hint {
      font-size: 11px;
      color: #9ca3af;
      margin-top: 6px;
      padding-left: 152px;
    }
    .currency-rates-box {
      margin-top: 12px;
      padding: 10px 12px;
      background: #ecfdf5;
      border: 1px solid #a7f3d0;
      border-radius: 6px;
    }
    .currency-rates-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .currency-rates-header span {
      font-size: 11px;
      font-weight: 600;
      color: #065f46;
    }
    .currency-rates-header button {
      padding: 4px 10px;
      font-size: 11px;
      background: #059669;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .currency-rates-header button:hover { background: #047857; }
    .currency-rates-header button:disabled {
      background: #9ca3af;
      cursor: not-allowed;
    }
    .currency-rates-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      font-size: 11px;
    }
    .currency-rate-item {
      display: flex;
      justify-content: space-between;
      padding: 4px 6px;
      background: white;
      border-radius: 3px;
    }
    .currency-rate-item .code { color: #6b7280; font-weight: 500; }
    .currency-rate-item .rate { color: #059669; font-family: monospace; }
    .rates-updated {
      margin-top: 8px;
      font-size: 10px;
      color: #6b7280;
      text-align: center;
    }
    #financialSettingsFooter {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      padding: 16px 20px;
      border-top: 1px solid #e5e7eb;
      background: #f9fafb;
    }
    #financialSettingsFooter button {
      padding: 8px 20px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
    }
    #financialSettingsFooter .btn-cancel {
      background: white;
      border: 1px solid #d1d5db;
      color: #374151;
    }
    #financialSettingsFooter .btn-cancel:hover { background: #f3f4f6; }
    #financialSettingsFooter .btn-save {
      background: #059669;
      border: 1px solid #059669;
      color: white;
    }
    #financialSettingsFooter .btn-save:hover { background: #047857; }

    /* Commercial Cost Section Styles */
    .cost-subsection {
      margin-top: 12px;
      padding: 10px;
      background: #fafafa;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
    }
    .cost-subsection-title {
      font-size: 10px;
      font-weight: 700;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .cost-subsection.lease { border-left: 3px solid #3b82f6; }
    .cost-subsection.iru { border-left: 3px solid #8b5cf6; }
    .cost-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    .cost-row:last-child { margin-bottom: 0; }
    .cost-row label {
      flex: 0 0 100px;
      font-size: 11px;
      color: #4b5563;
    }
    .cost-row input {
      flex: 1;
      padding: 5px 8px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-size: 12px;
      text-align: right;
    }
    .cost-row .currency-symbol {
      font-size: 11px;
      color: #6b7280;
      font-weight: 500;
      flex: 0 0 30px;
    }
    .cost-calculated {
      padding: 8px 10px;
      background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
      border: 1px solid #86efac;
      border-radius: 4px;
      margin-top: 8px;
    }
    .cost-calculated .label {
      font-size: 10px;
      font-weight: 600;
      color: #166534;
      text-transform: uppercase;
    }
    .cost-calculated .value {
      font-size: 14px;
      font-weight: 700;
      color: #047857;
      font-family: 'SF Mono', Monaco, monospace;
    }
    .cost-mode-selector {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    .cost-mode-selector label {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 10px;
      border: 2px solid #e5e7eb;
      border-radius: 6px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 500;
      transition: all 0.15s;
    }
    .cost-mode-selector label:has(input:checked) {
      border-color: #059669;
      background: #ecfdf5;
      color: #047857;
    }
    .cost-mode-selector input { display: none; }

    /* Tier Pricing Grid */
    .tier-pricing-grid {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
      margin-bottom: 10px;
    }
    .tier-pricing-grid th {
      background: #f8f9fa;
      padding: 6px 8px;
      text-align: center;
      font-weight: 600;
      color: #555;
      border-bottom: 2px solid #e0e0e0;
      font-size: 10px;
    }
    .tier-pricing-grid th:first-child {
      text-align: left;
      width: 45px;
    }
    .tier-pricing-grid td {
      padding: 4px 4px;
      border-bottom: 1px solid #f0f0f0;
      text-align: center;
    }
    .tier-pricing-grid td:first-child {
      text-align: left;
    }
    .tier-pricing-grid .tier-label {
      font-weight: 600;
      color: #0066a0;
      font-size: 11px;
    }
    .tier-pricing-grid input {
      width: 65px;
      padding: 4px 6px;
      border: 1px solid #d0d0d0;
      border-radius: 3px;
      text-align: right;
      font-size: 11px;
    }
    .tier-pricing-grid input:focus {
      border-color: #0096D6;
      outline: none;
    }
    .tier-pricing-grid .calculated {
      font-weight: 500;
      color: #1d4ed8;
      text-align: right;
      font-size: 11px;
      font-family: 'SF Mono', Monaco, monospace;
    }
    .tier-pricing-grid .calculated.iru {
      color: #7c3aed;
    }
    .tier-multiplier-help {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      padding: 6px 8px;
      background: #f8fafc;
      border-radius: 4px;
    }
    .tier-multiplier-help .hint {
      font-size: 10px;
      color: #64748b;
    }

    /* Settings link in pathfinder */
    .settings-link {
      font-size: 10px;
      color: #6b7280;
      display: flex;
      align-items: center;
      gap: 4px;
      margin-top: 8px;
      padding: 6px 8px;
      background: #f3f4f6;
      border-radius: 4px;
    }
    .settings-link a {
      color: #059669;
      text-decoration: none;
      cursor: pointer;
    }
    .settings-link a:hover { text-decoration: underline; }

    /* Shape Library Panel */
    #shapeLibraryPanel {
      position: fixed;
      left: 0;
      top: 120px;
      width: 220px;
      max-height: calc(100vh - 140px);
      background: #fff;
      border: 1px solid #d0d0d0;
      border-left: none;
      border-radius: 0 8px 8px 0;
      box-shadow: 2px 2px 12px rgba(0,0,0,0.1);
      z-index: 100;
      display: none;
      flex-direction: column;
      overflow: hidden;
      transition: left 0.3s ease, top 0.3s ease;
    }
    #shapeLibraryPanel.visible {
      display: flex;
    }
    /* Docked state - locked to left side, below all toolbar rows */
    /* Note: top/height are set dynamically by JavaScript based on actual header height */
    #shapeLibraryPanel.docked {
      position: fixed;
      left: 0 !important;
      border-radius: 0;
      border-left: none;
      border-top: none;
      border-bottom: none;
      box-shadow: 2px 0 12px rgba(0,0,0,0.1);
      z-index: 90;
    }
    #shapeLibraryPanel.docked .library-header {
      cursor: default;
    }
    #shapeLibraryPanel.docked .library-content {
      flex: 1;
      max-height: none;
    }
    /* When docked, adjust the main canvas */
    #wrap.library-docked #svgContainer {
      margin-left: 220px;
      width: calc(100% - 220px);
    }
    #wrap.library-docked #maplibreContainer {
      margin-left: 220px;
      width: calc(100% - 220px);
    }
    .library-header {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-weight: 600;
      font-size: 13px;
      cursor: grab;
      user-select: none;
    }
    .library-header:active {
      cursor: grabbing;
    }
    .library-header-actions {
      display: flex;
      gap: 4px;
    }
    .library-header-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    .library-header-btn:hover {
      background: rgba(255,255,255,0.3);
    }
    .library-header-btn.active {
      background: rgba(255,255,255,0.4);
    }
    .library-tabs {
      display: flex;
      border-bottom: 1px solid #e8e8e8;
      background: #f8f9fa;
    }
    .library-tab {
      flex: 1;
      padding: 8px 12px;
      border: none;
      background: transparent;
      font-size: 11px;
      font-weight: 500;
      color: #666;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }
    .library-tab:hover {
      background: #f0f0f0;
      color: #333;
    }
    .library-tab.active {
      color: #667eea;
      border-bottom-color: #667eea;
      background: white;
    }
    .library-search {
      padding: 8px;
      border-bottom: 1px solid #e8e8e8;
    }
    .library-search input {
      width: 100%;
      padding: 6px 10px;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      font-size: 12px;
    }
    .library-content {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }
    .library-category {
      margin-bottom: 12px;
      overflow: hidden;
    }
    .library-category-header {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: #f5f5f5;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      color: #555;
      cursor: pointer;
      user-select: none;
      position: relative;
      z-index: 1;
    }
    .library-category-header:hover {
      background: #eee;
    }
    .library-category-header .arrow {
      transition: transform 0.2s;
    }
    .library-category.collapsed .arrow {
      transform: rotate(-90deg);
    }
    .library-category.collapsed .library-items {
      display: none;
    }
    .library-items {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      padding: 8px 4px;
      overflow: hidden;
    }
    .library-item {
      aspect-ratio: 1;
      background: #f8f8f8;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      cursor: grab;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 4px;
      transition: all 0.15s;
      position: relative;
      overflow: hidden;
      min-height: 0;
    }
    .library-item:hover {
      border-color: #667eea;
      background: #f0f0ff;
      transform: scale(1.05);
    }
    .library-item:active {
      cursor: grabbing;
    }
    .library-item.selected {
      border-color: #667eea;
      background: #e8e8ff;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.3);
    }
    .library-item-preview {
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      flex-shrink: 0;
    }
    .library-item-preview svg {
      max-width: 100%;
      max-height: 100%;
      width: 32px;
      height: 32px;
      object-fit: contain;
    }
    .library-item-name {
      font-size: 9px;
      color: #666;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      width: 100%;
      margin-top: 2px;
    }
    .library-item-menu {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 16px;
      height: 16px;
      background: rgba(0,0,0,0.4);
      border-radius: 3px;
      color: white;
      font-size: 10px;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .library-item:hover .library-item-menu {
      display: flex;
    }
    .library-actions {
      padding: 8px;
      border-top: 1px solid #e8e8e8;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .library-action-btn {
      width: 100%;
      padding: 8px 12px;
      background: #f5f5f5;
      border: 1px solid #d0d0d0;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s;
    }
    .library-action-btn:hover {
      background: #e8e8e8;
      border-color: #bbb;
    }
    .library-action-btn.primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
    }
    .library-action-btn.primary:hover {
      filter: brightness(1.1);
    }
    .library-empty {
      text-align: center;
      padding: 20px;
      color: #999;
      font-size: 12px;
    }
    .library-empty svg {
      width: 48px;
      height: 48px;
      margin-bottom: 10px;
      opacity: 0.3;
    }

    /* Context menu for library */
    .context-menu {
      position: fixed;
      background: white;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.15);
      z-index: 10000;
      min-width: 160px;
      padding: 4px 0;
    }
    .context-menu-item {
      padding: 8px 14px;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .context-menu-item:hover {
      background: #f0f0ff;
    }
    .context-menu-item.danger {
      color: #c00;
    }
    .context-menu-item.danger:hover {
      background: #fff0f0;
    }
    .context-menu-sep {
      height: 1px;
      background: #e0e0e0;
      margin: 4px 0;
    }
    .context-menu-header {
      padding: 6px 14px 4px;
      font-size: 10px;
      font-weight: 600;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      pointer-events: none;
    }
    .context-menu-item.disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    /* ===== Datacenter Navigator Panel ===== */
    #dcNavigator {
      position: absolute;
      right: 20px;
      top: 20px;
      width: 310px;
      max-height: calc(100vh - 160px);
      background: #ffffff;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.12);
      z-index: 100;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      resize: both;
      min-width: 260px;
      max-width: 500px;
      min-height: 200px;
    }
    #dcNavigator.minimized {
      height: 40px !important;
      max-height: 40px;
      resize: none;
    }
    #dcNavigatorHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: linear-gradient(135deg, #fdf2f8 0%, #fce7f3 100%);
      border-bottom: 1px solid #f9a8d4;
      cursor: move;
      user-select: none;
    }
    #dcNavigatorHeader h3 {
      margin: 0; font-size: 13px; font-weight: 600; color: #831843;
    }
    #dcNavigatorControls {
      display: flex; gap: 4px;
    }
    #dcNavigatorControls button {
      background: transparent; border: 1px solid #f9a8d4; color: #9d174d;
      width: 24px; height: 24px; border-radius: 4px; cursor: pointer;
      font-size: 12px; display: flex; align-items: center; justify-content: center;
    }
    #dcNavigatorControls button:hover { background: #fce7f3; }
    #dcNavigatorContent {
      flex: 1; overflow: hidden; display: flex; flex-direction: column;
    }

    /* DC list items */
    .dc-item {
      padding: 6px 10px;
      border-bottom: 1px solid #f0f0f0;
      cursor: grab;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
    }
    .dc-item:hover { background: #fdf2f8; }
    .dc-item:active { cursor: grabbing; opacity: 0.7; }
    .dc-item.selected { background: #fce7f3; border-left: 3px solid #ec4899; }
    .dc-item .dc-name { font-weight: 500; font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .dc-item .dc-org { font-size: 9px; color: #888; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .dc-item .dc-meta { font-size: 9px; color: #999; }

    /* Carrier density badge (colored square) */
    .dc-density-badge {
      display: inline-block;
      width: 10px; height: 10px;
      border-radius: 2px;
      flex-shrink: 0;
    }
    .dc-density-badge.density-critical { background: #dc2626; box-shadow: 0 0 4px rgba(220,38,38,0.5); }
    .dc-density-badge.density-high     { background: #f97316; box-shadow: 0 0 4px rgba(249,115,22,0.5); }
    .dc-density-badge.density-medium   { background: #eab308; box-shadow: 0 0 3px rgba(234,179,8,0.4); }
    .dc-density-badge.density-low      { background: #22c55e; }
    .dc-density-badge.density-minimal  { background: #94a3b8; }

    /* DC region groups */
    .dc-region-group { margin-bottom: 2px; }
    .dc-region-header {
      padding: 5px 10px;
      background: linear-gradient(135deg, #fdf2f8 0%, #fce7f3 100%);
      border-bottom: 1px solid #f9a8d4;
      font-size: 10px; font-weight: 600; color: #831843;
      cursor: pointer;
      display: flex; justify-content: space-between; align-items: center;
      position: sticky; top: 0; z-index: 5;
    }
    .dc-region-header:hover { background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%); }
    .dc-region-items.collapsed { display: none; }

    /* DC detail expand panel */
    .dc-detail-panel {
      background: #fefce8;
      border-top: 1px solid #fde68a;
      border-bottom: 1px solid #fde68a;
      padding: 8px 10px;
      font-size: 10px;
      display: none;
    }
    .dc-detail-panel.show { display: block; }
    .dc-detail-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 4px;
    }
    .dc-detail-grid .dc-field {
      background: #fffbeb; padding: 4px 6px; border-radius: 4px; border: 1px solid #fef3c7;
    }
    .dc-detail-grid .dc-field-label { font-size: 9px; color: #92400e; text-transform: uppercase; letter-spacing: 0.3px; }
    .dc-detail-grid .dc-field-value { font-size: 11px; font-weight: 500; color: #1e293b; word-break: break-word; }
    .dc-detail-grid .dc-field.full-width { grid-column: 1 / -1; }
    .dc-networks-list {
      margin-top: 6px; max-height: 120px; overflow-y: auto;
    }
    .dc-net-tag {
      display: inline-flex; align-items: center; gap: 2px;
      padding: 2px 6px; margin: 2px; background: #eff6ff; border: 1px solid #bfdbfe;
      border-radius: 3px; font-size: 9px; color: #1e40af;
    }

    /* Drag-drop datacenter assignment */
    .dc-item[draggable="true"] { cursor: grab; }
    .dc-item[draggable="true"]:active { cursor: grabbing; opacity: 0.7; }
    .dc-drop-highlight { filter: drop-shadow(0 0 6px #ec4899) drop-shadow(0 0 12px #ec4899); }
    .node-dc-drop-highlight circle,
    .node-dc-drop-highlight rect,
    .node-dc-drop-highlight ellipse,
    .node-dc-drop-highlight polygon { filter: drop-shadow(0 0 6px #ec4899) drop-shadow(0 0 12px #ec4899); }

    /* Drag-drop cable system assignment */
    .cable-system-item[draggable="true"] { cursor: grab; }
    .cable-system-item[draggable="true"]:active { cursor: grabbing; opacity: 0.7; }
    .edge-drop-highlight path, .edge-drop-highlight line { filter: drop-shadow(0 0 6px #0096D6) drop-shadow(0 0 12px #0096D6); }
    #cableGeometryAssignDialog {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: white; border-radius: 10px; box-shadow: 0 8px 32px rgba(0,0,0,0.25);
      z-index: 10002; min-width: 380px; max-width: 500px; max-height: 80vh; overflow: hidden;
      display: flex; flex-direction: column;
    }
    #cableGeometryAssignDialog .dialog-header {
      padding: 14px 18px; border-bottom: 1px solid #e5e7eb; background: #f8f9fa;
      display: flex; justify-content: space-between; align-items: center;
    }
    #cableGeometryAssignDialog .dialog-body { padding: 14px 18px; overflow-y: auto; flex: 1; }
    #cableGeometryAssignDialog .dialog-footer {
      padding: 12px 18px; border-top: 1px solid #e5e7eb; display: flex; gap: 8px; justify-content: flex-end;
    }
    .geo-segment-list { max-height: 200px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 6px; padding: 6px; background: #fafafa; }
    .geo-segment-item { display: flex; align-items: center; gap: 8px; padding: 5px 4px; font-size: 11px; cursor: pointer; border-radius: 4px; }
    .geo-segment-item:hover { background: #f0f7ff; }
    .geo-segment-item .seg-info { flex: 1; min-width: 0; }
    .geo-segment-item .seg-name { font-weight: 500; color: #111; }
    .geo-segment-item .seg-detail { font-size: 9px; color: #888; }
    #cableGeoOverlay { position: fixed; inset: 0; background: rgba(0,0,0,0.3); z-index: 10001; }

    /* Canvas resize handle */
    #canvasResizeHandle {
      cursor: nwse-resize;
    }
    #canvasResizeHandle:hover path {
      stroke: #667eea;
      stroke-width: 2.5;
    }

    /* ========== Help Center Modal Styles ========== */
    #helpCenterModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.4);
      z-index: 20000;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(2px);
    }
    #helpCenterModal.show { display: flex; }

    #helpCenterContent {
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      width: 800px;
      max-width: 90vw;
      height: 600px;
      max-height: 85vh;
      min-width: 400px;
      min-height: 300px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      animation: helpCenterSlideIn 0.25s ease-out;
      position: relative;
    }
    #helpCenterContent.dragging {
      animation: none;
      user-select: none;
    }
    #helpCenterContent.positioned {
      position: fixed;
      animation: none;
    }

    @keyframes helpCenterSlideIn {
      from { opacity: 0; transform: scale(0.95) translateY(-10px); }
      to { opacity: 1; transform: scale(1) translateY(0); }
    }

    #helpCenterHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 24px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      cursor: move;
      user-select: none;
    }
    #helpCenterHeader h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #helpCenterHeader .close-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s;
    }
    #helpCenterHeader .close-btn:hover { background: rgba(255,255,255,0.3); }

    /* Resize handles for Help Center */
    .help-center-resize-handle {
      position: absolute;
      background: transparent;
    }
    .help-center-resize-handle.right {
      top: 0;
      right: 0;
      width: 8px;
      height: 100%;
      cursor: ew-resize;
    }
    .help-center-resize-handle.bottom {
      bottom: 0;
      left: 0;
      width: 100%;
      height: 8px;
      cursor: ns-resize;
    }
    .help-center-resize-handle.corner {
      bottom: 0;
      right: 0;
      width: 16px;
      height: 16px;
      cursor: nwse-resize;
      z-index: 1;
    }
    .help-center-resize-handle.corner::after {
      content: '';
      position: absolute;
      bottom: 4px;
      right: 4px;
      width: 8px;
      height: 8px;
      border-right: 2px solid rgba(102, 126, 234, 0.5);
      border-bottom: 2px solid rgba(102, 126, 234, 0.5);
    }

    #helpCenterSearch {
      padding: 14px 20px 14px 16px;
      background: #f8f9fa;
      border-bottom: 1px solid #e8e8e8;
    }
    #helpCenterSearch input {
      width: 100%;
      padding: 10px 16px 10px 40px;
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      font-size: 14px;
      background: white url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23999' stroke-width='2'%3E%3Ccircle cx='11' cy='11' r='8'/%3E%3Cpath d='m21 21-4.35-4.35'/%3E%3C/svg%3E") 12px center no-repeat;
      transition: border-color 0.15s, box-shadow 0.15s;
      box-sizing: border-box;
    }
    #helpCenterSearch input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.15);
    }
    #helpCenterSearch input::placeholder { color: #999; }

    #helpCenterBody {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    #helpCenterNav {
      width: 220px;
      min-width: 220px;
      background: #f8f9fa;
      border-right: 1px solid #e8e8e8;
      overflow-y: auto;
      padding: 12px 8px 12px 12px;
    }
    .help-nav-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px 12px 12px 8px;
      cursor: pointer;
      font-size: 13px;
      color: #555;
      transition: all 0.15s;
      border-left: 3px solid transparent;
      border-radius: 0 6px 6px 0;
    }
    .help-nav-item:hover {
      background: #f0f0f0;
      color: #333;
    }
    .help-nav-item.active {
      background: linear-gradient(90deg, rgba(102, 126, 234, 0.1) 0%, rgba(102, 126, 234, 0.05) 100%);
      color: #667eea;
      font-weight: 600;
      border-left-color: #667eea;
    }
    .help-nav-item .nav-icon {
      font-size: 16px;
      width: 24px;
      text-align: center;
    }
    .help-nav-item .nav-badge {
      margin-left: auto;
      background: #667eea;
      color: white;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: 600;
    }

    #helpCenterPanel {
      flex: 1;
      overflow-y: auto;
      padding: 20px 16px 20px 24px;
    }

    .help-section {
      display: none;
    }
    .help-section.active {
      display: block;
      animation: helpFadeIn 0.2s ease;
    }
    @keyframes helpFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .help-section h3 {
      margin: 0 0 16px 0;
      padding-top: 4px;
      font-size: 20px;
      color: #333;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .help-section h3 .section-icon { font-size: 24px; }

    .help-section p {
      color: #555;
      line-height: 1.6;
      margin: 0 0 16px 0;
    }

    /* Accordion for keyboard shortcuts */
    .help-accordion {
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 12px;
    }
    .help-accordion-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      background: #f8f9fa;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      color: #444;
      user-select: none;
      transition: background 0.15s;
    }
    .help-accordion-header:hover { background: #f0f0f0; }
    .help-accordion-header .accordion-icon {
      transition: transform 0.2s;
      color: #888;
    }
    .help-accordion.expanded .accordion-icon {
      transform: rotate(180deg);
    }
    .help-accordion-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.25s ease-out;
      background: white;
    }
    .help-accordion.expanded .help-accordion-content {
      max-height: 500px;
    }
    .help-accordion-inner {
      padding: 12px 16px;
    }

    /* Keyboard shortcut rows */
    .shortcut-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #f0f0f0;
    }
    .shortcut-row:last-child { border-bottom: none; }
    .shortcut-desc {
      color: #555;
      font-size: 13px;
    }
    .shortcut-keys {
      display: flex;
      gap: 4px;
    }
    .shortcut-keys kbd {
      display: inline-block;
      padding: 3px 8px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', monospace;
      font-size: 11px;
      color: #555;
      background: linear-gradient(180deg, #f8f8f8 0%, #e8e8e8 100%);
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1), inset 0 1px 0 rgba(255,255,255,0.8);
    }
    .shortcut-keys .plus {
      color: #999;
      font-size: 12px;
      align-self: center;
    }

    /* Feature cards */
    .feature-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
    }
    .feature-card {
      background: #f8f9fa;
      border: 1px solid #e8e8e8;
      border-radius: 10px;
      padding: 16px;
      transition: all 0.2s;
      cursor: pointer;
      position: relative;
    }
    .feature-card:hover {
      border-color: #667eea;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
      transform: translateY(-2px);
    }
    .feature-card:hover .feature-link {
      opacity: 1;
    }
    .feature-card h4 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #333;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .feature-card h4 .feature-icon { font-size: 18px; }
    .feature-card p {
      margin: 0;
      font-size: 12px;
      color: #666;
      line-height: 1.5;
    }
    .feature-card .feature-link {
      display: block;
      margin-top: 10px;
      font-size: 11px;
      font-weight: 600;
      color: #667eea;
      opacity: 0;
      transition: opacity 0.2s;
    }

    /* Tips list */
    .tips-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .tips-list li {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 12px 16px;
      background: #f8f9fa;
      border-radius: 8px;
      margin-bottom: 10px;
      border-left: 3px solid #667eea;
    }
    .tips-list li:last-child { margin-bottom: 0; }
    .tips-list .tip-icon {
      font-size: 18px;
      flex-shrink: 0;
    }
    .tips-list .tip-content {
      flex: 1;
    }
    .tips-list .tip-title {
      font-weight: 600;
      color: #333;
      margin-bottom: 4px;
      font-size: 13px;
    }
    .tips-list .tip-desc {
      color: #666;
      font-size: 12px;
      line-height: 1.5;
    }

    /* FAQ */
    .faq-item {
      margin-bottom: 12px;
      border: 1px solid #e8e8e8;
      border-radius: 8px;
      overflow: hidden;
    }
    .faq-question {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px;
      background: #f8f9fa;
      cursor: pointer;
      font-weight: 500;
      font-size: 13px;
      color: #333;
    }
    .faq-question:hover { background: #f0f0f0; }
    .faq-question .faq-icon {
      color: #888;
      transition: transform 0.2s;
    }
    .faq-item.expanded .faq-icon {
      transform: rotate(45deg);
    }
    .faq-answer {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.25s ease-out;
    }
    .faq-item.expanded .faq-answer {
      max-height: 300px;
    }
    .faq-answer-inner {
      padding: 14px 16px;
      color: #555;
      font-size: 13px;
      line-height: 1.6;
      border-top: 1px solid #e8e8e8;
    }

    /* Changelog */
    .changelog-version {
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid #e8e8e8;
    }
    .changelog-version:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
    .changelog-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }
    .changelog-badge {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
    }
    .changelog-badge.latest {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
    }
    .changelog-date {
      color: #888;
      font-size: 12px;
    }
    .changelog-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .changelog-list li {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 6px 0;
      font-size: 13px;
      color: #555;
    }
    .changelog-list .change-type {
      flex-shrink: 0;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .changelog-list .change-type.new { background: #dcfce7; color: #166534; }
    .changelog-list .change-type.improved { background: #dbeafe; color: #1e40af; }
    .changelog-list .change-type.fixed { background: #fef3c7; color: #92400e; }

    /* Search results highlight */
    .help-highlight {
      background: #fef08a;
      padding: 1px 2px;
      border-radius: 2px;
    }

    /* No results message */
    .help-no-results {
      text-align: center;
      padding: 40px 20px;
      color: #888;
    }
    .help-no-results .no-results-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }
    .help-no-results p {
      margin: 0;
      font-size: 14px;
    }

    /* Search Results Styling */
    .search-results-header {
      padding: 12px 16px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 8px;
      margin-bottom: 16px;
      font-size: 14px;
      color: #495057;
    }
    .search-results-header .results-count {
      color: #667eea;
      font-weight: 600;
    }
    .search-results-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .search-category {
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #868e96;
      padding: 12px 0 6px;
      border-bottom: 1px solid #e9ecef;
      margin-top: 8px;
    }
    .search-category:first-child {
      margin-top: 0;
    }
    .search-result-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: white;
      border: 1px solid #e9ecef;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .search-result-item:hover {
      border-color: #667eea;
      background: linear-gradient(135deg, #f8f9ff 0%, #f0f4ff 100%);
      transform: translateX(4px);
      box-shadow: 0 2px 8px rgba(102, 126, 234, 0.15);
    }
    .search-result-item .result-icon {
      font-size: 24px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8f9fa;
      border-radius: 8px;
      flex-shrink: 0;
    }
    .search-result-item:hover .result-icon {
      background: white;
    }
    .search-result-item .result-content {
      flex: 1;
      min-width: 0;
    }
    .search-result-item .result-title {
      font-size: 14px;
      font-weight: 600;
      color: #333;
      margin-bottom: 2px;
    }
    .search-result-item .result-desc {
      font-size: 12px;
      color: #666;
      line-height: 1.4;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .search-result-item .result-arrow {
      font-size: 16px;
      color: #adb5bd;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    .search-result-item:hover .result-arrow {
      color: #667eea;
      transform: translateX(4px);
    }
    .search-results-footer {
      margin-top: 20px;
      padding-top: 16px;
      border-top: 1px solid #e9ecef;
      text-align: center;
    }
    .search-full-guide-btn {
      padding: 12px 24px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .search-full-guide-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    /* Quick start cards */
    .quick-start-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }
    .quick-start-card {
      background: white;
      border: 1px solid #e8e8e8;
      border-radius: 10px;
      padding: 16px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    .quick-start-card:hover {
      border-color: #667eea;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .quick-start-card:hover .qs-link {
      opacity: 1;
    }
    .quick-start-card .qs-icon {
      font-size: 28px;
      margin-bottom: 8px;
    }
    .quick-start-card .qs-title {
      font-weight: 600;
      font-size: 13px;
      color: #333;
      margin-bottom: 4px;
    }
    .quick-start-card .qs-desc {
      font-size: 11px;
      color: #888;
    }
    .quick-start-card .qs-link {
      font-size: 10px;
      color: #667eea;
      margin-top: 8px;
      opacity: 0;
      transition: opacity 0.2s;
      font-weight: 600;
    }

    /* Help Action Buttons */
    .help-action-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }
    .help-action-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 10px 16px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border: 1px solid #dee2e6;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      color: #495057;
      cursor: pointer;
      transition: all 0.2s;
    }
    .help-action-btn:hover {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-color: #667eea;
      color: white;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    .help-action-btn span {
      font-size: 16px;
    }

    /* Printable shortcuts */
    #helpCenterFooter {
      padding: 12px 24px;
      background: #f8f9fa;
      border-top: 1px solid #e8e8e8;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #helpCenterFooter .footer-left {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #888;
      font-size: 12px;
    }
    #helpCenterFooter .footer-btn {
      padding: 8px 16px;
      background: white;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s;
    }
    #helpCenterFooter .footer-btn:hover {
      background: #f0f0f0;
      border-color: #bbb;
    }
  </style>
</head>
<body>

<header style="background:#fafafa; border-bottom:1px solid #e0e0e0;">
  <!-- Menu Bar (text menus) -->
  <div style="display:flex; align-items:center; gap:0; padding:4px 12px; background:#fff; border-bottom:1px solid #e8e8e8;">
    <div style="display:flex; align-items:center; gap:8px; margin-right:20px; cursor:default;">
      <!-- NexiMap Studio Logo - Minimal Network Grid -->
      <svg width="28" height="28" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="logoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#667eea"/>
            <stop offset="100%" style="stop-color:#764ba2"/>
          </linearGradient>
        </defs>
        <!-- Rounded square background -->
        <rect x="2" y="2" width="28" height="28" rx="4" fill="url(#logoGradient)"/>
        <!-- Subtle grid lines -->
        <path d="M8 8H24M8 16H24M8 24H24M8 8V24M16 8V24M24 8V24" stroke="white" stroke-width="0.8" opacity="0.2"/>
        <!-- Network highlight (X pattern) -->
        <path d="M8 8L16 16L24 8M16 16L8 24M16 16L24 24" stroke="white" stroke-width="1.8" stroke-linecap="round"/>
        <!-- Network nodes -->
        <circle cx="8" cy="8" r="2.5" fill="white"/>
        <circle cx="24" cy="8" r="2.5" fill="white"/>
        <circle cx="16" cy="16" r="3" fill="white"/>
        <circle cx="8" cy="24" r="2.5" fill="white"/>
        <circle cx="24" cy="24" r="2.5" fill="white"/>
      </svg>
      <span style="font-weight:600; font-size:15px; color:#5a67d8; letter-spacing:-0.3px;">NexiMap</span>
      <span style="font-weight:400; font-size:15px; color:#666; letter-spacing:-0.3px;">Studio</span>
      <span id="appVersionBadge" style="font-size:9px; font-weight:500; color:#94a3b8; background:#f1f5f9; border:1px solid #e2e8f0; border-radius:4px; padding:1px 5px; margin-left:2px; letter-spacing:0.2px; cursor:default; user-select:none;" title="Click for version info">v62.2</span>
    </div>
    <button class="menu-item" id="btnFile" type="button">File</button>
    <button class="menu-item" id="btnEditMenu" type="button">Edit</button>
    <button class="menu-item" id="btnViewMenu" type="button">View</button>
    <button class="menu-item" id="btnDataMenu" type="button">Data</button>
    <button class="menu-item" id="btnSettingsMenu" type="button">Settings</button>
    <button class="menu-item" id="btnHelp" type="button">Help</button>
    <div class="menu" id="fileMenu" hidden>
      <div class="item" id="miNew">New <span style="opacity:0.5;float:right">Ctrl+N</span></div>
      <div class="item" id="miOpen">Openâ€¦ <span style="opacity:0.5;float:right">Ctrl+O</span></div>
      <div class="sep"></div>
      <div class="item" id="miSave">Save <span style="opacity:0.5;float:right">Ctrl+S</span></div>
      <div class="item" id="miSaveAs">Save Asâ€¦</div>
      <div class="sep"></div>

      <!-- Import/Export Submenu -->
      <div class="item has-submenu">
        Import / Export
        <div class="submenu">
          <div class="menu-section-header">SPREADSHEET DATA</div>
          <div class="item" id="btnDownloadTemplate">ðŸ“‹ Download Import Templateâ€¦</div>
          <div class="item" id="btnImportProject">ðŸ“¥ Import from Spreadsheetâ€¦</div>
          <div class="sep"></div>
          <div class="menu-section-header">EXPORT DATA (CSV)</div>
          <div class="item" id="btnExportNodes">Export Nodesâ€¦</div>
          <div class="item" id="btnExportLinks">Export Linksâ€¦</div>
          <div class="sep"></div>
          <div class="menu-section-header">EXPORT IMAGE</div>
          <div class="item" id="miExportSVG">Export as SVGâ€¦</div>
          <div class="item" id="miExportPNG">Export as PNGâ€¦</div>
          <div class="item" id="miExportJPG">Export as JPGâ€¦</div>
        </div>
      </div>
      <div class="sep"></div>

      <div class="item" id="miPrintPreview">Print Previewâ€¦</div>
      <div class="item" id="miPrint">Printâ€¦ <span style="opacity:0.5;float:right">Ctrl+P</span></div>
      <div class="sep"></div>

      <!-- Recovery Submenu -->
      <div class="item has-submenu">
        Recovery
        <div class="submenu">
          <div class="item" id="miRecover">Recover Autosave</div>
          <div class="item" id="miClearAutosave">Clear Autosave</div>
        </div>
      </div>
      <div class="sep"></div>

      <div class="item" id="miClearDiagram">Clear Diagram</div>
      <div class="item" id="miTrimCanvas">Trim Canvas to Content</div>
    </div>
    <div class="menu" id="editMenu" hidden>
      <div class="item" id="miUndo">Undo <span style="opacity:0.5;float:right">Ctrl+Z</span></div>
      <div class="item" id="miRedo">Redo <span style="opacity:0.5;float:right">Ctrl+Shift+Z</span></div>
      <div class="sep"></div>
      <div class="item" id="miCopy">Copy <span style="opacity:0.5;float:right">Ctrl+C</span></div>
      <div class="item" id="miCut">Cut <span style="opacity:0.5;float:right">Ctrl+X</span></div>
      <div class="item" id="miPaste">Paste <span style="opacity:0.5;float:right">Ctrl+V</span></div>
      <div class="sep"></div>
      <div class="item" id="miDelete">Delete <span style="opacity:0.5;float:right">Del</span></div>
    </div>
    <div class="menu" id="viewMenu" hidden style="min-width:220px;">
      <div class="item" id="miZoomIn">Zoom In <span style="opacity:0.5;float:right">Ctrl++</span></div>
      <div class="item" id="miZoomOut">Zoom Out <span style="opacity:0.5;float:right">Ctrl+-</span></div>
      <div class="item" id="miFitView">Fit to View</div>
      <div class="sep"></div>
      <div class="item" id="miToggleInspector">Toggle Inspector <span style="opacity:0.5;float:right">I</span></div>
      <div class="item" id="miTagFilter">Tag Filterâ€¦ <span style="opacity:0.5;float:right">F</span></div>
      <div class="sep"></div>

      <!-- Heat Map Section -->
      <div class="menu-section-header">ðŸŒ¡ï¸ Heat Map</div>
      <div class="item has-submenu" id="heatMapMenuItem">ðŸ”¥ Link Heat Map
        <div class="submenu" id="heatMapSubmenu" style="min-width:320px;">
          <div class="menu-section-header">Heat Map Mode</div>
          <label class="item toggle-item"><input type="radio" name="heatMapMode" id="heatMapModeOff" checked /> Off (Normal View)</label>
          <label class="item toggle-item"><input type="radio" name="heatMapMode" id="heatMapModeCapacity" /> ðŸ“Š Capacity Available</label>
          <label class="item toggle-item"><input type="radio" name="heatMapMode" id="heatMapModePrice" /> ðŸ’° Price (MRC)</label>
          <div class="sep"></div>

          <!-- Price Tier Selection (shown when Price mode selected) -->
          <div id="heatMapPriceTierSection" style="display:none; padding:8px 12px; background:#f8f9fa;">
            <div style="font-size:10px; font-weight:600; color:#666; margin-bottom:6px; text-transform:uppercase;">Price Tier</div>
            <div style="display:flex; gap:4px;">
              <label style="flex:1; display:flex; align-items:center; justify-content:center; padding:6px 4px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600; background:white;" id="heatMapTier1GLabel">
                <input type="radio" name="heatMapPriceTier" id="heatMapTier1G" value="1G" style="display:none;" />
                <span>1G</span>
              </label>
              <label style="flex:1; display:flex; align-items:center; justify-content:center; padding:6px 4px; border:2px solid #3b82f6; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600; background:#eff6ff; color:#1d4ed8;" id="heatMapTier10GLabel">
                <input type="radio" name="heatMapPriceTier" id="heatMapTier10G" value="10G" checked style="display:none;" />
                <span>10G</span>
              </label>
              <label style="flex:1; display:flex; align-items:center; justify-content:center; padding:6px 4px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600; background:white;" id="heatMapTier100GLabel">
                <input type="radio" name="heatMapPriceTier" id="heatMapTier100G" value="100G" style="display:none;" />
                <span>100G</span>
              </label>
              <label style="flex:1; display:flex; align-items:center; justify-content:center; padding:6px 4px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600; background:white;" id="heatMapTier400GLabel">
                <input type="radio" name="heatMapPriceTier" id="heatMapTier400G" value="400G" style="display:none;" />
                <span>400G</span>
              </label>
            </div>
          </div>

          <div class="sep"></div>
          <div class="menu-section-header">Color Gradient</div>
          <div style="padding:10px 12px;">
            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
              <span style="font-size:11px; color:#666; width:70px;">Low (Cold):</span>
              <div id="heatMapColdColorSwatch" style="width:28px; height:22px; background:#22c55e; border-radius:4px; border:1px solid #ccc; cursor:pointer; position:relative;" title="Click to change color"></div>
              <div id="heatMapColdColorPicker" style="display:none; position:absolute; z-index:1000; margin-top:4px;"></div>
              <input type="color" id="heatMapColdColor" value="#22c55e" style="display:none;">
              <span id="heatMapColdColorHex" style="font-size:10px; color:#888; font-family:monospace;">#22c55e</span>
            </div>
            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
              <span style="font-size:11px; color:#666; width:70px;">High (Hot):</span>
              <div id="heatMapHotColorSwatch" style="width:28px; height:22px; background:#ef4444; border-radius:4px; border:1px solid #ccc; cursor:pointer; position:relative;" title="Click to change color"></div>
              <div id="heatMapHotColorPicker" style="display:none; position:absolute; z-index:1000; margin-top:4px;"></div>
              <input type="color" id="heatMapHotColor" value="#ef4444" style="display:none;">
              <span id="heatMapHotColorHex" style="font-size:10px; color:#888; font-family:monospace;">#ef4444</span>
            </div>
            <!-- Gradient Preview -->
            <div style="margin-top:10px;">
              <div style="font-size:10px; color:#666; margin-bottom:4px;">Preview:</div>
              <div id="heatMapGradientPreview" style="height:16px; border-radius:4px; background:linear-gradient(to right, #22c55e, #ef4444); border:1px solid #ddd;"></div>
              <div style="display:flex; justify-content:space-between; font-size:9px; color:#888; margin-top:2px;">
                <span>Min</span>
                <span>Max</span>
              </div>
            </div>
          </div>

          <div class="sep"></div>
          <!-- Legend Display Option -->
          <label class="item toggle-item"><input type="checkbox" id="heatMapShowLegend" checked /> Show Legend on Canvas</label>
          <label class="item toggle-item" title="Use logarithmic scale for better visualization of wide value ranges"><input type="checkbox" id="heatMapUseLogarithmic" /> ðŸ“ˆ Logarithmic Scale</label>

          <div class="sep"></div>
          <div style="padding:8px 12px; font-size:10px; color:#666; background:#f0fdf4; border-top:1px solid #86efac;">
            <strong>ðŸ’¡ Tip:</strong> Capacity: red=low (bad), green=high (good). Price: green=low (good), red=high (bad). Use logarithmic scale for wide ranges.
          </div>
        </div>
      </div>

      <div class="sep"></div>

      <!-- View Mode Section -->
      <div class="menu-section-header">ðŸŒ View Mode</div>
      <label class="item toggle-item"><input type="radio" name="viewMode" id="viewModeStandard" checked /> Standard Canvas</label>
      <label class="item toggle-item"><input type="radio" name="viewMode" id="viewModeGeo" /> ðŸŒ Geo Static Background</label>
      <label class="item toggle-item"><input type="radio" name="viewMode" id="viewModeMapLibre" /> ðŸ—ºï¸ Geo Dynamic Map</label>

      <div class="sep"></div>

      <!-- Geo Dynamic Map Settings - Submenu -->
      <div class="item has-submenu" id="mapLibreSettingsItem">ðŸ—ºï¸ Geo Dynamic Map Settings
        <div class="submenu" id="mapLibreSubmenu" style="min-width:280px;">
          <div class="menu-section-header">Map Style</div>
          <label class="item toggle-item"><input type="radio" name="mapLibreStyle" id="mapStyleLiberty" checked /> Liberty (Default)</label>
          <label class="item toggle-item"><input type="radio" name="mapLibreStyle" id="mapStyleBright" /> Bright</label>
          <label class="item toggle-item"><input type="radio" name="mapLibreStyle" id="mapStylePositron" /> Positron (Light)</label>
          <label class="item toggle-item"><input type="radio" name="mapLibreStyle" id="mapStyleDarkMatter" /> Dark Matter</label>
          <div class="sep"></div>

          <div class="menu-section-header">Element Style Mode</div>
          <label class="item toggle-item" title="Show nodes and links with their individual canvas colors and sizes">
            <input type="radio" name="mlStyleMode" id="mlStyleModeCanvas" checked /> Use Canvas Styles
          </label>
          <label class="item toggle-item" title="Show all nodes and links with uniform simplified styles">
            <input type="radio" name="mlStyleMode" id="mlStyleModeSimplified" /> Use Simplified View
          </label>

          <!-- Simplified View Settings (shown when Simplified View is selected) -->
          <div id="mlSimplifiedSettings" style="display:none; padding:8px 12px; background:#f8f9fa; border-top:1px solid #e5e5e5;">
            <div style="font-size:10px; font-weight:600; color:#666; margin-bottom:8px; text-transform:uppercase;">Simplified Node Style</div>
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:6px;">
              <label style="width:50px; font-size:11px;">Fill:</label>
              <div id="mlSimplifiedNodeFillPicker"></div>
              <input type="color" id="mlSimplifiedNodeFill" value="#dae8fc" style="display:none;">
            </div>
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:6px;">
              <label style="width:50px; font-size:11px;">Stroke:</label>
              <div id="mlSimplifiedNodeStrokePicker"></div>
              <input type="color" id="mlSimplifiedNodeStroke" value="#6c8ebf" style="display:none;">
            </div>
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:10px;">
              <label style="width:50px; font-size:11px;">Size:</label>
              <input type="range" id="mlSimplifiedNodeSize" min="8" max="40" step="2" value="20" style="width:80px;">
              <span id="mlSimplifiedNodeSizeVal" style="font-size:10px; color:#888;">20px</span>
            </div>

            <div style="font-size:10px; font-weight:600; color:#666; margin-bottom:8px; text-transform:uppercase; border-top:1px solid #e0e0e0; padding-top:8px;">Simplified Link Style</div>
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:6px;">
              <label style="width:50px; font-size:11px;">Color:</label>
              <div id="mlSimplifiedLinkColorPicker"></div>
              <input type="color" id="mlSimplifiedLinkColor" value="#6c8ebf" style="display:none;">
            </div>
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:6px;">
              <label style="width:50px; font-size:11px;">Width:</label>
              <input type="range" id="mlSimplifiedLinkWidth" min="1" max="8" step="0.5" value="2" style="width:80px;">
              <span id="mlSimplifiedLinkWidthVal" style="font-size:10px; color:#888;">2px</span>
            </div>
            <div style="display:flex; align-items:center; gap:6px;">
              <label style="width:50px; font-size:11px;">Style:</label>
              <select id="mlSimplifiedLinkStyle" style="font-size:11px; padding:2px 4px; border:1px solid #ccc; border-radius:3px;">
                <option value="solid">Solid</option>
                <option value="dashed">Dashed</option>
                <option value="dotted">Dotted</option>
              </select>
            </div>
          </div>

          <div class="sep"></div>
          <div class="menu-section-header">Display</div>
          <label class="item toggle-item"><input type="checkbox" id="mlShowNodes" checked /> Show Nodes</label>
          <label class="item toggle-item"><input type="checkbox" id="mlShowLinks" checked /> Show Links</label>
          <div style="padding:4px 14px; font-size:9px; color:#888;">
            OpenFreeMap + OpenStreetMap
          </div>
        </div>
      </div>

      <!-- Geo Static Background Settings - Submenu -->
      <div class="item has-submenu" id="geoViewSettingsItem">ðŸŒ Geo Static Background Settings
        <div class="submenu" id="geoViewSubmenu" style="min-width:280px;">
          <div class="menu-section-header">Map Background</div>
          <label class="item toggle-item"><input type="radio" name="mapSource" id="mapSourceUrl" checked /> Wikimedia Map</label>
          <label class="item toggle-item"><input type="radio" name="mapSource" id="mapSourceUpload" /> Uploaded Image</label>
          <label class="item toggle-item"><input type="radio" name="mapSource" id="mapSourceBuiltin" /> Built-in SVG Map</label>
          <div class="item" id="miLoadMapUrl" style="color:#0096D6;">ðŸ”— Load from URL...</div>
          <div class="item" id="miUploadGeoMap" style="color:#0096D6;">ðŸ“· Upload Image...</div>
          <div class="sep"></div>

          <div class="menu-section-header">Element Style Mode</div>
          <label class="item toggle-item" title="Show nodes and links with their individual canvas colors and sizes">
            <input type="radio" name="geoStaticStyleMode" id="geoStaticStyleModeCanvas" checked /> Use Canvas Styles
          </label>
          <label class="item toggle-item" title="Show all nodes and links with uniform simplified styles">
            <input type="radio" name="geoStaticStyleMode" id="geoStaticStyleModeSimplified" /> Use Simplified View
          </label>

          <!-- Simplified View Settings for Geo Static -->
          <div id="geoStaticSimplifiedSettings" style="display:none; padding:8px 12px; background:#f8f9fa; border-top:1px solid #e5e5e5;">
            <div style="font-size:10px; font-weight:600; color:#666; margin-bottom:8px; text-transform:uppercase;">Simplified Node Style</div>
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:6px;">
              <label style="width:50px; font-size:11px;">Fill:</label>
              <div id="geoStaticNodeFillPicker"></div>
              <input type="color" id="geoStaticNodeFill" value="#dae8fc" style="display:none;">
            </div>
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:6px;">
              <label style="width:50px; font-size:11px;">Stroke:</label>
              <div id="geoStaticNodeStrokePicker"></div>
              <input type="color" id="geoStaticNodeStroke" value="#6c8ebf" style="display:none;">
            </div>
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:10px;">
              <label style="width:50px; font-size:11px;">Size:</label>
              <input type="range" id="geoStaticNodeSize" min="4" max="24" step="1" value="12" style="width:80px;">
              <span id="geoStaticNodeSizeVal" style="font-size:10px; color:#888;">12px</span>
            </div>

            <div style="font-size:10px; font-weight:600; color:#666; margin-bottom:8px; text-transform:uppercase; border-top:1px solid #e0e0e0; padding-top:8px;">Simplified Link Style</div>
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:6px;">
              <label style="width:50px; font-size:11px;">Color:</label>
              <div id="geoStaticLinkColorPicker"></div>
              <input type="color" id="geoStaticLinkColor" value="#666666" style="display:none;">
            </div>
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:6px;">
              <label style="width:50px; font-size:11px;">Width:</label>
              <input type="range" id="geoStaticLinkWidth" min="1" max="8" step="0.5" value="2" style="width:80px;">
              <span id="geoStaticLinkWidthVal" style="font-size:10px; color:#888;">2px</span>
            </div>
            <div style="display:flex; align-items:center; gap:6px;">
              <label style="width:50px; font-size:11px;">Style:</label>
              <select id="geoStaticLinkStyle" style="font-size:11px; padding:2px 4px; border:1px solid #ccc; border-radius:3px;">
                <option value="solid">Solid</option>
                <option value="dashed">Dashed</option>
                <option value="dotted">Dotted</option>
              </select>
            </div>
          </div>

          <div class="sep"></div>
          <div class="menu-section-header">Projection Adjustment</div>
          <div class="submenu-content" style="font-size:11px;">
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:4px;">
              <label style="width:55px; color:#666;">Scale X:</label>
              <input type="range" id="projScaleX" min="0.8" max="1.2" step="0.005" value="0.895" style="width:60px; cursor:pointer;">
              <input type="number" id="projScaleXVal" value="0.895" step="0.005" min="0.5" max="1.5" style="width:50px; font-size:10px; text-align:center; padding:2px;">
            </div>
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:4px;">
              <label style="width:55px; color:#666;">Scale Y:</label>
              <input type="range" id="projScaleY" min="0.8" max="1.2" step="0.005" value="0.815" style="width:60px; cursor:pointer;">
              <input type="number" id="projScaleYVal" value="0.815" step="0.005" min="0.5" max="1.5" style="width:50px; font-size:10px; text-align:center; padding:2px;">
            </div>
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:4px;">
              <label style="width:55px; color:#666;">Offset X:</label>
              <input type="range" id="projOffsetX" min="-100" max="100" step="1" value="-61" style="width:60px; cursor:pointer;">
              <input type="number" id="projOffsetXVal" value="-61" step="1" min="-200" max="200" style="width:50px; font-size:10px; text-align:center; padding:2px;">
            </div>
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:4px;">
              <label style="width:55px; color:#666;">Offset Y:</label>
              <input type="range" id="projOffsetY" min="-100" max="100" step="1" value="-10" style="width:60px; cursor:pointer;">
              <input type="number" id="projOffsetYVal" value="-10" step="1" min="-200" max="200" style="width:50px; font-size:10px; text-align:center; padding:2px;">
            </div>
            <div style="display:flex; gap:4px; margin-top:6px;">
              <button id="projResetBtn" class="btn mini-btn" style="flex:1; font-size:10px; padding:3px 6px;">Reset</button>
              <button id="projShowValuesBtn" class="btn mini-btn" style="flex:1; font-size:10px; padding:3px 6px;">ðŸ“‹ Copy</button>
            </div>
          </div>
        </div>
      </div>

      <div class="sep"></div>

      <!-- Labels - Submenu -->
      <div class="item has-submenu">ðŸ·ï¸ Labels
        <div class="submenu">
          <div style="display:flex; justify-content:space-between; align-items:center; padding:4px 10px; border-bottom:1px solid #e5e5e5; margin-bottom:4px;">
            <span style="font-size:11px; color:#666;">Label Visibility</span>
            <button id="btnPinLabels" title="Pin as floating panel" style="background:none; border:1px solid #ccc; border-radius:3px; padding:2px 6px; font-size:10px; cursor:pointer;">ðŸ“Œ Pin</button>
          </div>
          <div class="menu-section-header">Node Labels</div>
          <label class="item toggle-item"><input type="checkbox" id="tglShowNodeName" checked /> Node Names</label>
          <label class="item toggle-item"><input type="checkbox" id="tglShowNodeCode" checked /> Node Codes</label>
          <label class="item toggle-item"><input type="checkbox" id="tglShowNodeTags" /> Node Tags</label>
          <label class="item toggle-item"><input type="checkbox" id="tglShowExtraTags" /> Additional Tags</label>
          <div class="sep"></div>
          <div class="menu-section-header">Link Labels</div>
          <label class="item toggle-item"><input type="checkbox" id="tglShowLinkTag" checked /> Link Tags</label>
          <label class="item toggle-item"><input type="checkbox" id="tglShowLinkCode" checked /> Link Codes</label>
          <label class="item toggle-item"><input type="checkbox" id="tglShowLatency" checked /> Latency Values</label>
          <div class="sep"></div>
          <div class="menu-section-header">Container Labels</div>
          <label class="item toggle-item"><input type="checkbox" id="tglShowContainerTitle" checked /> Container Titles</label>
        </div>
      </div>
    </div>

    <!-- Floating Labels Panel (pinned) -->
    <div id="floatingLabelsPanel" class="floating-panel" style="display:none; position:fixed; top:80px; right:20px; z-index:1500; background:white; border-radius:8px; box-shadow:0 4px 20px rgba(0,0,0,0.25); min-width:200px; font-size:12px;">
      <div class="floating-panel-header" style="display:flex; justify-content:space-between; align-items:center; padding:8px 12px; background:#f5f5f5; border-radius:8px 8px 0 0; cursor:move; border-bottom:1px solid #e0e0e0;">
        <span style="font-weight:600; font-size:12px;">ðŸ·ï¸ Labels</span>
        <div>
          <span id="floatingLabelsViewIndicator" style="font-size:10px; color:#666; margin-right:8px;">Canvas</span>
          <button id="btnCloseLabelsPanel" title="Close" style="background:none; border:none; font-size:14px; cursor:pointer; color:#666;">âœ•</button>
        </div>
      </div>
      <div style="padding:8px 0;">
        <div class="menu-section-header" style="padding:4px 12px; font-size:10px; color:#888; text-transform:uppercase;">Node Labels</div>
        <label class="item toggle-item" style="display:flex; align-items:center; padding:4px 12px; cursor:pointer;"><input type="checkbox" id="floatShowNodeName" style="margin-right:8px;" /> Node Names</label>
        <label class="item toggle-item" style="display:flex; align-items:center; padding:4px 12px; cursor:pointer;"><input type="checkbox" id="floatShowNodeCode" style="margin-right:8px;" /> Node Codes</label>
        <label class="item toggle-item" style="display:flex; align-items:center; padding:4px 12px; cursor:pointer;"><input type="checkbox" id="floatShowNodeTags" style="margin-right:8px;" /> Node Tags</label>
        <label class="item toggle-item" style="display:flex; align-items:center; padding:4px 12px; cursor:pointer;"><input type="checkbox" id="floatShowExtraTags" style="margin-right:8px;" /> Additional Tags</label>
        <div style="border-top:1px solid #eee; margin:4px 0;"></div>
        <div class="menu-section-header" style="padding:4px 12px; font-size:10px; color:#888; text-transform:uppercase;">Link Labels</div>
        <label class="item toggle-item" style="display:flex; align-items:center; padding:4px 12px; cursor:pointer;"><input type="checkbox" id="floatShowLinkTag" style="margin-right:8px;" /> Link Tags</label>
        <label class="item toggle-item" style="display:flex; align-items:center; padding:4px 12px; cursor:pointer;"><input type="checkbox" id="floatShowLinkCode" style="margin-right:8px;" /> Link Codes</label>
        <label class="item toggle-item" style="display:flex; align-items:center; padding:4px 12px; cursor:pointer;"><input type="checkbox" id="floatShowLatency" style="margin-right:8px;" /> Latency Values</label>
        <div style="border-top:1px solid #eee; margin:4px 0;"></div>
        <div class="menu-section-header" style="padding:4px 12px; font-size:10px; color:#888; text-transform:uppercase;">Container Labels</div>
        <label class="item toggle-item" style="display:flex; align-items:center; padding:4px 12px; cursor:pointer;"><input type="checkbox" id="floatShowContainerTitle" style="margin-right:8px;" /> Container Titles</label>
      </div>
    </div>

    <div class="menu" id="helpMenu" hidden style="min-width:200px;">
      <div class="item" id="miHelpCenter">ðŸ“› Help Center... <span style="opacity:0.5;float:right">F1</span></div>
      <div class="item" id="miOnlineGuide">ðŸŒ Online User Guide...</div>
      <div class="sep"></div>
      <div class="item" id="miQuickShortcuts">âŒ¨ï¸ Quick Shortcuts</div>
      <div class="sep"></div>
      <div class="item" id="miAbout">â„¹ï¸ About NexiMap Studio</div>
    </div>

    <!-- Data Menu -->
    <div class="menu" id="dataMenu" hidden style="min-width:220px;">
      <div class="menu-section-header">ðŸ“Š DATA MANAGEMENT</div>
      <div class="item" id="miDataTable">ðŸ“‹ Data Table View... <span style="opacity:0.5;float:right">Ctrl+T</span></div>
      <div class="item" id="miCapacityEditor">ðŸ“Š Capacity Editor... <span style="opacity:0.5;float:right">Ctrl+K</span></div>
      <div class="sep"></div>
      <div class="menu-section-header">BULK OPERATIONS</div>
      <div class="item" id="miBulkEditLinks">ðŸ“ Bulk Edit Links...</div>
      <div class="item" id="miBulkEditNodes">ðŸ“ Bulk Edit Nodes...</div>
      <div class="sep"></div>
      <div class="item" id="miRecalculateCosts">ðŸ”„ Recalculate All Costs</div>
      <div class="sep"></div>
      <div class="menu-section-header">GEO TOOLS</div>
      <div class="item" id="miKMLStudio">ðŸŒ KML Studio... <span style="opacity:0.5;float:right">Ctrl+G</span></div>
      <div class="item" id="miKMLStudioSelection">ðŸŒ Open Selection in KML Studio</div>
    </div>

    <!-- Settings Menu -->
    <div class="menu" id="settingsMenu" hidden style="min-width:220px;">
      <div class="menu-section-header">â›™ï¸ CONFIGURATION</div>
      <div class="item" id="miFinancialSettings">ðŸ’° Financial Settings...</div>
      <div class="item" id="miDisplayPrefs">ðŸŽ¨ Display Preferences...</div>
      <div class="sep"></div>
      <div class="menu-section-header">DEFAULTS</div>
      <div class="item" id="miNodeDefaults">ðŸ“ Default Node Style...</div>
      <div class="item" id="miLinkDefaults">ðŸ”— Default Link Style...</div>
    </div>
    <input type="file" id="fileLoad" accept=".ndg,application/json" style="display:none;" />
  </div>

  <!-- Icon Toolbar -->
  <div style="display:flex; align-items:center; gap:2px; padding:4px 12px; background:#fafafa;">
    <!-- Zoom Controls -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnZoomLevel" type="button" style="min-width:60px; font-size:12px; gap:4px;" title="Click for zoom options">
        <span id="zoomLevel">100%</span> <span style="font-size:10px;">â–¾</span>
      </button>
      <div class="menu" id="zoomMenu" hidden style="min-width:180px;">
        <div class="item" id="zoomFitView">Fit to View <span style="opacity:0.5;float:right">Enter</span></div>
        <div class="sep"></div>
        <div class="item zoom-preset" data-zoom="0.25">25%</div>
        <div class="item zoom-preset" data-zoom="0.50">50%</div>
        <div class="item zoom-preset" data-zoom="0.75">75%</div>
        <div class="item zoom-preset" data-zoom="1.00">100%</div>
        <div class="item zoom-preset" data-zoom="1.25">125%</div>
        <div class="item zoom-preset" data-zoom="1.50">150%</div>
        <div class="item zoom-preset" data-zoom="2.00">200%</div>
        <div class="item zoom-preset" data-zoom="3.00">300%</div>
        <div class="item zoom-preset" data-zoom="4.00">400%</div>
        <div class="sep"></div>
        <div class="item" id="zoomReset">Reset to 100% <span style="opacity:0.5;float:right">Ctrl+0</span></div>
      </div>
    </div>
    <!-- Zoom In -->
    <button class="tool-btn" id="btnZoomIn" type="button" title="Zoom In">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/>
      </svg>
    </button>
    <!-- Zoom Out -->
    <button class="tool-btn" id="btnZoomOut" type="button" title="Zoom Out">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/>
      </svg>
    </button>
    <!-- Fit to View -->
    <button class="tool-btn" id="btnZoomFit" type="button" title="Fit to View">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
      </svg>
    </button>
    <!-- Grid Toggle -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnGridToggle" type="button" title="Toggle Grid">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
          <line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/>
          <line x1="6" y1="3" x2="6" y2="21"/><line x1="12" y1="3" x2="12" y2="21"/><line x1="18" y1="3" x2="18" y2="21"/>
        </svg>
      </button>
      <div class="menu" id="gridMenu" hidden style="min-width:150px;">
        <label class="item toggle-item"><input type="checkbox" id="gridEnabled" checked /> Show Grid</label>
        <div class="sep"></div>
        <div class="item grid-size" data-size="10">Fine (10px)</div>
        <div class="item grid-size" data-size="20">Small (20px)</div>
        <div class="item grid-size active" data-size="40">Medium (40px)</div>
        <div class="item grid-size" data-size="60">Large (60px)</div>
        <div class="item grid-size" data-size="100">Extra Large (100px)</div>
      </div>
    </div>

    <div class="tool-sep"></div>

    <!-- Undo -->
    <button class="tool-btn" id="btnUndo" type="button" title="Undo (Ctrl+Z)">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M3 7v6h6"/><path d="M3 13c0-4.97 4.03-9 9-9s9 4.03 9 9-4.03 9-9 9c-2.12 0-4.07-.74-5.61-1.97"/>
      </svg>
    </button>
    <!-- Redo -->
    <button class="tool-btn" id="btnRedo" type="button" title="Redo (Ctrl+Shift+Z)">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 7v6h-6"/><path d="M21 13c0-4.97-4.03-9-9-9s-9 4.03-9 9 4.03 9 9 9c2.12 0 4.07-.74 5.61-1.97"/>
      </svg>
    </button>

    <div class="tool-sep"></div>

    <!-- Delete -->
    <button class="tool-btn" id="btnDelete" type="button" title="Delete Selected">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/>
      </svg>
    </button>

    <div class="tool-sep"></div>

    <!-- Container Box -->
    <button class="tool-btn" id="btnAddGroup" type="button" title="Add Container Box">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2"/>
      </svg>
    </button>
    <!-- Group Box -->
    <button class="tool-btn" id="btnAddRegion" type="button" title="Add Group Box (Container of Containers)">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="8" height="8" rx="1"/><rect x="13" y="3" width="8" height="8" rx="1"/><rect x="3" y="13" width="8" height="8" rx="1"/><rect x="13" y="13" width="8" height="8" rx="1"/>
      </svg>
    </button>
    <!-- DC Container (Datacenter) -->
    <button class="tool-btn" id="btnAddDCContainer" type="button" title="Add Datacenter Container">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <rect x="4" y="2" width="16" height="20" rx="1"/>
        <line x1="4" y1="7" x2="20" y2="7"/>
        <line x1="4" y1="12" x2="20" y2="12"/>
        <line x1="4" y1="17" x2="20" y2="17"/>
        <circle cx="17" cy="4.5" r="1" fill="currentColor"/>
        <circle cx="17" cy="9.5" r="1" fill="currentColor"/>
        <circle cx="17" cy="14.5" r="1" fill="currentColor"/>
        <circle cx="17" cy="19.5" r="1" fill="currentColor"/>
      </svg>
    </button>

    <div class="tool-sep"></div>

    <!-- Shape Tools -->
    <button class="tool-btn shape-tool active" data-shape="circle" type="button" title="Circle">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="9"/></svg>
    </button>
    <button class="tool-btn shape-tool" data-shape="square" type="button" title="Square">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="4" y="4" width="16" height="16"/></svg>
    </button>
    <button class="tool-btn shape-tool" data-shape="triangle" type="button" title="Triangle">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"><polygon points="12,3 22,21 2,21"/></svg>
    </button>
    <button class="tool-btn shape-tool" data-shape="rectangle" type="button" title="Rectangle">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="6" width="20" height="12"/></svg>
    </button>
    <button class="tool-btn shape-tool" data-shape="ellipse" type="button" title="Ellipse">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><ellipse cx="12" cy="12" rx="10" ry="6"/></svg>
    </button>
    <button class="tool-btn shape-tool" data-shape="hexagon" type="button" title="Hexagon">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"><polygon points="12,2 21,7 21,17 12,22 3,17 3,7"/></svg>
    </button>

    <div class="tool-sep"></div>

    <!-- Link Tool -->
    <button class="tool-btn" id="btnCreateLink" type="button" title="Create Link (click two nodes)">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/>
      </svg>
    </button>

    <div class="tool-sep"></div>

    <!-- Fill Color -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnFillColor" type="button" title="Fill Color">
        <span style="display:flex; flex-direction:column; align-items:center; line-height:1;">
          <svg width="18" height="14" viewBox="0 0 24 18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M17 9l-6-6-7.4 7.4a2 2 0 0 0 0 2.8l4.2 4.2a2 2 0 0 0 2.8 0L17 9z"/>
            <path d="M4 2l4 4"/>
            <path d="M20 12c0 1.5-1.2 2.5-2.5 2.5S15 14 15 14s1.2-2.5 2.5-2.5S20 10.5 20 12z" fill="currentColor"/>
          </svg>
          <span id="fillColorIndicator" style="width:18px; height:4px; background:#dae8fc; border:1px solid #999; margin-top:2px; border-radius:1px;"></span>
        </span>
      </button>
      <div class="menu color-menu" id="fillColorMenu" hidden style="min-width:180px; padding:8px;">
        <div style="font-size:11px; color:#666; margin-bottom:6px;">Fill Color</div>
        <div class="color-grid" id="fillColorGrid"></div>
        <div style="margin-top:8px; display:flex; gap:4px; align-items:center;">
          <input type="color" id="fillColorCustom" style="width:28px; height:28px; border:none; padding:0; cursor:pointer;" />
          <span style="font-size:11px; color:#666;">Custom</span>
        </div>
      </div>
    </div>

    <div style="position:relative;">
      <button class="tool-btn" id="btnStrokeColor" type="button" title="Stroke/Line Color">
        <span style="display:flex; flex-direction:column; align-items:center; line-height:1;">
          <svg width="18" height="14" viewBox="0 0 24 18" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M15 2a2.5 2.5 0 1 1 3.5 3.5L6 18l-4 1 1-4L15 2z"/>
          </svg>
          <span id="strokeColorIndicator" style="width:18px; height:4px; background:#6c8ebf; border:1px solid #999; margin-top:2px; border-radius:1px;"></span>
        </span>
      </button>
      <div class="menu color-menu" id="strokeColorMenu" hidden style="min-width:180px; padding:8px;">
        <div style="font-size:11px; color:#666; margin-bottom:6px;">Stroke/Line Color</div>
        <div class="color-grid" id="strokeColorGrid"></div>
        <div style="margin-top:8px; display:flex; gap:4px; align-items:center;">
          <input type="color" id="strokeColorCustom" style="width:28px; height:28px; border:none; padding:0; cursor:pointer;" />
          <span style="font-size:11px; color:#666;">Custom</span>
        </div>
      </div>
    </div>

    <!-- Line Format (Width + Style) -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnLineWidth" type="button" title="Line Format (Width & Style)">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" stroke="none">
          <rect x="2" y="4" width="20" height="2" rx="1"/>
          <rect x="2" y="11" width="20" height="3" rx="1.5"/>
          <rect x="2" y="18" width="20" height="4" rx="2"/>
        </svg>
      </button>
      <div class="menu" id="lineWidthMenu" hidden style="min-width:160px;">
        <div style="padding:6px 12px; font-size:11px; color:#666; border-bottom:1px solid #e0e0e0;">Line Width</div>
        <div class="item line-width-item" data-width="1">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="1"/></svg> 1px
        </div>
        <div class="item line-width-item" data-width="2">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="2"/></svg> 2px
        </div>
        <div class="item line-width-item" data-width="3">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="3"/></svg> 3px
        </div>
        <div class="item line-width-item" data-width="4">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="4"/></svg> 4px
        </div>
        <div class="item line-width-item" data-width="5">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="5"/></svg> 5px
        </div>
        <div class="item line-width-item" data-width="6">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="6"/></svg> 6px
        </div>
        <div class="sep"></div>
        <div style="padding:6px 12px; font-size:11px; color:#666; border-bottom:1px solid #e0e0e0;">Line Style</div>
        <div class="item line-style-item" data-linestyle="solid">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="2"/></svg> Solid
        </div>
        <div class="item line-style-item" data-linestyle="dashed">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="2" stroke-dasharray="8,4"/></svg> Dashed
        </div>
        <div class="item line-style-item" data-linestyle="dotted">
          <svg width="60" height="12" style="vertical-align:middle;"><line x1="5" y1="6" x2="55" y2="6" stroke="currentColor" stroke-width="2" stroke-dasharray="2,3"/></svg> Dotted
        </div>
      </div>
    </div>

    <!-- Link Style -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnLinkStyle" type="button" title="Link Style">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
          <path d="M5 19 Q 5 5, 19 5"/>
        </svg>
      </button>
      <div class="menu" id="linkStyleMenu" hidden style="min-width:160px;">
        <div style="padding:6px 12px; font-size:11px; color:#666; border-bottom:1px solid #e0e0e0;">Link Style</div>
        <div class="item link-style-item" data-style="straight">â€• Straight</div>
        <div class="item link-style-item" data-style="orthogonal">â”Œ Orthogonal (90Â°)</div>
        <div class="item link-style-item" data-style="curve">âˆ¿ Curved</div>
        <div class="sep"></div>
        <div style="padding:6px 12px; font-size:11px; color:#666;">Orthogonal Direction</div>
        <div class="item link-route-item" data-route="hv">â†’â†“ Horizontal first</div>
        <div class="item link-route-item" data-route="vh">â†“â†’ Vertical first</div>
      </div>
    </div>

    <div class="tool-sep"></div>

    <!-- Font Colour -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnFontColor" type="button" title="Font Colour">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <text x="6" y="16" font-size="14" font-weight="bold" fill="currentColor" stroke="none">A</text>
          <rect x="3" y="19" width="18" height="3" fill="#e53935" stroke="none"/>
        </svg>
      </button>
      <div class="menu" id="fontColorMenu" hidden style="min-width:260px; max-height:400px; overflow-y:auto; left:auto; right:0;">
        <div style="padding:8px 12px; font-weight:600; border-bottom:1px solid #e0e0e0;">Font Colour & Visibility</div>
        <div id="fontColorNoSelection" class="muted" style="padding:12px;">Select a node, link, or container to format text.</div>
        <div id="fontColorFields" style="display:none;"></div>
      </div>
    </div>

    <!-- Font Type -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnFontType" type="button" title="Font Type & Size">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <text x="3" y="16" font-size="16" font-weight="bold" fill="currentColor" stroke="none">T</text>
          <text x="13" y="16" font-size="10" fill="currentColor" stroke="none">T</text>
        </svg>
      </button>
      <div class="menu" id="fontTypeMenu" hidden style="min-width:280px; max-height:400px; overflow-y:auto; left:auto; right:0;">
        <div style="padding:8px 12px; font-weight:600; border-bottom:1px solid #e0e0e0;">Font Type & Size</div>
        <div id="fontTypeNoSelection" class="muted" style="padding:12px;">Select a node, link, or container to format text.</div>
        <div id="fontTypeFields" style="display:none;"></div>
      </div>
    </div>

    <div class="tool-sep"></div>

    <!-- Brush (Format Painter) - Tilted brush like reference -->
    <button class="tool-btn" id="btnBrush" type="button" title="Format Painter - Copy and apply formatting">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <!-- Handle -->
        <path d="M5 19 Q 7 17, 9 15"/>
        <circle cx="4" cy="20" r="1.5" fill="currentColor"/>
        <!-- Ferrule -->
        <rect x="8" y="8" width="8" height="4" rx="1" transform="rotate(-45 12 10)"/>
        <!-- Bristles -->
        <path d="M13 7 L19 1 L23 5 L17 11 Z"/>
        <path d="M15 5 L17 7" stroke-width="1.5"/>
        <path d="M17 3 L19 5" stroke-width="1.5"/>
        <path d="M19 5 L21 7" stroke-width="1.5"/>
      </svg>
    </button>

    <!-- Apply Style Button -->
    <div style="position:relative;">
      <button class="tool-btn" id="btnApplyStyle" type="button" title="Apply Saved Style to Selection">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <!-- Magic wand -->
          <path d="M15 4l-9 9 3 3 9-9-3-3z"/>
          <path d="M14.5 4.5l3 3"/>
          <!-- Sparkles -->
          <path d="M3 11l1-1-1-1-1 1 1 1z" fill="currentColor" stroke="none"/>
          <path d="M7 7l1-1-1-1-1 1 1 1z" fill="currentColor" stroke="none"/>
          <path d="M11 3l1-1-1-1-1 1 1 1z" fill="currentColor" stroke="none"/>
          <path d="M19 11v2M18 12h2" stroke-width="1.5"/>
          <path d="M5 19v2M4 20h2" stroke-width="1.5"/>
        </svg>
      </button>
      <div class="menu" id="applyStyleMenu" hidden style="min-width:240px; max-width:320px; max-height:400px; overflow-y:auto;">
        <div style="padding:8px 12px; font-size:12px; font-weight:600; color:#333; border-bottom:1px solid #e0e0e0; background:#f8f8f8;">
          Apply Style to Selection
        </div>
        <div id="applyStyleContent">
          <!-- Content will be populated dynamically -->
        </div>
        <div id="applyStyleEmpty" style="padding:16px 12px; text-align:center; color:#888; font-size:12px;">
          Select items to apply styles
        </div>
        <div style="padding:8px 12px; border-top:1px solid #e0e0e0; background:#f8f8f8;">
          <button class="mini-btn" id="btnManageStyles" style="width:100%; font-size:11px;">Manage Styles...</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Toolbar Line 2: Filters and Panels -->
  <div style="display:flex; align-items:center; gap:2px; padding:4px 12px; background:#f5f5f5; border-top:1px solid #e8e8e8; flex-wrap:wrap;">
    <!-- Unified Filters Button -->
    <button class="tool-btn" id="btnUnifiedFilter" type="button" title="Filter by Tags, Cable System, Node, Container (F)">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">Filters</span>
      <span class="filter-badge" id="filterBadge">0</span>
    </button>

    <div class="tool-sep"></div>

    <!-- Inspector Toggle (for nodes, links, groups) -->
    <button class="tool-btn" id="btnToggleInspector" type="button" title="Toggle Inspector (I)">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <line x1="4" y1="7" x2="20" y2="7"/><circle cx="8" cy="7" r="2" fill="currentColor"/>
        <line x1="4" y1="12" x2="20" y2="12"/><circle cx="14" cy="12" r="2" fill="currentColor"/>
        <line x1="4" y1="17" x2="20" y2="17"/><circle cx="10" cy="17" r="2" fill="currentColor"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">Inspector</span>
    </button>

    <!-- Shape Library Toggle -->
    <button class="tool-btn" id="btnToggleLibrary" type="button" title="Toggle Shape Library">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
        <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
        <circle cx="12" cy="10" r="3"/>
        <path d="M9 16h6"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">Library</span>
    </button>

    <div class="tool-sep"></div>

    <!-- Cable System List Toggle -->
    <button class="tool-btn" id="btnToggleCableNavigator" type="button" title="Toggle Cable System List">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M4 4h6v6H4zM14 4h6v6h-6zM4 14h6v6H4z"/>
        <line x1="17" y1="14" x2="17" y2="20"/>
        <line x1="14" y1="17" x2="20" y2="17"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">CS List</span>
    </button>

    <!-- Cable System Details Toggle -->
    <button class="tool-btn" id="btnToggleCableInspector" type="button" title="Toggle Cable System Details">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2"/>
        <line x1="3" y1="9" x2="21" y2="9"/>
        <line x1="9" y1="21" x2="9" y2="9"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">CS Details</span>
    </button>

    <!-- Datacenter List Toggle -->
    <button class="tool-btn" id="btnToggleDCNavigator" type="button" title="Toggle Datacenter List">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <rect x="4" y="2" width="16" height="20" rx="1"/>
        <line x1="4" y1="7" x2="20" y2="7"/>
        <line x1="4" y1="12" x2="20" y2="12"/>
        <line x1="4" y1="17" x2="20" y2="17"/>
        <circle cx="17" cy="4.5" r="1" fill="currentColor"/>
        <circle cx="17" cy="9.5" r="1" fill="currentColor"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">DC List</span>
    </button>

    <div class="tool-sep"></div>

    <!-- Multilink Group Manager Toggle -->
    <button class="tool-btn" id="btnToggleMultilinkManager" type="button" title="Toggle Multilink Group Manager">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="5" cy="6" r="2"/>
        <circle cx="12" cy="6" r="2"/>
        <circle cx="19" cy="6" r="2"/>
        <circle cx="5" cy="18" r="2"/>
        <circle cx="12" cy="18" r="2"/>
        <circle cx="19" cy="18" r="2"/>
        <path d="M5 8v8M12 8v8M19 8v8"/>
        <path d="M5 12h14" stroke-dasharray="2 2"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">ML Groups</span>
    </button>

    <div style="flex:1;"></div>

    <!-- Label Manager Button -->
    <button class="tool-btn" id="btnLabelManager" type="button" title="Label Manager - Manage tags across nodes, links, and containers">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 2L2 7l10 5 10-5-10-5z"/>
        <path d="M2 17l10 5 10-5"/>
        <path d="M2 12l10 5 10-5"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">Labels</span>
    </button>

    <!-- Main Canvas View Button -->
    <button class="tool-btn active" id="btnMainView" type="button" title="Main Canvas View - Standard network diagram view" style="color: #10b981;">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <!-- Grid/canvas icon -->
        <rect x="3" y="3" width="18" height="18" rx="2"/>
        <circle cx="8" cy="8" r="2" fill="currentColor"/>
        <circle cx="16" cy="8" r="2" fill="currentColor"/>
        <circle cx="12" cy="16" r="2" fill="currentColor"/>
        <line x1="8" y1="10" x2="12" y2="14"/>
        <line x1="16" y1="10" x2="12" y2="14"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">Main</span>
    </button>

    <!-- Geographic View Toggle Button -->
    <button class="tool-btn" id="btnGeoView" type="button" title="Geo Static Background - Show nodes on customizable world map based on GPS coordinates">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="10"/>
        <ellipse cx="12" cy="12" rx="10" ry="4"/>
        <path d="M12 2v20"/>
        <path d="M2 12h20"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">Geo</span>
    </button>

    <!-- Geo Dynamic Map (MapLibre) Button -->
    <button class="tool-btn" id="btnMapLibre" type="button" title="Geo Dynamic Map - Zoomable interactive map with OpenStreetMap tiles">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <!-- Folded map icon -->
        <path d="M3 6l6-3 6 3 6-3v15l-6 3-6-3-6 3V6z"/>
        <path d="M9 3v15"/>
        <path d="M15 6v15"/>
        <!-- Location pin -->
        <circle cx="17" cy="9" r="2" fill="currentColor" stroke="currentColor"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">Map</span>
    </button>

    <!-- Show Paths Toggle (only visible when in Map view) -->
    <button class="tool-btn" id="btnShowPaths" type="button" title="KML View - Toggle between cable geometry routes and straight lines" style="display:none; color: #6366f1;">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <!-- Wavy path icon -->
        <circle cx="4" cy="12" r="2" fill="currentColor"/>
        <circle cx="20" cy="12" r="2" fill="currentColor"/>
        <path d="M6 12 Q 9 6, 12 12 T 18 12"/>
      </svg>
      <span style="font-size:10px; margin-left:2px;">KML</span>
    </button>

    <!-- Route Finder Button -->
    <button class="tool-btn" id="btnRouteFinder" type="button" title="Route Finder - Find optimal paths between nodes">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <!-- Path/route icon -->
        <circle cx="5" cy="5" r="3" fill="#22c55e" stroke="#22c55e"/>
        <circle cx="19" cy="19" r="3" fill="#ef4444" stroke="#ef4444"/>
        <path d="M7 7 L12 12 L17 17" stroke-dasharray="3,2"/>
        <path d="M5 8 L5 16 L8 19" stroke-width="1.5"/>
        <path d="M8 5 L16 5 L19 8" stroke-width="1.5"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">Routes</span>
    </button>

    <div class="tool-sep"></div>

    <!-- KML Studio Button / Drop Zone -->
    <button class="tool-btn" id="btnKMLStudio" type="button" title="KML Studio - Open geographic editor (drag entities here to open in KML Studio)">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#0096D6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M8 12L16 8L24 12L16 16Z" transform="scale(0.75) translate(4,4)" fill="#0096D6" opacity="0.2"/>
        <path d="M8 16L16 20L24 16" transform="scale(0.75) translate(4,4)"/>
        <path d="M8 20L16 24L24 20" transform="scale(0.75) translate(4,4)"/>
      </svg>
      <span style="font-size:11px; margin-left:4px;">KML Studio</span>
    </button>
  </div>
</header>

<!-- Unified Filter Panel (Accordion) -->
<div id="unifiedFilterPanel" hidden>
  <div class="unified-filter-header" id="unifiedFilterDragHandle">
    <span style="display:flex; align-items:center; gap:6px;">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>
      </svg>
      Active Filters
    </span>
    <div style="display:flex; align-items:center; gap:8px;">
      <span style="font-size:9px; color:#aaa;">drag to move</span>
      <button id="btnUnifiedFilterClose" style="background:none; border:none; font-size:18px; cursor:pointer; color:#888; padding:0 2px; line-height:1;" title="Close">Ã—</button>
    </div>
  </div>

  <!-- Tags Section -->
  <div class="filter-accordion-section" data-filter="tags">
    <div class="filter-accordion-header" data-section="tags">
      <span class="filter-dot" id="dotTagFilter"></span>
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M19 12.5l-6 6a2 2 0 0 1-2.8 0L3 11.5V4h7.5l8.5 8.5z"/>
        <circle cx="7" cy="8" r="1.5" fill="currentColor"/>
      </svg>
      <span class="filter-section-title">Tags</span>
      <span class="filter-arrow">â–¶</span>
    </div>
    <div class="filter-accordion-content" id="tagFilterAccordion">
      <div style="padding:8px 12px;">
        <input type="text" id="tagFilterSearch" placeholder="Search tags..." style="width:100%; padding:6px 8px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
      </div>
      <label class="item toggle-item"><input type="radio" name="filterMode" value="all" checked /> Show All (no filter)</label>
      <label class="item toggle-item"><input type="radio" name="filterMode" value="include" /> Show only selected tags</label>
      <label class="item toggle-item"><input type="radio" name="filterMode" value="exclude" /> Hide selected tags</label>
      <div class="sep"></div>
      <label class="item toggle-item"><input type="checkbox" id="tagFilterExclusive" /> Exclusive (ignore Cable System filter)</label>
      <div class="sep"></div>
      <div style="padding:4px 12px; font-size:11px; color:#666;">Tags:</div>
      <div id="tagFilterList" style="max-height:200px; overflow-y:auto;"></div>
      <div class="sep"></div>
      <div style="display:flex; gap:8px; padding:8px 12px;">
        <button class="mini-btn" id="btnTagSelectAll" type="button">Select All</button>
        <button class="mini-btn" id="btnTagClearAll" type="button">Clear All</button>
      </div>
    </div>
  </div>

  <!-- Cable System Section -->
  <div class="filter-accordion-section" data-filter="cableSystem">
    <div class="filter-accordion-header" data-section="cableSystem">
      <span class="filter-dot" id="dotCableSystemFilter"></span>
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
        <ellipse cx="4" cy="12" rx="2" ry="5"/>
        <line x1="6" y1="7" x2="14" y2="6"/>
        <line x1="6" y1="12" x2="14" y2="12"/>
        <line x1="6" y1="17" x2="14" y2="18"/>
        <polygon points="16 4 22 4 19 10 19 14 16 14 16 10" fill="none"/>
      </svg>
      <span class="filter-section-title">Cable System</span>
      <span class="filter-arrow">â–¶</span>
    </div>
    <div class="filter-accordion-content" id="cableSystemFilterAccordion">
      <div style="padding:8px 12px;">
        <input type="text" id="cableSystemFilterSearch" placeholder="Search cable systems..." style="width:100%; padding:6px 8px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
      </div>
      <label class="item toggle-item"><input type="radio" name="cableFilterMode" value="all" checked /> Show All</label>
      <label class="item toggle-item"><input type="radio" name="cableFilterMode" value="selected" /> Show selected systems only</label>
      <div class="sep"></div>
      <label class="item toggle-item"><input type="checkbox" id="cableFilterShowUnmapped" checked /> Include unmapped items</label>
      <label class="item toggle-item"><input type="checkbox" id="cableFilterExclusive" /> Exclusive (ignore Tag filter)</label>
      <div class="sep"></div>
      <div style="padding:4px 12px; font-size:11px; color:#666;">Cable Systems:</div>
      <div id="cableSystemFilterList" style="max-height:200px; overflow-y:auto;"></div>
      <div class="sep"></div>
      <div style="display:flex; gap:8px; padding:8px 12px;">
        <button class="mini-btn" id="btnCableSelectAll" type="button">Select All</button>
        <button class="mini-btn" id="btnCableClearAll" type="button">Clear All</button>
      </div>
    </div>
  </div>

  <!-- Node Section -->
  <div class="filter-accordion-section" data-filter="node">
    <div class="filter-accordion-header" data-section="node">
      <span class="filter-dot" id="dotNodeFilter"></span>
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="8"/>
        <line x1="12" y1="2" x2="12" y2="6"/>
        <line x1="12" y1="18" x2="12" y2="22"/>
        <line x1="2" y1="12" x2="6" y2="12"/>
        <line x1="18" y1="12" x2="22" y2="12"/>
      </svg>
      <span class="filter-section-title">Node</span>
      <span class="filter-arrow">â–¶</span>
    </div>
    <div class="filter-accordion-content" id="nodeFilterAccordion">
      <div style="padding:8px 12px;">
        <input type="text" id="nodeFilterSearch" placeholder="Search nodes..." style="width:100%; padding:6px 8px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
      </div>
      <label class="item toggle-item"><input type="radio" name="nodeFilterMode" value="all" checked /> Show All</label>
      <label class="item toggle-item"><input type="radio" name="nodeFilterMode" value="selected" /> Show selected nodes only</label>
      <div class="sep"></div>
      <div style="padding:4px 12px; font-size:11px; color:#666;">Display as:</div>
      <label class="item toggle-item"><input type="radio" name="nodeDisplayMode" value="name" checked /> Node Name</label>
      <label class="item toggle-item"><input type="radio" name="nodeDisplayMode" value="code" /> Node Code</label>
      <div class="sep"></div>
      <label class="item toggle-item"><input type="checkbox" id="nodeFilterExclusive" /> Exclusive (ignore other filters)</label>
      <div class="sep"></div>
      <div style="padding:4px 12px; font-size:11px; color:#666;">Nodes:</div>
      <div id="nodeFilterList" style="max-height:200px; overflow-y:auto;"></div>
      <div class="sep"></div>
      <div style="display:flex; gap:8px; padding:8px 12px;">
        <button class="mini-btn" id="btnNodeSelectAll" type="button">Select All</button>
        <button class="mini-btn" id="btnNodeClearAll" type="button">Clear All</button>
      </div>
    </div>
  </div>

  <!-- Container Section -->
  <div class="filter-accordion-section" data-filter="container">
    <div class="filter-accordion-header" data-section="container">
      <span class="filter-dot" id="dotContainerFilter"></span>
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2"/>
        <rect x="7" y="7" width="10" height="10" rx="1"/>
      </svg>
      <span class="filter-section-title">Container</span>
      <span class="filter-arrow">â–¶</span>
    </div>
    <div class="filter-accordion-content" id="containerFilterAccordion">
      <div style="padding:8px 12px;">
        <input type="text" id="containerFilterSearch" placeholder="Search containers..." style="width:100%; padding:6px 8px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
      </div>
      <label class="item toggle-item"><input type="radio" name="containerFilterMode" value="all" checked /> Show All</label>
      <label class="item toggle-item"><input type="radio" name="containerFilterMode" value="selected" /> Show selected containers only</label>
      <div class="sep"></div>
      <label class="item toggle-item"><input type="checkbox" id="containerFilterExclusive" /> Exclusive (ignore other filters)</label>
      <div class="sep"></div>
      <div id="containerFilterSections">
        <div style="padding:4px 12px; font-size:11px; color:#666; background:#f5f5f5; border-top:1px solid #e0e0e0;">â–¢ Container Boxes:</div>
        <div id="containerFilterListBoxes" style="max-height:150px; overflow-y:auto;"></div>
        <div style="padding:4px 12px; font-size:11px; color:#666; background:#f5f5f5; border-top:1px solid #e0e0e0;">â–£ Groups (Container of Containers):</div>
        <div id="containerFilterListGroups" style="max-height:150px; overflow-y:auto;"></div>
      </div>
      <div class="sep"></div>
      <div style="display:flex; gap:8px; padding:8px 12px;">
        <button class="mini-btn" id="btnContainerSelectAll" type="button">Select All</button>
        <button class="mini-btn" id="btnContainerClearAll" type="button">Clear All</button>
      </div>
    </div>
  </div>

  <!-- Clear All Filters -->
  <div class="filter-clear-section">
    <button class="mini-btn" id="btnClearAllFilters" type="button" style="width:100%; background:#fff0f0; color:#c62828; border-color:#ef9a9a;">Clear All Filters</button>
  </div>
</div>

<!-- Shape Library Panel -->
<div id="shapeLibraryPanel">
  <div class="library-header" title="Drag to move â€¢ Double-click to reset position">
    <span>ðŸ“› Shape Library</span>
    <div class="library-header-actions">
      <button class="library-header-btn" id="btnLibraryDock" title="Dock to left side">ðŸ“Œ</button>
      <button class="library-header-btn" id="btnLibraryImport" title="Import SVG">+</button>
      <button class="library-header-btn" id="btnLibraryMenu" title="Library Options">â‹®</button>
      <button class="library-header-btn" id="btnLibraryClose" title="Close Library">Ã—</button>
    </div>
  </div>
  <!-- Library Tabs -->
  <div class="library-tabs">
    <button class="library-tab active" data-tab="nodes">ðŸ”µ Nodes</button>
    <button class="library-tab" data-tab="containers">ðŸ“¦ Containers</button>
  </div>
  <div class="library-search">
    <input type="text" id="librarySearch" placeholder="Search shapes..." />
  </div>
  <div class="library-content" id="libraryContent">
    <!-- Library items will be populated here -->
  </div>
  <div class="library-actions" id="libraryActionsNodes">
    <button class="library-action-btn primary" id="btnSaveNodeToLibrary">
      <span>ðŸ’¾</span> Save Selected Node
    </button>
    <button class="library-action-btn" id="btnImportSVGToLibrary">
      <span>ðŸ“</span> Import SVG File
    </button>
    <div style="display:flex; gap:4px;">
      <button class="library-action-btn" id="btnImportLibraryFile" style="flex:1;">
        <span>ðŸ“¥</span> Import Library
      </button>
      <button class="library-action-btn" id="btnExportLibrary" style="flex:1;">
        <span>ðŸ“¤</span> Export Library
      </button>
    </div>
  </div>
  <div class="library-actions" id="libraryActionsContainers" style="display:none;">
    <button class="library-action-btn" id="btnImportContainerShape">
      <span>ðŸ“</span> Import Shape SVG
    </button>
    <div style="font-size:10px; color:#888; text-align:center; padding:4px 8px;">
      Drag shapes to canvas to create containers
    </div>
  </div>
</div>

<!-- Hidden file inputs for library -->
<input type="file" id="svgImportInput" accept=".svg,image/svg+xml" style="display:none;" />
<input type="file" id="libraryImportInput" accept=".ndl" style="display:none;" />

<div id="layout">
  <div id="wrap">
    <div id="svgContainer" style="transform-origin: 0 0;">
      <svg id="svg" viewBox="0 0 1600 900" preserveAspectRatio="none"></svg>
    </div>
    <!-- MapLibre GL Interactive Map Container -->
    <div id="maplibreContainer">
      <div id="maplibreMap"></div>
    </div>
    <div class="toast" id="toast"></div>

    <!-- Heat Map Legend (visible when heat map mode is active) -->
    <div id="heatMapLegend" style="
      position: absolute;
      right: 20px;
      bottom: 80px;
      background: rgba(255,255,255,0.97);
      border: 1px solid #d0d0d0;
      border-radius: 8px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.15);
      padding: 12px 16px;
      z-index: 150;
      display: none;
      min-width: 180px;
      cursor: move;
      user-select: none;
    ">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <div style="font-size:12px; font-weight:600; color:#333;" id="heatMapLegendTitle">ðŸŒ¡ï¸ Heat Map</div>
        <button id="btnCloseHeatMapLegend" style="background:none; border:none; cursor:pointer; color:#999; font-size:14px; padding:0; line-height:1;" title="Hide legend">âœ•</button>
      </div>
      <div style="font-size:10px; color:#666; margin-bottom:8px;" id="heatMapLegendSubtitle">Capacity Available</div>
      <div id="heatMapLegendGradient" style="height:12px; border-radius:3px; background:linear-gradient(to right, #22c55e, #ef4444); margin-bottom:4px;"></div>
      <div style="display:flex; justify-content:space-between; font-size:10px; color:#666;">
        <span id="heatMapLegendMin">0</span>
        <span id="heatMapLegendMax">100</span>
      </div>
      <!-- No Data indicator -->
      <div style="display:flex; align-items:center; gap:6px; margin-top:10px; padding-top:8px; border-top:1px solid #e5e7eb;">
        <div style="width:20px; height:12px; background:#9ca3af; border-radius:2px; border:1px solid #6b7280;"></div>
        <span style="font-size:10px; color:#6b7280;">No data available</span>
      </div>
      <div style="font-size:9px; color:#aaa; margin-top:6px; text-align:center;">drag to move</div>
    </div>

    <!-- Heat Map Active Indicator (top bar when heat map is on) -->
    <div id="heatMapActiveIndicator" style="
      position: absolute;
      top: 60px;
      right: 20px;
      background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      box-shadow: 0 2px 12px rgba(249, 115, 22, 0.4);
      z-index: 150;
      display: none;
      font-size: 12px;
      font-weight: 500;
      cursor: default;
      user-select: none;
      align-items: center;
      gap: 8px;
    ">
      <span>ðŸŒ¡ï¸</span>
      <span id="heatMapActiveLabel">Heat Map: Capacity</span>
      <button id="heatMapScaleToggle" style="
        background: rgba(255,255,255,0.25);
        border: 1px solid rgba(255,255,255,0.4);
        color: white;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 10px;
        font-weight: 500;
        cursor: pointer;
        margin-left: 4px;
        transition: background 0.2s;
      " title="Toggle between linear and logarithmic scale">Lin</button>
      <span id="heatMapExitBtn" style="background:rgba(255,255,255,0.3); padding:2px 8px; border-radius:10px; font-size:10px; margin-left:4px; cursor:pointer;" title="Click to disable heat map">âœ• Exit</span>
    </div>
  </div>

  <!-- Floating Projection Adjustment Panel (visible in Geo View) -->
  <div id="projectionPanel" style="
    position: absolute;
    left: 20px;
    top: 20px;
    width: 280px;
    background: #ffffff;
    border: 1px solid #d0d0d0;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.12);
    z-index: 100;
    display: none;
    font-size: 12px;
  ">
    <div style="
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      background: #f8f9fa;
      border-bottom: 1px solid #e8e8e8;
      border-radius: 8px 8px 0 0;
    ">
      <span style="font-weight: 600; color: #333;">ðŸŽ¯ Projection Adjustment</span>
      <button id="projPanelClose" style="
        background: none;
        border: none;
        font-size: 16px;
        cursor: pointer;
        color: #999;
        padding: 0 4px;
      ">âœ•</button>
    </div>
    <div style="padding: 12px;">
      <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
        <label style="width:65px; color:#666; font-size:11px;">Scale X:</label>
        <input type="range" id="projScaleX2" min="0.8" max="1.2" step="0.005" value="0.895" style="flex:1; cursor:pointer;">
        <input type="number" id="projScaleXVal2" value="0.895" step="0.005" min="0.5" max="1.5" style="width:50px; font-size:10px; text-align:center; padding:3px; border:1px solid #ccc; border-radius:3px;">
      </div>
      <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
        <label style="width:65px; color:#666; font-size:11px;">Scale Y:</label>
        <input type="range" id="projScaleY2" min="0.8" max="1.2" step="0.005" value="0.815" style="flex:1; cursor:pointer;">
        <input type="number" id="projScaleYVal2" value="0.815" step="0.005" min="0.5" max="1.5" style="width:50px; font-size:10px; text-align:center; padding:3px; border:1px solid #ccc; border-radius:3px;">
      </div>
      <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
        <label style="width:65px; color:#666; font-size:11px;">Offset X:</label>
        <input type="range" id="projOffsetX2" min="-100" max="100" step="1" value="-61" style="flex:1; cursor:pointer;">
        <input type="number" id="projOffsetXVal2" value="-61" step="1" min="-200" max="200" style="width:50px; font-size:10px; text-align:center; padding:3px; border:1px solid #ccc; border-radius:3px;">
      </div>
      <div style="display:flex; align-items:center; gap:8px; margin-bottom:10px;">
        <label style="width:65px; color:#666; font-size:11px;">Offset Y:</label>
        <input type="range" id="projOffsetY2" min="-100" max="100" step="1" value="-10" style="flex:1; cursor:pointer;">
        <input type="number" id="projOffsetYVal2" value="-10" step="1" min="-200" max="200" style="width:50px; font-size:10px; text-align:center; padding:3px; border:1px solid #ccc; border-radius:3px;">
      </div>
      <div style="display:flex; gap:6px;">
        <button id="projResetBtn2" class="btn mini-btn" style="flex:1; font-size:10px;">ðŸ”„ Reset</button>
        <button id="projCopyBtn2" class="btn mini-btn" style="flex:1; font-size:10px;">ðŸ“‹ Copy</button>
      </div>
      <div style="font-size:9px; color:#888; margin-top:8px; line-height:1.4;">
        ðŸ’¡ Scale &lt;1 shrinks nodes toward center.<br>
        Adjust until nodes align with map features.
      </div>
    </div>
  </div>

  <aside id="inspector">
    <div id="inspectorHeader">
      <h3>Inspector</h3>
      <div id="inspectorControls">
        <button id="btnMinimizeInspector" title="Minimize/Maximize">âˆ’</button>
        <button id="btnCloseInspector" title="Hide Inspector">âœ•</button>
      </div>
    </div>
    <div id="inspectorContent">
      <div class="muted" id="inspectorHelp">
        Select a node, link, or container box to edit it. Use Delete/Backspace to remove selected.
        <br/>Move any label only with <kbd>Ctrl</kbd>+drag (so normal dragging moves nodes/boxes).
      </div>

      <div id="canvasSettings">
        <h4 style="margin: 12px 0 10px; font-size: 13px; opacity: 0.9;">Canvas Settings</h4>
        <div class="row inline">
          <div>
            <label>Canvas Width</label>
            <input id="canvasWidth" type="number" min="400" step="100" />
        </div>
        <div>
          <label>Canvas Height</label>
          <input id="canvasHeight" type="number" min="300" step="100" />
        </div>
      </div>
      <div style="display:flex; gap:6px; margin-top:8px;">
        <button class="btn" id="btnAutoFitCanvas" style="flex:1; font-size:11px; padding:6px;" title="Automatically expand canvas to fit all elements">
          ðŸ“ Auto-fit Canvas
        </button>
        <button class="btn" id="btnCenterElements" style="flex:1; font-size:11px; padding:6px;" title="Center all elements on canvas">
          âŠ Center All
        </button>
      </div>
      <label class="toggle"><input type="checkbox" id="tglCanvasBorder" checked />Show Canvas Border</label>
      <label class="toggle"><input type="checkbox" id="tglAutoExpandCanvas" checked />Auto-expand on drag</label>
      <div class="muted" style="margin-top: 8px;">Drag objects beyond the border to expand the workspace.</div>
    </div>

    <div id="noSelection" class="muted">Nothing selected.</div>

<div id="nodeInspector" style="display:none;">
  <!-- Identity Section -->
  <div class="inspector-section" data-section="node-identity">
    <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
      <span>Identity</span>
      <span class="section-icon">â–¼</span>
    </div>
    <div class="inspector-section-content">
      <div class="row">
        <label>Node Name</label>
        <div class="field-with-controls">
          <input id="nodeName" />
          <div class="field-inline-controls">
            <select class="field-font-select" id="nodeNameFontInline" title="Font size">
              <option value="8">8</option><option value="10">10</option><option value="11">11</option>
              <option value="12">12</option><option value="13" selected>13</option><option value="14">14</option>
              <option value="16">16</option><option value="18">18</option><option value="20">20</option>
              <option value="24">24</option><option value="28">28</option><option value="32">32</option>
            </select>
            <div class="field-color-swatch" id="nodeNameColorSwatch" title="Name color">
              <input type="color" id="nodeNameColorInline" />
            </div>
            <button class="field-visibility-btn" id="nodeNameVisibility" title="Toggle visibility">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
            </button>
          </div>
        </div>
      </div>
      <div class="row">
        <label>Node Code</label>
        <div class="field-with-controls">
          <input id="nodeCode" placeholder="e.g. N-001" />
          <div class="field-inline-controls">
            <select class="field-font-select" id="nodeCodeFontInline" title="Font size">
              <option value="8">8</option><option value="10">10</option><option value="11">11</option>
              <option value="12">12</option><option value="13" selected>13</option><option value="14">14</option>
              <option value="16">16</option><option value="18">18</option><option value="20">20</option>
              <option value="24">24</option><option value="28">28</option><option value="32">32</option>
            </select>
            <div class="field-color-swatch" id="nodeCodeColorSwatch" title="Code color">
              <input type="color" id="nodeCodeColorInline" />
            </div>
            <button class="field-visibility-btn" id="nodeCodeVisibility" title="Toggle visibility">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Tags Section -->
  <div class="inspector-section" data-section="node-tags">
    <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
      <span>Tags & Metadata</span>
      <span class="section-icon">â–¼</span>
    </div>
    <div class="inspector-section-content">
      <div class="row">
        <label>Filter Tags (comma-separated)</label>
        <textarea id="nodeTags" placeholder="default, core, production"></textarea>
      </div>
      <div class="row">
        <label>Additional Tags (free text)</label>
        <div class="field-with-controls">
          <input id="nodeExtraTags" placeholder="e.g. role=core, owner=teamA" />
          <div class="field-inline-controls">
            <select class="field-font-select" id="nodeExtraTagsFontInline" title="Font size">
              <option value="8">8</option><option value="9">9</option><option value="10">10</option>
              <option value="11" selected>11</option><option value="12">12</option><option value="13">13</option>
              <option value="14">14</option><option value="16">16</option>
            </select>
            <div class="field-color-swatch" id="nodeExtraTagsColorSwatch" title="Tags color">
              <input type="color" id="nodeExtraTagsColorInline" />
            </div>
            <button class="field-visibility-btn" id="nodeExtraTagsVisibility" title="Toggle visibility">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Location Section -->
  <div class="inspector-section collapsed" data-section="node-location">
    <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
      <span>Location</span>
      <span class="section-icon">â–¼</span>
    </div>
    <div class="inspector-section-content">
      <div class="row">
        <label>Address</label>
        <input id="nodeAddress" placeholder="e.g. 123 Main Street" />
      </div>
      <div class="row inline">
        <div style="flex:2;">
          <label>City</label>
          <input id="nodeCity" placeholder="e.g. New York" />
        </div>
        <div style="flex:1;">
          <label>Postal Code</label>
          <input id="nodePostalCode" placeholder="e.g. 10013" />
        </div>
      </div>
      <div class="row inline">
        <div>
          <label>County / Province</label>
          <input id="nodeCounty" placeholder="e.g. Manhattan" />
        </div>
        <div>
          <label>State / Region</label>
          <input id="nodeState" placeholder="e.g. New York" />
        </div>
      </div>
      <div class="row">
        <label>Country</label>
        <input id="nodeCountry" placeholder="e.g. USA" style="width:50%;" />
      </div>

      <!-- GPS Coordinates -->
      <div style="margin-top:12px; padding-top:10px; border-top:1px solid #e0e0e0;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
          <label style="font-weight:600; font-size:11px; color:#1d4ed8;">ðŸŒ GPS Coordinates</label>
          <select id="nodeGpsFormat" style="font-size:10px; padding:2px 6px; border-radius:3px;">
            <option value="DD">Decimal (DD)</option>
            <option value="DMS">Deg/Min/Sec (DMS)</option>
          </select>
        </div>

        <!-- Quick lookup buttons -->
        <div style="display:flex; gap:6px; margin-bottom:8px;">
          <button id="btnLookupCity" type="button" style="flex:1; font-size:10px; padding:5px 8px; background:#e0f2fe; border:1px solid #7dd3fc; border-radius:4px; cursor:pointer; color:#0369a1;" title="Lookup GPS by city or country name">
            ðŸ™ï¸ Lookup City/Country
          </button>
          <button id="btnUseAddress" type="button" style="flex:1; font-size:10px; padding:5px 8px; background:#fef3c7; border:1px solid #fcd34d; border-radius:4px; cursor:pointer; color:#92400e;" title="Geocode GPS from address fields via OpenStreetMap Nominatim API">
            ðŸ“ Geocode Address
          </button>
        </div>

        <!-- Decimal Degrees Format -->
        <div id="gpsFormatDD" class="row inline">
          <div>
            <label style="font-size:10px;">Latitude (Y)</label>
            <input id="nodeLatDD" type="text" placeholder="e.g. 40.7128" style="font-family:monospace; font-size:11px;" />
            <div style="font-size:9px; color:#888; margin-top:2px;">-90 to 90 (N positive)</div>
          </div>
          <div>
            <label style="font-size:10px;">Longitude (X)</label>
            <input id="nodeLonDD" type="text" placeholder="e.g. -74.0060" style="font-family:monospace; font-size:11px;" />
            <div style="font-size:9px; color:#888; margin-top:2px;">-180 to 180 (E positive)</div>
          </div>
        </div>

        <!-- Degrees Minutes Seconds Format -->
        <div id="gpsFormatDMS" style="display:none;">
          <div class="row">
            <label style="font-size:10px;">Latitude (Y)</label>
            <div style="display:flex; gap:4px; align-items:center;">
              <input id="nodeLatDeg" type="number" min="-90" max="90" placeholder="40" style="width:45px; font-size:11px; text-align:center;" />
              <span style="font-size:10px;">Â°</span>
              <input id="nodeLatMin" type="number" min="0" max="59" placeholder="42" style="width:40px; font-size:11px; text-align:center;" />
              <span style="font-size:10px;">'</span>
              <input id="nodeLatSec" type="number" min="0" max="59.99" step="0.01" placeholder="46" style="width:50px; font-size:11px; text-align:center;" />
              <span style="font-size:10px;">"</span>
              <select id="nodeLatDir" style="font-size:11px; padding:2px;">
                <option value="N">N</option>
                <option value="S">S</option>
              </select>
            </div>
          </div>
          <div class="row">
            <label style="font-size:10px;">Longitude (X)</label>
            <div style="display:flex; gap:4px; align-items:center;">
              <input id="nodeLonDeg" type="number" min="-180" max="180" placeholder="74" style="width:45px; font-size:11px; text-align:center;" />
              <span style="font-size:10px;">Â°</span>
              <input id="nodeLonMin" type="number" min="0" max="59" placeholder="0" style="width:40px; font-size:11px; text-align:center;" />
              <span style="font-size:10px;">'</span>
              <input id="nodeLonSec" type="number" min="0" max="59.99" step="0.01" placeholder="21" style="width:50px; font-size:11px; text-align:center;" />
              <span style="font-size:10px;">"</span>
              <select id="nodeLonDir" style="font-size:11px; padding:2px;">
                <option value="E">E</option>
                <option value="W">W</option>
              </select>
            </div>
          </div>
        </div>

        <div style="margin-top:6px; font-size:9px; color:#666; background:#f0f9ff; padding:4px 6px; border-radius:3px;">
          ðŸ’¡ Nodes with GPS data appear in Geographic View
        </div>
      </div>
    </div>
  </div>

  <!-- Appearance Section -->
  <div class="inspector-section" data-section="node-appearance">
    <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
      <span>Appearance</span>
      <span class="section-icon">â–¼</span>
    </div>
    <div class="inspector-section-content">
      <div class="row">
        <label>Style Preset</label>
        <div class="inline">
          <select id="nodePreset"></select>
          <button class="mini-btn" id="btnNodePresetSave" title="Save current style">Save</button>
          <button class="mini-btn" id="btnNodePresetApply" title="Apply preset">Apply</button>
          <button class="mini-btn" id="btnNodePresetDelete" title="Delete preset">Del</button>
        </div>
      </div>
      <div class="row inline">
        <div>
          <label>Fill Color</label>
          <div class="inspector-color-picker" id="nodeFillPicker">
            <div class="inspector-color-swatch" title="Click to choose color">
              <div class="inspector-color-swatch-inner" id="nodeFillSwatch"></div>
            </div>
            <div class="inspector-color-dropdown" hidden>
              <div class="inspector-color-grid" data-target="nodeFill"></div>
              <div class="inspector-color-custom">
                <input type="color" id="nodeFillCustom" />
                <input type="text" id="nodeFillHex" placeholder="#000000" maxlength="7" />
              </div>
            </div>
            <input id="nodeFill" type="hidden" />
          </div>
        </div>
        <div>
          <label>Stroke Color</label>
          <div class="inspector-color-picker" id="nodeStrokePicker">
            <div class="inspector-color-swatch" title="Click to choose color">
              <div class="inspector-color-swatch-inner" id="nodeStrokeSwatch"></div>
            </div>
            <div class="inspector-color-dropdown" hidden>
              <div class="inspector-color-grid" data-target="nodeStroke"></div>
              <div class="inspector-color-custom">
                <input type="color" id="nodeStrokeCustom" />
                <input type="text" id="nodeStrokeHex" placeholder="#000000" maxlength="7" />
              </div>
            </div>
            <input id="nodeStroke" type="hidden" />
          </div>
        </div>
      </div>
      <div class="row inline">
        <div>
          <label>Line Width</label>
          <input id="nodeStrokeW" type="number" min="0.5" max="12" step="0.5" />
        </div>
        <div>
          <label>Node Size</label>
          <input id="nodeSize" type="number" min="10" max="80" step="1" />
        </div>
      </div>
    </div>
  </div>

  <!-- Connections Section -->
  <div class="inspector-section" data-section="node-connections">
    <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
      <span>Connections</span>
      <span class="section-icon">â–¼</span>
    </div>
    <div class="inspector-section-content">
      <div class="row">
        <label>Cable Systems</label>
        <div id="nodeCableSystems" style="max-height:100px; overflow-y:auto; border:1px solid #d0d0d0; border-radius:4px; padding:4px; background:#fafafa;">
          <div class="muted" style="font-size:11px;">No cable systems defined</div>
        </div>
      </div>
      <div class="row">
        <label>Container Box</label>
        <input id="nodeGroup" disabled style="background:#f5f5f5;" />
      </div>
    </div>
  </div>

  <!-- Advanced Section -->
  <div class="inspector-section collapsed" data-section="node-advanced">
    <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
      <span>Advanced</span>
      <span class="section-icon">â–¼</span>
    </div>
    <div class="inspector-section-content">
      <div class="row">
        <label>Unique ID (UUID)</label>
        <input id="nodeUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:10px;" />
      </div>
    </div>
  </div>

  <!-- Hidden fields for compatibility -->
  <input type="hidden" id="nodeNameFont" />
  <input type="hidden" id="nodeTagFont" />
  <input type="hidden" id="nodeNameColor" />
  <input type="hidden" id="nodeTagColor" />
  <input type="hidden" id="nodeShowCode" />
</div>

    <div id="edgeInspector" style="display:none;">
      <!-- Identity Section -->
      <div class="inspector-section" data-section="edge-identity">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Identity</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Link Tag</label>
            <div class="field-with-controls">
              <input id="edgeTag" />
              <div class="field-inline-controls">
                <select class="field-font-select" id="edgeLabelFontInline" title="Font size">
                  <option value="8">8</option><option value="9">9</option><option value="10">10</option>
                  <option value="11">11</option><option value="12" selected>12</option><option value="13">13</option>
                  <option value="14">14</option><option value="16">16</option><option value="18">18</option>
                </select>
                <div class="field-color-swatch" id="edgeTagColorSwatch" title="Label color">
                  <input type="color" id="edgeTagColorInline" />
                </div>
                <button class="field-visibility-btn" id="edgeTagVisibility" title="Toggle visibility">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                </button>
              </div>
            </div>
          </div>
          <div class="row">
            <label>Link Code</label>
            <div class="field-with-controls">
              <input id="edgeCode" placeholder="e.g. L-010" />
              <div class="field-inline-controls">
                <button class="field-visibility-btn" id="edgeCodeVisibility" title="Toggle visibility">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                </button>
              </div>
            </div>
          </div>
          <div class="row">
            <label>Cable System</label>
            <select id="edgeCableSystem" style="width:100%;">
              <option value="">(None)</option>
            </select>
            <div id="edgeCableSystemInfo" class="muted" style="margin-top:4px; font-size:11px;"></div>
          </div>
        </div>
      </div>

      <!-- Data Section -->
      <div class="inspector-section" data-section="edge-data">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Data</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Latency (ms)</label>
            <div class="field-with-controls">
              <input id="edgeLatency" type="text" inputmode="decimal" placeholder="e.g. 1.234" />
              <div class="field-inline-controls">
                <button class="field-visibility-btn" id="edgeLatencyVisibility" title="Toggle visibility">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                </button>
              </div>
            </div>
          </div>
          <div class="row">
            <label>Priority (-100 to +100)</label>
            <input id="edgePriority" type="number" min="-100" max="100" step="1" placeholder="0" style="width:100%;" />
            <div class="hint">+100 = half cost (preferred), -100 = 1.5Ã— cost (avoided)</div>
          </div>
        </div>
      </div>

      <!-- Tags Section -->
      <div class="inspector-section collapsed" data-section="edge-tags">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Tags & Metadata</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Filter Tags (comma-separated)</label>
            <textarea id="edgeFilterTags" placeholder="default, onnet, Asia" style="height:40px;"></textarea>
          </div>
          <div class="row">
            <label>Additional Tags (free text)</label>
            <input id="edgeExtraTags" placeholder="e.g. provider=ISP1, circuit=ABC123" />
          </div>
        </div>
      </div>

      <!-- Physical Routing Diversity Section -->
      <div class="inspector-section collapsed" data-section="edge-routing-overlap">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ”€ Physical Routing Diversity</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="hint" style="margin-bottom:10px;">
            Define diversity levels with other links based on shared physical infrastructure (conduits, ducts, rights-of-way). 100% = fully diverse, 0% = identical path.
          </div>
          <div class="row">
            <label>Diversity with Other Links</label>
            <div id="edgeRoutingOverlapList" style="min-height:30px; max-height:180px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:6px; padding:6px; background:#f9fafb; margin-bottom:8px;">
              <span class="muted" style="font-size:11px;">No diversity constraints defined</span>
            </div>
            <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
              <select id="edgeRoutingOverlapSelect" style="flex:1; padding:6px; font-size:12px; border:1px solid #d1d5db; border-radius:4px;">
                <option value="">-- Select link --</option>
              </select>
              <div style="display:flex; align-items:center; gap:4px;">
                <input id="edgeRoutingOverlapDiversity" type="number" min="0" max="100" value="0" style="width:60px; padding:6px; font-size:12px; border:1px solid #d1d5db; border-radius:4px; text-align:center;" />
                <span style="font-size:12px; color:#6b7280;">%</span>
              </div>
              <button id="btnAddRoutingOverlap" class="btn" style="padding:6px 12px; font-size:12px; background:#0096D6; color:white; border:none; border-radius:4px;">Add</button>
            </div>
            <div class="hint" style="margin-top:6px; display:flex; align-items:center; gap:8px;">
              <button id="btnPickRoutingOverlap" class="btn" style="padding:4px 8px; font-size:11px; background:#f59e0b; color:white; border:none; border-radius:4px; cursor:pointer;">
                ðŸ–±ï¸ Pick from canvas
              </button>
              <span style="color:#6b7280;">Click a link on the canvas, then set diversity %</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Capacity Inventory Section -->
      <div class="inspector-section collapsed" data-section="edge-capacity-inventory">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ“Š Capacity Inventory</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <!-- Design Maximum Capacity -->
          <div class="row" style="margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid #e5e7eb;">
            <label style="font-weight:600; color:#1e40af;">Total Design Maximum Capacity</label>
            <div style="display:flex; align-items:center; gap:6px; margin-top:4px;">
              <input id="edgeDesignCapacity" type="number" min="0" step="0.1" value="0" placeholder="0" style="flex:1; text-align:right; padding:6px 8px; font-size:13px; border:2px solid #93c5fd; border-radius:4px;" />
              <span style="font-weight:600; color:#1e40af; font-size:12px;">Gbps</span>
            </div>
            <div class="hint" style="margin-top:4px;">Maximum theoretical capacity of this link</div>
          </div>

          <!-- Available Inventory -->
          <div style="font-size:11px; font-weight:600; color:#6b7280; margin-bottom:8px; text-transform:uppercase; letter-spacing:0.5px;">Available Inventory by Speed</div>
          <div class="row" style="display:grid; grid-template-columns:1fr 80px; gap:6px; align-items:center;">
            <label style="font-size:11px;">Quantity of 1 Gbps</label>
            <input id="edgeCap1G" type="number" min="0" step="0.1" value="0" style="text-align:right; padding:4px 6px;" />
          </div>
          <div class="row" style="display:grid; grid-template-columns:1fr 80px; gap:6px; align-items:center;">
            <label style="font-size:11px;">Quantity of 10 Gbps</label>
            <input id="edgeCap10G" type="number" min="0" step="0.1" value="0" style="text-align:right; padding:4px 6px;" />
          </div>
          <div class="row" style="display:grid; grid-template-columns:1fr 80px; gap:6px; align-items:center;">
            <label style="font-size:11px;">Quantity of 100 Gbps</label>
            <input id="edgeCap100G" type="number" min="0" step="0.1" value="0" style="text-align:right; padding:4px 6px;" />
          </div>
          <div class="row" style="display:grid; grid-template-columns:1fr 80px; gap:6px; align-items:center;">
            <label style="font-size:11px;">Quantity of 400 Gbps</label>
            <input id="edgeCap400G" type="number" min="0" step="0.1" value="0" style="text-align:right; padding:4px 6px;" />
          </div>
          <div class="row" style="display:grid; grid-template-columns:1fr 80px; gap:6px; align-items:center;">
            <label style="font-size:11px;">Quantity of Tbps</label>
            <input id="edgeCapTbps" type="number" min="0" step="0.1" value="0" style="text-align:right; padding:4px 6px;" />
          </div>
          <div style="margin-top:10px; padding:8px 10px; background:linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%); border-radius:6px; border:1px solid #a7f3d0;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="font-weight:600; font-size:11px; color:#065f46;">Total Available</span>
              <span id="edgeCapTotalGbps" style="font-weight:700; font-size:14px; color:#047857;">0 Gbps</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Commercial Cost Section -->
      <div class="inspector-section collapsed" data-section="edge-commercial-cost">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ’° Commercial Cost</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <!-- Cost Mode Selector -->
          <div style="margin-bottom:12px;">
            <label style="font-size:10px; font-weight:600; color:#6b7280; text-transform:uppercase; letter-spacing:0.3px; margin-bottom:6px; display:block;">Pathfinder Cost Mode</label>
            <div class="cost-mode-selector">
              <label title="Use Annual Contract Value for pathfinding">
                <input type="radio" name="edgeCostMode" id="edgeCostModeLease" value="lease" checked />
                <span>ðŸ“„ Lease (ACV)</span>
              </label>
              <label title="Use IRU Net Present Value for pathfinding">
                <input type="radio" name="edgeCostMode" id="edgeCostModeIRU" value="iru" />
                <span>ðŸ“œ IRU (NPV)</span>
              </label>
            </div>
          </div>

          <!-- Lease Subsection - Tier-based -->
          <div class="cost-subsection lease">
            <div class="cost-subsection-title">
              <span>ðŸ“„ Lease Terms (by Capacity Tier)</span>
              <span id="edgeLeaseCurrency" style="font-size:10px; color:#3b82f6; font-weight:600;">USD</span>
            </div>
            <table class="tier-pricing-grid">
              <thead>
                <tr>
                  <th>Tier</th>
                  <th>NRC</th>
                  <th>MRC</th>
                  <th>ACV</th>
                </tr>
              </thead>
              <tbody>
                <tr data-tier="1G">
                  <td class="tier-label">1G</td>
                  <td><input type="number" id="edgeLeaseNRC_1G" min="0" step="0.01" value="0" /></td>
                  <td><input type="number" id="edgeLeaseMRC_1G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated" id="edgeLeaseACV_1G">$12</td>
                </tr>
                <tr data-tier="10G">
                  <td class="tier-label">10G</td>
                  <td><input type="number" id="edgeLeaseNRC_10G" min="0" step="0.01" value="0" /></td>
                  <td><input type="number" id="edgeLeaseMRC_10G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated" id="edgeLeaseACV_10G">$12</td>
                </tr>
                <tr data-tier="100G">
                  <td class="tier-label">100G</td>
                  <td><input type="number" id="edgeLeaseNRC_100G" min="0" step="0.01" value="0" /></td>
                  <td><input type="number" id="edgeLeaseMRC_100G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated" id="edgeLeaseACV_100G">$12</td>
                </tr>
                <tr data-tier="400G">
                  <td class="tier-label">400G</td>
                  <td><input type="number" id="edgeLeaseNRC_400G" min="0" step="0.01" value="0" /></td>
                  <td><input type="number" id="edgeLeaseMRC_400G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated" id="edgeLeaseACV_400G">$12</td>
                </tr>
              </tbody>
            </table>
            <div class="tier-multiplier-help">
              <button class="mini-btn" id="btnAutoFillLeaseTiers" title="Auto-calculate higher tiers based on 1G pricing">â›¡ Auto-fill from 1G</button>
              <span class="hint">Ã—2.5 (10G), Ã—6.25 (100G), Ã—15.625 (400G)</span>
            </div>
          </div>

          <!-- IRU Subsection - Tier-based -->
          <div class="cost-subsection iru">
            <div class="cost-subsection-title">
              <span>ðŸ“œ IRU Terms (by Capacity Tier)</span>
              <span id="edgeIRUCurrency" style="font-size:10px; color:#8b5cf6; font-weight:600;">USD</span>
            </div>
            <table class="tier-pricing-grid">
              <thead>
                <tr>
                  <th>Tier</th>
                  <th>IRU Fee</th>
                  <th>NPV</th>
                </tr>
              </thead>
              <tbody>
                <tr data-tier="1G">
                  <td class="tier-label">1G</td>
                  <td><input type="number" id="edgeIRUFee_1G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated iru" id="edgeIRUNPV_1G">$1</td>
                </tr>
                <tr data-tier="10G">
                  <td class="tier-label">10G</td>
                  <td><input type="number" id="edgeIRUFee_10G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated iru" id="edgeIRUNPV_10G">$1</td>
                </tr>
                <tr data-tier="100G">
                  <td class="tier-label">100G</td>
                  <td><input type="number" id="edgeIRUFee_100G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated iru" id="edgeIRUNPV_100G">$1</td>
                </tr>
                <tr data-tier="400G">
                  <td class="tier-label">400G</td>
                  <td><input type="number" id="edgeIRUFee_400G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated iru" id="edgeIRUNPV_400G">$1</td>
                </tr>
              </tbody>
            </table>
            <div class="tier-multiplier-help">
              <button class="mini-btn" id="btnAutoFillIRUTiers" title="Auto-calculate higher tiers based on 1G pricing">â›¡ Auto-fill from 1G</button>
              <span class="hint">Ã—2.5 (10G), Ã—6.25 (100G), Ã—15.625 (400G)</span>
            </div>

            <!-- Common IRU terms (apply to all tiers) -->
            <div style="margin-top:12px; padding-top:12px; border-top:1px solid #e5e7eb;">
              <div style="font-size:10px; font-weight:600; color:#6b7280; margin-bottom:8px;">Common IRU Terms (all tiers)</div>
              <div class="cost-row">
                <label>Term</label>
                <input type="number" id="edgeIRUTerm" min="1" max="30" step="1" value="15" style="width:60px;" />
                <span style="font-size:11px; color:#6b7280;">years</span>
              </div>
              <div class="cost-row">
                <label>O&M (%)</label>
                <input type="number" id="edgeIRUOAM" min="0" max="100" step="0.1" value="3" style="width:60px;" />
                <span style="font-size:11px; color:#6b7280;">% of IRU fee/year</span>
              </div>
              <div class="cost-row">
                <label>O&M Annual Incr.</label>
                <input type="number" id="edgeIRUOAMIncrement" min="0" max="50" step="0.1" value="2" style="width:60px;" />
                <span style="font-size:11px; color:#6b7280;">%</span>
              </div>
              <div style="font-size:9px; color:#7c3aed; margin-top:6px;">
                NPV @ <span id="edgeIRUDiscountRate">12.5</span>% discount rate
              </div>
            </div>
          </div>

          <!-- Settings Link -->
          <div class="settings-link">
            <span>ðŸ’¡</span>
            <span>Currency & NPV settings: <a id="edgeCostSettingsLink">Financial Settings</a></span>
          </div>
        </div>
      </div>

      <!-- Appearance Section -->
      <div class="inspector-section" data-section="edge-appearance">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Appearance</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Style Preset</label>
            <div class="inline">
              <select id="edgePreset"></select>
              <button class="mini-btn" id="btnEdgePresetSave" title="Save">Save</button>
              <button class="mini-btn" id="btnEdgePresetApply" title="Apply">Apply</button>
              <button class="mini-btn" id="btnEdgePresetDelete" title="Delete">Del</button>
            </div>
          </div>
          <div class="row inline">
            <div>
              <label>Line Style</label>
              <select id="edgeStyle">
                <option value="straight">Straight</option>
                <option value="orthogonal">90Â° Orthogonal</option>
                <option value="curve">Curve (Bezier)</option>
              </select>
            </div>
            <div>
              <label>Routing</label>
              <select id="edgeRoute">
                <option value="hv">H â†’ V</option>
                <option value="vh">V â†’ H</option>
              </select>
            </div>
          </div>
          <div class="row" id="curveArchControl" style="display:none;">
            <label>Curve Bend</label>
            <input id="edgeCurveArch" type="range" min="-0.6" max="0.6" step="0.05" />
            <span id="curveArchValue" style="font-size:11px; color:#666;">0.30</span>
          </div>
          <div class="row inline">
            <div>
              <label>Line Width</label>
              <input id="edgeStrokeW" type="number" min="0.5" max="12" step="0.5" />
            </div>
            <div>
              <label>Line Color</label>
              <div class="inspector-color-picker" id="edgeStrokeColorPicker">
                <div class="inspector-color-swatch" title="Click to choose color">
                  <div class="inspector-color-swatch-inner" id="edgeStrokeColorSwatch"></div>
                </div>
                <div class="inspector-color-dropdown" hidden>
                  <div class="inspector-color-grid" data-target="edgeStrokeColor"></div>
                  <div class="inspector-color-custom">
                    <input type="color" id="edgeStrokeColorCustom" />
                    <input type="text" id="edgeStrokeColorHex" placeholder="#000000" maxlength="7" />
                  </div>
                </div>
                <input id="edgeStrokeColor" type="hidden" />
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Path Geometry Section (for geographic cable routing) -->
      <div class="inspector-section collapsed" data-section="edge-path-geometry">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ“ Path Geometry</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div id="pathGeometryStatus" style="padding:8px; background:#f9fafb; border-radius:6px; margin-bottom:10px;">
            <div style="display:flex; align-items:center; gap:8px; margin-bottom:4px;">
              <span id="pathStatusIcon" style="font-size:16px;">âž–</span>
              <span id="pathStatusText" style="font-size:12px; color:#6b7280;">No path defined (straight line)</span>
            </div>
            <div id="pathStatusDetails" style="font-size:11px; color:#9ca3af;"></div>
          </div>

          <div id="pathGeometryNoPath">
            <p style="font-size:11px; color:#6b7280; margin:0 0 10px;">
              Define a custom geographic path for this link instead of a straight line.
              Only visible in Dynamic Map view.
            </p>
            <button id="btnEditPathGeometry" class="btn-tool" style="width:100%; padding:10px; display:flex; align-items:center; justify-content:center; gap:8px; background:linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color:white; border:none; border-radius:6px; cursor:pointer; font-weight:600;">
              <span>ðŸ›¤ï¸</span> Edit Path Geometry
            </button>
          </div>

          <div id="pathGeometryHasPath" style="display:none;">
            <div style="display:flex; gap:6px; margin-bottom:8px;">
              <button id="btnPreviewPath" class="btn-tool" style="flex:1; padding:8px; background:#f3f4f6; border:1px solid #d1d5db; border-radius:4px; cursor:pointer; font-size:11px;">
                ðŸ‘ï¸ Preview
              </button>
              <button id="btnEditExistingPath" class="btn-tool" style="flex:1; padding:8px; background:#dbeafe; border:1px solid #93c5fd; border-radius:4px; cursor:pointer; font-size:11px; color:#1d4ed8;">
                âœï¸ Edit
              </button>
              <button id="btnRemovePath" class="btn-tool" style="flex:1; padding:8px; background:#fef2f2; border:1px solid #fecaca; border-radius:4px; cursor:pointer; font-size:11px; color:#dc2626;">
                ðŸ—‘ï¸ Remove
              </button>
            </div>
          </div>

          <div class="hint" style="margin-top:8px;">
            Path is shown in Dynamic Map view when "Show Paths" is enabled.
          </div>
        </div>
      </div>

      <!-- Advanced Section -->
      <div class="inspector-section collapsed" data-section="edge-advanced">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Advanced</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Unique ID (UUID)</label>
            <input id="edgeUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:10px;" />
          </div>
          <div class="row inline">
            <div>
              <label>Source UUID</label>
              <input id="edgeSourceUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:9px;" />
            </div>
            <div>
              <label>Target UUID</label>
              <input id="edgeTargetUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:9px;" />
            </div>
          </div>
        </div>
      </div>

      <!-- Hidden fields for compatibility -->
      <input type="hidden" id="edgeLabelFont" />
      <input type="hidden" id="edgeLabelColor" />
      <input type="hidden" id="edgeShowCode" />
    </div>

    <div id="groupInspector" style="display:none;">
      <!-- Identity Section -->
      <div class="inspector-section" data-section="group-identity">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Identity</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Title</label>
            <div class="field-with-controls">
              <input id="groupTitle" />
              <div class="field-inline-controls">
                <select class="field-font-select" id="groupTitleFontInline" title="Font size">
                  <option value="10">10</option><option value="11">11</option><option value="12">12</option>
                  <option value="13">13</option><option value="14" selected>14</option><option value="16">16</option>
                  <option value="18">18</option><option value="20">20</option><option value="24">24</option>
                </select>
                <div class="field-color-swatch" id="groupTitleColorSwatch" title="Title color">
                  <input type="color" id="groupTitleColorInline" />
                </div>
                <button class="field-visibility-btn" id="groupTitleVisibility" title="Toggle visibility">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                </button>
              </div>
            </div>
          </div>
          <div class="row inline">
            <div>
              <label>Type</label>
              <select id="groupType">
                <option value="country">Container</option>
                <option value="region">Group</option>
                <option value="dc">Datacenter</option>
              </select>
            </div>
            <div>
              <label>Parent Group</label>
              <select id="groupParent"></select>
            </div>
          </div>
        </div>
      </div>

      <!-- Tags Section -->
      <div class="inspector-section collapsed" data-section="group-tags">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Tags & Metadata</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Filter Tags (comma-separated)</label>
            <textarea id="groupFilterTags" placeholder="default, APAC, production" style="height:40px;"></textarea>
          </div>
          <div class="row">
            <label>Additional Tags (free text)</label>
            <input id="groupExtraTags" placeholder="e.g. area=APAC" />
          </div>
        </div>
      </div>

      <!-- Datacenter Info Section (shown only for DC type containers) -->
      <div class="inspector-section" data-section="group-dc-info" id="groupDCInfoSection" style="display:none;">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span id="groupDCInfoSectionTitle">Datacenter Info</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row inline">
            <div style="flex:1;">
              <label>Facility Type</label>
              <select id="groupDCFacilityType" style="width:100%; padding:4px 6px; border:1px solid #d0d0d0; border-radius:4px; font-size:11px;">
                <option value="datacenter">Datacenter</option>
                <option value="cable_station">Cable Station</option>
              </select>
            </div>
            <div style="flex:0 0 80px;">
              <label>PeeringDB ID</label>
              <input id="groupDCPeeringDbId" type="text" readonly style="background:#f3f4f6;color:#666;" />
            </div>
          </div>
          <div class="row inline">
            <div style="flex:1;">
              <label>Organization</label>
              <input id="groupDCOrgName" placeholder="e.g. Equinix" />
            </div>
          </div>
          <div class="row">
            <label>Address</label>
            <input id="groupDCAddress" placeholder="e.g. 123 Data Center Drive" />
          </div>
          <div class="row inline">
            <div style="flex:2;">
              <label>City</label>
              <input id="groupDCCity" placeholder="e.g. Frankfurt" />
            </div>
            <div style="flex:1;">
              <label>Postal Code</label>
              <input id="groupDCZipcode" placeholder="e.g. 60314" />
            </div>
          </div>
          <div class="row inline">
            <div>
              <label>State / Region</label>
              <input id="groupDCState" placeholder="e.g. Hesse" />
            </div>
            <div>
              <label>Country</label>
              <input id="groupDCCountry" placeholder="e.g. Germany" />
            </div>
          </div>
          <div class="row inline">
            <div>
              <label>Continent</label>
              <input id="groupDCRegion" placeholder="e.g. Europe" />
            </div>
            <div>
              <label>Website</label>
              <input id="groupDCWebsite" placeholder="https://..." />
            </div>
          </div>
          <div style="margin-top:8px; padding-top:8px; border-top:1px solid #e0e0e0;">
            <label style="font-weight:600; font-size:11px; color:#9333ea;">GPS Coordinates</label>
            <div class="row inline" style="margin-top:4px;">
              <div>
                <label style="font-size:10px;">Latitude</label>
                <input id="groupDCLatitude" type="text" placeholder="e.g. 50.1109" style="font-family:monospace;font-size:11px;" />
              </div>
              <div>
                <label style="font-size:10px;">Longitude</label>
                <input id="groupDCLongitude" type="text" placeholder="e.g. 8.6821" style="font-family:monospace;font-size:11px;" />
              </div>
            </div>
          </div>
          <div id="groupDCCableSystemsSection" style="margin-top:8px; padding-top:8px; border-top:1px solid #e0e0e0; display:none;">
            <label style="font-weight:600; font-size:11px; color:#2563eb;">Cable Systems Landing Here</label>
            <textarea id="groupDCCableSystems" placeholder="One cable system per line, e.g.&#10;MAREA&#10;Dunant&#10;AEConnect-1" style="width:100%; min-height:60px; margin-top:4px; padding:6px 8px; border:1px solid #93c5fd; border-radius:4px; font-size:11px; resize:vertical;"></textarea>
            <div style="font-size:9px; color:#888; margin-top:2px;">One cable system name per line</div>
          </div>
          <div style="margin-top:8px; padding-top:8px; border-top:1px solid #e0e0e0;">
            <label style="font-weight:600; font-size:11px; color:#9333ea;">Network Presence</label>
            <div class="row inline" style="margin-top:4px;">
              <div style="flex:1;text-align:center;">
                <div style="font-size:18px;font-weight:700;color:#9333ea;" id="groupDCNetCount">0</div>
                <div style="font-size:9px;color:#888;">Networks</div>
              </div>
              <div style="flex:1;text-align:center;">
                <div style="font-size:18px;font-weight:700;color:#2563eb;" id="groupDCIxCount">0</div>
                <div style="font-size:9px;color:#888;">IXPs</div>
              </div>
              <div style="flex:1;text-align:center;">
                <div style="font-size:18px;font-weight:700;color:#059669;" id="groupDCCarrierCount">0</div>
                <div style="font-size:9px;color:#888;">Carriers</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Routing Section -->
      <div class="inspector-section" data-section="group-routing">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>â›¡ Routing</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Transit Latency (ms)</label>
            <input id="groupTransitLatency" type="number" min="0" step="0.1" placeholder="Default: use global setting" />
            <div class="hint" style="margin-top:4px;">Latency added when routing through this container. Leave empty to use global default.</div>
          </div>
        </div>
      </div>

      <!-- Commercial Cost Section -->
      <div class="inspector-section collapsed" data-section="group-commercial-cost">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ’° Commercial Cost</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <!-- Override Status -->
          <div id="groupCostOverrideStatus" style="margin-bottom:12px; padding:8px; background:#fef3c7; border:1px solid #fcd34d; border-radius:6px; display:none;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="font-size:11px; color:#92400e;">âœï¸ <strong>User Override</strong> - values set manually</span>
              <button class="mini-btn" id="btnGroupResetCost" style="font-size:10px; padding:2px 6px;">ðŸ”„ Reset to Calculated</button>
            </div>
          </div>

          <div id="groupCostCalculatedStatus" style="margin-bottom:12px; padding:8px; background:#ecfdf5; border:1px solid #a7f3d0; border-radius:6px;">
            <span style="font-size:11px; color:#065f46;">ðŸ“Š <strong>Auto-calculated</strong> from <span id="groupCostSourceDesc">internal links</span></span>
          </div>

          <!-- Cost Mode Selector -->
          <div style="margin-bottom:12px;">
            <label style="font-size:10px; font-weight:600; color:#6b7280; text-transform:uppercase; letter-spacing:0.3px; margin-bottom:6px; display:block;">Pathfinder Cost Mode</label>
            <div class="cost-mode-selector">
              <label title="Use Annual Contract Value for pathfinding">
                <input type="radio" name="groupCostMode" id="groupCostModeLease" value="lease" checked />
                <span>ðŸ“„ Lease (ACV)</span>
              </label>
              <label title="Use IRU Net Present Value for pathfinding">
                <input type="radio" name="groupCostMode" id="groupCostModeIRU" value="iru" />
                <span>ðŸ“œ IRU (NPV)</span>
              </label>
            </div>
          </div>

          <!-- Lease Subsection - Tier-based -->
          <div class="cost-subsection lease">
            <div class="cost-subsection-title">
              <span>ðŸ“„ Lease Terms (by Capacity Tier)</span>
              <span id="groupLeaseCurrency" style="font-size:10px; color:#3b82f6; font-weight:600;">USD</span>
            </div>
            <table class="tier-pricing-grid">
              <thead>
                <tr>
                  <th>Tier</th>
                  <th>NRC</th>
                  <th>MRC</th>
                  <th>ACV</th>
                </tr>
              </thead>
              <tbody>
                <tr data-tier="1G">
                  <td class="tier-label">1G</td>
                  <td><input type="number" id="groupLeaseNRC_1G" min="0" step="0.01" value="0" /></td>
                  <td><input type="number" id="groupLeaseMRC_1G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated" id="groupLeaseACV_1G">$12</td>
                </tr>
                <tr data-tier="10G">
                  <td class="tier-label">10G</td>
                  <td><input type="number" id="groupLeaseNRC_10G" min="0" step="0.01" value="0" /></td>
                  <td><input type="number" id="groupLeaseMRC_10G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated" id="groupLeaseACV_10G">$12</td>
                </tr>
                <tr data-tier="100G">
                  <td class="tier-label">100G</td>
                  <td><input type="number" id="groupLeaseNRC_100G" min="0" step="0.01" value="0" /></td>
                  <td><input type="number" id="groupLeaseMRC_100G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated" id="groupLeaseACV_100G">$12</td>
                </tr>
                <tr data-tier="400G">
                  <td class="tier-label">400G</td>
                  <td><input type="number" id="groupLeaseNRC_400G" min="0" step="0.01" value="0" /></td>
                  <td><input type="number" id="groupLeaseMRC_400G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated" id="groupLeaseACV_400G">$12</td>
                </tr>
              </tbody>
            </table>
            <div class="tier-multiplier-help">
              <button class="mini-btn" id="btnGroupAutoFillLeaseTiers" title="Auto-calculate higher tiers based on 1G pricing">â›¡ Auto-fill from 1G</button>
              <span class="hint">Ã—2.5 (10G), Ã—6.25 (100G), Ã—15.625 (400G)</span>
            </div>
          </div>

          <!-- IRU Subsection - Tier-based -->
          <div class="cost-subsection iru">
            <div class="cost-subsection-title">
              <span>ðŸ“œ IRU Terms (by Capacity Tier)</span>
              <span id="groupIRUCurrency" style="font-size:10px; color:#8b5cf6; font-weight:600;">USD</span>
            </div>
            <table class="tier-pricing-grid">
              <thead>
                <tr>
                  <th>Tier</th>
                  <th>IRU Fee</th>
                  <th>NPV</th>
                </tr>
              </thead>
              <tbody>
                <tr data-tier="1G">
                  <td class="tier-label">1G</td>
                  <td><input type="number" id="groupIRUFee_1G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated iru" id="groupIRUNPV_1G">$1</td>
                </tr>
                <tr data-tier="10G">
                  <td class="tier-label">10G</td>
                  <td><input type="number" id="groupIRUFee_10G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated iru" id="groupIRUNPV_10G">$1</td>
                </tr>
                <tr data-tier="100G">
                  <td class="tier-label">100G</td>
                  <td><input type="number" id="groupIRUFee_100G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated iru" id="groupIRUNPV_100G">$1</td>
                </tr>
                <tr data-tier="400G">
                  <td class="tier-label">400G</td>
                  <td><input type="number" id="groupIRUFee_400G" min="0" step="0.01" value="1" /></td>
                  <td class="calculated iru" id="groupIRUNPV_400G">$1</td>
                </tr>
              </tbody>
            </table>
            <div class="tier-multiplier-help">
              <button class="mini-btn" id="btnGroupAutoFillIRUTiers" title="Auto-calculate higher tiers based on 1G pricing">â›¡ Auto-fill from 1G</button>
              <span class="hint">Ã—2.5 (10G), Ã—6.25 (100G), Ã—15.625 (400G)</span>
            </div>

            <!-- Common IRU terms (apply to all tiers) -->
            <div style="margin-top:12px; padding-top:12px; border-top:1px solid #e5e7eb;">
              <div style="font-size:10px; font-weight:600; color:#6b7280; margin-bottom:8px;">Common IRU Terms (all tiers)</div>
              <div class="cost-row">
                <label>Term</label>
                <input type="number" id="groupIRUTerm" min="1" max="30" step="1" value="15" style="width:60px;" />
                <span style="font-size:11px; color:#6b7280;">years</span>
              </div>
              <div class="cost-row">
                <label>O&M (%)</label>
                <input type="number" id="groupIRUOAM" min="0" max="100" step="0.1" value="3" style="width:60px;" />
                <span style="font-size:11px; color:#6b7280;">% of IRU fee/year</span>
              </div>
              <div class="cost-row">
                <label>O&M Annual Incr.</label>
                <input type="number" id="groupIRUOAMIncrement" min="0" max="50" step="0.1" value="2" style="width:60px;" />
                <span style="font-size:11px; color:#6b7280;">%</span>
              </div>
              <div style="font-size:9px; color:#7c3aed; margin-top:6px;">
                NPV @ <span id="groupIRUDiscountRate">12.5</span>% discount rate
              </div>
            </div>
          </div>

          <!-- Settings Link -->
          <div class="settings-link">
            <span>ðŸ’¡</span>
            <span>Currency & NPV settings: <a id="groupCostSettingsLink" style="color:#059669; cursor:pointer;">Financial Settings</a></span>
          </div>
        </div>
      </div>

      <!-- Appearance Section -->
      <div class="inspector-section" data-section="group-appearance">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Appearance</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Style Preset</label>
            <div class="inline">
              <select id="groupPreset"></select>
              <button class="mini-btn" id="btnGroupPresetSave" title="Save">Save</button>
              <button class="mini-btn" id="btnGroupPresetApply" title="Apply">Apply</button>
              <button class="mini-btn" id="btnGroupPresetDelete" title="Delete">Del</button>
            </div>
          </div>
          <div class="row">
            <label>Fill Color</label>
            <div class="field-with-controls" style="gap:8px;">
              <div class="inspector-color-picker" id="groupFillColorPicker">
                <div class="inspector-color-swatch" title="Click to choose color">
                  <div class="inspector-color-swatch-inner" id="groupFillColorSwatch"></div>
                </div>
                <div class="inspector-color-dropdown" hidden>
                  <div class="inspector-color-grid" data-target="groupFillColor"></div>
                  <div class="inspector-color-custom">
                    <input type="color" id="groupFillColorCustom" />
                    <input type="text" id="groupFillColorHex" placeholder="#000000" maxlength="7" />
                  </div>
                </div>
                <input id="groupFillColor" type="hidden" />
              </div>
              <div style="flex:1; display:flex; align-items:center; gap:6px;">
                <span style="font-size:10px; color:#666;">Opacity:</span>
                <input id="groupFillOpacity" type="range" min="0" max="100" value="100" style="flex:1;" />
                <span id="groupFillOpacityValue" style="font-size:10px; color:#666; min-width:32px;">100%</span>
              </div>
            </div>
            <input id="groupFill" type="hidden" />
          </div>
          <div class="row">
            <label>Stroke Color</label>
            <div class="inspector-color-picker" id="groupStrokePicker">
              <div class="inspector-color-swatch" title="Click to choose color">
                <div class="inspector-color-swatch-inner" id="groupStrokeSwatch"></div>
              </div>
              <div class="inspector-color-dropdown" hidden>
                <div class="inspector-color-grid" data-target="groupStroke"></div>
                <div class="inspector-color-custom">
                  <input type="color" id="groupStrokeCustom" />
                  <input type="text" id="groupStrokeHex" placeholder="#000000" maxlength="7" />
                </div>
              </div>
              <input id="groupStroke" type="hidden" />
            </div>
          </div>
          <div class="row inline">
            <div>
              <label>Border Width</label>
              <input id="groupStrokeW" type="number" min="0.5" max="12" step="0.5" />
            </div>
            <div style="flex:0;">
              <!-- Spacer -->
            </div>
          </div>
        </div>
      </div>

      <!-- Size Section -->
      <div class="inspector-section" data-section="group-size">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Size</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row inline">
            <div>
              <label>Width</label>
              <input id="groupW" type="number" min="120" />
            </div>
            <div>
              <label>Height</label>
              <input id="groupH" type="number" min="90" />
            </div>
          </div>
        </div>
      </div>

      <!-- Container Shape Section -->
      <div class="inspector-section collapsed" data-section="group-decoration">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ—ºï¸ Container Shape</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row" id="groupShapeInfo">
            <div style="font-size:11px; color:#666; font-style:italic;">Standard rectangular container</div>
          </div>
          <div class="row" style="display:flex; gap:6px;">
            <button class="btn" id="btnOpenLibraryForShape" style="flex:1; font-size:11px;">
              ðŸ“› Open Library
            </button>
            <button class="btn" id="btnRemoveGroupShape" style="flex:1; font-size:11px;" disabled>
              ðŸ”„ Reset to Rect
            </button>
          </div>
          <div class="hint" style="margin-top:6px;">Drag shapes from Library â†’ Containers tab to create shaped containers</div>
        </div>
      </div>

      <!-- Advanced Section -->
      <div class="inspector-section collapsed" data-section="group-advanced">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Advanced</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label>Unique ID (UUID)</label>
            <input id="groupUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:10px;" />
          </div>
        </div>
      </div>

      <!-- Hidden fields for compatibility -->
      <input type="hidden" id="groupTitleFont" />
      <input type="hidden" id="groupTitleColor" />
    </div>
    </div><!-- end inspectorContent -->
  </aside>

  <!-- Cable System Details Panel -->
  <aside id="cableSystemInspectorPanel" style="display:none;">
    <div id="cableInspectorHeader">
      <h3>Cable System Details</h3>
      <div id="cableInspectorControls">
        <button id="btnMinimizeCableInspector" title="Minimize/Maximize">âˆ’</button>
        <button id="btnCloseCableInspector" title="Hide">âœ•</button>
      </div>
    </div>
    <div id="cableInspectorContent">
      <div id="cableSystemInspector">
        <div id="csNoSelection" class="muted" style="padding:12px;">Select a cable system from the Systems List to view/edit details.</div>

        <div id="csDetails" style="display:none;">
          <div class="row">
            <label>Unique ID</label>
            <input id="csUUID" disabled style="background:#f5f5f5; color:#999; font-family:monospace; font-size:11px;" />
          </div>

          <div class="row">
            <label>Short Name</label>
            <input id="csShortName" placeholder="e.g. SMW6" maxlength="20" />
          </div>

          <div class="row">
            <label>Full Name</label>
            <input id="csName" placeholder="e.g. SEA-ME-WE 6" />
          </div>

          <div class="row inline">
            <div>
              <label>Type</label>
              <select id="csType">
                <option value="wet">Submarine (Wet)</option>
                <option value="terrestrial">Terrestrial</option>
              </select>
            </div>
            <div>
              <label>Status</label>
              <select id="csStatus">
                <option value="planned">Planned</option>
                <option value="under-construction">Under Construction</option>
                <option value="operational">In Operation</option>
                <option value="decommissioned">Decommissioned</option>
              </select>
            </div>
          </div>

          <div class="row inline">
            <div>
              <label>RFS Year</label>
              <input id="csRfsYear" type="number" min="1980" max="2100" placeholder="2025" />
            </div>
            <div>
              <label>Fiber Pairs</label>
              <input id="csFiberPairs" type="number" min="1" max="100" placeholder="8" />
            </div>
          </div>

          <div class="row">
            <label>Total Capacity (Tbps)</label>
            <input id="csCapacity" type="number" min="0" step="0.1" placeholder="100" />
          </div>

          <div class="row">
            <label>Owners (comma-separated)</label>
            <input id="csOwners" placeholder="e.g. Google, Meta, Orange" />
          </div>

          <div class="row">
            <label>Filter Tags (comma-separated)</label>
            <textarea id="csFilterTags" placeholder="default, submarine, Asia" style="height:40px;"></textarea>
          </div>

          <div class="sep" style="margin:8px 0; border-top:1px dashed #e0e0e0;"></div>

          <div class="row">
            <label style="display:flex; align-items:center; gap:6px;">
              ðŸ”— Live Status Link
              <span class="fa-link-badge" id="csFaLinkStatus">Not linked</span>
            </label>
            <div style="display:flex; gap:6px; align-items:center;">
              <div style="flex:1; position:relative;">
                <input id="csFaSearchInput" placeholder="Search Live Status cables..." style="width:100%; padding-right:24px; font-size:11px;" autocomplete="off" />
                <span id="csFaSearchClear" style="position:absolute; right:6px; top:50%; transform:translateY(-50%); cursor:pointer; font-size:14px; color:#999; display:none;" title="Clear selection">Ã—</span>
                <div id="csFaDropdown" style="display:none; position:absolute; top:100%; left:0; right:0; max-height:200px; overflow-y:auto; background:white; border:1px solid #d0d0d0; border-top:none; border-radius:0 0 6px 6px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:1000; font-size:11px;">
                </div>
              </div>
              <button class="mini-btn" id="btnAutoMatchFA" title="Auto-match with Live Status" style="padding:4px 8px; font-size:10px;">ðŸ” Auto</button>
            </div>
            <input type="hidden" id="csFiberAtlanticId" />
            <div id="csFaMatchInfo" style="font-size:10px; color:#64748b; margin-top:4px;"></div>
          </div>

          <div class="row">
            <label>Notes</label>
            <textarea id="csNotes" placeholder="Additional notes..." style="height:60px;"></textarea>
          </div>

          <div class="sep" style="margin:12px 0;"></div>

          <div class="row">
            <label style="font-weight:600;">Member Links (<span id="csMemberLinksCount">0</span>)
              <button class="mini-btn" id="btnAddLinksToCS" style="margin-left:8px;" title="Click links on canvas to add">+ Add</button>
            </label>
            <div id="csMemberLinks" style="max-height:100px; overflow-y:auto; border:1px solid #d0d0d0; border-radius:4px; padding:4px; background:#fafafa; font-size:11px;">
              <div class="muted">No links assigned</div>
            </div>
            <div style="margin-top:6px;">
              <button class="mini-btn" id="btnApplyCSNameToLinks" style="font-size:10px; padding:3px 8px;" title="Add cable system name to link tags">ðŸ·ï¸ Apply Name to Link Tags</button>
            </div>
          </div>

          <div class="row">
            <label style="font-weight:600;">Member Nodes (<span id="csMemberNodesCount">0</span>)
              <button class="mini-btn" id="btnAddNodesToCS" style="margin-left:8px;" title="Click nodes on canvas to add">+ Add</button>
            </label>
            <div id="csMemberNodes" style="max-height:100px; overflow-y:auto; border:1px solid #d0d0d0; border-radius:4px; padding:4px; background:#fafafa; font-size:11px;">
              <div class="muted">No nodes assigned</div>
            </div>
          </div>

          <!-- Add mode indicator bar (hidden by default) -->
          <div id="csAddModeBar" style="display:none; position:sticky; bottom:0; background:#fff3cd; border:1px solid #ffc107; border-radius:4px; padding:8px; margin-top:12px;">
            <div style="font-size:12px; font-weight:500; color:#856404;">
              <span id="csAddModeText">Click links on canvas to add them...</span>
            </div>
            <div style="display:flex; gap:8px; margin-top:8px;">
              <button class="btn primary" id="btnAcceptAddToCS" style="flex:1;">Accept</button>
              <button class="btn" id="btnCancelAddToCS" style="flex:1;">Cancel</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </aside>

  <!-- Cable System List Panel -->
  <aside id="cableNavigator" style="display:none;">
    <div id="cableNavigatorHeader">
      <h3>Cable System List</h3>
      <div id="cableNavigatorControls">
        <button id="btnOpenCableVisor" title="Open Submarine Cable Visor">ðŸŒ</button>
        <button id="btnMinimizeCableNav" title="Minimize/Maximize">âˆ’</button>
        <button id="btnCloseCableNav" title="Hide Navigator">âœ•</button>
      </div>
    </div>
    <div id="cableNavigatorContent">
      <div style="padding:8px 12px; border-bottom:1px solid #e0e0e0;">
        <input type="text" id="cableNavSearch" placeholder="Search cable systems..." style="width:100%; padding:6px 8px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
        <div style="margin-top:6px; display:flex; gap:6px; align-items:center;">
          <label style="font-size:10px; color:#666; display:flex; align-items:center; gap:4px;">
            <input type="checkbox" id="cableNavGroupByRegion" checked style="width:12px; height:12px;" />
            Group by Region
          </label>
          <label style="font-size:10px; color:#666; display:flex; align-items:center; gap:4px;">
            <input type="checkbox" id="cableNavMultiSelect" style="width:12px; height:12px;" />
            Multi-select
          </label>
          <div style="flex:1;"></div>
          <div style="display:flex; gap:4px; font-size:9px; flex-wrap:wrap;">
            <span title="Operational / Ready for Service" style="display:flex; align-items:center; gap:2px;"><span class="cs-status-badge operational" style="width:8px;height:8px;margin:0;"></span>RFS</span>
            <span title="Under Construction" style="display:flex; align-items:center; gap:2px;"><span class="cs-status-badge under-construction" style="width:8px;height:8px;margin:0;"></span>WIP</span>
            <span title="Planned" style="display:flex; align-items:center; gap:2px;"><span class="cs-status-badge planned" style="width:8px;height:8px;margin:0;"></span>Plan</span>
            <span title="Decommissioned (20+ years)" style="display:flex; align-items:center; gap:2px;"><span class="cs-status-badge decommissioned" style="width:8px;height:8px;margin:0;"></span>EOL</span>
            <span style="color:#cbd5e1; margin:0 1px;">|</span>
            <span title="Live: Online (from Live Status)" style="display:flex; align-items:center; gap:1px;"><span class="cs-live-badge live-online" style="padding:0 3px;font-size:8px;"><span class="live-dot" style="width:5px;height:5px;"></span>Up</span></span>
            <span title="Live: Outage (from Live Status)" style="display:flex; align-items:center; gap:1px;"><span class="cs-live-badge live-outage" style="padding:0 3px;font-size:8px;"><span class="live-dot" style="width:5px;height:5px;"></span>Fault</span></span>
          </div>
        </div>
      </div>
      <!-- Multi-select toolbar (hidden by default) -->
      <div id="cableNavMultiSelectBar" style="display:none; padding:6px 12px; background:#e0f2fe; border-bottom:1px solid #7dd3fc;">
        <div style="display:flex; gap:6px; align-items:center; flex-wrap:wrap;">
          <span style="font-size:11px; font-weight:500; color:#0369a1;"><span id="csMultiSelectCount">0</span> selected</span>
          <div style="flex:1;"></div>
          <button class="btn" id="btnCsSelectAll" style="padding:3px 8px; font-size:10px;">âœ“ All</button>
          <button class="btn" id="btnCsSelectNone" style="padding:3px 8px; font-size:10px;">âœ— None</button>
          <button class="btn" id="btnCsDeleteSelected" style="padding:3px 8px; font-size:10px; background:#fee2e2; border-color:#fca5a5; color:#b91c1c;">ðŸ—‘ï¸ Delete</button>
        </div>
      </div>
      <div id="cableSystemList" style="flex:1; overflow-y:auto; padding:4px;">
        <div class="muted" style="padding:12px; text-align:center;">No cable systems defined.<br/>Click "New" to create one.</div>
      </div>
      <div style="padding:8px 12px; border-top:1px solid #e0e0e0; display:grid; grid-template-columns:1fr 1fr 1fr 1fr; gap:6px;">
        <button class="btn primary" id="btnNewCableSystem" style="font-size:11px; padding:5px 2px;">+ New</button>
        <button class="btn" id="btnImportCableSystems" style="font-size:11px; padding:5px 2px;" title="Import cable systems from database or API">ðŸ“¥ Import</button>
        <div style="position:relative; display:flex;">
          <button class="btn" id="btnExportCableSystems" style="flex:1; font-size:11px; padding:5px 2px; border-top-right-radius:0; border-bottom-right-radius:0;" title="Export cable systems to GeoJSON">ðŸ“¤ Export</button>
          <button class="btn" id="btnExportCableDropdown" style="padding:4px 3px; border-top-left-radius:0; border-bottom-left-radius:0; border-left:1px solid #ccc; font-size:10px;" title="Export options">â–¼</button>
          <div id="exportCableDropdownMenu" style="display:none; position:absolute; bottom:100%; right:0; background:white; border:1px solid #ccc; border-radius:6px; box-shadow:0 2px 8px rgba(0,0,0,0.15); z-index:9999; min-width:180px; margin-bottom:2px;">
            <button class="btn" id="btnExportCableGeoJSON" style="display:block; width:100%; text-align:left; border:none; border-radius:6px 6px 0 0; padding:8px 12px; font-size:11px;">ðŸŒ Export as GeoJSON</button>
            <button class="btn" id="btnExportCableJSON" style="display:block; width:100%; text-align:left; border:none; border-radius:0 0 6px 6px; padding:8px 12px; font-size:11px;">ðŸ“„ Export as JSON (internal)</button>
          </div>
        </div>
        <button class="btn" id="btnDeleteCableSystem" style="font-size:11px; padding:5px 2px;">ðŸ—‘ Delete</button>
      </div>
      <div style="padding:4px 12px 8px; display:flex; gap:8px;">
        <button class="btn" id="btnBatchAutoMatchFA" style="flex:1; font-size:10px; padding:4px 8px; background:#f0fdf4; border-color:#86efac; color:#166534;" title="Auto-match all cable systems with Live Status for live status">ðŸ”— Link All to Live Status</button>
        <button class="btn" id="btnRefreshLiveStatus" style="flex:1; font-size:10px; padding:4px 8px; background:#eff6ff; border-color:#93c5fd; color:#1e40af;" title="Refresh live status for all linked cables">ðŸ”„ Refresh Live</button>
      </div>
    </div>
  </aside>

  <!-- Datacenter Navigator Panel -->
  <aside id="dcNavigator" style="display:none;">
    <div id="dcNavigatorHeader">
      <h3>Facility List</h3>
      <div id="dcNavigatorControls">
        <button id="btnOpenDCVisor" title="Open Datacenter Visor">&#x1F3E2;</button>
        <button id="btnMinimizeDCNav" title="Minimize/Maximize">âˆ’</button>
        <button id="btnCloseDCNav" title="Hide Navigator">âœ•</button>
      </div>
    </div>
    <div id="dcNavigatorContent">
      <div style="padding:8px 10px; border-bottom:1px solid #f9a8d4;">
        <input type="text" id="dcNavSearch" placeholder="Search facilities..." style="width:100%; padding:5px 8px; border:1px solid #f9a8d4; border-radius:4px; font-size:11px;" />
        <div style="margin-top:5px; display:flex; gap:4px; align-items:center;">
          <select id="dcNavTypeFilter" style="padding:2px 4px; border:1px solid #f9a8d4; border-radius:3px; font-size:10px; max-width:110px; accent-color:#ec4899;">
            <option value="">All Types</option>
            <option value="datacenter">Datacenters</option>
            <option value="cable_station">Cable Stations</option>
          </select>
          <label style="font-size:10px; color:#831843; display:flex; align-items:center; gap:3px;">
            <input type="checkbox" id="dcNavGroupByRegion" checked style="width:12px; height:12px; accent-color:#ec4899;" />
            Region
          </label>
          <select id="dcNavCountryFilter" style="padding:2px 4px; border:1px solid #f9a8d4; border-radius:3px; font-size:10px; max-width:90px;">
            <option value="">All Countries</option>
          </select>
        </div>
        <div style="margin-top:4px; display:flex; gap:6px; font-size:9px; align-items:center; justify-content:flex-start;">
          <span style="font-size:9px; color:#831843; font-weight:600;">Density:</span>
          <span title="Critical: 50+ carriers" style="display:flex; align-items:center; gap:2px;"><span class="dc-density-badge density-critical" style="width:8px;height:8px;"></span>50+</span>
          <span title="High: 20-49 carriers" style="display:flex; align-items:center; gap:2px;"><span class="dc-density-badge density-high" style="width:8px;height:8px;"></span>20+</span>
          <span title="Medium: 5-19 carriers" style="display:flex; align-items:center; gap:2px;"><span class="dc-density-badge density-medium" style="width:8px;height:8px;"></span>5+</span>
          <span title="Low: 1-4 carriers" style="display:flex; align-items:center; gap:2px;"><span class="dc-density-badge density-low" style="width:8px;height:8px;"></span>1+</span>
          <span title="No carrier data" style="display:flex; align-items:center; gap:2px;"><span class="dc-density-badge density-minimal" style="width:8px;height:8px;"></span>0</span>
        </div>
      </div>
      <div id="dcList" style="flex:1; overflow-y:auto; padding:2px;">
        <div class="muted" style="padding:12px; text-align:center;">Loading datacenter database...</div>
      </div>
      <div style="padding:6px 10px; border-top:1px solid #f9a8d4; background:#fdf2f8; font-size:10px; color:#831843; display:flex; justify-content:space-between; align-items:center;">
        <span id="dcNavCount">0 datacenters</span>
        <span>Drag to container or node</span>
      </div>
    </div>
  </aside>

  <!-- Cable System Bulk Import Modal -->
  <div id="csBulkImportModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:11000; align-items:center; justify-content:center;">
    <div style="background:white; border-radius:12px; width:90%; max-width:800px; max-height:85vh; display:flex; flex-direction:column; box-shadow:0 8px 32px rgba(0,0,0,0.3);">
      <div style="padding:16px 20px; border-bottom:1px solid #e0e0e0; display:flex; justify-content:space-between; align-items:center;">
        <div>
          <h3 style="margin:0; font-size:18px;">ðŸ“¥ Import Cable Systems</h3>
          <div style="font-size:12px; color:#666; margin-top:4px;">Select cables to import as Cable System objects</div>
        </div>
        <button id="btnCloseCsBulkImport" style="background:none; border:none; font-size:24px; cursor:pointer; color:#666; padding:0 8px;">&times;</button>
      </div>

      <div style="padding:10px 20px; border-bottom:1px solid #e0e0e0; background:#f0f9ff; display:flex; gap:12px; align-items:center; flex-wrap:wrap;">
        <span style="font-size:12px; font-weight:600; color:#0369a1;">Source:</span>
        <label id="lblSrcLocal" style="display:flex; align-items:center; gap:6px; cursor:pointer; padding:6px 12px; border-radius:6px; border:2px solid #0369a1; background:#e0f2fe;">
          <input type="radio" name="csBulkSrc" id="rdoSrcLocal" value="local" checked style="margin:0;" />
          <span style="font-size:12px;">ðŸ“‚ Internal</span>
        </label>
        <label id="lblSrcTG" style="display:flex; align-items:center; gap:6px; cursor:pointer; padding:6px 12px; border-radius:6px; border:2px solid transparent; background:white;">
          <input type="radio" name="csBulkSrc" id="rdoSrcTG" value="telegeography" style="margin:0;" />
          <span style="font-size:12px;">ðŸŒ Public Cable System DB (500+)</span>
        </label>
        <button id="btnBulkRefreshAPI" class="btn" style="padding:4px 10px; font-size:11px; margin-left:auto;" title="Fetch fresh data from Public Cable System DB API">ðŸ”„ Refresh from API</button>
      </div>

      <div style="padding:12px 20px; border-bottom:1px solid #e0e0e0; display:flex; gap:12px; flex-wrap:wrap; align-items:center;">
        <input type="text" id="csBulkSearchInput" placeholder="Search cables..." style="flex:1; min-width:200px; padding:8px 12px; border:1px solid #d0d0d0; border-radius:6px; font-size:13px;" />
        <select id="csBulkRegionFilter" style="padding:8px 12px; border:1px solid #d0d0d0; border-radius:6px; font-size:13px;">
          <option value="">All Corridors</option>
        </select>
        <div style="display:flex; gap:8px;">
          <button id="btnCsBulkSelectAll" class="btn" style="padding:6px 12px; font-size:12px;">âœ“ Select All</button>
          <button id="btnCsBulkSelectNone" class="btn" style="padding:6px 12px; font-size:12px;">âœ— Clear All</button>
        </div>
      </div>

      <div id="csBulkCableList" style="flex:1; overflow-y:auto; padding:12px 20px;">
        <div style="text-align:center; padding:40px; color:#666;">Loading cable database...</div>
      </div>

      <div style="padding:12px 20px; border-top:1px solid #e0e0e0; display:flex; justify-content:space-between; align-items:center; background:#f8f9fa;">
        <div style="font-size:13px;">
          <span id="csBulkSelectedCount">0</span> cables selected
        </div>
        <div style="display:flex; gap:8px;">
          <button id="btnCsBulkCancel" class="btn" style="padding:8px 20px;">Cancel</button>
          <button id="btnCsBulkImport" class="btn primary" style="padding:8px 20px;" disabled>ðŸ“¥ Import Selected</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Multilink Group Manager Panel -->
  <aside id="multilinkManager" style="display:none;">
    <div id="multilinkManagerHeader">
      <h3>ðŸ”— Multilink Groups</h3>
      <div id="multilinkManagerControls">
        <button id="btnMinimizeMLManager" title="Minimize/Maximize">âˆ’</button>
        <button id="btnCloseMLManager" title="Hide Manager">âœ•</button>
      </div>
    </div>
    <div id="multilinkManagerContent">
      <div style="padding:8px 12px; border-bottom:1px solid #e0e0e0;">
        <input type="text" id="mlgSearch" placeholder="Search multilink groups..." style="width:100%; padding:6px 8px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
      </div>
      <div id="multilinkGroupList" style="flex:1; overflow-y:auto; padding:4px;">
        <div class="muted" style="padding:12px; text-align:center;">No multilink groups defined.<br/>Click "+ New" to create one.</div>
      </div>
      <div style="padding:8px 12px; border-top:1px solid #e0e0e0; display:flex; gap:8px;">
        <button class="btn primary" id="btnNewMultilinkGroup" style="flex:1;">+ New</button>
        <button class="btn" id="btnDeleteMultilinkGroup" style="flex:1;">Delete</button>
      </div>
    </div>
  </aside>

  <!-- Multilink Group Editor Panel -->
  <aside id="multilinkEditor" style="display:none;">
    <div id="multilinkEditorHeader">
      <h3 id="mlEditorTitle">New Multilink Group</h3>
      <div id="multilinkEditorControls">
        <button id="btnMinimizeMLEditor" title="Minimize/Maximize">âˆ’</button>
        <button id="btnCloseMLEditor" title="Close Editor">âœ•</button>
      </div>
    </div>
    <div id="multilinkEditorContent">
      <!-- Basic Info -->
      <div class="row">
        <label>Name</label>
        <input type="text" id="mlgName" placeholder="e.g., US-EU Backbone" />
      </div>
      <div class="row" style="display:flex; gap:8px;">
        <div style="flex:1;">
          <label>Color</label>
          <input type="color" id="mlgColor" value="#f59e0b" style="height:32px; padding:2px;" />
        </div>
        <div style="flex:2;">
          <label>Description</label>
          <input type="text" id="mlgDescription" placeholder="Optional description" />
        </div>
      </div>

      <!-- Segments Section -->
      <div style="margin-top:16px; margin-bottom:8px; display:flex; justify-content:space-between; align-items:center;">
        <h4 style="margin:0; font-size:12px; font-weight:600; color:#475569;">Segments</h4>
        <button class="btn mini-btn" id="btnAddSegment" style="font-size:10px; padding:4px 8px;">+ Add Segment</button>
      </div>

      <div id="mlgSegmentsContainer">
        <div class="muted" style="padding:12px; text-align:center; font-size:11px; color:#94a3b8;">
          No segments yet. Click "+ Add Segment" to start building the multilink group.
        </div>
      </div>

      <!-- Computed Properties -->
      <div id="mlgComputedProps" class="mlg-computed" style="display:none;">
        <div class="mlg-computed-row">
          <span class="label">Type:</span>
          <span class="value" id="mlgComputedType">â€”</span>
        </div>
        <div class="mlg-computed-row">
          <span class="label">Route:</span>
          <span class="value" id="mlgComputedRoute">â€”</span>
        </div>
        <div class="mlg-computed-row">
          <span class="label">Total Latency:</span>
          <span class="value" id="mlgComputedLatency">â€”</span>
        </div>
        <div class="mlg-computed-row">
          <span class="label">Diversity:</span>
          <span class="value" id="mlgComputedDiversity">â€”</span>
        </div>
      </div>

      <!-- Commercial Cost Section -->
      <div id="mlgCostSection" style="display:none; margin-top:12px; padding:12px; background:#f8fafb; border:1px solid #e5e7eb; border-radius:8px;">
        <div style="font-size:11px; font-weight:700; color:#059669; text-transform:uppercase; letter-spacing:0.3px; margin-bottom:10px; display:flex; align-items:center; gap:6px;">
          ðŸ’° Commercial Cost
          <span id="mlgCostCurrency" style="font-size:10px; color:#6b7280; font-weight:500; margin-left:auto;">USD</span>
        </div>

        <!-- Capacity Tier Selector for MLG -->
        <div style="margin-bottom:10px;">
          <label style="font-size:10px; font-weight:600; color:#6b7280; text-transform:uppercase; margin-bottom:4px; display:block;">Capacity Tier for Pricing</label>
          <div style="display:flex; gap:4px;">
            <label style="flex:1; display:flex; align-items:center; justify-content:center; padding:6px 4px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600; background:white;" id="mlgCapTier1GLabel">
              <input type="radio" name="mlgCapacityTier" id="mlgCapTier1G" value="1G" style="display:none;" />
              <span>1G</span>
            </label>
            <label style="flex:1; display:flex; align-items:center; justify-content:center; padding:6px 4px; border:2px solid #059669; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600; background:#ecfdf5; color:#047857;" id="mlgCapTier10GLabel">
              <input type="radio" name="mlgCapacityTier" id="mlgCapTier10G" value="10G" checked style="display:none;" />
              <span>10G</span>
            </label>
            <label style="flex:1; display:flex; align-items:center; justify-content:center; padding:6px 4px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600; background:white;" id="mlgCapTier100GLabel">
              <input type="radio" name="mlgCapacityTier" id="mlgCapTier100G" value="100G" style="display:none;" />
              <span>100G</span>
            </label>
            <label style="flex:1; display:flex; align-items:center; justify-content:center; padding:6px 4px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600; background:white;" id="mlgCapTier400GLabel">
              <input type="radio" name="mlgCapacityTier" id="mlgCapTier400G" value="400G" style="display:none;" />
              <span>400G</span>
            </label>
          </div>
        </div>

        <!-- Cost Mode for MLG -->
        <div style="margin-bottom:10px;">
          <label style="font-size:10px; font-weight:600; color:#6b7280; text-transform:uppercase; margin-bottom:4px; display:block;">Pathfinder Cost Mode</label>
          <div style="display:flex; gap:6px;">
            <label style="flex:1; display:flex; align-items:center; gap:4px; padding:6px 8px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:10px; font-weight:500;">
              <input type="radio" name="mlgCostMode" id="mlgCostModeLease" value="lease" checked style="margin:0;" />
              <span>ðŸ“„ Lease (ACV)</span>
            </label>
            <label style="flex:1; display:flex; align-items:center; gap:4px; padding:6px 8px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:10px; font-weight:500;">
              <input type="radio" name="mlgCostMode" id="mlgCostModeIRU" value="iru" style="margin:0;" />
              <span>ðŸ“œ IRU (NPV)</span>
            </label>
          </div>
        </div>

        <!-- Lease Section -->
        <div style="padding:8px; background:#eff6ff; border:1px solid #bfdbfe; border-left:3px solid #3b82f6; border-radius:4px; margin-bottom:8px;">
          <div style="font-size:10px; font-weight:600; color:#1e40af; margin-bottom:6px;">ðŸ“„ Lease Terms</div>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
            <div>
              <label style="font-size:9px; color:#6b7280;">NRC (Sum)</label>
              <div style="display:flex; align-items:center; gap:4px;">
                <input type="number" id="mlgLeaseNRC" min="0" step="0.01" style="width:100%; padding:4px 6px; font-size:11px; text-align:right; border:1px solid #d1d5db; border-radius:3px;" />
                <label style="font-size:9px; display:flex; align-items:center; gap:2px; white-space:nowrap;" title="Override auto-calculated sum">
                  <input type="checkbox" id="mlgLeaseNRCOverride" style="width:12px; height:12px;" />
                  <span style="color:#6b7280;">Ovr</span>
                </label>
              </div>
              <div id="mlgLeaseNRCCalc" style="font-size:9px; color:#3b82f6; margin-top:2px;">ÃŽÂ£ â€”</div>
            </div>
            <div>
              <label style="font-size:9px; color:#6b7280;">MRC (Sum)</label>
              <div style="display:flex; align-items:center; gap:4px;">
                <input type="number" id="mlgLeaseMRC" min="0" step="0.01" style="width:100%; padding:4px 6px; font-size:11px; text-align:right; border:1px solid #d1d5db; border-radius:3px;" />
                <label style="font-size:9px; display:flex; align-items:center; gap:2px; white-space:nowrap;" title="Override auto-calculated sum">
                  <input type="checkbox" id="mlgLeaseMRCOverride" style="width:12px; height:12px;" />
                  <span style="color:#6b7280;">Ovr</span>
                </label>
              </div>
              <div id="mlgLeaseMRCCalc" style="font-size:9px; color:#3b82f6; margin-top:2px;">ÃŽÂ£ â€”</div>
            </div>
          </div>
          <div style="margin-top:8px; padding:6px 8px; background:linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); border-radius:4px;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="font-size:10px; font-weight:600; color:#1e40af;">Annual Contract Value (ACV)</span>
              <span id="mlgLeaseACV" style="font-size:13px; font-weight:700; color:#1d4ed8; font-family:'SF Mono',Monaco,monospace;">$0.00</span>
            </div>
          </div>
        </div>

        <!-- IRU Section -->
        <div style="padding:8px; background:#faf5ff; border:1px solid #e9d5ff; border-left:3px solid #8b5cf6; border-radius:4px;">
          <div style="font-size:10px; font-weight:600; color:#6b21a8; margin-bottom:6px;">ðŸ“œ IRU Terms</div>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px; margin-bottom:6px;">
            <div>
              <label style="font-size:9px; color:#6b7280;">IRU Fee (Sum)</label>
              <div style="display:flex; align-items:center; gap:4px;">
                <input type="number" id="mlgIRUFee" min="0" step="0.01" style="width:100%; padding:4px 6px; font-size:11px; text-align:right; border:1px solid #d1d5db; border-radius:3px;" />
                <label style="font-size:9px; display:flex; align-items:center; gap:2px; white-space:nowrap;" title="Override auto-calculated sum">
                  <input type="checkbox" id="mlgIRUFeeOverride" style="width:12px; height:12px;" />
                  <span style="color:#6b7280;">Ovr</span>
                </label>
              </div>
              <div id="mlgIRUFeeCalc" style="font-size:9px; color:#8b5cf6; margin-top:2px;">ÃŽÂ£ â€”</div>
            </div>
            <div>
              <label style="font-size:9px; color:#6b7280;">Term (years)</label>
              <input type="number" id="mlgIRUTerm" min="1" max="30" step="1" value="15" style="width:100%; padding:4px 6px; font-size:11px; text-align:right; border:1px solid #d1d5db; border-radius:3px;" />
            </div>
          </div>
          <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px; margin-bottom:6px;">
            <div>
              <label style="font-size:9px; color:#6b7280;">O&M % (Avg)</label>
              <div style="display:flex; align-items:center; gap:4px;">
                <input type="number" id="mlgIRUOAM" min="0" max="100" step="0.1" style="width:100%; padding:4px 6px; font-size:11px; text-align:right; border:1px solid #d1d5db; border-radius:3px;" />
                <label style="font-size:9px; display:flex; align-items:center; gap:2px; white-space:nowrap;" title="Override weighted average">
                  <input type="checkbox" id="mlgIRUOAMOverride" style="width:12px; height:12px;" />
                  <span style="color:#6b7280;">Ovr</span>
                </label>
              </div>
              <div id="mlgIRUOAMCalc" style="font-size:9px; color:#8b5cf6; margin-top:2px;">Avg â€”</div>
            </div>
            <div>
              <label style="font-size:9px; color:#6b7280;">O&M Incr. %</label>
              <input type="number" id="mlgIRUOAMIncrement" min="0" max="50" step="0.1" value="0" style="width:100%; padding:4px 6px; font-size:11px; text-align:right; border:1px solid #d1d5db; border-radius:3px;" />
            </div>
          </div>
          <div style="margin-top:8px; padding:6px 8px; background:linear-gradient(135deg, #f3e8ff 0%, #e9d5ff 100%); border-radius:4px;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <span style="font-size:10px; font-weight:600; color:#6b21a8;">IRU NPV (Total Cost)</span>
              <span id="mlgIRUNPV" style="font-size:13px; font-weight:700; color:#7c3aed; font-family:'SF Mono',Monaco,monospace;">$0.00</span>
            </div>
            <div style="font-size:8px; color:#7c3aed; margin-top:2px;">
              NPV @ <span id="mlgIRUDiscountRate">12.5</span>% discount rate
            </div>
          </div>
        </div>

        <!-- Settings Link -->
        <div style="margin-top:8px; font-size:9px; color:#6b7280; display:flex; align-items:center; gap:4px;">
          <span>ðŸ’¡</span>
          <span>Currency & NPV settings: <a id="mlgCostSettingsLink" style="color:#059669; cursor:pointer;">Financial Settings</a></span>
        </div>
      </div>

      <!-- Warnings -->
      <div id="mlgWarningsBox" class="mlg-warnings-box" style="display:none;">
        <div class="warning-title">âš ï¸ Warnings</div>
        <div id="mlgWarningsList"></div>
      </div>

      <!-- Actions -->
      <div style="margin-top:16px; display:flex; gap:8px;">
        <button class="btn" id="btnCancelMLEditor" style="flex:1;">Cancel</button>
        <button class="btn primary" id="btnSaveMultilinkGroup" style="flex:1;">Save</button>
      </div>
    </div>
  </aside>

  <!-- Route Finder Panel (Inspector Style) -->
  <aside id="routeFinderPanel">
    <div id="routeFinderHeader">
      <h3>ðŸ›¤ï¸ Route Finder</h3>
      <div id="routeFinderControls">
        <button id="btnCloseRouteFinder" title="Exit Route Finder">âœ•</button>
      </div>
    </div>
    <div id="routeFinderContent">
      <!-- Mode Indicator -->
      <div style="padding:10px 12px; background:linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); border-bottom:1px solid #93c5fd;">
        <div style="display:flex; align-items:center; gap:8px;">
          <span style="font-size:16px;">ðŸ§­</span>
          <div>
            <div style="font-weight:600; font-size:12px; color:#1e40af;">Calculation Mode Active</div>
            <div style="font-size:11px; color:#3b82f6;">Click nodes or use dropdowns to select endpoints</div>
          </div>
        </div>
      </div>

      <!-- Visibility Filter -->
      <div style="padding:10px 12px; background:#f8fafc; border-bottom:1px solid #e2e8f0;">
        <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:12px;">
          <input type="checkbox" id="routeVisibleOnly" style="width:16px; height:16px; accent-color:#5a67d8;">
          <span style="color:#475569;">Calculate using <strong>visible elements only</strong></span>
        </label>
        <div style="font-size:10px; color:#94a3b8; margin-top:4px; margin-left:24px;">Respects current tag filters and visibility settings</div>

        <label style="display:flex; align-items:center; gap:8px; cursor:pointer; font-size:12px; margin-top:8px;">
          <input type="checkbox" id="routeSkipImplicitTransit" style="width:16px; height:16px; accent-color:#5a67d8;">
          <span style="color:#475569;">Skip <strong>implicit container transit</strong></span>
        </label>
        <div style="font-size:10px; color:#94a3b8; margin-top:4px; margin-left:24px;">Don't use dashed-line connections through containers/regions</div>
      </div>

      <!-- Cost Optimization Section -->
      <div class="inspector-section" data-section="route-cost-optimization">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ’° Cost Optimization</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label style="font-size:11px; font-weight:600; color:#475569; margin-bottom:8px; display:block;">Optimization Balance</label>
            <div style="display:flex; align-items:center; gap:8px;">
              <span style="font-size:10px; color:#3b82f6; font-weight:500; min-width:50px;">â›¡ Latency</span>
              <input type="range" id="routeOptimizationBalance" min="0" max="100" value="0"
                style="flex:1; height:8px; accent-color:#059669;" />
              <span style="font-size:10px; color:#059669; font-weight:500; min-width:40px; text-align:right;">ðŸ’° Cost</span>
            </div>
            <div style="display:flex; justify-content:space-between; margin-top:4px;">
              <span id="routeBalanceLatencyPct" style="font-size:10px; color:#3b82f6;">100%</span>
              <span id="routeBalanceValue" style="font-size:10px; color:#6b7280; font-weight:500;">Pure Latency</span>
              <span id="routeBalanceCostPct" style="font-size:10px; color:#059669;">0%</span>
            </div>
          </div>

          <div class="row" style="margin-top:12px;">
            <label style="font-size:10px; font-weight:600; color:#6b7280; text-transform:uppercase;">Cost Metric</label>
            <div style="display:flex; gap:6px; margin-top:4px;">
              <label style="flex:1; display:flex; align-items:center; gap:4px; padding:6px 8px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:10px; font-weight:500; background:white;" id="routeCostMetricLeaseLabel">
                <input type="radio" name="routeCostMetric" id="routeCostMetricLease" value="lease" checked style="margin:0;" />
                <span>ðŸ“„ Lease (ACV)</span>
              </label>
              <label style="flex:1; display:flex; align-items:center; gap:4px; padding:6px 8px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:10px; font-weight:500; background:white;" id="routeCostMetricIRULabel">
                <input type="radio" name="routeCostMetric" id="routeCostMetricIRU" value="iru" style="margin:0;" />
                <span>ðŸ“œ IRU (NPV)</span>
              </label>
            </div>
          </div>

          <!-- Capacity Tier Selector -->
          <div class="row" style="margin-top:12px;">
            <label style="font-size:10px; font-weight:600; color:#6b7280; text-transform:uppercase;">Capacity Tier for Pricing</label>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <label style="flex:1; display:flex; align-items:center; justify-content:center; gap:2px; padding:6px 4px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600; background:white;" id="routeCapTier1GLabel">
                <input type="radio" name="routeCapacityTier" id="routeCapTier1G" value="1G" style="display:none;" />
                <span>1G</span>
              </label>
              <label style="flex:1; display:flex; align-items:center; justify-content:center; gap:2px; padding:6px 4px; border:2px solid #059669; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600; background:#ecfdf5; color:#047857;" id="routeCapTier10GLabel">
                <input type="radio" name="routeCapacityTier" id="routeCapTier10G" value="10G" checked style="display:none;" />
                <span>10G</span>
              </label>
              <label style="flex:1; display:flex; align-items:center; justify-content:center; gap:2px; padding:6px 4px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600; background:white;" id="routeCapTier100GLabel">
                <input type="radio" name="routeCapacityTier" id="routeCapTier100G" value="100G" style="display:none;" />
                <span>100G</span>
              </label>
              <label style="flex:1; display:flex; align-items:center; justify-content:center; gap:2px; padding:6px 4px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:11px; font-weight:600; background:white;" id="routeCapTier400GLabel">
                <input type="radio" name="routeCapacityTier" id="routeCapTier400G" value="400G" style="display:none;" />
                <span>400G</span>
              </label>
            </div>
            <div style="font-size:9px; color:#94a3b8; margin-top:4px;">Cost calculations use pricing for this capacity tier</div>
          </div>

          <div class="row" style="margin-top:12px;">
            <label style="font-size:10px; font-weight:600; color:#6b7280; text-transform:uppercase;">Cost Scale</label>
            <div style="display:flex; gap:6px; margin-top:4px;">
              <label style="flex:1; display:flex; align-items:center; gap:4px; padding:6px 8px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:10px; font-weight:500; background:white;">
                <input type="radio" name="routeCostScale" id="routeCostScaleLog" value="logarithmic" checked style="margin:0;" />
                <span>ðŸ“Š Logarithmic</span>
              </label>
              <label style="flex:1; display:flex; align-items:center; gap:4px; padding:6px 8px; border:2px solid #e5e7eb; border-radius:4px; cursor:pointer; font-size:10px; font-weight:500; background:white;">
                <input type="radio" name="routeCostScale" id="routeCostScaleLinear" value="linear" style="margin:0;" />
                <span>ðŸ“ Linear</span>
              </label>
            </div>
            <div style="font-size:9px; color:#94a3b8; margin-top:4px;">Logarithmic scale recommended when costs vary significantly between links</div>
          </div>

          <div style="margin-top:10px; padding:8px; background:#f0fdf4; border:1px solid #86efac; border-radius:6px;">
            <div style="font-size:10px; color:#166534;">
              <strong>ðŸ’¡ Tip:</strong> Slide towards Cost to find cheaper routes. Route results will show both latency and cost totals.
            </div>
          </div>
        </div>
      </div>

      <!-- Endpoint Selection Section -->
      <div class="inspector-section" data-section="route-endpoints">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Endpoints</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label style="color:#166534; font-weight:600;">ðŸŸ¢ Origin (A-Node)</label>
            <select id="routeOriginSelect" style="width:100%; padding:8px; border:2px solid #86efac; border-radius:4px; background:#f0fff4; font-size:12px;">
              <option value="">-- Click a node or select from list --</option>
            </select>
          </div>
          <div class="row">
            <label style="color:#991b1b; font-weight:600;">ðŸ”´ Destination (B-Node)</label>
            <select id="routeDestSelect" style="width:100%; padding:8px; border:2px solid #fca5a5; border-radius:4px; background:#fef2f2; font-size:12px;">
              <option value="">-- Click a node or select from list --</option>
            </select>
          </div>
          <div class="row" style="display:flex; gap:8px; margin-top:12px;">
            <button class="btn" id="btnSwapEndpoints" style="flex:1;">â‡„ Swap</button>
            <button class="btn primary" id="btnCalculateRoutes" style="flex:1;" disabled>ðŸ” Calculate</button>
          </div>
          <!-- Active Filters Indicator -->
          <div id="activeFiltersIndicator" style="display:none; margin-top:10px; padding:8px; background:#fef3c7; border:1px solid #fcd34d; border-radius:6px;">
            <div style="display:flex; justify-content:space-between; align-items:center;">
              <div style="font-size:11px; color:#92400e;">
                <span style="font-weight:600;">âš ï¸ Active Filters:</span>
                <span id="activeFiltersText"></span>
              </div>
            </div>
          </div>
          <div class="row" style="margin-top:8px;">
            <button class="btn" id="btnResetAllFilters" style="width:100%; font-size:11px; padding:6px; background:#fee2e2; border-color:#fca5a5; color:#991b1b;">
              ðŸ§¹ Reset All Filters
            </button>
          </div>
        </div>
      </div>

      <!-- Restrictions Section -->
      <div class="inspector-section collapsed" data-section="route-restrictions">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ›« Restrictions</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <!-- Excluded Nodes -->
          <div class="row">
            <label style="font-weight:600; color:#7c3aed; font-size:11px;">Excluded Nodes</label>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <select id="routeExcludeNodeSelect" style="flex:1; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd;">
                <option value="">-- Select node to exclude --</option>
              </select>
              <button class="btn" id="btnAddExcludeNode" style="padding:6px 10px; font-size:11px;" title="Add selected node">+</button>
              <button class="btn" id="btnPickExcludeNode" style="padding:6px 10px; font-size:11px;" title="Click on canvas to pick">âŠ•</button>
            </div>
            <div id="excludedNodesList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:4px;">
              <!-- Excluded nodes will appear here as tags -->
            </div>
          </div>

          <!-- Excluded Links -->
          <div class="row" style="margin-top:12px;">
            <label style="font-weight:600; color:#dc2626; font-size:11px;">Excluded Links</label>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <select id="routeExcludeLinkSelect" style="flex:1; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd;">
                <option value="">-- Select link to exclude --</option>
              </select>
              <button class="btn" id="btnAddExcludeLink" style="padding:6px 10px; font-size:11px;" title="Add selected link">+</button>
              <button class="btn" id="btnPickExcludeLink" style="padding:6px 10px; font-size:11px;" title="Click on canvas to pick">âŠ•</button>
            </div>
            <div id="excludedLinksList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:4px;">
              <!-- Excluded links will appear here as tags -->
            </div>
          </div>

          <!-- Clear All Exclusions -->
          <div class="row" style="margin-top:12px;">
            <button class="btn" id="btnClearAllRestrictions" style="width:100%; font-size:11px; padding:6px; background:#fef2f2; border-color:#fecaca; color:#991b1b;">
              ðŸ—‘ï¸ Clear All Exclusions
            </button>
          </div>
        </div>
      </div>

      <!-- Must-Use Constraints Section -->
      <div class="inspector-section collapsed" data-section="route-must-use">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>âœ… Must-Use Constraints</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="hint" style="margin-bottom:10px; padding:6px; background:#f0fdf4; border-radius:4px; color:#166534;">
            Force routes to pass through specific nodes or links.
          </div>

          <!-- Must-Use Nodes -->
          <div class="row">
            <label style="font-weight:600; color:#16a34a; font-size:11px;">Must-Use Nodes</label>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <select id="routeMustUseNodeSelect" style="flex:1; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd;">
                <option value="">-- Select node (must pass through) --</option>
              </select>
              <button class="btn" id="btnAddMustUseNode" style="padding:6px 10px; font-size:11px; background:#f0fdf4; border-color:#86efac;" title="Add must-use node">+</button>
              <button class="btn" id="btnPickMustUseNode" style="padding:6px 10px; font-size:11px; background:#f0fdf4; border-color:#86efac;" title="Click on canvas to pick">âŠ•</button>
            </div>
            <div id="mustUseNodesList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:4px;">
              <!-- Must-use nodes will appear here as tags -->
            </div>
          </div>

          <!-- Must-Use Links -->
          <div class="row" style="margin-top:12px;">
            <label style="font-weight:600; color:#16a34a; font-size:11px;">Must-Use Links</label>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <select id="routeMustUseLinkSelect" style="flex:1; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd;">
                <option value="">-- Select link (must use) --</option>
              </select>
              <button class="btn" id="btnAddMustUseLink" style="padding:6px 10px; font-size:11px; background:#f0fdf4; border-color:#86efac;" title="Add must-use link">+</button>
              <button class="btn" id="btnPickMustUseLink" style="padding:6px 10px; font-size:11px; background:#f0fdf4; border-color:#86efac;" title="Click on canvas to pick">âŠ•</button>
            </div>
            <div id="mustUseLinksList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:4px;">
              <!-- Must-use links will appear here as tags -->
            </div>
          </div>

          <!-- Clear All Must-Use -->
          <div class="row" style="margin-top:12px;">
            <button class="btn" id="btnClearAllMustUse" style="width:100%; font-size:11px; padding:6px; background:#f0fdf4; border-color:#86efac; color:#166534;">
              ðŸ—‘ï¸ Clear All Must-Use Constraints
            </button>
          </div>
        </div>
      </div>

      <!-- Physical Routing Diversity Section -->
      <div class="inspector-section collapsed" data-section="route-physical-diversity">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ”€ Physical Routing Diversity</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="hint" style="margin-bottom:10px; padding:8px; background:#f0fdf4; border:1px solid #86efac; border-radius:6px; color:#166534;">
            Enforce physical path diversity when calculating routes. Links with diversity below the threshold relative to specified links will be excluded.
          </div>

          <!-- Enable/Disable Physical Diversity -->
          <div class="row" style="margin-bottom:12px;">
            <div style="display:flex; align-items:center; gap:8px;">
              <input type="checkbox" id="chkLinearPhysicalDiversity" style="width:16px; height:16px; cursor:pointer;" />
              <label for="chkLinearPhysicalDiversity" style="font-weight:600; color:#166534; font-size:11px; cursor:pointer;">
                Enable Physical Diversity Check
              </label>
            </div>
            <div style="font-size:10px; color:#6b7280; margin-top:4px; margin-left:24px;">
              When enabled, routes will avoid links that share physical infrastructure with specified "diverse from" links.
            </div>
          </div>

          <!-- Required Diversity Percentage -->
          <div class="row" style="margin-bottom:12px; padding:10px; background:#ecfdf5; border-radius:6px;">
            <div style="display:flex; align-items:center; gap:8px;">
              <span style="font-size:11px; color:#166534; font-weight:600;">Required Diversity:</span>
              <input type="number" id="inputLinearRequiredDiversity" min="0" max="100" value="100"
                     style="width:60px; padding:4px 6px; font-size:11px; text-align:center; border:1px solid #86efac; border-radius:4px;" />
              <span style="font-size:11px; color:#166534;">%</span>
            </div>
            <div style="font-size:10px; color:#15803d; margin-top:6px;">
              Links with diversity below this threshold will be excluded from route calculation.
            </div>
          </div>

          <!-- Diverse From Links -->
          <div class="row">
            <label style="font-weight:600; color:#166534; font-size:11px;">Must Be Diverse From Links</label>
            <div style="font-size:10px; color:#6b7280; margin-bottom:6px;">
              Route will avoid links that have low physical diversity with these links.
            </div>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <select id="routeDiverseFromLinkSelect" style="flex:1; padding:6px; font-size:11px; border-radius:4px; border:1px solid #86efac;">
                <option value="">-- Select link --</option>
              </select>
              <button class="btn" id="btnAddDiverseFromLink" style="padding:6px 10px; font-size:11px; background:#f0fdf4; border-color:#86efac;" title="Add link">+</button>
              <button class="btn" id="btnPickDiverseFromLink" style="padding:6px 10px; font-size:11px; background:#f0fdf4; border-color:#86efac;" title="Click on canvas to pick">âŠ•</button>
            </div>
            <div id="diverseFromLinksList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:4px;">
              <!-- Diverse-from links will appear here as tags -->
            </div>
          </div>

          <!-- Clear All Diversity Constraints -->
          <div class="row" style="margin-top:12px;">
            <button class="btn" id="btnClearDiversityConstraints" style="width:100%; font-size:11px; padding:6px; background:#f0fdf4; border-color:#86efac; color:#166534;">
              ðŸ—‘ï¸ Clear Diversity Constraints
            </button>
          </div>
        </div>
      </div>

      <!-- Tag Filters Section -->
      <div class="inspector-section collapsed" data-section="route-tag-filters">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ·ï¸ Tag Filters</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="hint" style="margin-bottom:10px; padding:6px; background:#fefce8; border-radius:4px; color:#854d0e;">
            Filter path calculation by node or link tags. Independent of global filters.
          </div>

          <!-- Node Tag Filter -->
          <div class="row">
            <label style="font-weight:600; color:#6366f1; font-size:11px;">Node Tags</label>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <select id="routeNodeTagMode" style="width:80px; padding:4px; font-size:10px; border-radius:4px; border:1px solid #ddd;">
                <option value="any">Any</option>
                <option value="include">Include</option>
                <option value="exclude">Exclude</option>
              </select>
              <span style="font-size:10px; color:#888; align-self:center; flex:1; text-align:right;" id="routeNodeTagModeHint">All nodes allowed</span>
            </div>
            <div id="routeNodeTagList" style="margin-top:6px; max-height:100px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:4px; padding:4px; display:none;">
              <!-- Node tags will be listed here -->
            </div>
            <div id="routeNodeTagSelected" style="margin-top:6px; display:flex; flex-wrap:wrap; gap:3px;">
              <!-- Selected node tags shown as chips -->
            </div>
          </div>

          <!-- Link Tag Filter -->
          <div class="row" style="margin-top:12px;">
            <label style="font-weight:600; color:#6366f1; font-size:11px;">Link Tags</label>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <select id="routeLinkTagMode" style="width:80px; padding:4px; font-size:10px; border-radius:4px; border:1px solid #ddd;">
                <option value="any">Any</option>
                <option value="include">Include</option>
                <option value="exclude">Exclude</option>
              </select>
              <span style="font-size:10px; color:#888; align-self:center; flex:1; text-align:right;" id="routeLinkTagModeHint">All links allowed</span>
            </div>
            <div id="routeLinkTagList" style="margin-top:6px; max-height:100px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:4px; padding:4px; display:none;">
              <!-- Link tags will be listed here -->
            </div>
            <div id="routeLinkTagSelected" style="margin-top:6px; display:flex; flex-wrap:wrap; gap:3px;">
              <!-- Selected link tags shown as chips -->
            </div>
          </div>

          <!-- Clear Tag Filters -->
          <div class="row" style="margin-top:12px;">
            <button class="btn" id="btnClearRouteTagFilters" style="width:100%; font-size:11px; padding:6px; background:#fefce8; border-color:#fde047; color:#854d0e;">
              ðŸ—‘ï¸ Clear Tag Filters
            </button>
          </div>
        </div>
      </div>

      <!-- Multilink Groups Preference Section (Phase 1) -->
      <div class="inspector-section collapsed" data-section="route-mlg-preference">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ”— Multilink Groups</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="hint" style="margin-bottom:10px; padding:6px; background:#fdf4ff; border-radius:4px; color:#86198f;">
            Use pre-defined Multilink Groups as preferred routing paths. MLGs are atomic super-edges.
          </div>

          <!-- Prefer MLGs Toggle -->
          <div class="row">
            <label style="display:flex; align-items:center; gap:8px; cursor:pointer; padding:6px; background:#faf5ff; border:1px solid #e9d5ff; border-radius:6px;">
              <input type="checkbox" id="routePreferMLGs" style="width:18px; height:18px; accent-color:#a855f7;" />
              <div>
                <span style="font-weight:600; font-size:12px; color:#7c3aed;">Prefer Multilink Groups</span>
                <div style="font-size:10px; color:#9333ea; margin-top:2px;">Route through MLGs when available</div>
              </div>
            </label>
          </div>

          <!-- MLG Topology Type Filter -->
          <div class="row" id="mlgTopologyFilterRow" style="margin-top:12px; display:none;">
            <label style="font-weight:600; color:#7c3aed; font-size:11px; margin-bottom:6px; display:block;">Include Topology Types</label>
            <div style="display:flex; flex-wrap:wrap; gap:6px;">
              <label style="display:flex; align-items:center; gap:4px; cursor:pointer; padding:4px 8px; background:#f5f3ff; border:1px solid #ddd6fe; border-radius:4px; font-size:11px;">
                <input type="checkbox" id="mlgFilterLinear" checked style="accent-color:#a855f7;" />
                <span>âž¡ï¸ Linear</span>
              </label>
              <label style="display:flex; align-items:center; gap:4px; cursor:pointer; padding:4px 8px; background:#f5f3ff; border:1px solid #ddd6fe; border-radius:4px; font-size:11px;">
                <input type="checkbox" id="mlgFilterRing" checked style="accent-color:#a855f7;" />
                <span>ðŸ¡ï¸ Ring</span>
              </label>
              <label style="display:flex; align-items:center; gap:4px; cursor:pointer; padding:4px 8px; background:#f5f3ff; border:1px solid #ddd6fe; border-radius:4px; font-size:11px;">
                <input type="checkbox" id="mlgFilterRingLinear" checked style="accent-color:#a855f7;" />
                <span>ðŸ”€ Ring+Linear</span>
              </label>
            </div>
          </div>

          <!-- Must-Use MLGs -->
          <div class="row" id="mlgMustUseRow" style="margin-top:12px; display:none;">
            <label style="font-weight:600; color:#16a34a; font-size:11px;">Must-Use MLGs</label>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <select id="routeMustUseMLGSelect" style="flex:1; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd;">
                <option value="">-- Select MLG (must use) --</option>
              </select>
              <button class="btn" id="btnAddMustUseMLG" style="padding:6px 10px; font-size:11px; background:#f0fdf4; border-color:#86efac;" title="Add must-use MLG">+</button>
            </div>
            <div id="mustUseMLGsList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:4px;">
              <!-- Must-use MLGs will appear here as tags -->
            </div>
          </div>

          <!-- Excluded MLGs -->
          <div class="row" id="mlgExcludeRow" style="margin-top:12px; display:none;">
            <label style="font-weight:600; color:#dc2626; font-size:11px;">Excluded MLGs</label>
            <div style="display:flex; gap:4px; margin-top:4px;">
              <select id="routeExcludeMLGSelect" style="flex:1; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd;">
                <option value="">-- Select MLG to exclude --</option>
              </select>
              <button class="btn" id="btnAddExcludeMLG" style="padding:6px 10px; font-size:11px; background:#fef2f2; border-color:#fecaca;" title="Add excluded MLG">+</button>
            </div>
            <div id="excludedMLGsList" style="margin-top:8px; display:flex; flex-wrap:wrap; gap:4px;">
              <!-- Excluded MLGs will appear here as tags -->
            </div>
          </div>

          <!-- MLG Capacity Filter (collapsed subsection) -->
          <div id="mlgCapacitySection" style="margin-top:12px; display:none;">
            <div style="border:1px solid #e9d5ff; border-radius:6px; overflow:hidden;">
              <div style="padding:8px 10px; background:#faf5ff; cursor:pointer; display:flex; justify-content:space-between; align-items:center;" onclick="document.getElementById('mlgCapacityContent').style.display = document.getElementById('mlgCapacityContent').style.display === 'none' ? 'block' : 'none'; this.querySelector('.mlg-cap-icon').textContent = document.getElementById('mlgCapacityContent').style.display === 'none' ? 'â–¶' : 'â–¼';">
                <span style="font-size:11px; font-weight:600; color:#7c3aed;">ðŸ“Š MLG Capacity Filter</span>
                <span class="mlg-cap-icon" style="font-size:10px; color:#a855f7;">â–¶</span>
              </div>
              <div id="mlgCapacityContent" style="display:none; padding:10px; background:#fefbff;">
                <!-- MLG Capacity Mode -->
                <div class="row">
                  <label style="display:flex; align-items:center; gap:6px; cursor:pointer; padding:4px 0;">
                    <input type="radio" name="routeMLGCapacityMode" value="none" checked style="accent-color:#a855f7;" />
                    <span style="font-size:11px;">No capacity filter</span>
                  </label>
                  <label style="display:flex; align-items:center; gap:6px; cursor:pointer; padding:4px 0;">
                    <input type="radio" name="routeMLGCapacityMode" value="total" style="accent-color:#a855f7;" />
                    <span style="font-size:11px;">Minimum Total Capacity</span>
                  </label>
                  <label style="display:flex; align-items:center; gap:6px; cursor:pointer; padding:4px 0;">
                    <input type="radio" name="routeMLGCapacityMode" value="units" style="accent-color:#a855f7;" />
                    <span style="font-size:11px;">Minimum by Speed Tier</span>
                  </label>
                </div>

                <!-- MLG Total Capacity (shown when mode=total) -->
                <div id="mlgCapacityTotalSection" style="display:none; margin-top:8px; padding:8px; background:#f5f3ff; border-radius:4px;">
                  <div style="display:flex; align-items:center; gap:6px;">
                    <input id="routeMLGCapacityMinTotal" type="number" min="0" step="0.1" value="0" style="flex:1; text-align:right; padding:4px 6px; font-size:11px;" />
                    <span style="font-size:11px; font-weight:600; color:#7c3aed;">Gbps</span>
                  </div>
                </div>

                <!-- MLG Units Capacity (shown when mode=units) -->
                <div id="mlgCapacityUnitsSection" style="display:none; margin-top:8px; padding:8px; background:#f5f3ff; border-radius:4px;">
                  <div style="display:grid; grid-template-columns:1fr 50px; gap:3px; align-items:center; font-size:10px;">
                    <span>1G units</span>
                    <input id="routeMLGCapacityMin1G" type="number" min="0" value="0" style="text-align:right; padding:2px 4px; font-size:10px;" />
                    <span>10G units</span>
                    <input id="routeMLGCapacityMin10G" type="number" min="0" value="0" style="text-align:right; padding:2px 4px; font-size:10px;" />
                    <span>100G units</span>
                    <input id="routeMLGCapacityMin100G" type="number" min="0" value="0" style="text-align:right; padding:2px 4px; font-size:10px;" />
                    <span>400G units</span>
                    <input id="routeMLGCapacityMin400G" type="number" min="0" value="0" style="text-align:right; padding:2px 4px; font-size:10px;" />
                    <span>Tbps units</span>
                    <input id="routeMLGCapacityMinTbps" type="number" min="0" value="0" style="text-align:right; padding:2px 4px; font-size:10px;" />
                  </div>
                </div>

                <!-- Include undefined MLG capacity -->
                <div style="margin-top:8px;">
                  <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:10px;">
                    <input type="checkbox" id="routeMLGCapacityIncludeUndefined" checked style="accent-color:#a855f7;" />
                    <span>Include MLGs with undefined capacity</span>
                  </label>
                </div>
              </div>
            </div>
          </div>

          <!-- Clear MLG Settings -->
          <div class="row" id="mlgClearRow" style="margin-top:12px; display:none;">
            <button class="btn" id="btnClearMLGSettings" style="width:100%; font-size:11px; padding:6px; background:#fdf4ff; border-color:#e9d5ff; color:#86198f;">
              ðŸ—‘ï¸ Clear MLG Settings
            </button>
          </div>

          <!-- Available MLGs Summary -->
          <div id="mlgAvailableSummary" style="margin-top:10px; padding:8px; background:#f9fafb; border-radius:4px; font-size:10px; color:#6b7280;">
            <span id="mlgCountDisplay">0 Multilink Groups available</span>
          </div>
        </div>
      </div>

      <!-- Capacity Requirements Section -->
      <div class="inspector-section collapsed" data-section="route-capacity-filter">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ“Š Capacity Requirements</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="hint" style="margin-bottom:10px; padding:6px; background:#eff6ff; border-radius:4px; color:#1e40af;">
            Filter paths by available capacity on links.
          </div>

          <!-- Filter Mode Selection -->
          <div class="row">
            <label style="display:flex; align-items:center; gap:6px; cursor:pointer; padding:4px 0;">
              <input type="radio" name="routeCapacityMode" value="none" checked style="accent-color:#3b82f6;" />
              <span style="font-size:11px;">No capacity filter (use all links)</span>
            </label>
            <label style="display:flex; align-items:center; gap:6px; cursor:pointer; padding:4px 0;">
              <input type="radio" name="routeCapacityMode" value="total" style="accent-color:#3b82f6;" />
              <span style="font-size:11px;">Minimum Total Available Capacity</span>
            </label>
            <label style="display:flex; align-items:center; gap:6px; cursor:pointer; padding:4px 0;">
              <input type="radio" name="routeCapacityMode" value="units" style="accent-color:#3b82f6;" />
              <span style="font-size:11px;">Minimum Units by Speed Tier</span>
            </label>
          </div>

          <!-- Total Capacity Filter (shown when mode=total) -->
          <div id="routeCapacityTotalSection" style="display:none; margin-top:10px; padding:10px; background:#f8fafc; border-radius:6px; border:1px solid #e2e8f0;">
            <label style="font-size:11px; font-weight:600; color:#1e40af;">Required Total Capacity</label>
            <div style="display:flex; align-items:center; gap:6px; margin-top:4px;">
              <input id="routeCapacityMinTotal" type="number" min="0" step="0.1" value="0" style="flex:1; text-align:right; padding:6px 8px;" />
              <span style="font-size:11px; font-weight:600; color:#1e40af;">Gbps</span>
            </div>
          </div>

          <!-- Units Filter (shown when mode=units) -->
          <div id="routeCapacityUnitsSection" style="display:none; margin-top:10px; padding:10px; background:#f8fafc; border-radius:6px; border:1px solid #e2e8f0;">
            <label style="font-size:11px; font-weight:600; color:#1e40af; margin-bottom:6px; display:block;">Required Units (minimum)</label>
            <div style="display:grid; grid-template-columns:1fr 60px; gap:4px; align-items:center;">
              <span style="font-size:10px;">1 Gbps units</span>
              <input id="routeCapacityMin1G" type="number" min="0" step="0.1" value="0" style="text-align:right; padding:3px 6px; font-size:11px;" />
            </div>
            <div style="display:grid; grid-template-columns:1fr 60px; gap:4px; align-items:center; margin-top:3px;">
              <span style="font-size:10px;">10 Gbps units</span>
              <input id="routeCapacityMin10G" type="number" min="0" step="0.1" value="0" style="text-align:right; padding:3px 6px; font-size:11px;" />
            </div>
            <div style="display:grid; grid-template-columns:1fr 60px; gap:4px; align-items:center; margin-top:3px;">
              <span style="font-size:10px;">100 Gbps units</span>
              <input id="routeCapacityMin100G" type="number" min="0" step="0.1" value="0" style="text-align:right; padding:3px 6px; font-size:11px;" />
            </div>
            <div style="display:grid; grid-template-columns:1fr 60px; gap:4px; align-items:center; margin-top:3px;">
              <span style="font-size:10px;">400 Gbps units</span>
              <input id="routeCapacityMin400G" type="number" min="0" step="0.1" value="0" style="text-align:right; padding:3px 6px; font-size:11px;" />
            </div>
            <div style="display:grid; grid-template-columns:1fr 60px; gap:4px; align-items:center; margin-top:3px;">
              <span style="font-size:10px;">Tbps units</span>
              <input id="routeCapacityMinTbps" type="number" min="0" step="0.1" value="0" style="text-align:right; padding:3px 6px; font-size:11px;" />
            </div>
          </div>

          <!-- Include undefined capacity option -->
          <div class="row" style="margin-top:10px; padding-top:10px; border-top:1px solid #e5e7eb;">
            <label style="display:flex; align-items:flex-start; gap:6px; cursor:pointer;">
              <input type="checkbox" id="routeCapacityIncludeUndefined" checked style="accent-color:#3b82f6; margin-top:2px;" />
              <div>
                <span style="font-size:11px; font-weight:500;">Include links with undefined capacity</span>
                <div style="font-size:10px; color:#888; margin-top:2px;">Links where all capacity fields are zero will be included in path calculation</div>
              </div>
            </label>
          </div>

          <!-- Clear Capacity Filter -->
          <div class="row" style="margin-top:10px;">
            <button class="btn" id="btnClearRouteCapacityFilter" style="width:100%; font-size:11px; padding:6px; background:#eff6ff; border-color:#93c5fd; color:#1e40af;">
              ðŸ—‘ï¸ Clear Capacity Filter
            </button>
          </div>
        </div>
      </div>

      <!-- Routes Results Section -->
      <div class="inspector-section" data-section="route-results" id="routeResultsSection" style="display:none;">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Routes Found</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content" id="routeResultsContent">
          <!-- Route options will be dynamically inserted here -->
        </div>
      </div>

      <!-- Route Details Section -->
      <div class="inspector-section collapsed" data-section="route-details" id="routeDetailsSection" style="display:none;">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Route Details</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content" id="routeDetailsContent">
          <!-- Selected route details will be shown here -->
        </div>
        <!-- Save as MLG Button (Phase 1) -->
        <div id="saveAsMLGContainer" style="display:none; padding:10px 12px; border-top:1px solid #e5e7eb;">
          <!-- Save Mode Selection -->
          <div style="margin-bottom:10px;">
            <label style="font-size:11px; font-weight:600; color:#6b7280; text-transform:uppercase; display:block; margin-bottom:6px;">Save Route To</label>
            <div style="display:flex; gap:6px;">
              <label style="flex:1; display:flex; align-items:center; gap:4px; padding:8px; border:2px solid #a855f7; border-radius:6px; cursor:pointer; font-size:11px; font-weight:500; background:#faf5ff; color:#7c3aed;" id="mlgSaveModeNewLabel">
                <input type="radio" name="mlgSaveMode" id="mlgSaveModeNew" value="new" checked style="margin:0; accent-color:#a855f7;" />
                <span>âž• New MLG</span>
              </label>
              <label style="flex:1; display:flex; align-items:center; gap:4px; padding:8px; border:2px solid #e5e7eb; border-radius:6px; cursor:pointer; font-size:11px; font-weight:500; background:white;" id="mlgSaveModeExistingLabel">
                <input type="radio" name="mlgSaveMode" id="mlgSaveModeExisting" value="existing" style="margin:0; accent-color:#a855f7;" />
                <span>ðŸ“Ž Existing MLG</span>
              </label>
            </div>
          </div>

          <!-- Existing MLG Selection (hidden by default) -->
          <div id="existingMLGSelection" style="display:none; margin-bottom:10px;">
            <label style="font-size:11px; font-weight:600; color:#7c3aed; display:block; margin-bottom:4px;">Select Compatible MLG</label>
            <select id="compatibleMLGSelect" style="width:100%; padding:8px; border:2px solid #e9d5ff; border-radius:6px; font-size:12px; background:#fefbff;">
              <option value="">-- Select an MLG with same endpoints --</option>
            </select>
            <div id="compatibleMLGInfo" style="font-size:10px; color:#6b7280; margin-top:4px;"></div>
          </div>

          <!-- Save as New MLG Button -->
          <button class="btn primary" id="btnSaveRouteAsMLG" style="width:100%; padding:10px; font-size:12px; background:linear-gradient(135deg, #a855f7 0%, #7c3aed 100%); border-color:#7c3aed;">
            ðŸ’¾ Save Route as Multilink Group
          </button>

          <!-- Add to Existing MLG Button (hidden by default) -->
          <button class="btn primary" id="btnAddRouteToMLG" style="display:none; width:100%; padding:10px; font-size:12px; background:linear-gradient(135deg, #10b981 0%, #059669 100%); border-color:#059669;">
            âž• Add Path to Selected MLG
          </button>

          <div id="mlgSaveHint" style="font-size:10px; color:#6b7280; margin-top:6px; text-align:center;">
            Creates a new MLG from the currently selected route
          </div>
        </div>
      </div>

      <!-- Protection Path Section (Ring Protection) -->
      <div class="inspector-section" data-section="route-protection" id="routeProtectionSection" style="display:none;">
        <div class="inspector-section-header" style="background:linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ¡ï¸ Protection Path</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="hint" style="margin-bottom:10px; padding:8px; background:#fffbeb; border:1px solid #fcd34d; border-radius:6px; color:#92400e;">
            Create a diverse protection path that avoids the primary route's links. Select ring closure nodes below.
          </div>

          <!-- Protection Mode Toggle -->
          <div class="row" style="margin-bottom:12px;">
            <button class="btn" id="btnProtectionModeToggle" onclick="routeFinderState.protectionMode ? exitProtectionMode() : enterProtectionMode()"
                    style="width:100%; padding:10px; font-size:12px; background:linear-gradient(135deg, #f59e0b 0%, #d97706 100%); border:none; color:white; font-weight:600; border-radius:6px; cursor:pointer;">
              Enter Protection Mode
            </button>
            <div style="font-size:10px; color:#6b7280; margin-top:6px; text-align:center;">
              When active, all restriction tools (exclusions, must-use, tags, capacity) configure the protection path. Primary path remains locked.
            </div>
          </div>

          <!-- Protection Mode Active Banner -->
          <div id="protectionModeBanner" style="display:none; margin-bottom:12px; padding:10px; background:linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border:2px solid #f59e0b; border-radius:8px; text-align:center;">
            <div style="font-weight:700; color:#92400e; font-size:12px; margin-bottom:4px;">PROTECTION MODE ACTIVE</div>
            <div style="font-size:10px; color:#a16207;">All restriction sections now configure the protection path. Primary path is locked.</div>
          </div>

          <!-- Physical Routing Diversity Settings -->
          <div class="row" style="margin-bottom:12px; padding:10px; background:#f0fdf4; border:1px solid #86efac; border-radius:6px;">
            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
              <input type="checkbox" id="chkPhysicalDiversity" checked style="width:16px; height:16px; cursor:pointer;" />
              <label for="chkPhysicalDiversity" style="font-weight:600; color:#166534; font-size:11px; cursor:pointer;">
                ðŸ”€ Physical Routing Diversity
              </label>
            </div>
            <div style="display:flex; align-items:center; gap:8px; margin-left:24px;">
              <span style="font-size:11px; color:#166534;">Required Diversity:</span>
              <input type="number" id="inputRequiredDiversity" min="0" max="100" value="100"
                     style="width:60px; padding:4px 6px; font-size:11px; text-align:center; border:1px solid #86efac; border-radius:4px;" />
              <span style="font-size:11px; color:#166534;">%</span>
            </div>
            <div style="font-size:10px; color:#15803d; margin-top:6px; margin-left:24px;">
              Protection path will exclude links with diversity below this threshold relative to primary path links.
            </div>
          </div>

          <!-- Ring Closure Nodes Selection -->
          <div class="row">
            <label style="font-weight:600; color:#d97706; font-size:11px; margin-bottom:8px; display:block;">Ring Closure Nodes</label>
            <div style="font-size:10px; color:#6b7280; margin-bottom:8px;">
              Origin and destination are pre-selected. Select intermediate nodes that the protection path must pass through.
            </div>
            <div id="protectionClosureNodesList" style="max-height:200px; overflow-y:auto; border:1px solid #fcd34d; border-radius:6px; padding:8px; background:#fffef7;">
              <!-- Closure nodes will be rendered here as checkboxes -->
            </div>
          </div>

          <!-- Calculate Protection Button -->
          <div class="row" style="margin-top:12px;">
            <button class="btn" id="btnCalculateProtection" style="width:100%; padding:10px; font-size:12px; background:linear-gradient(135deg, #f59e0b 0%, #d97706 100%); border:none; color:white; font-weight:600;">
              ðŸ” Calculate Protection Path
            </button>
          </div>

          <!-- Protection Path Result -->
          <div id="protectionPathResult" style="display:none; margin-top:12px;">
            <div style="padding:10px; background:#fef3c7; border:2px solid #f59e0b; border-radius:8px;">
              <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                <span style="font-weight:600; color:#92400e; font-size:12px;">ðŸ¡ï¸ Protection Path</span>
                <div style="display:flex; gap:8px; font-size:11px; color:#92400e;">
                  <span id="protectionLatency">-</span>
                  <span id="protectionHops">-</span>
                </div>
              </div>
              <div id="protectionPathNodes" style="font-size:11px; color:#78350f; word-break:break-word;"></div>
            </div>
          </div>

          <!-- Protection Path Error -->
          <div id="protectionPathError" style="display:none; margin-top:12px;">
            <div style="padding:10px; background:#fef2f2; border:2px solid #fca5a5; border-radius:8px;">
              <div style="font-weight:600; color:#991b1b; font-size:12px; margin-bottom:4px;">âŒ Protection Not Viable</div>
              <div id="protectionErrorText" style="font-size:11px; color:#991b1b;"></div>
            </div>
          </div>

          <!-- Save as Protected MLG -->
          <div id="saveProtectedMLGContainer" style="display:none; margin-top:12px; padding-top:12px; border-top:1px solid #fcd34d;">
            <button class="btn" id="btnSaveProtectedMLG" style="width:100%; padding:10px; font-size:12px; background:linear-gradient(135deg, #10b981 0%, #059669 100%); border:none; color:white; font-weight:600;">
              ðŸ’¾ Save as Protected MLG (Ring)
            </button>
            <div style="font-size:10px; color:#6b7280; margin-top:6px; text-align:center;">
              Creates an MLG with primary + protection paths between closure nodes
            </div>
          </div>
        </div>
      </div>

      <!-- Settings Section -->
      <div class="inspector-section collapsed" data-section="route-settings">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>Settings</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="row">
            <label class="toggle-item" style="display:flex; align-items:center; gap:8px; cursor:pointer;">
              <input type="checkbox" id="routeEnableContainerTransit" checked style="accent-color:#0096D6;" />
              <span style="font-weight:600;">Enable Container Transit</span>
            </label>
            <div class="hint">When enabled, nodes within the same container can connect implicitly. Disable to only use explicit links.</div>
          </div>
          <div class="row">
            <label class="toggle-item" style="display:flex; align-items:center; gap:8px; cursor:pointer;">
              <input type="checkbox" id="routeEnableRegionTransit" checked style="accent-color:#0096D6;" />
              <span style="font-weight:600;">Enable Region Transit</span>
            </label>
            <div class="hint">When enabled, nodes in sibling containers (same region) can connect implicitly.</div>
          </div>
          <div class="row" id="containerLatencyRow">
            <label>Default Container Latency (ms)</label>
            <input id="routeContainerLatency" type="number" value="1" min="0.000001" step="0.1" style="width:100%;" />
            <div class="hint">Default for containers without custom values. Per-container settings in Inspector â†’ Routing prevail.</div>
          </div>
          <div class="row" id="regionLatencyRow">
            <label>Default Region Latency (ms)</label>
            <input id="routeRegionLatency" type="number" value="10" min="0.000001" step="1" style="width:100%;" />
            <div class="hint">Default for regions without custom values. Per-region settings in Inspector â†’ Routing prevail.</div>
          </div>
          <div style="margin-top:8px; padding:8px; background:#f0f9ff; border:1px solid #bae6fd; border-radius:6px;">
            <div style="font-size:10px; color:#0369a1;">ðŸ’¡ <strong>Note:</strong> When cost optimization is enabled (balance > 0%), container transit also considers commercial cost. Configure per-container costs in Inspector â†’ Commercial Cost section.</div>
          </div>
        </div>
      </div>

      <!-- Exit Button -->
      <div style="padding:12px; border-top:1px solid #e0e0e0;">
        <button class="btn" id="btnExitRouteFinder" style="width:100%; background:#f3f4f6; border-color:#d1d5db;">
          â† Exit Route Finder (Return to Edit Mode)
        </button>
      </div>
    </div>
  </aside>

  <!-- Label Manager Panel -->
  <aside id="labelManagerPanel">
    <div id="labelManagerHeader">
      <h3>ðŸ·ï¸ Label Manager</h3>
      <div id="labelManagerControls">
        <button id="btnCloseLabelManager" title="Close Label Manager">âœ•</button>
      </div>
    </div>
    <div id="labelManagerContent">
      <!-- Selection Status -->
      <div id="lmSelectionStatus" class="lm-selection-status">
        <span style="font-size:14px;">ðŸ“Œ</span>
        <div style="flex:1;">
          <div style="font-weight:600; font-size:12px; color:#5b21b6;">Selection</div>
          <div id="lmSelectionSummary" style="font-size:11px; color:#7c3aed;">Nothing selected</div>
        </div>
      </div>

      <!-- Project Tags Section -->
      <div class="inspector-section" data-section="lm-project-tags">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>ðŸ“‹ Project Tags</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div style="margin-bottom:8px;">
            <input type="text" id="lmTagSearch" placeholder="Search tags..." style="width:100%; padding:6px 10px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
          </div>
          <div style="display:flex; gap:4px; margin-bottom:8px;">
            <button class="btn" id="lmFilterAll" style="flex:1; font-size:10px; padding:4px 6px;" title="Show all tags">All</button>
            <button class="btn" id="lmFilterNodes" style="flex:1; font-size:10px; padding:4px 6px;" title="Show tags used on nodes">ðŸ”µ Nodes</button>
            <button class="btn" id="lmFilterLinks" style="flex:1; font-size:10px; padding:4px 6px;" title="Show tags used on links">ðŸ”¶ Links</button>
            <button class="btn" id="lmFilterContainers" style="flex:1; font-size:10px; padding:4px 6px;" title="Show tags used on containers">ðŸŸ© Boxes</button>
          </div>
          <div id="lmProjectTagsList" style="max-height:200px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:4px;">
            <!-- Tags will be rendered here -->
          </div>
          <div style="display:flex; gap:6px; margin-top:8px;">
            <button class="btn" id="lmSelectAllWithTag" style="flex:1; font-size:11px; padding:6px;" disabled>
              ðŸŽ¯ Select All with Checked Tags
            </button>
          </div>
          <div style="display:flex; gap:6px; margin-top:6px;">
            <button class="btn" id="lmNewTag" style="flex:1; font-size:11px; padding:6px;">
              + New Tag
            </button>
            <button class="btn" id="lmDeleteUnused" style="flex:1; font-size:11px; padding:6px;" title="Remove tags not used anywhere">
              ðŸ—‘ï¸ Delete Unused
            </button>
          </div>
        </div>
      </div>

      <!-- Selection Tags Section -->
      <div class="inspector-section" data-section="lm-selection-tags">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>âœï¸ Selection Tags</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div id="lmNoSelection" style="padding:12px; text-align:center; color:#9ca3af; font-size:12px;">
            <div style="font-size:24px; margin-bottom:6px;">ðŸ‘†</div>
            Select nodes, links, or containers<br>to manage their tags
          </div>
          <div id="lmSelectionTags" style="display:none;">
            <div style="font-size:11px; color:#6b7280; margin-bottom:8px;">
              Check/uncheck to add/remove tags from selection:
            </div>
            <div id="lmSelectionTagsList" style="max-height:180px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:4px;">
              <!-- Selection tags with checkboxes -->
            </div>
            <div style="display:flex; gap:6px; margin-top:8px;">
              <button class="btn" id="lmApplyChecked" style="flex:1; font-size:11px; padding:6px; background:#f0fdf4; border-color:#86efac; color:#166534;">
                âœ“ Apply Checked
              </button>
              <button class="btn" id="lmRemoveUnchecked" style="flex:1; font-size:11px; padding:6px; background:#fef2f2; border-color:#fecaca; color:#991b1b;">
                âœ— Remove Unchecked
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Bulk Apply Section -->
      <div class="inspector-section" data-section="lm-bulk-apply">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>â›¡ Bulk Apply</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="hint" style="margin-bottom:10px; padding:6px; background:#f3e8ff; border-radius:4px; color:#6d28d9; font-size:11px;">
            Apply or remove multiple tags at once
          </div>

          <!-- Tags to apply/remove -->
          <div class="row">
            <label style="font-weight:600; font-size:11px;">Tags to Apply/Remove</label>
            <div id="lmBulkTagsSelected" style="min-height:30px; padding:6px; background:#f9fafb; border:1px solid #e5e7eb; border-radius:4px; margin-top:4px; display:flex; flex-wrap:wrap; gap:4px;">
              <span style="color:#9ca3af; font-size:11px;">Click tags below to add</span>
            </div>
          </div>

          <!-- Available tags multiselect -->
          <div class="row" style="margin-top:8px;">
            <label style="font-weight:600; font-size:11px;">Available Tags (click to add)</label>
            <div id="lmBulkAvailableTags" style="max-height:100px; overflow-y:auto; padding:6px; background:#f9fafb; border:1px solid #e5e7eb; border-radius:4px; margin-top:4px; display:flex; flex-wrap:wrap; gap:4px;">
              <!-- Available tags -->
            </div>
            <div style="display:flex; gap:4px; margin-top:6px;">
              <input type="text" id="lmBulkNewTag" placeholder="Or type new tag..." style="flex:1; padding:6px; font-size:11px; border:1px solid #d0d0d0; border-radius:4px;" />
              <button class="btn" id="lmBulkAddNewTag" style="padding:6px 10px; font-size:11px;">+</button>
            </div>
          </div>

          <!-- Action mode -->
          <div class="row" style="margin-top:10px;">
            <label style="font-weight:600; font-size:11px;">Action</label>
            <div style="display:flex; flex-direction:column; gap:4px; margin-top:4px;">
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:12px;">
                <input type="radio" name="lmBulkAction" value="add" checked style="accent-color:#8b5cf6;" />
                <span style="color:#166534;">âž• Add tags to targets</span>
              </label>
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:12px;">
                <input type="radio" name="lmBulkAction" value="remove" style="accent-color:#8b5cf6;" />
                <span style="color:#991b1b;">âž– Remove tags from targets</span>
              </label>
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:12px;">
                <input type="radio" name="lmBulkAction" value="set" style="accent-color:#8b5cf6;" />
                <span style="color:#1d4ed8;">ðŸ”„ Set tags exactly (replace all)</span>
              </label>
            </div>
          </div>

          <!-- Target selection -->
          <div class="row" style="margin-top:10px;">
            <label style="font-weight:600; font-size:11px;">Target Elements</label>
            <div style="display:flex; flex-direction:column; gap:4px; margin-top:4px;">
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:12px;">
                <input type="radio" name="lmBulkTarget" value="selection" checked style="accent-color:#8b5cf6;" />
                <span>Current selection</span>
                <span id="lmBulkSelectionCount" class="lm-selection-badge" style="font-size:10px;">0 items</span>
              </label>
              <label style="display:flex; align-items:center; gap:6px; cursor:pointer; font-size:12px;">
                <input type="radio" name="lmBulkTarget" value="pick" style="accent-color:#8b5cf6;" />
                <span>Pick elements on canvas</span>
                <button class="btn" id="lmBulkPickMode" style="padding:2px 8px; font-size:10px; margin-left:auto;">ðŸŽ¯ Start Pick</button>
              </label>
            </div>
            <div id="lmBulkPickList" style="display:none; margin-top:8px; padding:6px; background:#fef3c7; border-radius:4px;">
              <div style="font-size:11px; font-weight:600; color:#92400e; margin-bottom:4px;">Picked elements:</div>
              <div id="lmBulkPickedItems" style="display:flex; flex-wrap:wrap; gap:4px;">
                <!-- Picked items will appear here -->
              </div>
              <button class="btn" id="lmBulkClearPicked" style="width:100%; margin-top:6px; font-size:10px; padding:4px;">Clear All</button>
            </div>
          </div>

          <!-- Apply button -->
          <div class="row" style="margin-top:12px;">
            <button class="btn primary" id="lmBulkApply" style="width:100%; padding:10px; font-size:12px; background:linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); border:none; color:white;">
              â›¡ Apply Changes
            </button>
          </div>
        </div>
      </div>

      <!-- Rename Tag Section -->
      <div class="inspector-section collapsed" data-section="lm-rename">
        <div class="inspector-section-header" onclick="this.parentElement.classList.toggle('collapsed')">
          <span>âœï¸ Rename Tag</span>
          <span class="section-icon">â–¼</span>
        </div>
        <div class="inspector-section-content">
          <div class="hint" style="margin-bottom:10px; padding:6px; background:#fef3c7; border-radius:4px; color:#92400e; font-size:11px;">
            Rename a tag across all nodes, links, and containers
          </div>
          <div class="row">
            <label style="font-weight:600; font-size:11px;">Current Tag Name</label>
            <select id="lmRenameFrom" style="width:100%; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd; margin-top:4px;">
              <option value="">-- Select tag to rename --</option>
            </select>
          </div>
          <div class="row" style="margin-top:8px;">
            <label style="font-weight:600; font-size:11px;">New Tag Name</label>
            <input type="text" id="lmRenameTo" placeholder="Enter new name..." style="width:100%; padding:6px; font-size:11px; border-radius:4px; border:1px solid #ddd; margin-top:4px;" />
          </div>
          <div class="row" style="margin-top:10px;">
            <button class="btn" id="lmRenameApply" style="width:100%; padding:8px; font-size:11px; background:#fef3c7; border-color:#fcd34d; color:#92400e;">
              âœï¸ Rename Tag Globally
            </button>
          </div>
        </div>
      </div>
    </div>
  </aside>
</div>

<script>
(() => {
  const svg = document.getElementById('svg');
  const toastEl = document.getElementById('toast');

  // UUID generation for unique identifiers
  function generateUUID() {
    // Use crypto.randomUUID if available (modern browsers), fallback to manual generation
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }
    // Fallback UUID v4 generation
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  // Color Palette System
  const colorPalette = {
    // Row 1: White, Light grays, Soft colors
    row1: ['#ffffff', '#f5f5f5', '#e8e8e8', '#dae8fc', '#d5e8d4', '#fff2cc', '#f8cecc', '#e1d5e7'],
    // Row 2: Pastel colors
    row2: ['#eeeeee', '#dae8fc', '#d5e8d4', '#fff2cc', '#f8cecc', '#e1d5e7', '#fce5cd', '#cce5ff'],
    // Row 3: Medium colors
    row3: ['#b3b3b3', '#6c8ebf', '#82b366', '#d6b656', '#b85450', '#9673a6', '#d79b00', '#36a2eb'],
    // Row 4: Darker/saturated colors
    row4: ['#666666', '#1a5276', '#196f3d', '#b7950b', '#922b21', '#6c3483', '#a04000', '#1f618d']
  };

  function createColorPicker(inputElement, onChange) {
    const wrapper = document.createElement('div');
    wrapper.className = 'color-picker-wrap';

    const swatch = document.createElement('div');
    swatch.className = 'color-swatch';

    const preview = document.createElement('div');
    preview.className = 'color-swatch-preview';
    preview.style.backgroundColor = inputElement.value || '#ffffff';

    const label = document.createElement('span');
    label.className = 'color-swatch-label';
    label.textContent = inputElement.value || '#ffffff';

    swatch.appendChild(preview);
    swatch.appendChild(label);

    const palette = document.createElement('div');
    palette.className = 'color-palette';

    // Add color rows
    [colorPalette.row1, colorPalette.row2, colorPalette.row3, colorPalette.row4].forEach(row => {
      const rowDiv = document.createElement('div');
      rowDiv.className = 'color-palette-row';
      row.forEach(color => {
        const item = document.createElement('div');
        item.className = 'color-palette-item';
        item.style.backgroundColor = color;
        item.dataset.color = color;
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          selectColor(color);
        });
        rowDiv.appendChild(item);
      });
      palette.appendChild(rowDiv);
    });

    // Custom color picker
    const customDiv = document.createElement('div');
    customDiv.className = 'color-palette-custom';
    const customInput = document.createElement('input');
    customInput.type = 'color';
    customInput.value = inputElement.value || '#ffffff';
    customInput.addEventListener('input', (e) => {
      selectColor(e.target.value);
    });
    const customLabel = document.createElement('span');
    customLabel.textContent = 'Custom color';
    customDiv.appendChild(customInput);
    customDiv.appendChild(customLabel);
    palette.appendChild(customDiv);

    wrapper.appendChild(swatch);
    wrapper.appendChild(palette);

    // Replace original input
    inputElement.style.display = 'none';
    inputElement.parentNode.insertBefore(wrapper, inputElement);

    function selectColor(color) {
      inputElement.value = color;
      preview.style.backgroundColor = color;
      label.textContent = color;
      customInput.value = color;
      palette.classList.remove('show');
      if (onChange) onChange(color);
      // Trigger change event on original input
      inputElement.dispatchEvent(new Event('input', { bubbles: true }));
    }

    function updateFromInput() {
      const color = inputElement.value || '#ffffff';
      preview.style.backgroundColor = color;
      label.textContent = color;
      customInput.value = color;
    }

    swatch.addEventListener('click', (e) => {
      e.stopPropagation();
      // Close other palettes
      document.querySelectorAll('.color-palette.show').forEach(p => {
        if (p !== palette) p.classList.remove('show');
      });
      palette.classList.toggle('show');
    });

    // Close palette when clicking outside
    document.addEventListener('click', () => {
      palette.classList.remove('show');
    });

    palette.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    return { update: updateFromInput };
  }

  // Global visibility toggles
  const tglShowLatency = document.getElementById('tglShowLatency');
  const tglShowNodeCode = document.getElementById('tglShowNodeCode');
  const tglShowLinkCode = document.getElementById('tglShowLinkCode');
  const tglShowNodeTags = document.getElementById('tglShowNodeTags');
  const tglShowExtraTags = document.getElementById('tglShowExtraTags');
  const tglShowNodeName = document.getElementById('tglShowNodeName');
  const tglShowLinkTag = document.getElementById('tglShowLinkTag');
  const tglShowContainerTitle = document.getElementById('tglShowContainerTitle');
  const canvasWidth = document.getElementById('canvasWidth');
  const canvasHeight = document.getElementById('canvasHeight');
  const tglCanvasBorder = document.getElementById('tglCanvasBorder');

  function syncGlobalToggles() {
    if (tglShowLatency) tglShowLatency.checked = !!state.ui.showLatency;
    if (tglShowNodeCode) tglShowNodeCode.checked = !!state.ui.showNodeCode;
    if (tglShowLinkCode) tglShowLinkCode.checked = !!state.ui.showLinkCode;
    if (tglShowNodeTags) tglShowNodeTags.checked = !!state.ui.showNodeTags;
    if (tglShowExtraTags) tglShowExtraTags.checked = !!state.ui.showExtraTags;
    if (tglShowNodeName) tglShowNodeName.checked = state.ui.showNodeName !== false;
    if (tglShowLinkTag) tglShowLinkTag.checked = state.ui.showLinkTag !== false;
    if (tglShowContainerTitle) tglShowContainerTitle.checked = state.ui.showContainerTitle !== false;
    if (canvasWidth) canvasWidth.value = state.canvasWidth;
    if (canvasHeight) canvasHeight.value = state.canvasHeight;
    if (tglCanvasBorder) tglCanvasBorder.checked = !!state.showCanvasBorder;
  }

  [tglShowLatency, tglShowNodeCode, tglShowLinkCode, tglShowNodeTags, tglShowExtraTags, tglShowNodeName, tglShowLinkTag, tglShowContainerTitle].forEach(el => {
    if (!el) return;
    el.addEventListener('change', () => {

      state.ui.showLatency = !!tglShowLatency?.checked;
      state.ui.showNodeCode = !!tglShowNodeCode?.checked;
      state.ui.showLinkCode = !!tglShowLinkCode?.checked;
      state.ui.showNodeTags = !!tglShowNodeTags?.checked;
      state.ui.showExtraTags = !!tglShowExtraTags?.checked;
      state.ui.showNodeName = tglShowNodeName?.checked !== false;
      state.ui.showLinkTag = tglShowLinkTag?.checked !== false;
      state.ui.showContainerTitle = tglShowContainerTitle?.checked !== false;



      // Save to current view settings
      if (typeof saveCurrentViewLabelSettings === 'function') {
        saveCurrentViewLabelSettings();
      }

      // Re-render the appropriate view (use window references since mapLibreState is defined later)

      if (window.mapLibreState && window.mapLibreState.active && typeof window.renderMapLibreContent === 'function') {

        window.mapLibreState.skipFitBounds = true;
        window.renderMapLibreContent();
      } else {

        render();
      }

      // Sync floating panel checkboxes
      syncFloatingLabelsPanel();
    });
  });

  // ============== FLOATING LABELS PANEL ==============

  // Sync floating panel checkboxes with state.ui
  function syncFloatingLabelsPanel() {
    const floatShowNodeName = document.getElementById('floatShowNodeName');
    const floatShowNodeCode = document.getElementById('floatShowNodeCode');
    const floatShowNodeTags = document.getElementById('floatShowNodeTags');
    const floatShowExtraTags = document.getElementById('floatShowExtraTags');
    const floatShowLinkTag = document.getElementById('floatShowLinkTag');
    const floatShowLinkCode = document.getElementById('floatShowLinkCode');
    const floatShowLatency = document.getElementById('floatShowLatency');
    const floatShowContainerTitle = document.getElementById('floatShowContainerTitle');

    if (floatShowNodeName) floatShowNodeName.checked = state.ui.showNodeName;
    if (floatShowNodeCode) floatShowNodeCode.checked = state.ui.showNodeCode;
    if (floatShowNodeTags) floatShowNodeTags.checked = state.ui.showNodeTags;
    if (floatShowExtraTags) floatShowExtraTags.checked = state.ui.showExtraTags;
    if (floatShowLinkTag) floatShowLinkTag.checked = state.ui.showLinkTag;
    if (floatShowLinkCode) floatShowLinkCode.checked = state.ui.showLinkCode;
    if (floatShowLatency) floatShowLatency.checked = state.ui.showLatency;
    if (floatShowContainerTitle) floatShowContainerTitle.checked = state.ui.showContainerTitle;

    // Update view indicator
    updateFloatingLabelsViewIndicator();
  }

  // Update the view indicator in floating panel
  function updateFloatingLabelsViewIndicator() {
    const indicator = document.getElementById('floatingLabelsViewIndicator');
    if (indicator) {
      if (window.mapLibreState && window.mapLibreState.active) {
        indicator.textContent = 'ðŸ—ºï¸ Geo Dynamic';
        indicator.style.color = '#10b981';
      } else if (window.geoViewState && window.geoViewState.active) {
        indicator.textContent = 'ðŸŒ Geo Static';
        indicator.style.color = '#0096D6';
      } else {
        indicator.textContent = 'ðŸ“‹ Canvas';
        indicator.style.color = '#666';
      }
    }
  }

  // Sync main menu checkboxes from floating panel
  function syncMainMenuFromFloating() {
    if (tglShowNodeName) tglShowNodeName.checked = state.ui.showNodeName;
    if (tglShowNodeCode) tglShowNodeCode.checked = state.ui.showNodeCode;
    if (tglShowNodeTags) tglShowNodeTags.checked = state.ui.showNodeTags;
    if (tglShowExtraTags) tglShowExtraTags.checked = state.ui.showExtraTags;
    if (tglShowLinkTag) tglShowLinkTag.checked = state.ui.showLinkTag;
    if (tglShowLinkCode) tglShowLinkCode.checked = state.ui.showLinkCode;
    if (tglShowLatency) tglShowLatency.checked = state.ui.showLatency;
    if (tglShowContainerTitle) tglShowContainerTitle.checked = state.ui.showContainerTitle;
  }

  // Handle floating panel checkbox changes
  function setupFloatingPanelHandlers() {
    const floatCheckboxes = [
      { id: 'floatShowNodeName', prop: 'showNodeName' },
      { id: 'floatShowNodeCode', prop: 'showNodeCode' },
      { id: 'floatShowNodeTags', prop: 'showNodeTags' },
      { id: 'floatShowExtraTags', prop: 'showExtraTags' },
      { id: 'floatShowLinkTag', prop: 'showLinkTag' },
      { id: 'floatShowLinkCode', prop: 'showLinkCode' },
      { id: 'floatShowLatency', prop: 'showLatency' },
      { id: 'floatShowContainerTitle', prop: 'showContainerTitle' }
    ];

    floatCheckboxes.forEach(({ id, prop }) => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener('change', () => {
          state.ui[prop] = el.checked;

          // Save to current view settings
          if (typeof saveCurrentViewLabelSettings === 'function') {
            saveCurrentViewLabelSettings();
          }

          // Sync main menu
          syncMainMenuFromFloating();

          // Re-render
          if (window.mapLibreState && window.mapLibreState.active && typeof window.renderMapLibreContent === 'function') {
            window.mapLibreState.skipFitBounds = true;
            window.renderMapLibreContent();
          } else {
            render();
          }
        });
      }
    });

    // Pin button handler
    const btnPinLabels = document.getElementById('btnPinLabels');
    const floatingPanel = document.getElementById('floatingLabelsPanel');
    if (btnPinLabels && floatingPanel) {
      btnPinLabels.addEventListener('click', (e) => {
        e.stopPropagation();
        floatingPanel.style.display = 'block';
        syncFloatingLabelsPanel();
        // Close the menu
        document.querySelectorAll('.menu').forEach(m => m.hidden = true);
      });
    }

    // Close button handler
    const btnCloseLabelsPanel = document.getElementById('btnCloseLabelsPanel');
    if (btnCloseLabelsPanel && floatingPanel) {
      btnCloseLabelsPanel.addEventListener('click', () => {
        floatingPanel.style.display = 'none';
      });
    }

    // Make panel draggable
    if (floatingPanel) {
      const header = floatingPanel.querySelector('.floating-panel-header');
      if (header) {
        let isDragging = false;
        let offsetX, offsetY;

        header.addEventListener('mousedown', (e) => {
          if (e.target.tagName === 'BUTTON') return;
          isDragging = true;
          offsetX = e.clientX - floatingPanel.offsetLeft;
          offsetY = e.clientY - floatingPanel.offsetTop;
          header.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          floatingPanel.style.left = (e.clientX - offsetX) + 'px';
          floatingPanel.style.top = (e.clientY - offsetY) + 'px';
          floatingPanel.style.right = 'auto';
        });

        document.addEventListener('mouseup', () => {
          isDragging = false;
          header.style.cursor = 'move';
        });
      }
    }
  }

  // Initialize floating panel handlers when DOM is ready
  setTimeout(setupFloatingPanelHandlers, 100);

  // Expose functions for view switching
  window.syncFloatingLabelsPanel = syncFloatingLabelsPanel;
  window.updateFloatingLabelsViewIndicator = updateFloatingLabelsViewIndicator;

  // ============== END FLOATING LABELS PANEL ==============

  // Canvas settings handlers are initialized later after state is defined

  if (tglCanvasBorder) {
    // This handler is also moved later
  }




  const state = {
    nodes: [],
    edges: [],
    groups: [],
    cableSystems: [],  // Cable system objects
    multilinkGroups: [],  // Multilink group objects
    nextNode: 1,
    nextEdge: 1,
    nextGroup: 1,
    nextCableSystem: 1,
    nextMultilinkGroup: 1,
    selected: null,
    selectedCableSystem: null,  // Currently selected cable system ID
    selectedMultilinkGroup: null,  // Currently selected multilink group ID
    connectFrom: null,
    dragging: null,
    resizingGroup: null,
    resizingNode: null,
    placingGroup: false,
    defaultNodeShape: 'circle',
    placingGroupType: 'country',

    // Path Edit Mode state
    pathEditMode: {
      active: false,
      linkId: null,
      originalPath: null,      // For cancel/restore
      currentPath: [],         // Working coordinates [[lng,lat], ...]
      currentSegments: null,   // For multi-segment imports: [[seg1coords], [seg2coords], ...] or null
      hasUnsavedChanges: false,
      editMethod: null,        // 'manual' | 'telegeography' | 'kml-import'
      selectedSegments: [],    // For Cable Database multilinestring selection
      telegeographyData: null  // Cached cable data from Cable Database
    },

    // Canvas dimensions (now customizable)
    canvasWidth: 1600,
    canvasHeight: 900,
    showCanvasBorder: true,

    // Grid settings
    gridEnabled: true,
    gridSize: 40,

    // Tag filter settings
    tagFilter: {
      mode: 'all',  // 'all', 'include', 'exclude'
      selectedTags: new Set(),
      exclusive: false  // If true, ignore other filters
    },

    // Cable system filter settings
    cableSystemFilter: {
      mode: 'all',  // 'all', 'selected'
      selectedSystems: new Set(),
      showUnmapped: true,
      exclusive: false  // If true, ignore other filters
    },

    // Node filter settings
    nodeFilter: {
      mode: 'all',  // 'all', 'selected'
      selectedNodes: new Set(),
      displayMode: 'name',  // 'name' or 'code'
      exclusive: false  // If true, ignore other filters
    },

    // Container filter settings
    containerFilter: {
      mode: 'all',  // 'all', 'selected'
      selectedBoxes: new Set(),    // Container boxes (country type)
      selectedGroups: new Set(),   // Groups/regions (container of containers)
      exclusive: false  // If true, ignore other filters
    },

    // Zoom level (CSS transform based)
    zoom: 1,

    // UI/global toggles - now with per-view settings
    ui: {
      showLatency: true,
      showNodeCode: true,
      showLinkCode: true,
      showNodeTags: false,
      showExtraTags: false,
      showNodeName: true,
      showLinkTag: true,
      showContainerTitle: true
    },

    // Per-view label settings (each view stores its own label visibility preferences)
    viewSettings: {
      canvas: {
        showNodeName: true,
        showNodeCode: true,
        showNodeTags: false,
        showExtraTags: false,
        showLinkTag: true,
        showLinkCode: true,
        showLatency: true,
        showContainerTitle: true
      },
      geoStatic: {
        showNodeName: true,
        showNodeCode: true,
        showNodeTags: false,
        showExtraTags: false,
        showLinkTag: true,
        showLinkCode: false,
        showLatency: true,
        showContainerTitle: false
      },
      geoDynamic: {
        showNodeName: false,
        showNodeCode: true,
        showNodeTags: false,
        showExtraTags: false,
        showLinkTag: true,
        showLinkCode: false,
        showLatency: false,
        showContainerTitle: false
      }
    },

    // Named style presets (saved inside .ndg)
    stylePresets: { node: {}, edge: {}, group: {} },

    // Shape Library (persisted to localStorage)
    shapeLibrary: {
      shapes: {},      // id -> node shape definition
      categories: ['Network Devices', 'Cloud Services', 'Custom'],  // default categories for nodes
      containerShapes: {},  // id -> container shape definition (decorative SVG)
      containerCategories: ['Europe', 'North America', 'Central America & Caribbean', 'South America', 'Middle East', 'Africa', 'East Asia', 'South & Southeast Asia', 'Oceania', 'Custom']  // default categories for containers
    },

    // Current library tab
    libraryTab: 'nodes',  // 'nodes' or 'containers'
    // Selected items in the shape library (Set of shape IDs)
    selectedLibraryItems: new Set(),

    // Format painter (session-only)
    styleBrush: null,

    // Multi-selection (ids)
    selection: { nodes: new Set(), edges: new Set(), groups: new Set() },
    marquee: null,
    lastMouse: { x: 0, y: 0 },

    // Financial settings (project-wide)
    financialSettings: {
      baseCurrency: 'USD',
      exchangeRates: {},           // { EUR: 0.92, GBP: 0.79, ... }
      exchangeRatesUpdated: null,  // ISO timestamp
      npvDiscountRate: 12.5,       // percentage
      defaultMRC: 1,
      defaultNRC: 0,
      defaultIRU: 1,
      defaultIRUTerm: 15,
      defaultOAM: 3,               // percentage of IRU fee
      defaultOAMIncrement: 2,      // yearly percentage increase
      tierMultipliers: { '10G': 2.5, '100G': 6.25, '400G': 15.625 },
      iruFromMRCMultiplier: 36,    // IRU Fee = MRC Ã— this multiplier (default: 36 = 3 years)
      // Container defaults (used when no links exist inside container)
      containerDefaultMRC: 1,
      containerDefaultNRC: 0,
      containerDefaultIRU: 1,
      containerDefaultIRUTerm: 15,
      containerDefaultOAM: 3,
      containerDefaultOAMIncrement: 2
    },

    // Pathfinder cost settings
    pathfinderSettings: {
      optimizationBalance: 0,      // 0 = pure latency, 1 = pure cost
      costMetric: 'lease',         // 'lease' (ACV) or 'iru' (NPV)
      costScale: 'logarithmic'     // 'linear' or 'logarithmic'
    },

    // Default node style (for new nodes)
    defaultNodeStyle: {
      shape: 'circle',
      r: 24,
      fill: '#dae8fc',
      stroke: '#6c8ebf',
      strokeWidth: 2,
      labelFont: 12,
      labelColor: '#333333'
    },

    // Default link style (for new links)
    defaultLinkStyle: {
      lineType: 'straight',        // 'straight' or 'curved'
      stroke: '#666666',
      strokeWidth: 2,
      dashArray: '',               // '' for solid, '5,5' for dashed, etc.
      curveArch: 0.3,
      labelFont: 10,
      labelColor: '#666666',
      glow: false,
      glowColor: '#0096D6',
      arrowStart: false,
      arrowEnd: false
    }
  };

  // Expose state globally for cross-script access
  window.state = state;

  const history = { stack: [], index: -1, max: 120 };
  let dirty = false;

  // ============== HEAT MAP STATE ==============
  const heatMapState = {
    active: false,
    mode: 'off',           // 'off', 'capacity', 'price'
    priceTier: '10G',      // '1G', '10G', '100G', '400G'
    // Mode-specific colors (capacity uses inverted: red=low, green=high)
    capacityColdColor: '#ef4444',  // Red - low/no capacity (bad)
    capacityHotColor: '#22c55e',   // Green - high capacity (good)
    priceColdColor: '#22c55e',     // Green - low price (good)
    priceHotColor: '#ef4444',      // Red - high price (bad)
    // Current active colors (set based on mode)
    coldColor: '#ef4444',
    hotColor: '#22c55e',
    showLegend: true,
    useLogarithmic: false,  // Logarithmic scale for better visualization
    // Cached min/max values for current mode
    minValue: 0,
    maxValue: 100
  };

  // ============== VIEW-AWARE LABEL SETTINGS ==============

  // Get current view type
  function getCurrentViewType() {
    if (window.mapLibreState && window.mapLibreState.active) {
      return 'geoDynamic';
    }
    if (window.geoViewState && window.geoViewState.active) {
      return 'geoStatic';
    }
    return 'canvas';
  }

  // Save current label settings to the current view
  function saveCurrentViewLabelSettings() {
    const viewType = getCurrentViewType();
    if (!state.viewSettings[viewType]) {
      state.viewSettings[viewType] = {};
    }

    state.viewSettings[viewType].showNodeName = state.ui.showNodeName;
    state.viewSettings[viewType].showNodeCode = state.ui.showNodeCode;
    state.viewSettings[viewType].showNodeTags = state.ui.showNodeTags;
    state.viewSettings[viewType].showExtraTags = state.ui.showExtraTags;
    state.viewSettings[viewType].showLinkTag = state.ui.showLinkTag;
    state.viewSettings[viewType].showLinkCode = state.ui.showLinkCode;
    state.viewSettings[viewType].showLatency = state.ui.showLatency;
    state.viewSettings[viewType].showContainerTitle = state.ui.showContainerTitle;
  }

  // Load label settings for a specific view into state.ui and update checkboxes
  function loadViewLabelSettings(viewType) {
    const settings = state.viewSettings[viewType];
    if (!settings) return;

    // Update state.ui
    state.ui.showNodeName = settings.showNodeName !== false;
    state.ui.showNodeCode = settings.showNodeCode !== false;
    state.ui.showNodeTags = !!settings.showNodeTags;
    state.ui.showExtraTags = !!settings.showExtraTags;
    state.ui.showLinkTag = settings.showLinkTag !== false;
    state.ui.showLinkCode = settings.showLinkCode !== false;
    state.ui.showLatency = settings.showLatency !== false;
    state.ui.showContainerTitle = settings.showContainerTitle !== false;

    // Update checkboxes in the Labels submenu
    const tglShowNodeName = document.getElementById('tglShowNodeName');
    const tglShowNodeCode = document.getElementById('tglShowNodeCode');
    const tglShowNodeTags = document.getElementById('tglShowNodeTags');
    const tglShowExtraTags = document.getElementById('tglShowExtraTags');
    const tglShowLinkTag = document.getElementById('tglShowLinkTag');
    const tglShowLinkCode = document.getElementById('tglShowLinkCode');
    const tglShowLatency = document.getElementById('tglShowLatency');
    const tglShowContainerTitle = document.getElementById('tglShowContainerTitle');

    if (tglShowNodeName) tglShowNodeName.checked = state.ui.showNodeName;
    if (tglShowNodeCode) tglShowNodeCode.checked = state.ui.showNodeCode;
    if (tglShowNodeTags) tglShowNodeTags.checked = state.ui.showNodeTags;
    if (tglShowExtraTags) tglShowExtraTags.checked = state.ui.showExtraTags;
    if (tglShowLinkTag) tglShowLinkTag.checked = state.ui.showLinkTag;
    if (tglShowLinkCode) tglShowLinkCode.checked = state.ui.showLinkCode;
    if (tglShowLatency) tglShowLatency.checked = state.ui.showLatency;
    if (tglShowContainerTitle) tglShowContainerTitle.checked = state.ui.showContainerTitle;

    // Also sync floating panel if it exists
    if (typeof window.syncFloatingLabelsPanel === 'function') {
      window.syncFloatingLabelsPanel();
    }
  }

  // Switch label settings when changing views
  function switchViewLabelSettings(fromViewType, toViewType) {
    // Save current view's settings
    if (fromViewType && state.viewSettings[fromViewType]) {
      saveCurrentViewLabelSettings();
    }
    // Load new view's settings
    loadViewLabelSettings(toViewType);

    // Update floating panel view indicator
    if (typeof window.updateFloatingLabelsViewIndicator === 'function') {
      window.updateFloatingLabelsViewIndicator();
    }
  }

  // ============== END VIEW-AWARE LABEL SETTINGS ==============

  // Pan and Zoom functionality using CSS transform and scrollbars
  function updateViewBox() {
    // Keep the viewBox matching canvas dimensions
    svg.setAttribute('viewBox', `0 0 ${state.canvasWidth} ${state.canvasHeight}`);

    // Update SVG size based on zoom - always use the full canvas size
    // This ensures the entire canvas is always scrollable
    const scaledWidth = state.canvasWidth * state.zoom;
    const scaledHeight = state.canvasHeight * state.zoom;

    svg.setAttribute('width', scaledWidth);
    svg.setAttribute('height', scaledHeight);

    // Also set the container size explicitly to ensure scroll works
    const svgContainer = document.getElementById('svgContainer');
    if (svgContainer) {
      svgContainer.style.width = scaledWidth + 'px';
      svgContainer.style.height = scaledHeight + 'px';
    }

    // Update zoom level display
    const zoomPct = Math.round(state.zoom * 100);
    const zoomLevelEl = document.getElementById('zoomLevel');
    if (zoomLevelEl) zoomLevelEl.textContent = `${zoomPct}%`;
  }

  function setZoom(newZoom, centerOnMouse = false, mouseX = 0, mouseY = 0) {
    newZoom = Math.max(0.1, Math.min(5, newZoom)); // Clamp between 10% and 500%

    const wrap = document.getElementById('wrap');
    const oldZoom = state.zoom;

    if (centerOnMouse && wrap) {
      // Calculate the point under the mouse in canvas coordinates before zoom
      const scrollLeft = wrap.scrollLeft;
      const scrollTop = wrap.scrollTop;
      const pointX = (scrollLeft + mouseX) / oldZoom;
      const pointY = (scrollTop + mouseY) / oldZoom;

      state.zoom = newZoom;
      updateViewBox();

      // After zoom, scroll to keep the same point under the mouse
      wrap.scrollLeft = pointX * newZoom - mouseX;
      wrap.scrollTop = pointY * newZoom - mouseY;
    } else {
      state.zoom = newZoom;
      updateViewBox();
    }
  }

  function fitToView() {
    if (state.nodes.length === 0 && state.groups.length === 0) {
      // Nothing to fit - reset to 100%
      state.zoom = 1;
      updateViewBox();
      const wrap = document.getElementById('wrap');
      if (wrap) {
        wrap.scrollLeft = 0;
        wrap.scrollTop = 0;
      }
      return;
    }

    // Calculate bounding box of all content
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

    state.nodes.forEach(n => {
      const r = n.r || 24;
      minX = Math.min(minX, n.x - r - 50);
      minY = Math.min(minY, n.y - r - 50);
      maxX = Math.max(maxX, n.x + r + 50);
      maxY = Math.max(maxY, n.y + r + 50);
    });

    state.groups.forEach(g => {
      minX = Math.min(minX, g.x - 20);
      minY = Math.min(minY, g.y - 20);
      maxX = Math.max(maxX, g.x + g.w + 20);
      maxY = Math.max(maxY, g.y + g.h + 20);
    });

    const contentWidth = maxX - minX;
    const contentHeight = maxY - minY;

    const wrap = document.getElementById('wrap');
    const wrapWidth = wrap.clientWidth;
    const wrapHeight = wrap.clientHeight;

    // Calculate scale to fit content
    const scaleX = wrapWidth / contentWidth;
    const scaleY = wrapHeight / contentHeight;
    let scale = Math.min(scaleX, scaleY) * 0.9; // 90% to add padding

    // Ensure zoom doesn't make canvas smaller than viewport (so scrollbars remain)
    // The canvas at this zoom level should be larger than the viewport
    const minZoomForScrollX = (wrapWidth + 50) / state.canvasWidth;
    const minZoomForScrollY = (wrapHeight + 50) / state.canvasHeight;
    const minZoomForScroll = Math.max(minZoomForScrollX, minZoomForScrollY);

    // Use the larger of: content fit zoom, or minimum zoom for scrolling
    scale = Math.max(scale, minZoomForScroll);

    state.zoom = Math.max(0.1, Math.min(5, scale));
    updateViewBox();

    // Calculate scroll position to center the content
    if (wrap) {
      // Center the content in the viewport
      const contentCenterX = (minX + maxX) / 2;
      const contentCenterY = (minY + maxY) / 2;

      // Scroll to position content center in the middle of viewport
      const scrollX = (contentCenterX * state.zoom) - (wrapWidth / 2);
      const scrollY = (contentCenterY * state.zoom) - (wrapHeight / 2);

      wrap.scrollLeft = Math.max(0, scrollX);
      wrap.scrollTop = Math.max(0, scrollY);
    }
  }

  function trimCanvasToContent() {
    if (state.nodes.length === 0 && state.groups.length === 0) {
      showToast('No content to trim to.');
      return;
    }

    // Calculate bounding box of all content
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

    state.nodes.forEach(n => {
      const r = n.r || 24;
      minX = Math.min(minX, n.x - r);
      minY = Math.min(minY, n.y - r);
      maxX = Math.max(maxX, n.x + r);
      maxY = Math.max(maxY, n.y + r);
    });

    state.groups.forEach(g => {
      minX = Math.min(minX, g.x);
      minY = Math.min(minY, g.y);
      maxX = Math.max(maxX, g.x + g.w);
      maxY = Math.max(maxY, g.y + g.h);
    });

    // Add padding around content
    const padding = 50;
    minX = Math.max(0, minX - padding);
    minY = Math.max(0, minY - padding);
    maxX = maxX + padding;
    maxY = maxY + padding;

    // Calculate offset to move all objects
    const offsetX = -minX;
    const offsetY = -minY;

    // Move all nodes
    state.nodes.forEach(n => {
      n.x += offsetX;
      n.y += offsetY;
    });

    // Move all groups
    state.groups.forEach(g => {
      g.x += offsetX;
      g.y += offsetY;
    });

    // Update canvas size to fit content
    const newWidth = Math.max(400, maxX - minX);
    const newHeight = Math.max(300, maxY - minY);

    state.canvasWidth = Math.ceil(newWidth);
    state.canvasHeight = Math.ceil(newHeight);

    // Reset zoom to 100% and update
    state.zoom = 1;
    updateViewBox();

    // Scroll to top-left
    const wrap = document.getElementById('wrap');
    if (wrap) {
      wrap.scrollLeft = 0;
      wrap.scrollTop = 0;
    }

    commit();
    render();
    showToast(`Canvas trimmed to ${state.canvasWidth} Ã— ${state.canvasHeight} pixels.`);
  }

  // Auto-fit canvas to include all elements with padding
  function autoFitCanvas() {
    if (state.nodes.length === 0 && state.groups.length === 0) {
      showToast('No content to fit.');
      return;
    }

    // Calculate bounding box of ALL content (including those outside canvas)
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

    // Include nodes with their labels (estimate label width)
    state.nodes.forEach(n => {
      const r = n.r || 24;
      const labelPadding = 60; // Extra space for labels
      minX = Math.min(minX, n.x - r - labelPadding);
      minY = Math.min(minY, n.y - r - 30); // Space above for labels
      maxX = Math.max(maxX, n.x + r + labelPadding);
      maxY = Math.max(maxY, n.y + r + 40); // Space below for labels
    });

    // Include groups/containers
    state.groups.forEach(g => {
      minX = Math.min(minX, g.x - 20);
      minY = Math.min(minY, g.y - 30); // Title space above
      maxX = Math.max(maxX, g.x + g.w + 20);
      maxY = Math.max(maxY, g.y + g.h + 20);
    });

    // Add padding around content
    const padding = 80;

    // Calculate how much we need to shift elements (if minX or minY is negative or too small)
    const shiftX = minX < padding ? padding - minX : 0;
    const shiftY = minY < padding ? padding - minY : 0;

    // Move all nodes if needed
    if (shiftX > 0 || shiftY > 0) {
      state.nodes.forEach(n => {
        n.x += shiftX;
        n.y += shiftY;
      });

      // Move all groups
      state.groups.forEach(g => {
        g.x += shiftX;
        g.y += shiftY;
      });

      // Update bounds after shift
      minX += shiftX;
      minY += shiftY;
      maxX += shiftX;
      maxY += shiftY;
    }

    // Calculate new canvas size
    const newWidth = Math.max(state.canvasWidth, maxX + padding);
    const newHeight = Math.max(state.canvasHeight, maxY + padding);

    const wasExpanded = newWidth > state.canvasWidth || newHeight > state.canvasHeight;
    const wasShifted = shiftX > 0 || shiftY > 0;

    state.canvasWidth = Math.ceil(newWidth);
    state.canvasHeight = Math.ceil(newHeight);

    // Update viewBox
    updateViewBox();

    // Update canvas size inputs
    const canvasWidthInput = document.getElementById('canvasWidth');
    const canvasHeightInput = document.getElementById('canvasHeight');
    if (canvasWidthInput) canvasWidthInput.value = state.canvasWidth;
    if (canvasHeightInput) canvasHeightInput.value = state.canvasHeight;

    commit();
    render();

    if (wasShifted && wasExpanded) {
      showToast(`ðŸ“ Canvas expanded to ${state.canvasWidth} Ã— ${state.canvasHeight} and elements repositioned`);
    } else if (wasShifted) {
      showToast(`ðŸ“ Elements repositioned to fit within canvas`);
    } else if (wasExpanded) {
      showToast(`ðŸ“ Canvas expanded to ${state.canvasWidth} Ã— ${state.canvasHeight}`);
    } else {
      showToast(`ðŸ“ All elements already fit within canvas`);
    }
  }

  // Center all elements on the canvas
  function centerElements() {
    if (state.nodes.length === 0 && state.groups.length === 0) {
      showToast('No content to center.');
      return;
    }

    // Calculate bounding box of all content
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

    state.nodes.forEach(n => {
      const r = n.r || 24;
      minX = Math.min(minX, n.x - r);
      minY = Math.min(minY, n.y - r);
      maxX = Math.max(maxX, n.x + r);
      maxY = Math.max(maxY, n.y + r);
    });

    state.groups.forEach(g => {
      minX = Math.min(minX, g.x);
      minY = Math.min(minY, g.y);
      maxX = Math.max(maxX, g.x + g.w);
      maxY = Math.max(maxY, g.y + g.h);
    });

    // Calculate content dimensions
    const contentWidth = maxX - minX;
    const contentHeight = maxY - minY;

    // Calculate offset to center content
    const targetX = (state.canvasWidth - contentWidth) / 2;
    const targetY = (state.canvasHeight - contentHeight) / 2;

    const offsetX = targetX - minX;
    const offsetY = targetY - minY;

    // Move all nodes
    state.nodes.forEach(n => {
      n.x += offsetX;
      n.y += offsetY;
    });

    // Move all groups
    state.groups.forEach(g => {
      g.x += offsetX;
      g.y += offsetY;
    });

    commit();
    render();
    showToast('âŠ Elements centered on canvas');
  }

  // Check if elements are outside canvas bounds and auto-expand if enabled
  function checkAndAutoExpandCanvas() {
    const autoExpandCheckbox = document.getElementById('tglAutoExpandCanvas');
    if (!autoExpandCheckbox || !autoExpandCheckbox.checked) return;

    let needsExpansion = false;
    let maxX = state.canvasWidth;
    let maxY = state.canvasHeight;
    let minX = 0;
    let minY = 0;

    // Check nodes
    state.nodes.forEach(n => {
      const r = n.r || 24;
      if (n.x + r + 50 > maxX) { maxX = n.x + r + 100; needsExpansion = true; }
      if (n.y + r + 50 > maxY) { maxY = n.y + r + 100; needsExpansion = true; }
      if (n.x - r < minX + 50) { minX = n.x - r - 100; needsExpansion = true; }
      if (n.y - r < minY + 50) { minY = n.y - r - 100; needsExpansion = true; }
    });

    // Check groups
    state.groups.forEach(g => {
      if (g.x + g.w + 50 > maxX) { maxX = g.x + g.w + 100; needsExpansion = true; }
      if (g.y + g.h + 50 > maxY) { maxY = g.y + g.h + 100; needsExpansion = true; }
      if (g.x < minX + 50) { minX = g.x - 100; needsExpansion = true; }
      if (g.y < minY + 50) { minY = g.y - 100; needsExpansion = true; }
    });

    if (!needsExpansion) return;

    // Calculate shift needed for left/top expansion
    const shiftX = minX < 0 ? -minX : 0;
    const shiftY = minY < 0 ? -minY : 0;

    if (shiftX > 0 || shiftY > 0) {
      // Shift all elements to accommodate left/top expansion
      state.nodes.forEach(n => {
        n.x += shiftX;
        n.y += shiftY;
      });
      state.groups.forEach(g => {
        g.x += shiftX;
        g.y += shiftY;
      });
      maxX += shiftX;
      maxY += shiftY;
    }

    // Update canvas size
    state.canvasWidth = Math.ceil(Math.max(state.canvasWidth, maxX));
    state.canvasHeight = Math.ceil(Math.max(state.canvasHeight, maxY));

    updateViewBox();

    // Update canvas size inputs
    const canvasWidthInput = document.getElementById('canvasWidth');
    const canvasHeightInput = document.getElementById('canvasHeight');
    if (canvasWidthInput) canvasWidthInput.value = state.canvasWidth;
    if (canvasHeightInput) canvasHeightInput.value = state.canvasHeight;
  }

  // In-app clipboard (for copy/paste)
  let clipboard = null; // { nodes:[], groups:[], edges:[], bbox:{minX,minY} }

  function selectionToClipboard() {
    const nodeIds = new Set(state.selection.nodes);
    const groupIds = new Set(state.selection.groups);

    // Include edges where both endpoints are selected (plus any explicitly selected)
    const edgeIds = new Set(state.selection.edges);
    state.edges.forEach(e => { if (nodeIds.has(e.a) && nodeIds.has(e.b)) edgeIds.add(e.id); });

    const nodes = state.nodes.filter(n => nodeIds.has(n.id)).map(n => ({...n}));
    const groups = state.groups.filter(g => groupIds.has(g.id)).map(g => ({...g}));
    const edges = state.edges.filter(e => edgeIds.has(e.id)).map(e => ({...e}));

    if (nodes.length===0 && groups.length===0 && edges.length===0) return null;

    // bbox of nodes + groups (for paste offset)
    const xs = [], ys = [];
    nodes.forEach(n => { xs.push(n.x); ys.push(n.y); });
    groups.forEach(g => { xs.push(g.x, g.x+g.w); ys.push(g.y, g.y+g.h); });
    const minX = xs.length ? Math.min(...xs) : 0;
    const minY = ys.length ? Math.min(...ys) : 0;

    return { nodes, groups, edges, bbox: { minX, minY } };
  }

  function copySelection() {
    const clip = selectionToClipboard();
    if (!clip) { showToast('Nothing selected to copy.'); return; }
    clipboard = clip;
    showToast(`Copied ${clip.nodes.length} node(s), ${clip.edges.length} link(s), ${clip.groups.length} box(es).`);
  }

  function cutSelection() {
    copySelection();
    // If nothing copied, don't delete.
    if (!clipboard) return;
    deleteSelection();
  }

  function pasteSelection() {
    if (!clipboard) { showToast('Clipboard is empty.'); return; }

    const offset = 24;
    const targetX = state.lastMouse?.x ?? 200;
    const targetY = state.lastMouse?.y ?? 200;

    // Paste near last mouse position (or just offset)
    const dx = (targetX - clipboard.bbox.minX) + offset;
    const dy = (targetY - clipboard.bbox.minY) + offset;

    const nodeIdMap = new Map();
    const groupIdMap = new Map();

    // Duplicate groups first (so nodes can reference them)
    const newGroupIds = [];
    for (const g of clipboard.groups) {
      const id = state.nextGroup++;
      const ng = { ...g, id, x: g.x + dx, y: g.y + dy };
      // remap parentId if parent was also copied
      if (ng.parentId && groupIdMap.has(ng.parentId)) ng.parentId = groupIdMap.get(ng.parentId);
      state.groups.push(ng);
      groupIdMap.set(g.id, id);
      newGroupIds.push(id);
    }

    const newNodeIds = [];
    for (const n of clipboard.nodes) {
      const id = state.nextNode++;
      const nn = { ...n, id, x: n.x + dx, y: n.y + dy };
      if (nn.groupId && groupIdMap.has(nn.groupId)) nn.groupId = groupIdMap.get(nn.groupId);
      state.nodes.push(nn);
      nodeIdMap.set(n.id, id);
      newNodeIds.push(id);
    }

    const newEdgeIds = [];
    for (const e of clipboard.edges) {
      // only recreate edges whose endpoints were included in clipboard (typical copy behavior)
      if (!nodeIdMap.has(e.a) || !nodeIdMap.has(e.b)) continue;
      const id = state.nextEdge++;
      const ne = { ...e, id, a: nodeIdMap.get(e.a), b: nodeIdMap.get(e.b) };
      state.edges.push(ne);
      newEdgeIds.push(id);
    }

    refreshAllMemberships();
    commit();

    setMultiSelection({ nodes: newNodeIds, edges: newEdgeIds, groups: newGroupIds });
    render();
    showToast('Pasted selection.');
  }

  function cloneSelectionForDrag() {
    const clip = selectionToClipboard();
    if (!clip) return false;
    clipboard = clip;
    pasteSelection();
    return true;
  }



  const showToast = (msg) => {
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(() => toastEl.classList.remove('show'), 2400);
  };

  // Ribbon tabs (File/Home). This does not change any existing handlers.
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  // Color helper functions for rgba support
  function parseColorWithOpacity(colorStr) {
    if (!colorStr) return { color: '#ffffff', opacity: 1 };

    // Handle rgba format
    const rgbaMatch = colorStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
    if (rgbaMatch) {
      const r = parseInt(rgbaMatch[1]);
      const g = parseInt(rgbaMatch[2]);
      const b = parseInt(rgbaMatch[3]);
      const a = rgbaMatch[4] !== undefined ? parseFloat(rgbaMatch[4]) : 1;
      const hex = '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
      return { color: hex, opacity: a };
    }

    // Handle hex format (with optional alpha)
    if (colorStr.startsWith('#')) {
      if (colorStr.length === 9) {
        // #RRGGBBAA
        const alpha = parseInt(colorStr.slice(7, 9), 16) / 255;
        return { color: colorStr.slice(0, 7), opacity: alpha };
      }
      return { color: colorStr.slice(0, 7), opacity: 1 };
    }

    return { color: colorStr, opacity: 1 };
  }

  function combineColorWithOpacity(hexColor, opacity) {
    if (opacity >= 1) return hexColor;
    // Convert hex to rgba
    const r = parseInt(hexColor.slice(1, 3), 16);
    const g = parseInt(hexColor.slice(3, 5), 16);
    const b = parseInt(hexColor.slice(5, 7), 16);
    return `rgba(${r}, ${g}, ${b}, ${opacity.toFixed(2)})`;
  }

  // Node shape tool (sets default for NEW nodes only)
  const shapeButtons = document.querySelectorAll('.shape-tool');
  function setActiveShape(shape){
    state.defaultNodeShape = shape;
    if (state.defaultNodeStyle) {
      state.defaultNodeStyle.shape = shape;
    }
    shapeButtons.forEach(b=>{
      b.classList.toggle('active', b.dataset.shape === shape);
    });
  }

  shapeButtons.forEach(btn => {
    btn.addEventListener('click', (ev) => {
      const shape = btn.dataset.shape;
      setActiveShape(shape);

      // If a node is selected, update ONLY that node
      if (state.selected?.type === 'node'){
        const n = findNode(state.selected.id);
        if (n){
          n.shape = shape;
          commit(); render();
          showToast('Changed node shape to ' + shape + '.');
          return;
        }
      }
      showToast('New nodes will be ' + shape + '.');
    });
  });

  // --- File menu UI ---
  const fileBtn = document.getElementById('btnFile');
  const fileMenu = document.getElementById('fileMenu');
  const editBtn = document.getElementById('btnEditMenu');
  const editMenu = document.getElementById('editMenu');
  const viewBtn = document.getElementById('btnViewMenu');
  const viewMenu = document.getElementById('viewMenu');
  const dataBtn = document.getElementById('btnDataMenu');
  const dataMenu = document.getElementById('dataMenu');
  const settingsBtn = document.getElementById('btnSettingsMenu');
  const settingsMenu = document.getElementById('settingsMenu');

  function closeAllMenus(){
    fileMenu.hidden = true;
    if (editMenu) editMenu.hidden = true;
    if (viewMenu) viewMenu.hidden = true;
    if (dataMenu) dataMenu.hidden = true;
    if (settingsMenu) settingsMenu.hidden = true;
    const zoomMenu = document.getElementById('zoomMenu');
    if (zoomMenu) zoomMenu.hidden = true;
    const gridMenu = document.getElementById('gridMenu');
    if (gridMenu) gridMenu.hidden = true;
    const helpMenuEl = document.getElementById('helpMenu');
    if (helpMenuEl) helpMenuEl.hidden = true;
  }

  // Reposition a menu to prevent viewport overflow (right and bottom edges)
  function repositionMenuInViewport(menu) {
    if (!menu || menu.hidden) return;
    // Let the browser render, then check bounds
    requestAnimationFrame(() => {
      const rect = menu.getBoundingClientRect();
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      // Fix right overflow
      if (rect.right > vw - 8) {
        menu.style.left = 'auto';
        menu.style.right = '0';
      }
      // Fix left overflow (if right-aligned pushes it left)
      if (rect.left < 8) {
        menu.style.left = '0';
        menu.style.right = 'auto';
      }
      // Fix bottom overflow
      if (rect.bottom > vh - 8) {
        menu.style.top = 'auto';
        menu.style.bottom = '100%';
      }
    });
  }

  function toggleMenu(btn, menu) {
    closeAllMenus();
    menu.hidden = !menu.hidden;
    if (!menu.hidden) {
      const r = btn.getBoundingClientRect();
      menu.style.left = r.left + "px";
      menu.style.top = r.bottom + "px";

      // Position submenus intelligently
      positionSubmenus(menu);
    }
  }

  // Smart submenu positioning to prevent overflow
  function positionSubmenus(menu) {
    const submenus = menu.querySelectorAll('.submenu');
    submenus.forEach(submenu => {
      // Reset any previous positioning
      submenu.classList.remove('flip-up', 'flip-left');
      submenu.style.maxHeight = '';
      submenu.style.top = '';
      submenu.style.left = '';
      submenu.style.right = '';
      submenu.style.position = '';

      // Check position when parent is hovered
      const parent = submenu.parentElement;

      // Skip if already processed (use data attribute to track)
      if (parent.dataset.submenuPositioned) return;
      parent.dataset.submenuPositioned = 'true';

      parent.addEventListener('mouseenter', () => {
        requestAnimationFrame(() => {
          const parentRect = parent.getBoundingClientRect();
          const viewportHeight = window.innerHeight;
          const viewportWidth = window.innerWidth;

          // Special handling for fixed position submenus (MapLibre and GeoView settings, HeatMap)
          if (submenu.id === 'mapLibreSubmenu' || submenu.id === 'geoViewSubmenu' || submenu.id === 'heatMapSubmenu') {
            // Use fixed positioning for these complex submenus
            submenu.style.position = 'fixed';

            // Calculate available space on right vs left
            const spaceOnRight = viewportWidth - parentRect.right - 20;
            const spaceOnLeft = parentRect.left - 20;
            const submenuWidth = 300; // Approximate width

            if (spaceOnRight >= submenuWidth) {
              // Position to the right
              submenu.style.left = (parentRect.right + 5) + 'px';
              submenu.style.right = 'auto';
            } else if (spaceOnLeft >= submenuWidth) {
              // Position to the left
              submenu.style.left = 'auto';
              submenu.style.right = (viewportWidth - parentRect.left + 5) + 'px';
            } else {
              // Not enough space, overlay near center
              submenu.style.left = Math.max(10, (viewportWidth - submenuWidth) / 2) + 'px';
              submenu.style.right = 'auto';
            }

            // Vertical positioning - align with parent or use top
            const submenuHeight = 400; // Approximate max height
            if (parentRect.top + submenuHeight > viewportHeight - 20) {
              // Would overflow bottom, position from bottom
              submenu.style.top = 'auto';
              submenu.style.bottom = '20px';
            } else {
              submenu.style.top = Math.max(60, parentRect.top) + 'px';
              submenu.style.bottom = 'auto';
            }

            submenu.style.maxHeight = (viewportHeight - 80) + 'px';
            return;
          }

          const rect = submenu.getBoundingClientRect();

          // Check if submenu goes below viewport
          if (rect.bottom > viewportHeight - 20) {
            // Try flipping up first
            submenu.classList.add('flip-up');

            // Re-check after flip
            const newRect = submenu.getBoundingClientRect();
            if (newRect.top < 20) {
              // Can't flip, use scroll instead
              submenu.classList.remove('flip-up');
              submenu.style.maxHeight = (viewportHeight - rect.top - 40) + 'px';
            }
          }

          // Check if submenu goes past right edge
          if (rect.right > viewportWidth - 10) {
            submenu.classList.add('flip-left');
          }
        });
      });
    });
  }

  fileBtn.addEventListener('click', (ev) => { ev.stopPropagation(); toggleMenu(fileBtn, fileMenu); });
  if (editBtn && editMenu) editBtn.addEventListener('click', (ev) => { ev.stopPropagation(); toggleMenu(editBtn, editMenu); });
  if (viewBtn && viewMenu) viewBtn.addEventListener('click', (ev) => { ev.stopPropagation(); toggleMenu(viewBtn, viewMenu); });
  if (dataBtn && dataMenu) dataBtn.addEventListener('click', (ev) => { ev.stopPropagation(); toggleMenu(dataBtn, dataMenu); });
  if (settingsBtn && settingsMenu) settingsBtn.addEventListener('click', (ev) => { ev.stopPropagation(); toggleMenu(settingsBtn, settingsMenu); });

  document.addEventListener('click', () => closeAllMenus());
  window.addEventListener('keydown', (ev) => { if (ev.key === 'Escape') closeAllMenus(); });

  // Edit menu actions
  if (document.getElementById('miUndo')) document.getElementById('miUndo').addEventListener('click', () => { undo(); closeAllMenus(); });
  if (document.getElementById('miRedo')) document.getElementById('miRedo').addEventListener('click', () => { redo(); closeAllMenus(); });
  if (document.getElementById('miCopy')) document.getElementById('miCopy').addEventListener('click', () => { copySelection(); closeAllMenus(); });
  if (document.getElementById('miCut')) document.getElementById('miCut').addEventListener('click', () => { copySelection(); deleteSelected(); closeAllMenus(); });
  if (document.getElementById('miPaste')) document.getElementById('miPaste').addEventListener('click', () => { pasteSelection(); closeAllMenus(); });
  if (document.getElementById('miDelete')) document.getElementById('miDelete').addEventListener('click', () => { deleteSelected(); closeAllMenus(); });

  // View menu actions
  if (document.getElementById('miZoomIn')) document.getElementById('miZoomIn').addEventListener('click', () => { setZoom(state.zoom * 1.2); closeAllMenus(); });
  if (document.getElementById('miZoomOut')) document.getElementById('miZoomOut').addEventListener('click', () => { setZoom(state.zoom / 1.2); closeAllMenus(); });
  if (document.getElementById('miFitView')) document.getElementById('miFitView').addEventListener('click', () => { fitToView(); closeAllMenus(); });
  if (document.getElementById('miToggleInspector')) document.getElementById('miToggleInspector').addEventListener('click', () => {
    const inspector = document.getElementById('inspector');
    inspector.style.display = inspector.style.display === 'none' ? 'flex' : 'none';
    closeAllMenus();
  });

  // Toolbar button actions
  if (document.getElementById('btnUndo')) document.getElementById('btnUndo').addEventListener('click', () => undo());
  if (document.getElementById('btnRedo')) document.getElementById('btnRedo').addEventListener('click', () => redo());
  if (document.getElementById('btnDelete')) document.getElementById('btnDelete').addEventListener('click', () => deleteSelected());



  // --- Export helpers (SVG/PNG/JPG) ---
  function downloadBlob(blob, filename){
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 800);
  }

  function getSvgCloneForExport(){
    const svg = document.getElementById('svg');
    const clone = svg.cloneNode(true);

    clone.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
    // Remove resize handles - they are editing aids, not part of the diagram
    clone.querySelectorAll('.group-handle').forEach(el => el.remove());
    clone.querySelectorAll('.node-resize-handle').forEach(el => el.remove());
    clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');

    const style = document.createElementNS('http://www.w3.org/2000/svg','style');
    style.textContent = `
      .edge{ fill:none; stroke-linecap:round; }
      .edge-label{ font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
      .node-label{ font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
      .group-title{ font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    `;
    clone.insertBefore(style, clone.firstChild);

    const vb = clone.getAttribute('viewBox');
    let w=1600,h=900;
    if (vb){
      const p = vb.split(/\s+/).map(Number);
      if (p.length===4 && p.every(n=>isFinite(n))) { w=p[2]; h=p[3]; }
    }
    const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
    bg.setAttribute('x','0'); bg.setAttribute('y','0');
    bg.setAttribute('width', String(w)); bg.setAttribute('height', String(h));
    bg.setAttribute('fill', '#ffffff');
    clone.insertBefore(bg, style.nextSibling);

    clone.querySelectorAll('.edge-label').forEach(el => el.setAttribute('fill', '#000000'));
    clone.querySelectorAll('.node-label').forEach(el => el.setAttribute('fill', '#000000'));
    clone.querySelectorAll('.group-title').forEach(el => el.setAttribute('fill', '#000000'));

    return clone;
  }

  function exportSVG(){
    const clone = getSvgCloneForExport();
    const text = new XMLSerializer().serializeToString(clone);
    const blob = new Blob([text], {type:'image/svg+xml;charset=utf-8'});
    const name = (sanitizeBaseName(state.projectName || 'diagram') || 'diagram') + '.svg';
    downloadBlob(blob, name);
  }

  async function exportRaster(kind){
    const clone = getSvgCloneForExport();
    // Use viewBox for sizing if present
    const vb = clone.getAttribute('viewBox');
    let w = 1600, h = 900;
    if (vb){
      const p = vb.split(/\s+/).map(Number);
      if (p.length===4 && p.every(n=>isFinite(n))) { w = p[2]; h = p[3]; }
    } else {
      const ww = Number(clone.getAttribute('width')); const hh = Number(clone.getAttribute('height'));
      if (isFinite(ww)) w = ww;
      if (isFinite(hh)) h = hh;
    }

    const svgText = new XMLSerializer().serializeToString(clone);
    const svgBlob = new Blob([svgText], {type:'image/svg+xml;charset=utf-8'});
    const url = URL.createObjectURL(svgBlob);

    const img = new Image();
    await new Promise((res, rej)=>{ img.onload=res; img.onerror=rej; img.src=url; });

    const scale = 2; // sharper output
    const canvas = document.createElement('canvas');
    canvas.width = Math.round(w*scale);
    canvas.height = Math.round(h*scale);
    const ctx = canvas.getContext('2d');

    // Background (match page background)
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.scale(scale, scale);
    ctx.drawImage(img, 0, 0, w, h);
    URL.revokeObjectURL(url);

    const mime = (kind==='png') ? 'image/png' : 'image/jpeg';
    const ext = (kind==='png') ? '.png' : '.jpg';
    const quality = (kind==='png') ? undefined : 0.92;
    const dataUrl = canvas.toDataURL(mime, quality);

    const bin = atob(dataUrl.split(',')[1]);
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    const outBlob = new Blob([bytes], {type:mime});
    const name = (sanitizeBaseName(state.projectName || 'diagram') || 'diagram') + ext;
    downloadBlob(outBlob, name);
  }

document.getElementById('miNew').addEventListener('click', () => { closeAllMenus(); newDiagram(); });
document.getElementById('miSave').addEventListener('click', () => { closeAllMenus(); saveProject(false); });
  document.getElementById('miSaveAs').addEventListener('click', () => { closeAllMenus(); saveProject(true); });
  document.getElementById('miOpen').addEventListener('click', () => { closeAllMenus(); openProjectWithFilePicker(); });
  document.getElementById('miRecover').addEventListener('click', () => { closeAllMenus(); recoverAutosave(); });
  document.getElementById('miClearAutosave').addEventListener('click', () => { closeAllMenus(); clearAutosave(); });
  document.getElementById('miClearDiagram').addEventListener('click', () => { closeAllMenus(); clearDiagram(); });
  document.getElementById('miTrimCanvas').addEventListener('click', () => { closeAllMenus(); trimCanvasToContent(); });

  document.getElementById('miExportSVG').addEventListener('click', () => { closeAllMenus(); exportSVG(); showToast('Exported SVG.'); });
  document.getElementById('miExportPNG').addEventListener('click', () => { closeAllMenus(); exportRaster('png'); showToast('Exported PNG.'); });
  document.getElementById('miExportJPG').addEventListener('click', () => { closeAllMenus(); exportRaster('jpg'); showToast('Exported JPG.'); });

  // --- Style presets helpers ---
  const STYLE_FIELDS = {
    // Node: fill, stroke, stroke width, line style, shape, size (r), and all label formatting
    node: [
      "fill", "stroke", "strokeW", "lineStyle", "shape", "r",
      "nameColor", "nameSize", "nameFont", "nameDx", "nameDy",
      "codeColor", "codeSize", "codeFont",
      "extraTagsColor", "extraTagsSize", "extraTagsFont", "tagDx", "tagDy",
      "showCode", "showName", "showExtraTags"
    ],
    // Edge: stroke color, width, line style, edge style (straight/curve/orthogonal), and all label formatting
    edge: [
      "strokeColor", "strokeW", "lineStyle", "style", "route", "curveArch",
      "tagColor", "tagSize", "tagFont", "labelDx", "labelDy",
      "showCode", "showTag", "showLatency", "showCapacity", "showExtraTags"
    ],
    // Group: fill, stroke, stroke width, line style, size, and title formatting
    group: [
      "fill", "stroke", "strokeW", "lineStyle", "w", "h",
      "titleColor", "titleSize", "titleFont", "titleDx", "titleDy",
      "showTitle"
    ]
  };
  function pickStyle(type, obj){
    const s = {};
    (STYLE_FIELDS[type]||[]).forEach(k => { if (k in obj) s[k] = obj[k]; });
    return s;
  }
  function applyStyle(type, obj, style){
    if (!style) return;
    (STYLE_FIELDS[type]||[]).forEach(k => { if (k in style) obj[k] = style[k]; });
  }

  // Preset UI elements
  const nodePresetSel = document.getElementById('nodePreset');
  const edgePresetSel = document.getElementById('edgePreset');
  const groupPresetSel = document.getElementById('groupPreset');

  function refreshPresetSelects(){
    const fill = (sel, map) => {
      if (!sel) return;
      const cur = sel.value;
      sel.innerHTML = "";
      const opt0 = document.createElement('option');
      opt0.value = ""; opt0.textContent = "(none)";
      sel.appendChild(opt0);
      Object.keys(map||{}).sort((a,b)=>a.localeCompare(b)).forEach(name=>{
        const o = document.createElement('option');
        o.value = name; o.textContent = name;
        sel.appendChild(o);
      });
      sel.value = cur && (map||{})[cur] ? cur : "";
    };
    fill(nodePresetSel, state.stylePresets.node);
    fill(edgePresetSel, state.stylePresets.edge);
    fill(groupPresetSel, state.stylePresets.group);
  }

  function savePreset(type, obj){
    console.log(`[SAVE PRESET] Function called - type: ${type}, obj:`, obj);
    const name = sanitizeBaseName(prompt(`Save ${type} style as:`, "")) || "";
    console.log(`[SAVE PRESET] Prompt returned name: "${name}"`);
    if (!name) { showToast("Preset save cancelled."); return; }
    state.stylePresets[type][name] = pickStyle(type, obj);
    commit(); // persist in history and autosave
    refreshPresetSelects();
    showToast(`Saved preset: ${name}`);
  }
  function applyPreset(type, obj, name){
    const style = state.stylePresets[type][name];
    if (!style) { showToast("No preset selected."); return; }
    applyStyle(type, obj, style);
    commit(); render();
    showToast(`Applied preset: ${name}`);
  }
  function deletePreset(type, name){
    if (!name) { showToast("No preset selected."); return; }
    if (!confirm(`Delete preset "${name}"?`)) return;
    delete state.stylePresets[type][name];
    commit();
    refreshPresetSelects();
    showToast("Preset deleted.");
  }

  // --- Format painter (brush) ---
  const btnBrush = document.getElementById('btnBrush');
  function setBrushFromSelected(){
    const sel = state.selected;
    if (!sel) { showToast("Select an object first."); return; }
    if (sel.type === 'node') {
      const n = findNode(sel.id); if (!n) return;
      state.styleBrush = { type:'node', style: pickStyle('node', n) };
    } else if (sel.type === 'edge') {
      const e = findEdge(sel.id); if (!e) return;
      state.styleBrush = { type:'edge', style: pickStyle('edge', e) };
    } else if (sel.type === 'group') {
      const g = findGroup(sel.id); if (!g) return;
      state.styleBrush = { type:'group', style: pickStyle('group', g) };
    } else return;
    btnBrush.classList.add('primary');
    showToast("Format painter armed â€” click targets to apply (Esc cancels).");
  }
  function clearBrush(){
    state.styleBrush = null;
    btnBrush.classList.remove('primary');
  }
  btnBrush.addEventListener('click', (ev) => {
    ev.stopPropagation();
    if (state.styleBrush) { clearBrush(); showToast("Format painter off."); return; }
    setBrushFromSelected();
  });

  // --- Apply Style Panel ---
  const btnApplyStyle = document.getElementById('btnApplyStyle');
  const applyStyleMenu = document.getElementById('applyStyleMenu');
  const applyStyleContent = document.getElementById('applyStyleContent');
  const applyStyleEmpty = document.getElementById('applyStyleEmpty');
  const btnManageStyles = document.getElementById('btnManageStyles');

  function getSelectionCounts() {
    // Count selected items of each type
    let nodeCount = state.selection.nodes.size;
    let edgeCount = state.selection.edges.size;
    let groupCount = state.selection.groups.size;

    // Also include single selection if not in multi-select
    if (state.selected) {
      if (state.selected.type === 'node' && !state.selection.nodes.has(state.selected.id)) nodeCount++;
      if (state.selected.type === 'edge' && !state.selection.edges.has(state.selected.id)) edgeCount++;
      if (state.selected.type === 'group' && !state.selection.groups.has(state.selected.id)) groupCount++;
    }

    return { nodes: nodeCount, edges: edgeCount, groups: groupCount };
  }

  function getSelectedItemsOfType(type) {
    const items = [];

    if (type === 'node') {
      state.selection.nodes.forEach(id => {
        const n = findNode(id);
        if (n) items.push(n);
      });
      // Include single selection if applicable
      if (state.selected?.type === 'node' && !state.selection.nodes.has(state.selected.id)) {
        const n = findNode(state.selected.id);
        if (n) items.push(n);
      }
    } else if (type === 'edge') {
      state.selection.edges.forEach(id => {
        const e = findEdge(id);
        if (e) items.push(e);
      });
      if (state.selected?.type === 'edge' && !state.selection.edges.has(state.selected.id)) {
        const e = findEdge(state.selected.id);
        if (e) items.push(e);
      }
    } else if (type === 'group') {
      state.selection.groups.forEach(id => {
        const g = findGroup(id);
        if (g) items.push(g);
      });
      if (state.selected?.type === 'group' && !state.selection.groups.has(state.selected.id)) {
        const g = findGroup(state.selected.id);
        if (g) items.push(g);
      }
    }

    return items;
  }

  function createStyleSwatch(style, type) {
    const swatch = document.createElement('div');
    swatch.className = 'apply-style-swatch';

    // Fill swatch
    const fillDiv = document.createElement('div');
    fillDiv.className = 'apply-style-swatch-fill';

    // Stroke swatch
    const strokeDiv = document.createElement('div');
    strokeDiv.className = 'apply-style-swatch-stroke';

    if (type === 'node') {
      fillDiv.style.background = style.fill || '#1b2030';
      strokeDiv.style.background = style.stroke || '#9fb3ff';
    } else if (type === 'edge') {
      fillDiv.style.background = style.strokeColor || '#6c8ebf';
      strokeDiv.style.display = 'none'; // Edges don't have separate stroke
    } else if (type === 'group') {
      fillDiv.style.background = style.fill || '#ffffff';
      strokeDiv.style.background = style.stroke || '#666666';
    }

    swatch.appendChild(fillDiv);
    swatch.appendChild(strokeDiv);

    return swatch;
  }

  function buildApplyStyleSection(type, count, presets) {
    const section = document.createElement('div');
    section.className = 'apply-style-section';

    // Header
    const header = document.createElement('div');
    header.className = 'apply-style-section-header';

    const typeLabels = { node: 'Node Styles', edge: 'Link Styles', group: 'Container Styles' };
    header.innerHTML = `<span>${typeLabels[type]}</span><span class="count">${count} selected</span>`;
    section.appendChild(header);

    // Style items
    const presetNames = Object.keys(presets || {}).sort((a, b) => a.localeCompare(b));

    if (presetNames.length === 0) {
      const emptyMsg = document.createElement('div');
      emptyMsg.className = 'apply-style-empty-section';
      emptyMsg.textContent = `No ${type} styles saved yet`;
      section.appendChild(emptyMsg);
    } else {
      presetNames.forEach(name => {
        const style = presets[name];
        const item = document.createElement('div');
        item.className = 'apply-style-item';
        item.dataset.type = type;
        item.dataset.preset = name;

        // Swatch preview
        const swatch = createStyleSwatch(style, type);
        item.appendChild(swatch);

        // Name
        const nameSpan = document.createElement('span');
        nameSpan.className = 'apply-style-name';
        nameSpan.textContent = name;
        nameSpan.title = name;
        item.appendChild(nameSpan);

        // Click handler
        item.addEventListener('click', () => {
          applyStyleToSelection(type, name);
        });

        section.appendChild(item);
      });
    }

    return section;
  }

  function applyStyleToSelection(type, presetName) {
    const style = state.stylePresets[type]?.[presetName];
    if (!style) {
      showToast('Style not found.');
      return;
    }

    const items = getSelectedItemsOfType(type);
    if (items.length === 0) {
      showToast('No items to apply style to.');
      return;
    }

    // Apply style to all selected items of this type
    items.forEach(item => {
      applyStyle(type, item, style);
    });

    commit();
    render();

    // Close menu and show confirmation
    applyStyleMenu.hidden = true;
    const typeLabel = type === 'node' ? 'node' : (type === 'edge' ? 'link' : 'container');
    showToast(`Applied "${presetName}" to ${items.length} ${typeLabel}${items.length > 1 ? 's' : ''}`);
  }

  function updateApplyStyleMenu() {
    const counts = getSelectionCounts();
    const hasSelection = counts.nodes > 0 || counts.edges > 0 || counts.groups > 0;

    // Clear content
    applyStyleContent.innerHTML = '';

    if (!hasSelection) {
      applyStyleEmpty.style.display = 'block';
      applyStyleContent.style.display = 'none';
      return;
    }

    applyStyleEmpty.style.display = 'none';
    applyStyleContent.style.display = 'block';

    // Build sections for each type that has selections
    if (counts.nodes > 0) {
      applyStyleContent.appendChild(buildApplyStyleSection('node', counts.nodes, state.stylePresets.node));
    }
    if (counts.edges > 0) {
      applyStyleContent.appendChild(buildApplyStyleSection('edge', counts.edges, state.stylePresets.edge));
    }
    if (counts.groups > 0) {
      applyStyleContent.appendChild(buildApplyStyleSection('group', counts.groups, state.stylePresets.group));
    }
  }

  if (btnApplyStyle && applyStyleMenu) {
    btnApplyStyle.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateApplyStyleMenu();
      applyStyleMenu.hidden = !applyStyleMenu.hidden;
    });

    applyStyleMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }

  if (btnManageStyles) {
    btnManageStyles.addEventListener('click', () => {
      applyStyleMenu.hidden = true;
      showManageStylesDialog();
    });
  }

  // Help Button Handler
  const btnHelp = document.getElementById('btnHelp');
  const helpMenu = document.getElementById('helpMenu');
  if (btnHelp && helpMenu) {
    btnHelp.addEventListener('click', (ev) => { ev.stopPropagation(); toggleMenu(btnHelp, helpMenu); });
    helpMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }

  function showManageStylesDialog() {
    // Create modal dialog for managing styles
    const modal = document.createElement('div');
    modal.id = 'manageStylesModal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); z-index: 10000;
      display: flex; align-items: center; justify-content: center;
    `;

    const dialog = document.createElement('div');
    dialog.style.cssText = `
      background: white; border-radius: 8px; padding: 0;
      min-width: 400px; max-width: 500px; max-height: 80vh;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      display: flex; flex-direction: column;
    `;

    // Header
    const header = document.createElement('div');
    header.style.cssText = `
      padding: 16px 20px; border-bottom: 1px solid #e0e0e0;
      font-size: 16px; font-weight: 600; color: #333;
      display: flex; justify-content: space-between; align-items: center;
    `;
    header.innerHTML = `
      <span>Manage Styles</span>
      <button id="closeManageStyles" style="background:none; border:none; font-size:20px; cursor:pointer; color:#666;">Ã—</button>
    `;
    dialog.appendChild(header);

    // Content
    const content = document.createElement('div');
    content.style.cssText = `padding: 0; overflow-y: auto; flex: 1;`;

    function buildStyleList(type, label) {
      const section = document.createElement('div');
      section.style.cssText = `border-bottom: 1px solid #e8e8e8;`;

      const sectionHeader = document.createElement('div');
      sectionHeader.style.cssText = `
        padding: 10px 20px; background: #f5f5f5;
        font-size: 11px; font-weight: 600; color: #666;
        text-transform: uppercase; letter-spacing: 0.5px;
      `;
      sectionHeader.textContent = label;
      section.appendChild(sectionHeader);

      const presets = state.stylePresets[type] || {};
      const names = Object.keys(presets).sort((a, b) => a.localeCompare(b));

      if (names.length === 0) {
        const empty = document.createElement('div');
        empty.style.cssText = `padding: 12px 20px; color: #999; font-size: 12px; font-style: italic;`;
        empty.textContent = 'No styles saved';
        section.appendChild(empty);
      } else {
        names.forEach(name => {
          const row = document.createElement('div');
          row.style.cssText = `
            display: flex; align-items: center; gap: 10px;
            padding: 10px 20px; border-top: 1px solid #f0f0f0;
          `;

          const swatch = createStyleSwatch(presets[name], type);
          row.appendChild(swatch);

          const nameSpan = document.createElement('span');
          nameSpan.style.cssText = `flex: 1; font-size: 13px;`;
          nameSpan.textContent = name;
          row.appendChild(nameSpan);

          const deleteBtn = document.createElement('button');
          deleteBtn.style.cssText = `
            background: none; border: 1px solid #ddd; border-radius: 4px;
            padding: 4px 8px; font-size: 11px; cursor: pointer; color: #c00;
          `;
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click', () => {
            if (confirm(`Delete style "${name}"?`)) {
              delete state.stylePresets[type][name];
              commit();
              refreshPresetSelects();
              row.remove();
              showToast(`Deleted style: ${name}`);
            }
          });
          row.appendChild(deleteBtn);

          section.appendChild(row);
        });
      }

      return section;
    }

    content.appendChild(buildStyleList('node', 'Node Styles'));
    content.appendChild(buildStyleList('edge', 'Link Styles'));
    content.appendChild(buildStyleList('group', 'Container Styles'));

    dialog.appendChild(content);

    // Footer
    const footer = document.createElement('div');
    footer.style.cssText = `
      padding: 12px 20px; border-top: 1px solid #e0e0e0;
      display: flex; justify-content: flex-end;
    `;
    footer.innerHTML = `<button class="btn" id="closeManageStylesBtn">Close</button>`;
    dialog.appendChild(footer);

    modal.appendChild(dialog);
    document.body.appendChild(modal);

    // Event handlers
    const closeModal = () => modal.remove();
    modal.querySelector('#closeManageStyles').addEventListener('click', closeModal);
    modal.querySelector('#closeManageStylesBtn').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
    document.addEventListener('keydown', function escHandler(e) {
      if (e.key === 'Escape') {
        closeModal();
        document.removeEventListener('keydown', escHandler);
      }
    });
  }

  const btnCreateLink = document.getElementById('btnCreateLink');

  let linkMode = false;
  let linkSourceNode = null;  // Track the source node ID

  // Expose to window for MapLibre and other views to access
  window.linkMode = linkMode;
  window.linkSourceNode = linkSourceNode;

  function clearLinkMode() {
    linkMode = false;
    linkSourceNode = null;
    window.linkMode = false;
    window.linkSourceNode = null;
    state.connectFrom = null;
    btnCreateLink.classList.remove('primary');
  }

  btnCreateLink.addEventListener('click', (ev) => {
    ev.stopPropagation();
    linkMode = !linkMode;
    linkSourceNode = null;
    window.linkMode = linkMode;
    window.linkSourceNode = null;
    state.connectFrom = null;
    btnCreateLink.classList.toggle('primary', linkMode);
    console.log(`[LINK MODE] ${linkMode ? 'ACTIVATED' : 'DEACTIVATED'} - linkMode=${linkMode}, linkSourceNode=${linkSourceNode}`);
    if (linkMode) {
      // Check if a node is already selected
      if (state.selected && state.selected.type === 'node') {
        linkSourceNode = state.selected.id;
        window.linkSourceNode = linkSourceNode;
        const node = findNode(linkSourceNode);
        console.log(`[LINK MODE] Node ${linkSourceNode} already selected - using as source`);
        showToast(`Link source: ${node?.name || `N${linkSourceNode}`} â†’ Click target node`);
      } else {
        console.log(`[LINK MODE] No node selected - waiting for first click`);
        showToast('Link mode ON - Click first node');
      }
    } else {
      showToast('Link mode OFF');
    }
    render();
  });

  // Zoom controls
  const btnZoomIn = document.getElementById('btnZoomIn');
  const btnZoomOut = document.getElementById('btnZoomOut');
  const btnZoomFit = document.getElementById('btnZoomFit');
  const btnZoomLevel = document.getElementById('btnZoomLevel');
  const zoomMenu = document.getElementById('zoomMenu');

  if (btnZoomIn) {
    btnZoomIn.addEventListener('click', () => {
      setZoom(state.zoom * 1.2);
    });
  }

  if (btnZoomOut) {
    btnZoomOut.addEventListener('click', () => {
      setZoom(state.zoom / 1.2);
    });
  }

  if (btnZoomFit) {
    btnZoomFit.addEventListener('click', () => {
      fitToView();
    });
  }

  // Zoom dropdown menu
  if (btnZoomLevel && zoomMenu) {
    btnZoomLevel.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      zoomMenu.hidden = !zoomMenu.hidden;
      if (!zoomMenu.hidden) {
        const r = btnZoomLevel.getBoundingClientRect();
        zoomMenu.style.left = '0';
        zoomMenu.style.top = '100%';
      }
    });

    // Zoom preset items
    zoomMenu.querySelectorAll('.zoom-preset').forEach(item => {
      item.addEventListener('click', () => {
        const zoom = parseFloat(item.dataset.zoom);
        if (zoom) setZoom(zoom);
        zoomMenu.hidden = true;
      });
    });

    // Fit to view
    const zoomFitView = document.getElementById('zoomFitView');
    if (zoomFitView) {
      zoomFitView.addEventListener('click', () => {
        fitToView();
        zoomMenu.hidden = true;
      });
    }

    // Reset to 100%
    const zoomReset = document.getElementById('zoomReset');
    if (zoomReset) {
      zoomReset.addEventListener('click', () => {
        setZoom(1.0);
        zoomMenu.hidden = true;
      });
    }

    // Close menu when clicking outside
    document.addEventListener('click', () => {
      zoomMenu.hidden = true;
    });

    zoomMenu.addEventListener('click', (ev) => {
      ev.stopPropagation();
    });
  }

  // Keyboard shortcut for reset zoom
  window.addEventListener('keydown', (ev) => {
    if ((ev.ctrlKey || ev.metaKey) && ev.key === '0') {
      ev.preventDefault();
      setZoom(1.0);
    }
  });

  // Grid toggle and settings
  const btnGridToggle = document.getElementById('btnGridToggle');
  const gridMenu = document.getElementById('gridMenu');
  const gridEnabledCheckbox = document.getElementById('gridEnabled');

  if (btnGridToggle && gridMenu) {
    btnGridToggle.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      gridMenu.hidden = !gridMenu.hidden;
    });

    // Grid enable/disable checkbox
    if (gridEnabledCheckbox) {
      gridEnabledCheckbox.addEventListener('change', () => {
        state.gridEnabled = gridEnabledCheckbox.checked;
        btnGridToggle.classList.toggle('active', state.gridEnabled);
        render();
      });
    }

    // Grid size options
    gridMenu.querySelectorAll('.grid-size').forEach(item => {
      item.addEventListener('click', () => {
        const size = parseInt(item.dataset.size);
        if (size) {
          state.gridSize = size;
          // Update active state
          gridMenu.querySelectorAll('.grid-size').forEach(i => i.classList.remove('active'));
          item.classList.add('active');
          render();
        }
      });
    });

    // Close menu when clicking outside
    document.addEventListener('click', () => {
      gridMenu.hidden = true;
    });

    gridMenu.addEventListener('click', (ev) => {
      ev.stopPropagation();
    });

    // Initialize button state
    btnGridToggle.classList.toggle('active', state.gridEnabled);
  }

  // ============== TAG FILTER SYSTEM ==============
  const btnUnifiedFilter = document.getElementById('btnUnifiedFilter');
  const unifiedFilterPanel = document.getElementById('unifiedFilterPanel');
  const filterBadge = document.getElementById('filterBadge');
  const tagFilterList = document.getElementById('tagFilterList');
  const btnTagSelectAll = document.getElementById('btnTagSelectAll');
  const btnTagClearAll = document.getElementById('btnTagClearAll');
  const miTagFilter = document.getElementById('miTagFilter');
  const tagFilterAccordion = document.getElementById('tagFilterAccordion');

  // Collect all unique tags from nodes, edges, and groups - returns separate counts
  function collectAllTags() {
    const nodeTags = new Map();
    const edgeTags = new Map();
    const groupTags = new Map();
    const cableSystemTags = new Map();
    const allTags = new Set();

    // Count from nodes
    for (const node of state.nodes) {
      const tags = getNodeTags(node);
      for (const tag of tags) {
        nodeTags.set(tag, (nodeTags.get(tag) || 0) + 1);
        allTags.add(tag);
      }
    }
    // Count from edges
    for (const edge of state.edges) {
      const tags = getEdgeTags(edge);
      for (const tag of tags) {
        edgeTags.set(tag, (edgeTags.get(tag) || 0) + 1);
        allTags.add(tag);
      }
    }
    // Count from groups
    for (const group of state.groups) {
      const tags = getGroupTags(group);
      for (const tag of tags) {
        groupTags.set(tag, (groupTags.get(tag) || 0) + 1);
        allTags.add(tag);
      }
    }
    // Count from cable systems
    for (const cs of state.cableSystems) {
      const tags = getCableSystemTags(cs);
      for (const tag of tags) {
        cableSystemTags.set(tag, (cableSystemTags.get(tag) || 0) + 1);
        allTags.add(tag);
      }
    }
    return { nodeTags, edgeTags, groupTags, cableSystemTags, allTags };
  }

  // Get all tags for a cable system
  function getCableSystemTags(cs) {
    const tags = new Set();
    tags.add('default');
    if (Array.isArray(cs.filterTags)) {
      cs.filterTags.forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    return tags;
  }

  // Get all tags for a node (from tags array + extraTags)
  function getNodeTags(node) {
    const tags = new Set();
    // Always add 'default' tag
    tags.add('default');
    // Add from tags array
    if (Array.isArray(node.tags)) {
      node.tags.forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    // Add from extraTags (comma-separated)
    if (node.extraTags) {
      node.extraTags.split(',').forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    return tags;
  }

  // Get all tags for an edge (from filterTags array + extraTags)
  function getEdgeTags(edge) {
    const tags = new Set();
    // Always add 'default' tag
    tags.add('default');
    // Add from filterTags array
    if (Array.isArray(edge.filterTags)) {
      edge.filterTags.forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    // Add from extraTags (comma-separated)
    if (edge.extraTags) {
      edge.extraTags.split(',').forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    return tags;
  }

  // Get all tags for a group (from filterTags array + extraTags)
  function getGroupTags(group) {
    const tags = new Set();
    // Always add 'default' tag
    tags.add('default');
    // Add from filterTags array
    if (Array.isArray(group.filterTags)) {
      group.filterTags.forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    // Add from extraTags (comma-separated)
    if (group.extraTags) {
      group.extraTags.split(',').forEach(t => {
        const trimmed = t.trim().toLowerCase();
        if (trimmed) tags.add(trimmed);
      });
    }
    return tags;
  }

  // Check if a node should be visible based on current filter
  function isNodeVisible(node) {
    // ========== CHECK EXCLUSIVE MODES FIRST ==========
    // If Tag Filter is exclusive, ONLY apply tag filter (bypass all other filters)
    if (state.tagFilter.exclusive && state.tagFilter.mode !== 'all') {
      const nodeTags = getNodeTags(node);
      const selectedTags = state.tagFilter.selectedTags;
      if (selectedTags.size === 0) return true;

      let hasSelectedTag = false;
      for (const tag of nodeTags) {
        if (selectedTags.has(tag)) {
          hasSelectedTag = true;
          break;
        }
      }

      if (state.tagFilter.mode === 'include') {
        // Node is visible if it has a selected tag
        if (hasSelectedTag) return true;

        // OR if any connected edge has a selected tag
        const connectedEdges = state.edges.filter(e => e.a === node.id || e.b === node.id);
        for (const edge of connectedEdges) {
          const edgeTags = getEdgeTags(edge);
          for (const tag of edgeTags) {
            if (selectedTags.has(tag)) {
              return true;
            }
          }
        }
        return false;
      }
      if (state.tagFilter.mode === 'exclude') return !hasSelectedTag;
      return true;
    }

    // If Cable System Filter is exclusive, ONLY apply cable system filter (bypass container/node/tag filters)
    if (state.cableSystemFilter.exclusive &&
        state.cableSystemFilter.mode === 'selected' &&
        state.cableSystemFilter.selectedSystems.size > 0) {
      const nodeCSIds = node.cableSystemIds || [];
      const isUnmapped = nodeCSIds.length === 0;

      if (isUnmapped && state.cableSystemFilter.showUnmapped) {
        return true;
      }
      // Check if node belongs to any selected cable system
      for (const csId of nodeCSIds) {
        if (state.cableSystemFilter.selectedSystems.has(csId)) {
          return true;
        }
      }
      // Also check if any connected edge belongs to a selected cable system
      const connectedEdges = state.edges.filter(e => e.a === node.id || e.b === node.id);
      for (const edge of connectedEdges) {
        const edgeCSId = edge.cableSystemId;
        if (edgeCSId && state.cableSystemFilter.selectedSystems.has(edgeCSId)) {
          return true;
        }
        // Check if edge is unmapped and we're showing unmapped
        if ((edgeCSId === null || edgeCSId === undefined) && state.cableSystemFilter.showUnmapped) {
          return true;
        }
      }
      return false;
    }

    // ========== NORMAL FILTER HIERARCHY ==========
    // Check Container Filter first
    if (state.containerFilter.mode === 'selected' &&
        (state.containerFilter.selectedBoxes.size > 0 || state.containerFilter.selectedGroups.size > 0)) {

      let passesContainerFilter = false;

      // Check if node is in a selected box
      if (node.groupId && state.containerFilter.selectedBoxes.has(node.groupId)) {
        passesContainerFilter = true;
      }

      // Check if node is in a box that belongs to a selected group
      if (!passesContainerFilter && node.groupId) {
        const nodeBox = findGroup(node.groupId);
        if (nodeBox && nodeBox.parentId && state.containerFilter.selectedGroups.has(nodeBox.parentId)) {
          passesContainerFilter = true;
        }
      }

      if (state.containerFilter.exclusive) {
        return passesContainerFilter;
      }
      if (!passesContainerFilter) return false;
    }

    // Check Node Filter
    if (state.nodeFilter.mode === 'selected' && state.nodeFilter.selectedNodes.size > 0) {
      const passesNodeFilter = state.nodeFilter.selectedNodes.has(node.id);
      if (state.nodeFilter.exclusive) {
        return passesNodeFilter;
      }
      if (!passesNodeFilter) return false;
    }

    // Check Cable System Filter (non-exclusive mode)
    if (state.cableSystemFilter.mode === 'selected' && state.cableSystemFilter.selectedSystems.size > 0) {
      const nodeCSIds = node.cableSystemIds || [];
      const isUnmapped = nodeCSIds.length === 0;

      let passesCSFilter = false;
      if (isUnmapped && state.cableSystemFilter.showUnmapped) {
        passesCSFilter = true;
      } else {
        // Check if node belongs to any selected cable system
        for (const csId of nodeCSIds) {
          if (state.cableSystemFilter.selectedSystems.has(csId)) {
            passesCSFilter = true;
            break;
          }
        }
      }

      // Also check if any connected edge belongs to a selected cable system
      if (!passesCSFilter) {
        const connectedEdges = state.edges.filter(e => e.a === node.id || e.b === node.id);
        for (const edge of connectedEdges) {
          const edgeCSId = edge.cableSystemId;
          if (edgeCSId && state.cableSystemFilter.selectedSystems.has(edgeCSId)) {
            passesCSFilter = true;
            break;
          }
          // Check if edge is unmapped and we're showing unmapped
          if ((edgeCSId === null || edgeCSId === undefined) && state.cableSystemFilter.showUnmapped) {
            passesCSFilter = true;
            break;
          }
        }
      }

      if (!passesCSFilter) return false;
    }

    // Check Tag Filter (non-exclusive mode)
    if (state.tagFilter.mode === 'all') return true;

    const nodeTags = getNodeTags(node);
    const selectedTags = state.tagFilter.selectedTags;

    if (selectedTags.size === 0) return true; // No tags selected = show all

    // Check if node has ANY of the selected tags
    let hasSelectedTag = false;
    for (const tag of nodeTags) {
      if (selectedTags.has(tag)) {
        hasSelectedTag = true;
        break;
      }
    }

    if (state.tagFilter.mode === 'include') {
      // Node is visible if it has a selected tag
      if (hasSelectedTag) return true;

      // OR if any connected edge has a selected tag (so edges with tags can be shown)
      const connectedEdges = state.edges.filter(e => e.a === node.id || e.b === node.id);
      for (const edge of connectedEdges) {
        const edgeTags = getEdgeTags(edge);
        for (const tag of edgeTags) {
          if (selectedTags.has(tag)) {
            return true;
          }
        }
      }
      return false;
    } else if (state.tagFilter.mode === 'exclude') {
      return !hasSelectedTag;
    }

    return true;
  }

  // Check if an edge should be visible
  // Hierarchy: Check container filter, node filter, cable system filter, then tag filter
  function isEdgeVisible(edge) {
    const nodeA = findNode(edge.a);
    const nodeB = findNode(edge.b);
    if (!nodeA || !nodeB) return false;

    // ========== CHECK EXCLUSIVE MODES FIRST ==========
    // If Tag Filter is exclusive, ONLY apply tag filter (bypass all other filters except node visibility)
    if (state.tagFilter.exclusive && state.tagFilter.mode !== 'all') {
      // Still need both nodes to be visible (using tag filter logic)
      if (!isNodeVisible(nodeA) || !isNodeVisible(nodeB)) return false;

      const edgeTags = getEdgeTags(edge);
      const selectedTags = state.tagFilter.selectedTags;
      if (selectedTags.size === 0) return true;

      let hasSelectedTag = false;
      for (const tag of edgeTags) {
        if (selectedTags.has(tag)) {
          hasSelectedTag = true;
          break;
        }
      }

      if (state.tagFilter.mode === 'include') return hasSelectedTag;
      if (state.tagFilter.mode === 'exclude') return !hasSelectedTag;
      return true;
    }

    // If Cable System Filter is exclusive, ONLY apply cable system filter
    if (state.cableSystemFilter.exclusive &&
        state.cableSystemFilter.mode === 'selected' &&
        state.cableSystemFilter.selectedSystems.size > 0) {
      const edgeCSId = edge.cableSystemId;
      const isUnmapped = edgeCSId === null || edgeCSId === undefined;

      if (isUnmapped && state.cableSystemFilter.showUnmapped) {
        return true;
      }
      if (edgeCSId && state.cableSystemFilter.selectedSystems.has(edgeCSId)) {
        return true;
      }
      return false;
    }

    // ========== NORMAL FILTER HIERARCHY ==========
    // Check Container Filter (both nodes must be in selected containers)
    if (state.containerFilter.mode === 'selected' &&
        (state.containerFilter.selectedBoxes.size > 0 || state.containerFilter.selectedGroups.size > 0)) {

      // Helper to check if a node is in a selected container
      const nodeInSelectedContainer = (node) => {
        // Check if node is in a selected box
        if (node.groupId && state.containerFilter.selectedBoxes.has(node.groupId)) {
          return true;
        }
        // Check if node is in a box that belongs to a selected group
        if (node.groupId) {
          const nodeBox = findGroup(node.groupId);
          if (nodeBox && nodeBox.parentId && state.containerFilter.selectedGroups.has(nodeBox.parentId)) {
            return true;
          }
        }
        return false;
      };

      const bothNodesInContainer = nodeInSelectedContainer(nodeA) && nodeInSelectedContainer(nodeB);

      if (state.containerFilter.exclusive) {
        return bothNodesInContainer;
      }
      if (!bothNodesInContainer) return false;
    }

    // Check Node Filter (show edges connecting to selected nodes)
    if (state.nodeFilter.mode === 'selected' && state.nodeFilter.selectedNodes.size > 0) {
      const connectedToSelectedNode = state.nodeFilter.selectedNodes.has(edge.a) ||
                                       state.nodeFilter.selectedNodes.has(edge.b);
      if (state.nodeFilter.exclusive) {
        return connectedToSelectedNode;
      }
      if (!connectedToSelectedNode) return false;
    }

    // Check Cable System Filter (non-exclusive mode)
    if (state.cableSystemFilter.mode === 'selected' && state.cableSystemFilter.selectedSystems.size > 0) {
      const edgeCSId = edge.cableSystemId;
      const isUnmapped = edgeCSId === null || edgeCSId === undefined;

      let passesCSFilter = false;
      if (isUnmapped && state.cableSystemFilter.showUnmapped) {
        passesCSFilter = true;
      } else if (edgeCSId && state.cableSystemFilter.selectedSystems.has(edgeCSId)) {
        passesCSFilter = true;
      }

      if (!passesCSFilter) return false;
    }

    // FIRST: Both nodes must be visible (node filtering takes priority)
    if (!isNodeVisible(nodeA) || !isNodeVisible(nodeB)) return false;

    // THEN: Apply edge's own tag filter (non-exclusive mode, only if nodes are visible)
    if (state.tagFilter.mode === 'all') return true;

    const edgeTags = getEdgeTags(edge);
    const selectedTags = state.tagFilter.selectedTags;

    if (selectedTags.size === 0) return true;

    let hasSelectedTag = false;
    for (const tag of edgeTags) {
      if (selectedTags.has(tag)) {
        hasSelectedTag = true;
        break;
      }
    }

    if (state.tagFilter.mode === 'include') {
      return hasSelectedTag;
    } else if (state.tagFilter.mode === 'exclude') {
      return !hasSelectedTag;
    }

    return true;
  }

  // Check if a group contains any visible nodes
  function groupHasVisibleNodes(group) {
    return state.nodes.some(n => n.groupId === group.id && isNodeVisible(n));
  }

  // Check if a group should be visible based on current filter
  // Hierarchy: First check if group contains visible nodes, then apply group's own tag filter
  function isGroupVisible(group) {
    // Always show empty containers (so users can see and work with them)
    // Only apply filtering to containers that have content

    if (group.type === 'region') {
      // Region: check if it has any country boxes (visible or not)
      const hasAnyCountry = state.groups.some(g =>
        g.type === 'country' && g.parentId === group.id
      );
      // If region has no children, always show it (empty region)
      // If region has children, check if any are visible
      if (hasAnyCountry) {
        const hasVisibleCountry = state.groups.some(g =>
          g.type === 'country' && g.parentId === group.id && isCountryBoxVisible(g)
        );
        if (!hasVisibleCountry) return false;
      }
    } else {
      // Country box: check if it has any nodes
      const hasAnyNodes = state.nodes.some(n => n.groupId === group.id);
      // If container has no nodes, always show it (empty container)
      // If container has nodes, check if any are visible
      if (hasAnyNodes && !groupHasVisibleNodes(group)) return false;
    }

    // THEN: Apply group's own tag filter (only if it has visible content)
    if (state.tagFilter.mode === 'all') return true;

    const groupTags = getGroupTags(group);
    const selectedTags = state.tagFilter.selectedTags;

    if (selectedTags.size === 0) return true;

    let hasSelectedTag = false;
    for (const tag of groupTags) {
      if (selectedTags.has(tag)) {
        hasSelectedTag = true;
        break;
      }
    }

    if (state.tagFilter.mode === 'include') {
      return hasSelectedTag;
    } else if (state.tagFilter.mode === 'exclude') {
      return !hasSelectedTag;
    }

    return true;
  }

  // Helper for country boxes specifically (checks if it has visible nodes)
  function isCountryBoxVisible(group) {
    if (group.type !== 'country') return isGroupVisible(group);

    // Check if it has any nodes
    const hasAnyNodes = state.nodes.some(n => n.groupId === group.id);
    // If container has no nodes, always show it (empty container)
    // If container has nodes, check if any are visible
    if (hasAnyNodes && !groupHasVisibleNodes(group)) return false;

    // Then apply tag filter
    if (state.tagFilter.mode === 'all') return true;

    const groupTags = getGroupTags(group);
    const selectedTags = state.tagFilter.selectedTags;

    if (selectedTags.size === 0) return true;

    let hasSelectedTag = false;
    for (const tag of groupTags) {
      if (selectedTags.has(tag)) {
        hasSelectedTag = true;
        break;
      }
    }

    if (state.tagFilter.mode === 'include') {
      return hasSelectedTag;
    } else if (state.tagFilter.mode === 'exclude') {
      return !hasSelectedTag;
    }

    return true;
  }

  // Update the tag filter list UI
  function updateTagFilterList() {
    if (!tagFilterList) return;

    const { nodeTags, edgeTags, groupTags, cableSystemTags, allTags } = collectAllTags();
    tagFilterList.innerHTML = '';

    // Helper function to sort tags (default first, then alphabetically)
    const sortTags = (tagsMap) => {
      return Array.from(tagsMap.keys()).sort((a, b) => {
        if (a === 'default') return -1;
        if (b === 'default') return 1;
        return a.localeCompare(b);
      });
    };

    // Helper function to create a tag item
    const createTagItem = (tag, count) => {
      const label = document.createElement('label');
      label.className = 'tag-filter-item';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = state.tagFilter.selectedTags.has(tag);
      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          state.tagFilter.selectedTags.add(tag);
        } else {
          state.tagFilter.selectedTags.delete(tag);
        }
        updateFilterButtonState();
        render();
      });

      const nameSpan = document.createElement('span');
      nameSpan.className = 'tag-name';
      nameSpan.textContent = tag;

      const countSpan = document.createElement('span');
      countSpan.className = 'tag-count';
      countSpan.textContent = count;

      label.appendChild(checkbox);
      label.appendChild(nameSpan);
      label.appendChild(countSpan);
      return label;
    };

    // Helper function to create section header
    const createSectionHeader = (title, icon) => {
      const header = document.createElement('div');
      header.style.cssText = 'padding:6px 12px; font-size:11px; font-weight:600; color:#666; background:#f5f5f5; border-top:1px solid #e0e0e0; border-bottom:1px solid #e0e0e0;';
      header.textContent = `${icon} ${title}`;
      return header;
    };

    // Node Tags Section
    if (nodeTags.size > 0) {
      tagFilterList.appendChild(createSectionHeader('Node Tags', 'â—‹'));
      const sortedNodeTags = sortTags(nodeTags);
      for (const tag of sortedNodeTags) {
        tagFilterList.appendChild(createTagItem(tag, nodeTags.get(tag)));
      }
    }

    // Link Tags Section
    if (edgeTags.size > 0) {
      tagFilterList.appendChild(createSectionHeader('Link Tags', 'â†—'));
      const sortedEdgeTags = sortTags(edgeTags);
      for (const tag of sortedEdgeTags) {
        tagFilterList.appendChild(createTagItem(tag, edgeTags.get(tag)));
      }
    }

    // Box Tags Section
    if (groupTags.size > 0) {
      tagFilterList.appendChild(createSectionHeader('Container Box Tags', 'â–¢'));
      const sortedGroupTags = sortTags(groupTags);
      for (const tag of sortedGroupTags) {
        tagFilterList.appendChild(createTagItem(tag, groupTags.get(tag)));
      }
    }

    // Cable System Tags Section
    if (cableSystemTags.size > 0) {
      tagFilterList.appendChild(createSectionHeader('Cable System Tags', 'â›¡'));
      const sortedCSTags = sortTags(cableSystemTags);
      for (const tag of sortedCSTags) {
        tagFilterList.appendChild(createTagItem(tag, cableSystemTags.get(tag)));
      }
    }
  }

  // Update unified filter button badge and indicator dots
  function updateFilterButtonState() {
    const tagActive = state.tagFilter.mode !== 'all' && state.tagFilter.selectedTags.size > 0;
    const cableActive = state.cableSystemFilter.mode !== 'all' && state.cableSystemFilter.selectedSystems.size > 0;
    const nodeActive = state.nodeFilter.mode !== 'all' && state.nodeFilter.selectedNodes.size > 0;
    const containerActive = state.containerFilter.mode !== 'all' &&
      (state.containerFilter.selectedBoxes.size > 0 || state.containerFilter.selectedGroups.size > 0);

    const count = [tagActive, cableActive, nodeActive, containerActive].filter(Boolean).length;

    if (btnUnifiedFilter) {
      btnUnifiedFilter.classList.toggle('filtering', count > 0);
    }
    if (filterBadge) {
      filterBadge.textContent = count;
    }

    // Update indicator dots
    const dotTag = document.getElementById('dotTagFilter');
    const dotCable = document.getElementById('dotCableSystemFilter');
    const dotNode = document.getElementById('dotNodeFilter');
    const dotContainer = document.getElementById('dotContainerFilter');
    if (dotTag) dotTag.classList.toggle('active', tagActive);
    if (dotCable) dotCable.classList.toggle('active', cableActive);
    if (dotNode) dotNode.classList.toggle('active', nodeActive);
    if (dotContainer) dotContainer.classList.toggle('active', containerActive);
  }

  // Toggle unified filter panel
  function toggleUnifiedFilterPanel() {
    if (!unifiedFilterPanel) return;
    if (unifiedFilterPanel.hidden) {
      closeAllMenus();
      // Position near the button
      if (btnUnifiedFilter) {
        const rect = btnUnifiedFilter.getBoundingClientRect();
        unifiedFilterPanel.style.left = rect.left + 'px';
        unifiedFilterPanel.style.top = (rect.bottom + 4) + 'px';
      }
      updateTagFilterList();
      unifiedFilterPanel.hidden = false;
    } else {
      unifiedFilterPanel.hidden = true;
    }
  }

  // Unified Filters button click
  if (btnUnifiedFilter) {
    btnUnifiedFilter.addEventListener('click', (ev) => {
      ev.stopPropagation();
      toggleUnifiedFilterPanel();
    });
  }

  // Accordion toggle
  if (unifiedFilterPanel) {
    unifiedFilterPanel.querySelectorAll('.filter-accordion-header').forEach(header => {
      header.addEventListener('click', () => {
        const section = header.closest('.filter-accordion-section');
        const wasExpanded = section.classList.contains('expanded');
        section.classList.toggle('expanded');
        // Populate lists when expanding
        if (!wasExpanded) {
          const filterType = section.dataset.filter;
          if (filterType === 'tags') updateTagFilterList();
          else if (filterType === 'cableSystem') updateCableSystemFilterList();
          else if (filterType === 'node') updateNodeFilterList();
          else if (filterType === 'container') updateContainerFilterList();
        }
      });
    });

    // Prevent panel clicks from propagating
    unifiedFilterPanel.addEventListener('click', (ev) => {
      ev.stopPropagation();
    });
  }

  // Close panel button
  const btnUnifiedFilterClose = document.getElementById('btnUnifiedFilterClose');
  if (btnUnifiedFilterClose) {
    btnUnifiedFilterClose.addEventListener('click', (ev) => {
      ev.stopPropagation();
      if (unifiedFilterPanel) unifiedFilterPanel.hidden = true;
    });
  }

  // Make unified panel draggable
  (function initUnifiedFilterDrag() {
    const handle = document.getElementById('unifiedFilterDragHandle');
    if (!handle || !unifiedFilterPanel) return;
    let isDragging = false, startX, startY, startLeft, startTop;

    handle.addEventListener('mousedown', (ev) => {
      if (ev.target.tagName === 'BUTTON') return;
      isDragging = true;
      const rect = unifiedFilterPanel.getBoundingClientRect();
      startX = ev.clientX;
      startY = ev.clientY;
      startLeft = rect.left;
      startTop = rect.top;
      unifiedFilterPanel.style.position = 'fixed';
      unifiedFilterPanel.style.left = startLeft + 'px';
      unifiedFilterPanel.style.top = startTop + 'px';
      ev.preventDefault();
    });

    document.addEventListener('mousemove', (ev) => {
      if (!isDragging) return;
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;
      let newLeft = startLeft + dx;
      let newTop = startTop + dy;
      const panelRect = unifiedFilterPanel.getBoundingClientRect();
      newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - panelRect.width));
      newTop = Math.max(0, Math.min(newTop, window.innerHeight - panelRect.height));
      unifiedFilterPanel.style.left = newLeft + 'px';
      unifiedFilterPanel.style.top = newTop + 'px';
    });

    document.addEventListener('mouseup', () => { isDragging = false; });
  })();

  // Clear All Filters button
  const btnClearAllFilters = document.getElementById('btnClearAllFilters');
  if (btnClearAllFilters) {
    btnClearAllFilters.addEventListener('click', () => {
      // Reset tag filter
      state.tagFilter.mode = 'all';
      state.tagFilter.selectedTags.clear();
      state.tagFilter.exclusive = false;
      const tagModeAll = document.querySelector('input[name="filterMode"][value="all"]');
      if (tagModeAll) tagModeAll.checked = true;
      const tagExcl = document.getElementById('tagFilterExclusive');
      if (tagExcl) tagExcl.checked = false;

      // Reset cable system filter
      state.cableSystemFilter.mode = 'all';
      state.cableSystemFilter.selectedSystems.clear();
      state.cableSystemFilter.showUnmapped = true;
      state.cableSystemFilter.exclusive = false;
      const cableModeAll = document.querySelector('input[name="cableFilterMode"][value="all"]');
      if (cableModeAll) cableModeAll.checked = true;
      const cableUnmapped = document.getElementById('cableFilterShowUnmapped');
      if (cableUnmapped) cableUnmapped.checked = true;
      const cableExcl = document.getElementById('cableFilterExclusive');
      if (cableExcl) cableExcl.checked = false;

      // Reset node filter
      state.nodeFilter.mode = 'all';
      state.nodeFilter.selectedNodes.clear();
      state.nodeFilter.exclusive = false;
      const nodeModeAll = document.querySelector('input[name="nodeFilterMode"][value="all"]');
      if (nodeModeAll) nodeModeAll.checked = true;
      const nodeExcl = document.getElementById('nodeFilterExclusive');
      if (nodeExcl) nodeExcl.checked = false;

      // Reset container filter
      state.containerFilter.mode = 'all';
      state.containerFilter.selectedBoxes.clear();
      state.containerFilter.selectedGroups.clear();
      state.containerFilter.exclusive = false;
      const contModeAll = document.querySelector('input[name="containerFilterMode"][value="all"]');
      if (contModeAll) contModeAll.checked = true;
      const contExcl = document.getElementById('containerFilterExclusive');
      if (contExcl) contExcl.checked = false;

      updateFilterButtonState();
      render();
    });
  }

  // Tag filter accordion - radio/checkbox/button handlers
  if (tagFilterAccordion) {
    tagFilterAccordion.querySelectorAll('input[name="filterMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        state.tagFilter.mode = radio.value;
        updateFilterButtonState();
        render();
      });
    });

    const tagFilterExclusive = document.getElementById('tagFilterExclusive');
    if (tagFilterExclusive) {
      tagFilterExclusive.addEventListener('change', () => {
        state.tagFilter.exclusive = tagFilterExclusive.checked;
        render();
      });
    }

    if (btnTagSelectAll) {
      btnTagSelectAll.addEventListener('click', () => {
        const tagCounts = collectAllTags();
        state.tagFilter.selectedTags = new Set(tagCounts.keys());
        updateTagFilterList();
        updateFilterButtonState();
        render();
      });
    }

    if (btnTagClearAll) {
      btnTagClearAll.addEventListener('click', () => {
        state.tagFilter.selectedTags.clear();
        updateTagFilterList();
        updateFilterButtonState();
        render();
      });
    }
  }

  // View menu - Tag Filter option
  if (miTagFilter) {
    miTagFilter.addEventListener('click', (ev) => {
      ev.stopPropagation();
      fileMenu.hidden = true;
      if (editMenu) editMenu.hidden = true;
      if (viewMenu) viewMenu.hidden = true;
      const zoomMenu = document.getElementById('zoomMenu');
      if (zoomMenu) zoomMenu.hidden = true;
      const gridMenu = document.getElementById('gridMenu');
      if (gridMenu) gridMenu.hidden = true;

      // Open unified filter panel with tags section expanded
      if (unifiedFilterPanel) {
        if (btnUnifiedFilter) {
          const rect = btnUnifiedFilter.getBoundingClientRect();
          unifiedFilterPanel.style.left = rect.left + 'px';
          unifiedFilterPanel.style.top = (rect.bottom + 4) + 'px';
        }
        updateTagFilterList();
        unifiedFilterPanel.hidden = false;
        // Expand tags section
        const tagsSection = unifiedFilterPanel.querySelector('[data-filter="tags"]');
        if (tagsSection) tagsSection.classList.add('expanded');
      }
    });
  }

  // Keyboard shortcut for filters (F key)
  window.addEventListener('keydown', (ev) => {
    if (ev.key === 'f' || ev.key === 'F') {
      if (ev.target.tagName === 'INPUT' || ev.target.tagName === 'TEXTAREA') return;
      ev.preventDefault();
      toggleUnifiedFilterPanel();
    }
  });

  // Close unified panel when clicking outside
  document.addEventListener('click', () => {
    if (unifiedFilterPanel) unifiedFilterPanel.hidden = true;
  });

  // Add unified panel to closeAllMenus
  const originalCloseAllMenus = closeAllMenus;
  closeAllMenus = function() {
    originalCloseAllMenus();
    if (unifiedFilterPanel) unifiedFilterPanel.hidden = true;
    const fillColorMenu = document.getElementById('fillColorMenu');
    const strokeColorMenu = document.getElementById('strokeColorMenu');
    const linkStyleMenu = document.getElementById('linkStyleMenu');
    const lineWidthMenu = document.getElementById('lineWidthMenu');
    const fontColorMenu = document.getElementById('fontColorMenu');
    const fontTypeMenu = document.getElementById('fontTypeMenu');
    const applyStyleMenu = document.getElementById('applyStyleMenu');
    const helpMenu = document.getElementById('helpMenu');
    if (fillColorMenu) fillColorMenu.hidden = true;
    if (strokeColorMenu) strokeColorMenu.hidden = true;
    if (linkStyleMenu) linkStyleMenu.hidden = true;
    if (lineWidthMenu) lineWidthMenu.hidden = true;
    if (fontColorMenu) fontColorMenu.hidden = true;
    if (fontTypeMenu) fontTypeMenu.hidden = true;
    if (applyStyleMenu) applyStyleMenu.hidden = true;
    if (helpMenu) helpMenu.hidden = true;
  };

  // ============== NODE FILTER ==============
  const nodeFilterAccordion = document.getElementById('nodeFilterAccordion');
  const nodeFilterList = document.getElementById('nodeFilterList');
  const nodeFilterSearch = document.getElementById('nodeFilterSearch');
  const btnNodeSelectAll = document.getElementById('btnNodeSelectAll');
  const btnNodeClearAll = document.getElementById('btnNodeClearAll');

  function updateNodeFilterList() {
    if (!nodeFilterList) return;

    const searchTerm = (nodeFilterSearch?.value || '').toLowerCase();
    const displayMode = state.nodeFilter.displayMode || 'name';

    nodeFilterList.innerHTML = '';

    // Sort nodes by display value
    const sortedNodes = [...state.nodes].sort((a, b) => {
      const aVal = displayMode === 'name' ? (a.name || '') : (a.code || '');
      const bVal = displayMode === 'name' ? (b.name || '') : (b.code || '');
      return aVal.localeCompare(bVal);
    });

    // Filter by search
    const filteredNodes = sortedNodes.filter(n => {
      if (!searchTerm) return true;
      const name = (n.name || '').toLowerCase();
      const code = (n.code || '').toLowerCase();
      return name.includes(searchTerm) || code.includes(searchTerm);
    });

    if (filteredNodes.length === 0) {
      nodeFilterList.innerHTML = '<div class="muted" style="padding:8px 12px;">No nodes found.</div>';
      return;
    }

    filteredNodes.forEach(n => {
      const label = document.createElement('label');
      label.className = 'tag-filter-item';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = state.nodeFilter.selectedNodes.has(n.id);
      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          state.nodeFilter.selectedNodes.add(n.id);
        } else {
          state.nodeFilter.selectedNodes.delete(n.id);
        }
        updateNodeFilterButtonState();
        render();
      });

      const nameSpan = document.createElement('span');
      nameSpan.className = 'tag-name';
      const displayVal = displayMode === 'name' ? (n.name || `Node${n.id}`) : (n.code || `N-${n.id}`);
      const secondary = displayMode === 'name' ? (n.code || '') : (n.name || '');
      nameSpan.innerHTML = `${displayVal} <span style="color:#999; font-size:10px;">${secondary}</span>`;

      // Count connected links
      const linkCount = state.edges.filter(e => e.a === n.id || e.b === n.id).length;
      const countSpan = document.createElement('span');
      countSpan.className = 'tag-count';
      countSpan.textContent = `${linkCount}L`;
      countSpan.title = `${linkCount} connected links`;

      label.appendChild(checkbox);
      label.appendChild(nameSpan);
      label.appendChild(countSpan);
      nodeFilterList.appendChild(label);
    });
  }

  function updateNodeFilterButtonState() {
    updateFilterButtonState();
  }

  // Node filter accordion handlers
  if (nodeFilterAccordion) {
    nodeFilterAccordion.querySelectorAll('input[name="nodeFilterMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        state.nodeFilter.mode = radio.value;
        updateFilterButtonState();
        render();
      });
    });

    nodeFilterAccordion.querySelectorAll('input[name="nodeDisplayMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        state.nodeFilter.displayMode = radio.value;
        updateNodeFilterList();
      });
    });

    const nodeFilterExclusive = document.getElementById('nodeFilterExclusive');
    if (nodeFilterExclusive) {
      nodeFilterExclusive.addEventListener('change', () => {
        state.nodeFilter.exclusive = nodeFilterExclusive.checked;
        render();
      });
    }

    if (btnNodeSelectAll) {
      btnNodeSelectAll.addEventListener('click', () => {
        state.nodes.forEach(n => state.nodeFilter.selectedNodes.add(n.id));
        updateNodeFilterList();
        updateFilterButtonState();
        render();
      });
    }

    if (btnNodeClearAll) {
      btnNodeClearAll.addEventListener('click', () => {
        state.nodeFilter.selectedNodes.clear();
        updateNodeFilterList();
        updateFilterButtonState();
        render();
      });
    }

    if (nodeFilterSearch) {
      nodeFilterSearch.addEventListener('input', () => {
        updateNodeFilterList();
      });
    }
  }

  // ============== CABLE SYSTEM FILTER ==============
  const cableSystemFilterAccordion = document.getElementById('cableSystemFilterAccordion');
  const cableSystemFilterList = document.getElementById('cableSystemFilterList');
  const cableSystemFilterSearch = document.getElementById('cableSystemFilterSearch');
  const btnCableSelectAll = document.getElementById('btnCableSelectAll');
  const btnCableClearAll = document.getElementById('btnCableClearAll');

  function updateCableSystemFilterList() {
    if (!cableSystemFilterList) return;

    const searchTerm = (cableSystemFilterSearch?.value || '').toLowerCase();

    cableSystemFilterList.innerHTML = '';

    const filtered = state.cableSystems.filter(cs => {
      if (!searchTerm) return true;
      return cs.shortName.toLowerCase().includes(searchTerm) ||
             cs.name.toLowerCase().includes(searchTerm);
    });

    if (filtered.length === 0) {
      cableSystemFilterList.innerHTML = '<div class="muted" style="padding:8px 12px;">No cable systems found.</div>';
      return;
    }

    filtered.forEach(cs => {
      const label = document.createElement('label');
      label.className = 'tag-filter-item';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = state.cableSystemFilter.selectedSystems.has(cs.id);
      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          state.cableSystemFilter.selectedSystems.add(cs.id);
        } else {
          state.cableSystemFilter.selectedSystems.delete(cs.id);
        }
        updateCableSystemFilterButtonState();
        render();
      });

      const nameSpan = document.createElement('span');
      nameSpan.className = 'tag-name';
      nameSpan.innerHTML = `<strong>${cs.shortName}</strong> <span style="color:#999; font-size:10px;">${cs.name}</span>`;

      const linkCount = getCableSystemLinks(cs.id).length;
      const countSpan = document.createElement('span');
      countSpan.className = 'tag-count';
      countSpan.textContent = `${linkCount}L`;

      label.appendChild(checkbox);
      label.appendChild(nameSpan);
      label.appendChild(countSpan);
      cableSystemFilterList.appendChild(label);
    });
  }

  function updateCableSystemFilterButtonState() {
    updateFilterButtonState();
  }

  // Cable system filter accordion handlers
  if (cableSystemFilterAccordion) {
    cableSystemFilterAccordion.querySelectorAll('input[name="cableFilterMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        state.cableSystemFilter.mode = radio.value;
        updateFilterButtonState();
        render();
      });
    });

    const cableFilterShowUnmapped = document.getElementById('cableFilterShowUnmapped');
    if (cableFilterShowUnmapped) {
      cableFilterShowUnmapped.addEventListener('change', () => {
        state.cableSystemFilter.showUnmapped = cableFilterShowUnmapped.checked;
        render();
      });
    }

    const cableFilterExclusive = document.getElementById('cableFilterExclusive');
    if (cableFilterExclusive) {
      cableFilterExclusive.addEventListener('change', () => {
        state.cableSystemFilter.exclusive = cableFilterExclusive.checked;
        render();
      });
    }

    if (btnCableSelectAll) {
      btnCableSelectAll.addEventListener('click', () => {
        state.cableSystems.forEach(cs => state.cableSystemFilter.selectedSystems.add(cs.id));
        updateCableSystemFilterList();
        updateFilterButtonState();
        render();
      });
    }

    if (btnCableClearAll) {
      btnCableClearAll.addEventListener('click', () => {
        state.cableSystemFilter.selectedSystems.clear();
        updateCableSystemFilterList();
        updateFilterButtonState();
        render();
      });
    }

    if (cableSystemFilterSearch) {
      cableSystemFilterSearch.addEventListener('input', () => {
        updateCableSystemFilterList();
      });
    }
  }

  // ============== CONTAINER FILTER ==============
  const containerFilterAccordion = document.getElementById('containerFilterAccordion');
  const containerFilterListBoxes = document.getElementById('containerFilterListBoxes');
  const containerFilterListGroups = document.getElementById('containerFilterListGroups');
  const containerFilterSearch = document.getElementById('containerFilterSearch');
  const btnContainerSelectAll = document.getElementById('btnContainerSelectAll');
  const btnContainerClearAll = document.getElementById('btnContainerClearAll');

  function updateContainerFilterList() {
    if (!containerFilterListBoxes || !containerFilterListGroups) return;

    const searchTerm = (containerFilterSearch?.value || '').toLowerCase();

    // Separate boxes (country) and groups (region)
    const boxes = state.groups.filter(g => g.type === 'country' || !g.type);
    const groups = state.groups.filter(g => g.type === 'region');

    // Filter by search
    const filteredBoxes = boxes.filter(g => {
      if (!searchTerm) return true;
      return (g.title || '').toLowerCase().includes(searchTerm);
    });

    const filteredGroups = groups.filter(g => {
      if (!searchTerm) return true;
      return (g.title || '').toLowerCase().includes(searchTerm);
    });

    // Render boxes
    if (filteredBoxes.length === 0) {
      containerFilterListBoxes.innerHTML = '<div class="muted" style="padding:8px 12px; font-size:11px;">No container boxes found.</div>';
    } else {
      containerFilterListBoxes.innerHTML = '';
      filteredBoxes.forEach(g => {
        const label = document.createElement('label');
        label.className = 'tag-filter-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = state.containerFilter.selectedBoxes.has(g.id);
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            state.containerFilter.selectedBoxes.add(g.id);
          } else {
            state.containerFilter.selectedBoxes.delete(g.id);
          }
          updateContainerFilterButtonState();
          render();
        });

        const nameSpan = document.createElement('span');
        nameSpan.className = 'tag-name';
        nameSpan.textContent = g.title || `Container ${g.id}`;

        // Count nodes in this box
        const nodeCount = state.nodes.filter(n => n.groupId === g.id).length;
        const countSpan = document.createElement('span');
        countSpan.className = 'tag-count';
        countSpan.textContent = `${nodeCount}N`;
        countSpan.title = `${nodeCount} nodes`;

        label.appendChild(checkbox);
        label.appendChild(nameSpan);
        label.appendChild(countSpan);
        containerFilterListBoxes.appendChild(label);
      });
    }

    // Render groups
    if (filteredGroups.length === 0) {
      containerFilterListGroups.innerHTML = '<div class="muted" style="padding:8px 12px; font-size:11px;">No groups found.</div>';
    } else {
      containerFilterListGroups.innerHTML = '';
      filteredGroups.forEach(g => {
        const label = document.createElement('label');
        label.className = 'tag-filter-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = state.containerFilter.selectedGroups.has(g.id);
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            state.containerFilter.selectedGroups.add(g.id);
          } else {
            state.containerFilter.selectedGroups.delete(g.id);
          }
          updateContainerFilterButtonState();
          render();
        });

        const nameSpan = document.createElement('span');
        nameSpan.className = 'tag-name';
        nameSpan.textContent = g.title || `Group ${g.id}`;

        // Count child boxes in this group
        const boxCount = state.groups.filter(b => b.parentId === g.id).length;
        const countSpan = document.createElement('span');
        countSpan.className = 'tag-count';
        countSpan.textContent = `${boxCount}B`;
        countSpan.title = `${boxCount} container boxes`;

        label.appendChild(checkbox);
        label.appendChild(nameSpan);
        label.appendChild(countSpan);
        containerFilterListGroups.appendChild(label);
      });
    }
  }

  function updateContainerFilterButtonState() {
    updateFilterButtonState();
  }

  // Container filter accordion handlers
  if (containerFilterAccordion) {
    containerFilterAccordion.querySelectorAll('input[name="containerFilterMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        state.containerFilter.mode = radio.value;
        updateFilterButtonState();
        render();
      });
    });

    const containerFilterExclusive = document.getElementById('containerFilterExclusive');
    if (containerFilterExclusive) {
      containerFilterExclusive.addEventListener('change', () => {
        state.containerFilter.exclusive = containerFilterExclusive.checked;
        render();
      });
    }

    if (btnContainerSelectAll) {
      btnContainerSelectAll.addEventListener('click', () => {
        state.groups.forEach(g => {
          if (g.type === 'region') {
            state.containerFilter.selectedGroups.add(g.id);
          } else {
            state.containerFilter.selectedBoxes.add(g.id);
          }
        });
        updateContainerFilterList();
        updateFilterButtonState();
        render();
      });
    }

    if (btnContainerClearAll) {
      btnContainerClearAll.addEventListener('click', () => {
        state.containerFilter.selectedBoxes.clear();
        state.containerFilter.selectedGroups.clear();
        updateContainerFilterList();
        updateFilterButtonState();
        render();
      });
    }

    if (containerFilterSearch) {
      containerFilterSearch.addEventListener('input', () => {
        updateContainerFilterList();
      });
    }
  }

  // ============== QUICK FORMAT TOOLBAR ==============

  // Standard color palette (Draw.io style) for toolbar
  const toolbarColorPalette = [
    // Row 1 - Basic
    '#ffffff', '#f5f5f5', '#e0e0e0', '#bdbdbd', '#9e9e9e', '#757575', '#424242', '#000000',
    // Row 2 - Blues
    '#e3f2fd', '#90caf9', '#42a5f5', '#1e88e5', '#1565c0', '#0d47a1', '#002171', '#000051',
    // Row 3 - Greens
    '#e8f5e9', '#a5d6a7', '#66bb6a', '#43a047', '#2e7d32', '#1b5e20', '#003300', '#001a00',
    // Row 4 - Oranges/Yellows
    '#fff3e0', '#ffcc80', '#ffa726', '#fb8c00', '#ef6c00', '#e65100', '#bf360c', '#8c2703',
    // Row 5 - Reds/Pinks
    '#ffebee', '#ef9a9a', '#ef5350', '#e53935', '#c62828', '#b71c1c', '#7f0000', '#4a0000',
    // Row 6 - Purples
    '#f3e5f5', '#ce93d8', '#ab47bc', '#8e24aa', '#6a1b9a', '#4a148c', '#2a0050', '#12002a',
    // Row 7 - Cyans
    '#e0f7fa', '#80deea', '#26c6da', '#00acc1', '#00838f', '#006064', '#003d40', '#002020',
    // Row 8 - Draw.io defaults
    '#dae8fc', '#d5e8d4', '#ffe6cc', '#fff2cc', '#f8cecc', '#e1d5e7', '#60a917', '#6c8ebf'
  ];

  // Initialize color grids
  function initColorGrid(gridId, onColorSelect) {
    const grid = document.getElementById(gridId);
    if (!grid) return;
    grid.innerHTML = '';
    toolbarColorPalette.forEach(color => {
      const item = document.createElement('div');
      item.className = 'color-grid-item';
      item.style.backgroundColor = color;
      item.dataset.color = color;
      item.addEventListener('click', () => onColorSelect(color));
      grid.appendChild(item);
    });
  }

  // Fill Color Button
  const btnFillColor = document.getElementById('btnFillColor');
  const fillColorMenu = document.getElementById('fillColorMenu');
  const fillColorIndicator = document.getElementById('fillColorIndicator');
  const fillColorCustom = document.getElementById('fillColorCustom');

  if (btnFillColor && fillColorMenu) {
    initColorGrid('fillColorGrid', (color) => {
      applyFillColor(color);
      fillColorMenu.hidden = true;
    });

    btnFillColor.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      fillColorMenu.hidden = !fillColorMenu.hidden;
    });

    if (fillColorCustom) {
      fillColorCustom.addEventListener('input', (ev) => {
        applyFillColor(ev.target.value);
      });
      fillColorCustom.addEventListener('change', () => {
        fillColorMenu.hidden = true;
      });
    }

    fillColorMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }

  function applyFillColor(color) {
    if (fillColorIndicator) fillColorIndicator.style.backgroundColor = color;

    // Apply to selected elements
    if (state.selected) {
      if (state.selected.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) { n.fill = color; commit(); render(); }
      } else if (state.selected.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) { g.fill = color; commit(); render(); }
      }
    }

    // Apply to multi-selection
    if (state.selection.nodes.size > 0) {
      state.selection.nodes.forEach(id => {
        const n = findNode(id);
        if (n) n.fill = color;
      });
      commit(); render();
    }
    if (state.selection.groups.size > 0) {
      state.selection.groups.forEach(id => {
        const g = findGroup(id);
        if (g) g.fill = color;
      });
      commit(); render();
    }
  }

  // Stroke Color Button
  const btnStrokeColor = document.getElementById('btnStrokeColor');
  const strokeColorMenu = document.getElementById('strokeColorMenu');
  const strokeColorIndicator = document.getElementById('strokeColorIndicator');
  const strokeColorCustom = document.getElementById('strokeColorCustom');

  if (btnStrokeColor && strokeColorMenu) {
    initColorGrid('strokeColorGrid', (color) => {
      applyStrokeColor(color);
      strokeColorMenu.hidden = true;
    });

    btnStrokeColor.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      strokeColorMenu.hidden = !strokeColorMenu.hidden;
    });

    if (strokeColorCustom) {
      strokeColorCustom.addEventListener('input', (ev) => {
        applyStrokeColor(ev.target.value);
      });
      strokeColorCustom.addEventListener('change', () => {
        strokeColorMenu.hidden = true;
      });
    }

    strokeColorMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }

  function applyStrokeColor(color) {
    if (strokeColorIndicator) strokeColorIndicator.style.backgroundColor = color;

    // Apply to selected elements
    if (state.selected) {
      if (state.selected.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) { n.stroke = color; commit(); render(); }
      } else if (state.selected.type === 'edge') {
        const e = findEdge(state.selected.id);
        if (e) { e.strokeColor = color; commit(); render(); }
      } else if (state.selected.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) { g.stroke = color; commit(); render(); }
      }
    }

    // Apply to multi-selection
    if (state.selection.nodes.size > 0) {
      state.selection.nodes.forEach(id => {
        const n = findNode(id);
        if (n) n.stroke = color;
      });
      commit(); render();
    }
    if (state.selection.edges.size > 0) {
      state.selection.edges.forEach(id => {
        const e = findEdge(id);
        if (e) e.strokeColor = color;
      });
      commit(); render();
    }
    if (state.selection.groups.size > 0) {
      state.selection.groups.forEach(id => {
        const g = findGroup(id);
        if (g) g.stroke = color;
      });
      commit(); render();
    }
  }

  // ============== INSPECTOR PALETTE COLOR PICKERS ==============

  // Initialize an inspector color picker
  function initInspectorColorPicker(config) {
    const { pickerId, swatchId, hiddenInputId, customColorId, hexInputId, gridSelector, onChange } = config;

    const picker = document.getElementById(pickerId);
    const swatch = document.getElementById(swatchId);
    const hiddenInput = document.getElementById(hiddenInputId);
    const customColor = document.getElementById(customColorId);
    const hexInput = document.getElementById(hexInputId);
    const dropdown = picker?.querySelector('.inspector-color-dropdown');
    const grid = picker?.querySelector(gridSelector || '.inspector-color-grid');

    if (!picker || !swatch || !dropdown || !grid) return;

    // Build color grid
    grid.innerHTML = '';
    toolbarColorPalette.forEach(color => {
      const item = document.createElement('div');
      item.className = 'inspector-color-grid-item';
      item.style.backgroundColor = color;
      item.dataset.color = color;
      item.addEventListener('click', (ev) => {
        ev.stopPropagation();
        setColor(color);
        dropdown.hidden = true;
      });
      grid.appendChild(item);
    });

    // Swatch click - toggle dropdown
    swatch.addEventListener('click', (ev) => {
      ev.stopPropagation();
      // Close other inspector dropdowns
      document.querySelectorAll('.inspector-color-dropdown').forEach(d => {
        if (d !== dropdown) d.hidden = true;
      });
      dropdown.hidden = !dropdown.hidden;
    });

    // Custom color input
    if (customColor) {
      customColor.addEventListener('input', (ev) => {
        setColor(ev.target.value);
        if (hexInput) hexInput.value = ev.target.value;
      });
    }

    // Hex input
    if (hexInput) {
      hexInput.addEventListener('change', () => {
        let val = hexInput.value.trim();
        if (val && !val.startsWith('#')) val = '#' + val;
        if (/^#[0-9A-Fa-f]{6}$/.test(val)) {
          setColor(val);
          if (customColor) customColor.value = val;
        }
      });
    }

    // Dropdown click - prevent close
    dropdown.addEventListener('click', (ev) => ev.stopPropagation());

    function setColor(color) {
      swatch.style.backgroundColor = color;
      if (hiddenInput) hiddenInput.value = color;
      if (hexInput) hexInput.value = color;
      if (customColor) customColor.value = color;
      if (onChange) onChange(color);
    }

    // Return update function
    return {
      setValue: (color) => {
        swatch.style.backgroundColor = color;
        if (hiddenInput) hiddenInput.value = color;
        if (hexInput) hexInput.value = color;
        if (customColor) customColor.value = color;
      }
    };
  }

  // Close inspector dropdowns when clicking outside
  document.addEventListener('click', () => {
    document.querySelectorAll('.inspector-color-dropdown').forEach(d => d.hidden = true);
  });

  // Initialize all inspector color pickers
  const inspectorColorPickers = {};

  // Node Fill Color
  inspectorColorPickers.nodeFill = initInspectorColorPicker({
    pickerId: 'nodeFillPicker',
    swatchId: 'nodeFillSwatch',
    hiddenInputId: 'nodeFill',
    customColorId: 'nodeFillCustom',
    hexInputId: 'nodeFillHex',
    onChange: (color) => {
      if (state.selected?.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) { n.fill = color; commit(); render(); }
      }
    }
  });

  // Node Stroke Color
  inspectorColorPickers.nodeStroke = initInspectorColorPicker({
    pickerId: 'nodeStrokePicker',
    swatchId: 'nodeStrokeSwatch',
    hiddenInputId: 'nodeStroke',
    customColorId: 'nodeStrokeCustom',
    hexInputId: 'nodeStrokeHex',
    onChange: (color) => {
      if (state.selected?.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) { n.stroke = color; commit(); render(); }
      }
    }
  });

  // Edge Stroke Color
  inspectorColorPickers.edgeStrokeColor = initInspectorColorPicker({
    pickerId: 'edgeStrokeColorPicker',
    swatchId: 'edgeStrokeColorSwatch',
    hiddenInputId: 'edgeStrokeColor',
    customColorId: 'edgeStrokeColorCustom',
    hexInputId: 'edgeStrokeColorHex',
    onChange: (color) => {
      if (state.selected?.type === 'edge') {
        const e = findEdge(state.selected.id);
        if (e) { e.strokeColor = color; commit(); render(); }
      }
    }
  });

  // Group Fill Color
  inspectorColorPickers.groupFillColor = initInspectorColorPicker({
    pickerId: 'groupFillColorPicker',
    swatchId: 'groupFillColorSwatch',
    hiddenInputId: 'groupFillColor',
    customColorId: 'groupFillColorCustom',
    hexInputId: 'groupFillColorHex',
    onChange: (color) => {
      if (state.selected?.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) {
          // Combine with opacity
          const opacity = parseInt(document.getElementById('groupFillOpacity')?.value || 100) / 100;
          g.fill = hexToRgba(color, opacity);
          document.getElementById('groupFill').value = g.fill;
          commit(); render();
        }
      }
    }
  });

  // Group Stroke Color
  inspectorColorPickers.groupStroke = initInspectorColorPicker({
    pickerId: 'groupStrokePicker',
    swatchId: 'groupStrokeSwatch',
    hiddenInputId: 'groupStroke',
    customColorId: 'groupStrokeCustom',
    hexInputId: 'groupStrokeHex',
    onChange: (color) => {
      if (state.selected?.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) { g.stroke = color; commit(); render(); }
      }
    }
  });

  // Convert the inline field-color-swatch elements to palette pickers
  function initInlineColorSwatch(swatchContainerId, colorInputId, onChange) {
    const container = document.getElementById(swatchContainerId);
    const colorInput = document.getElementById(colorInputId);

    if (!container || !colorInput) return;

    // Create dropdown
    const dropdown = document.createElement('div');
    dropdown.className = 'inspector-color-dropdown';
    dropdown.hidden = true;
    dropdown.style.cssText = 'top: 24px; left: -80px;';

    // Build grid
    const grid = document.createElement('div');
    grid.className = 'inspector-color-grid';
    toolbarColorPalette.forEach(color => {
      const item = document.createElement('div');
      item.className = 'inspector-color-grid-item';
      item.style.backgroundColor = color;
      item.addEventListener('click', (ev) => {
        ev.stopPropagation();
        colorInput.value = color;
        container.style.backgroundColor = color;
        dropdown.hidden = true;
        if (onChange) onChange(color);
      });
      grid.appendChild(item);
    });
    dropdown.appendChild(grid);

    // Custom color row
    const customRow = document.createElement('div');
    customRow.className = 'inspector-color-custom';
    customRow.innerHTML = `
      <input type="color" value="${colorInput.value}" />
      <span>Custom</span>
    `;
    const customInput = customRow.querySelector('input');
    customInput.addEventListener('input', (ev) => {
      colorInput.value = ev.target.value;
      container.style.backgroundColor = ev.target.value;
      if (onChange) onChange(ev.target.value);
    });
    dropdown.appendChild(customRow);

    // Prevent dropdown close
    dropdown.addEventListener('click', (ev) => ev.stopPropagation());

    container.appendChild(dropdown);

    // Make the container clickable to toggle dropdown
    container.style.cursor = 'pointer';
    container.style.position = 'relative';
    container.addEventListener('click', (ev) => {
      ev.stopPropagation();
      // Close other dropdowns
      document.querySelectorAll('.inspector-color-dropdown').forEach(d => {
        if (d !== dropdown) d.hidden = true;
      });
      // Sync custom input
      customInput.value = colorInput.value;
      dropdown.hidden = !dropdown.hidden;
    });

    // Hide native color input visually but keep for form handling
    colorInput.style.opacity = '0';
    colorInput.style.position = 'absolute';
    colorInput.style.pointerEvents = 'none';
  }

  // Initialize inline color swatches
  initInlineColorSwatch('nodeNameColorSwatch', 'nodeNameColorInline', (color) => {
    if (state.selected?.type === 'node') {
      const n = findNode(state.selected.id);
      if (n) { n.nameColor = color; commit(); render(); }
    }
  });

  initInlineColorSwatch('nodeCodeColorSwatch', 'nodeCodeColorInline', (color) => {
    if (state.selected?.type === 'node') {
      const n = findNode(state.selected.id);
      if (n) { n.tagColor = color; commit(); render(); }
    }
  });

  initInlineColorSwatch('nodeExtraTagsColorSwatch', 'nodeExtraTagsColorInline', (color) => {
    if (state.selected?.type === 'node') {
      const n = findNode(state.selected.id);
      if (n) { n.extraTagsColor = color; commit(); render(); }
    }
  });

  initInlineColorSwatch('edgeTagColorSwatch', 'edgeTagColorInline', (color) => {
    if (state.selected?.type === 'edge') {
      const e = findEdge(state.selected.id);
      if (e) { e.labelColor = color; commit(); render(); }
    }
  });

  initInlineColorSwatch('groupTitleColorSwatch', 'groupTitleColorInline', (color) => {
    if (state.selected?.type === 'group') {
      const g = findGroup(state.selected.id);
      if (g) { g.titleColor = color; commit(); render(); }
    }
  });

  // Link Style Button
  const btnLinkStyle = document.getElementById('btnLinkStyle');
  const linkStyleMenu = document.getElementById('linkStyleMenu');

  if (btnLinkStyle && linkStyleMenu) {
    btnLinkStyle.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateLinkStyleMenu();
      linkStyleMenu.hidden = !linkStyleMenu.hidden;
    });

    // Link style items
    linkStyleMenu.querySelectorAll('.link-style-item').forEach(item => {
      item.addEventListener('click', () => {
        const style = item.dataset.style;
        applyLinkStyle(style);
        updateLinkStyleMenu();
      });
    });

    // Link route items
    linkStyleMenu.querySelectorAll('.link-route-item').forEach(item => {
      item.addEventListener('click', () => {
        const route = item.dataset.route;
        applyLinkRoute(route);
        updateLinkStyleMenu();
      });
    });

    linkStyleMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }

  function updateLinkStyleMenu() {
    if (!linkStyleMenu) return;

    // Get current selected edge style
    let currentStyle = 'straight';
    let currentRoute = 'hv';

    if (state.selected?.type === 'edge') {
      const e = findEdge(state.selected.id);
      if (e) {
        currentStyle = e.style || 'straight';
        currentRoute = e.route || 'hv';
      }
    }

    // Update active states
    linkStyleMenu.querySelectorAll('.link-style-item').forEach(item => {
      item.classList.toggle('active', item.dataset.style === currentStyle);
    });
    linkStyleMenu.querySelectorAll('.link-route-item').forEach(item => {
      item.classList.toggle('active', item.dataset.route === currentRoute);
    });
  }

  function applyLinkStyle(style) {
    // Apply to selected edge
    if (state.selected?.type === 'edge') {
      const e = findEdge(state.selected.id);
      if (e) { e.style = style; commit(); render(); }
    }

    // Apply to multi-selection
    if (state.selection.edges.size > 0) {
      state.selection.edges.forEach(id => {
        const e = findEdge(id);
        if (e) e.style = style;
      });
      commit(); render();
    }
  }

  function applyLinkRoute(route) {
    // Apply to selected edge
    if (state.selected?.type === 'edge') {
      const e = findEdge(state.selected.id);
      if (e) { e.route = route; commit(); render(); }
    }

    // Apply to multi-selection
    if (state.selection.edges.size > 0) {
      state.selection.edges.forEach(id => {
        const e = findEdge(id);
        if (e) e.route = route;
      });
      commit(); render();
    }
  }

  // Line Width Button
  const btnLineWidth = document.getElementById('btnLineWidth');
  const lineWidthMenu = document.getElementById('lineWidthMenu');

  if (btnLineWidth && lineWidthMenu) {
    btnLineWidth.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateLineWidthMenu();
      lineWidthMenu.hidden = !lineWidthMenu.hidden;
    });

    lineWidthMenu.querySelectorAll('.line-width-item').forEach(item => {
      item.addEventListener('click', () => {
        const width = parseInt(item.dataset.width);
        applyLineWidth(width);
        updateLineWidthMenu();
        lineWidthMenu.hidden = true;
      });
    });

    lineWidthMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }

  function updateLineWidthMenu() {
    if (!lineWidthMenu) return;

    let currentWidth = 2;
    let currentStyle = 'solid';

    if (state.selected?.type === 'edge') {
      const e = findEdge(state.selected.id);
      if (e) {
        currentWidth = e.strokeW || 2;
        currentStyle = e.lineStyle || 'solid';
      }
    } else if (state.selected?.type === 'node') {
      const n = findNode(state.selected.id);
      if (n) {
        currentWidth = n.strokeW || 2;
        currentStyle = n.lineStyle || 'solid';
      }
    } else if (state.selected?.type === 'group') {
      const g = findGroup(state.selected.id);
      if (g) {
        currentWidth = g.strokeW || 1;
        currentStyle = g.lineStyle || 'solid';
      }
    }

    lineWidthMenu.querySelectorAll('.line-width-item').forEach(item => {
      item.classList.toggle('active', parseInt(item.dataset.width) === currentWidth);
    });

    lineWidthMenu.querySelectorAll('.line-style-item').forEach(item => {
      item.classList.toggle('active', item.dataset.linestyle === currentStyle);
    });
  }

  function applyLineWidth(width) {
    // Apply to selected element
    if (state.selected) {
      if (state.selected.type === 'edge') {
        const e = findEdge(state.selected.id);
        if (e) { e.strokeW = width; commit(); render(); }
      } else if (state.selected.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) { n.strokeW = width; commit(); render(); }
      } else if (state.selected.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) { g.strokeW = width; commit(); render(); }
      }
    }

    // Apply to multi-selection
    if (state.selection.edges.size > 0) {
      state.selection.edges.forEach(id => {
        const e = findEdge(id);
        if (e) e.strokeW = width;
      });
      commit(); render();
    }
    if (state.selection.nodes.size > 0) {
      state.selection.nodes.forEach(id => {
        const n = findNode(id);
        if (n) n.strokeW = width;
      });
      commit(); render();
    }
    if (state.selection.groups.size > 0) {
      state.selection.groups.forEach(id => {
        const g = findGroup(id);
        if (g) g.strokeW = width;
      });
      commit(); render();
    }
  }

  // Line Style handler
  if (lineWidthMenu) {
    lineWidthMenu.querySelectorAll('.line-style-item').forEach(item => {
      item.addEventListener('click', () => {
        const lineStyle = item.dataset.linestyle;
        applyLineStyle(lineStyle);
        updateLineStyleMenu();
        lineWidthMenu.hidden = true;
      });
    });
  }

  function updateLineStyleMenu() {
    if (!lineWidthMenu) return;

    let currentStyle = 'solid';

    if (state.selected?.type === 'edge') {
      const e = findEdge(state.selected.id);
      if (e) currentStyle = e.lineStyle || 'solid';
    } else if (state.selected?.type === 'node') {
      const n = findNode(state.selected.id);
      if (n) currentStyle = n.lineStyle || 'solid';
    } else if (state.selected?.type === 'group') {
      const g = findGroup(state.selected.id);
      if (g) currentStyle = g.lineStyle || 'solid';
    }

    lineWidthMenu.querySelectorAll('.line-style-item').forEach(item => {
      item.classList.toggle('active', item.dataset.linestyle === currentStyle);
    });
  }

  function applyLineStyle(lineStyle) {
    // Apply to selected element
    if (state.selected) {
      if (state.selected.type === 'edge') {
        const e = findEdge(state.selected.id);
        if (e) { e.lineStyle = lineStyle; commit(); render(); }
      } else if (state.selected.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) { n.lineStyle = lineStyle; commit(); render(); }
      } else if (state.selected.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) { g.lineStyle = lineStyle; commit(); render(); }
      }
    }

    // Apply to multi-selection
    if (state.selection.edges.size > 0) {
      state.selection.edges.forEach(id => {
        const e = findEdge(id);
        if (e) e.lineStyle = lineStyle;
      });
      commit(); render();
    }
    if (state.selection.nodes.size > 0) {
      state.selection.nodes.forEach(id => {
        const n = findNode(id);
        if (n) n.lineStyle = lineStyle;
      });
      commit(); render();
    }
    if (state.selection.groups.size > 0) {
      state.selection.groups.forEach(id => {
        const g = findGroup(id);
        if (g) g.lineStyle = lineStyle;
      });
      commit(); render();
    }
  }

  // Font families and sizes available
  const fontFamilies = ['Arial', 'Times New Roman', 'Courier New', 'Verdana', 'Georgia', 'Helvetica'];
  const fontSizes = [6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 22, 24, 28, 32, 36, 40];

  // Text field definitions per object type
  // Simplified to match actual rendering: one text block per visual element
  const textFieldDefs = {
    node: [
      { key: 'name', label: 'Node Name', colorKey: 'nameColor', visibleKey: 'showName', fontKey: 'nameFont', sizeKey: 'nameSize', defaultVisible: true },
      { key: 'code', label: 'Node Code', colorKey: 'codeColor', visibleKey: 'showCode', fontKey: 'codeFont', sizeKey: 'codeSize', defaultVisible: true },
      { key: 'extraTags', label: 'Additional Tags', colorKey: 'extraTagsColor', visibleKey: 'showExtraTags', fontKey: 'extraTagsFont', sizeKey: 'extraTagsSize', defaultVisible: false }
    ],
    edge: [
      { key: 'tag', label: 'Link Label', colorKey: 'tagColor', visibleKey: 'showTag', fontKey: 'tagFont', sizeKey: 'tagSize', defaultVisible: true }
    ],
    group: [
      { key: 'title', label: 'Title', colorKey: 'titleColor', visibleKey: 'showTitle', fontKey: 'titleFont', sizeKey: 'titleSize', defaultVisible: true }
    ]
  };

  // Font Color Menu
  const btnFontColor = document.getElementById('btnFontColor');
  const fontColorMenu = document.getElementById('fontColorMenu');
  const fontColorNoSelection = document.getElementById('fontColorNoSelection');
  const fontColorFields = document.getElementById('fontColorFields');

  if (btnFontColor && fontColorMenu) {
    btnFontColor.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateFontColorMenu();
      fontColorMenu.hidden = !fontColorMenu.hidden;
      if (!fontColorMenu.hidden) repositionMenuInViewport(fontColorMenu);
    });

    fontColorMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }

  function updateFontColorMenu() {
    if (!fontColorFields || !fontColorNoSelection) return;

    const obj = getSelectedObject();
    if (!obj) {
      fontColorNoSelection.style.display = 'block';
      fontColorFields.style.display = 'none';
      return;
    }

    fontColorNoSelection.style.display = 'none';
    fontColorFields.style.display = 'block';
    fontColorFields.innerHTML = '';

    const type = state.selected.type === 'edge' ? 'edge' : (state.selected.type === 'node' ? 'node' : 'group');
    const fields = textFieldDefs[type] || [];

    fields.forEach(field => {
      const row = document.createElement('div');
      row.style.cssText = 'display:flex; align-items:center; gap:8px; padding:8px 12px; border-bottom:1px solid #f0f0f0;';

      // Visibility checkbox
      const visCheck = document.createElement('input');
      visCheck.type = 'checkbox';
      visCheck.checked = obj[field.visibleKey] !== false; // default true unless explicitly false
      visCheck.title = 'Show/Hide';
      visCheck.style.cssText = 'width:16px; height:16px; cursor:pointer; flex-shrink:0;';
      visCheck.addEventListener('change', () => {
        obj[field.visibleKey] = visCheck.checked;
        commit(); render();
      });

      // Label
      const label = document.createElement('span');
      label.textContent = field.label;
      label.style.cssText = 'flex:1; font-size:12px;';

      // Color button that opens palette
      const colorBtn = document.createElement('div');
      const currentColor = obj[field.colorKey] || '#eaeaea';
      colorBtn.style.cssText = `width:24px; height:24px; border:1px solid #999; border-radius:3px; cursor:pointer; background:${currentColor}; flex-shrink:0; position:relative;`;
      colorBtn.title = 'Click to change color';

      // Color palette dropdown
      const paletteDropdown = document.createElement('div');
      paletteDropdown.style.cssText = 'display:none; position:absolute; right:0; top:28px; background:white; border:1px solid #ccc; border-radius:4px; padding:6px; box-shadow:0 2px 8px rgba(0,0,0,0.15); z-index:1000; width:180px;';

      // Build palette grid
      const grid = document.createElement('div');
      grid.style.cssText = 'display:grid; grid-template-columns:repeat(8,1fr); gap:2px;';
      toolbarColorPalette.forEach(color => {
        const swatch = document.createElement('div');
        swatch.style.cssText = `width:18px; height:18px; background:${color}; border:1px solid #ccc; cursor:pointer; border-radius:2px;`;
        swatch.addEventListener('click', (ev) => {
          ev.stopPropagation();
          obj[field.colorKey] = color;
          colorBtn.style.background = color;
          paletteDropdown.style.display = 'none';
          commit(); render();
        });
        grid.appendChild(swatch);
      });
      paletteDropdown.appendChild(grid);

      // Custom color input
      const customRow = document.createElement('div');
      customRow.style.cssText = 'margin-top:6px; display:flex; align-items:center; gap:4px;';
      const customLabel = document.createElement('span');
      customLabel.textContent = 'Custom:';
      customLabel.style.cssText = 'font-size:10px;';
      const customInput = document.createElement('input');
      customInput.type = 'color';
      customInput.value = currentColor;
      customInput.style.cssText = 'width:24px; height:20px; border:none; cursor:pointer;';
      customInput.addEventListener('input', (ev) => {
        obj[field.colorKey] = ev.target.value;
        colorBtn.style.background = ev.target.value;
        commit(); render();
      });
      customRow.appendChild(customLabel);
      customRow.appendChild(customInput);
      paletteDropdown.appendChild(customRow);

      colorBtn.appendChild(paletteDropdown);

      colorBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        // Close other palettes
        fontColorFields.querySelectorAll('div[style*="position:absolute"]').forEach(p => {
          if (p !== paletteDropdown) p.style.display = 'none';
        });
        paletteDropdown.style.display = paletteDropdown.style.display === 'none' ? 'block' : 'none';
      });

      row.appendChild(visCheck);
      row.appendChild(label);
      row.appendChild(colorBtn);
      fontColorFields.appendChild(row);
    });

    // Close palettes when clicking elsewhere in the menu
    fontColorMenu.addEventListener('click', (ev) => {
      if (!ev.target.closest('div[style*="position:absolute"]') && !ev.target.closest('div[style*="cursor:pointer"]')) {
        fontColorFields.querySelectorAll('div[style*="position:absolute"]').forEach(p => {
          p.style.display = 'none';
        });
      }
    });
  }

  // Font Type Menu
  const btnFontType = document.getElementById('btnFontType');
  const fontTypeMenu = document.getElementById('fontTypeMenu');
  const fontTypeNoSelection = document.getElementById('fontTypeNoSelection');
  const fontTypeFields = document.getElementById('fontTypeFields');

  if (btnFontType && fontTypeMenu) {
    btnFontType.addEventListener('click', (ev) => {
      ev.stopPropagation();
      closeAllMenus();
      updateFontTypeMenu();
      fontTypeMenu.hidden = !fontTypeMenu.hidden;
      if (!fontTypeMenu.hidden) repositionMenuInViewport(fontTypeMenu);
    });

    fontTypeMenu.addEventListener('click', (ev) => ev.stopPropagation());
  }

  function updateFontTypeMenu() {
    if (!fontTypeFields || !fontTypeNoSelection) return;

    const obj = getSelectedObject();
    if (!obj) {
      fontTypeNoSelection.style.display = 'block';
      fontTypeFields.style.display = 'none';
      return;
    }

    fontTypeNoSelection.style.display = 'none';
    fontTypeFields.style.display = 'block';
    fontTypeFields.innerHTML = '';

    const type = state.selected.type === 'edge' ? 'edge' : (state.selected.type === 'node' ? 'node' : 'group');
    const fields = textFieldDefs[type] || [];

    fields.forEach(field => {
      const row = document.createElement('div');
      row.style.cssText = 'display:flex; align-items:center; gap:6px; padding:6px 12px; border-bottom:1px solid #f0f0f0;';

      // Label
      const label = document.createElement('span');
      label.textContent = field.label;
      label.style.cssText = 'width:90px; font-size:11px; flex-shrink:0;';

      // Font family select
      const fontSelect = document.createElement('select');
      fontSelect.style.cssText = 'flex:1; font-size:11px; padding:2px 4px; border:1px solid #ccc; border-radius:3px;';
      fontFamilies.forEach(f => {
        const opt = document.createElement('option');
        opt.value = f;
        opt.textContent = f;
        opt.selected = (obj[field.fontKey] || 'Arial') === f;
        fontSelect.appendChild(opt);
      });
      fontSelect.addEventListener('change', () => {
        obj[field.fontKey] = fontSelect.value;
        commit(); render();
      });

      // Font size stepper: [âˆ’] [input/dropdown] [+]
      const currentSize = obj[field.sizeKey] || 12;

      const sizeWrap = document.createElement('div');
      sizeWrap.style.cssText = 'display:flex; align-items:center; gap:0; flex-shrink:0; position:relative;';

      const applySize = (val) => {
        const n = Math.max(1, Math.min(200, parseInt(val) || 12));
        obj[field.sizeKey] = n;
        sizeInput.value = n;
        commit(); render();
      };

      // Decrease button
      const btnDec = document.createElement('button');
      btnDec.type = 'button';
      btnDec.textContent = '\u2212';
      btnDec.title = 'Decrease font size';
      btnDec.style.cssText = 'width:22px; height:24px; border:1px solid #ccc; border-radius:3px 0 0 3px; background:#f8f9fa; cursor:pointer; font-size:13px; font-weight:600; color:#333; display:flex; align-items:center; justify-content:center; padding:0; line-height:1;';
      btnDec.addEventListener('click', (ev) => {
        ev.stopPropagation();
        const cur = obj[field.sizeKey] || 12;
        // Step to previous preset, or -1 if between presets
        const smaller = fontSizes.filter(s => s < cur);
        applySize(smaller.length > 0 ? smaller[smaller.length - 1] : Math.max(1, cur - 1));
      });
      btnDec.addEventListener('mouseenter', () => { btnDec.style.background = '#e3f2fd'; });
      btnDec.addEventListener('mouseleave', () => { btnDec.style.background = '#f8f9fa'; });

      // Editable input with dropdown
      const sizeInput = document.createElement('input');
      sizeInput.type = 'text';
      sizeInput.value = currentSize;
      sizeInput.title = 'Type a custom size or click to select';
      sizeInput.style.cssText = 'width:38px; height:24px; border:1px solid #ccc; border-left:none; border-right:none; text-align:center; font-size:11px; padding:0 2px; box-sizing:border-box; outline:none; background:white;';

      // Select all on focus for easy replacement
      sizeInput.addEventListener('focus', () => {
        sizeInput.select();
        sizeDropdown.style.display = 'block';
      });
      sizeInput.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') {
          ev.preventDefault();
          applySize(sizeInput.value);
          sizeDropdown.style.display = 'none';
          sizeInput.blur();
        } else if (ev.key === 'Escape') {
          sizeInput.value = obj[field.sizeKey] || 12;
          sizeDropdown.style.display = 'none';
          sizeInput.blur();
        } else if (ev.key === 'ArrowUp') {
          ev.preventDefault();
          const cur = parseInt(sizeInput.value) || 12;
          const bigger = fontSizes.filter(s => s > cur);
          sizeInput.value = bigger.length > 0 ? bigger[0] : Math.min(200, cur + 1);
        } else if (ev.key === 'ArrowDown') {
          ev.preventDefault();
          const cur = parseInt(sizeInput.value) || 12;
          const smaller = fontSizes.filter(s => s < cur);
          sizeInput.value = smaller.length > 0 ? smaller[smaller.length - 1] : Math.max(1, cur - 1);
        }
      });
      sizeInput.addEventListener('blur', () => {
        // Delay to allow dropdown click
        setTimeout(() => { sizeDropdown.style.display = 'none'; }, 150);
      });

      // Preset size dropdown
      const sizeDropdown = document.createElement('div');
      sizeDropdown.style.cssText = 'display:none; position:absolute; top:100%; left:0; right:0; max-height:160px; overflow-y:auto; background:white; border:1px solid #ccc; border-radius:0 0 4px 4px; box-shadow:0 4px 12px rgba(0,0,0,0.12); z-index:1000;';
      fontSizes.forEach(s => {
        const item = document.createElement('div');
        item.textContent = s + 'px';
        item.style.cssText = `padding:3px 8px; font-size:11px; cursor:pointer; ${s === currentSize ? 'background:#e3f2fd; font-weight:600;' : ''}`;
        item.addEventListener('mouseenter', () => { item.style.background = '#e3f2fd'; });
        item.addEventListener('mouseleave', () => { item.style.background = s === (obj[field.sizeKey] || 12) ? '#e3f2fd' : 'white'; });
        item.addEventListener('mousedown', (ev) => {
          ev.preventDefault(); // Prevent input blur
          applySize(s);
          sizeDropdown.style.display = 'none';
        });
        sizeDropdown.appendChild(item);
      });

      // Increase button
      const btnInc = document.createElement('button');
      btnInc.type = 'button';
      btnInc.textContent = '+';
      btnInc.title = 'Increase font size';
      btnInc.style.cssText = 'width:22px; height:24px; border:1px solid #ccc; border-radius:0 3px 3px 0; background:#f8f9fa; cursor:pointer; font-size:13px; font-weight:600; color:#333; display:flex; align-items:center; justify-content:center; padding:0; line-height:1;';
      btnInc.addEventListener('click', (ev) => {
        ev.stopPropagation();
        const cur = obj[field.sizeKey] || 12;
        // Step to next preset, or +1 if between presets
        const bigger = fontSizes.filter(s => s > cur);
        applySize(bigger.length > 0 ? bigger[0] : Math.min(200, cur + 1));
      });
      btnInc.addEventListener('mouseenter', () => { btnInc.style.background = '#e3f2fd'; });
      btnInc.addEventListener('mouseleave', () => { btnInc.style.background = '#f8f9fa'; });

      sizeWrap.appendChild(btnDec);
      sizeWrap.appendChild(sizeInput);
      sizeWrap.appendChild(btnInc);
      sizeWrap.appendChild(sizeDropdown);

      row.appendChild(label);
      row.appendChild(fontSelect);
      row.appendChild(sizeWrap);
      fontTypeFields.appendChild(row);
    });
  }

  // Helper to get currently selected object
  function getSelectedObject() {
    if (!state.selected) return null;
    if (state.selected.type === 'node') return findNode(state.selected.id);
    if (state.selected.type === 'edge') return findEdge(state.selected.id);
    if (state.selected.type === 'group') return findGroup(state.selected.id);
    return null;
  }

  // Helper to get stroke-dasharray value for line style
  function getStrokeDasharray(lineStyle, strokeWidth) {
    const sw = strokeWidth || 2;
    if (lineStyle === 'dashed') return `${sw * 4},${sw * 2}`;
    if (lineStyle === 'dotted') return `${sw},${sw * 1.5}`;
    return 'none';
  }

  // Update color indicators when selection changes
  function updateFormatIndicators() {
    if (state.selected) {
      if (state.selected.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) {
          if (fillColorIndicator) fillColorIndicator.style.backgroundColor = n.fill || '#dae8fc';
          if (strokeColorIndicator) strokeColorIndicator.style.backgroundColor = n.stroke || '#6c8ebf';
        }
      } else if (state.selected.type === 'edge') {
        const e = findEdge(state.selected.id);
        if (e) {
          if (strokeColorIndicator) strokeColorIndicator.style.backgroundColor = e.strokeColor || '#666666';
        }
      } else if (state.selected.type === 'group') {
        const g = findGroup(state.selected.id);
        if (g) {
          if (fillColorIndicator) fillColorIndicator.style.backgroundColor = g.fill || '#ffffff';
          if (strokeColorIndicator) strokeColorIndicator.style.backgroundColor = g.stroke || '#666666';
        }
      }
    }
  }

  // Mouse wheel zoom (centered on mouse position)
  svg.addEventListener('wheel', (ev) => {
    if (ev.ctrlKey || ev.metaKey) {
      ev.preventDefault();
      const delta = ev.deltaY > 0 ? 0.9 : 1.1;
      const rect = svg.getBoundingClientRect();
      const mouseX = ev.clientX - rect.left;
      const mouseY = ev.clientY - rect.top;
      setZoom(state.zoom * delta, true, mouseX, mouseY);
    }
  }, { passive: false });


  const downloadText = (filename, text, mime="text/plain") => {
    const blob = new Blob([text], {type: mime});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(a.href), 500);
  };

  function getMouse(ev) {
    const pt = svg.createSVGPoint();
    pt.x = ev.clientX; pt.y = ev.clientY;
    const m = pt.matrixTransform(svg.getScreenCTM().inverse());
    return { x: m.x, y: m.y };
  }

  const findNode = (id) => state.nodes.find(n => n.id === id);
  const findEdge = (id) => state.edges.find(e => e.id === id);
  const findGroup = (id) => state.groups.find(g => g.id === id);

  function pointInGroup(x,y,g){
    // Always use bounding rectangle for containment (simpler, works for all shapes)
    return x >= g.x && x <= g.x+g.w && y >= g.y && y <= g.y+g.h;
  }
  function updateNodeGroupMembership(node) {
    let gid = null;
    // Nodes belong to the top-most *country* box they are inside (regions don't directly own nodes)
    for (let i = state.groups.length - 1; i >= 0; i--) {
      const g = state.groups[i];
      if (g.type !== 'country') continue;
      if (pointInGroup(node.x, node.y, g)) { gid = g.id; break; }
    }
    node.groupId = gid;
  }
  function updateCountryRegionMembership(country) {
    if (!country || country.type !== 'country') return;
    let rid = null;
    const cx = country.x + country.w / 2;
    const cy = country.y + country.h / 2;
    for (let i = state.groups.length - 1; i >= 0; i--) {
      const g = state.groups[i];
      if (g.type !== 'region') continue;
      if (pointInGroup(cx, cy, g)) { rid = g.id; break; }
    }
    country.parentId = rid;
  }

  function refreshAllMemberships() {
    state.groups.forEach(g => { if (g.type === 'country' || g.type === 'dc') updateCountryRegionMembership(g); });
    state.nodes.forEach(updateNodeGroupMembership);
  }

  function projectSnapshot() {
    return JSON.parse(JSON.stringify({
      nodes: state.nodes, edges: state.edges, groups: state.groups,
      cableSystems: state.cableSystems,
      multilinkGroups: state.multilinkGroups,
      nextNode: state.nextNode, nextEdge: state.nextEdge, nextGroup: state.nextGroup,
      nextCableSystem: state.nextCableSystem,
      nextMultilinkGroup: state.nextMultilinkGroup,
      stylePresets: state.stylePresets,
      canvasWidth: state.canvasWidth,
      canvasHeight: state.canvasHeight,
      showCanvasBorder: state.showCanvasBorder
    }));
  }
  function applySnapshot(snap) {
    state.nodes = snap.nodes || [];
    state.edges = snap.edges || [];
    state.groups = snap.groups || [];
    state.cableSystems = snap.cableSystems || [];
    state.multilinkGroups = snap.multilinkGroups || [];
    state.nextNode = snap.nextNode || (Math.max(0, ...state.nodes.map(n=>n.id)) + 1);
    state.nextEdge = snap.nextEdge || (Math.max(0, ...state.edges.map(e=>e.id)) + 1);
    state.nextGroup = snap.nextGroup || (Math.max(0, ...state.groups.map(g=>g.id)) + 1);
    state.nextCableSystem = snap.nextCableSystem || (Math.max(0, ...state.cableSystems.map(cs=>cs.id)) + 1);
    // Filter out string IDs (like "mlg_123") when calculating next numeric ID
    state.nextMultilinkGroup = snap.nextMultilinkGroup || (Math.max(0, ...state.multilinkGroups.filter(mlg => typeof mlg.id === 'number').map(mlg=>mlg.id)) + 1);

    // Backward compatibility: ensure cableSystemId exists on edges
    state.edges.forEach(e => {
      if (e.cableSystemId === undefined) e.cableSystemId = null;
    });
    // Backward compatibility: ensure cableSystemIds exists on nodes
    state.nodes.forEach(n => {
      if (!Array.isArray(n.cableSystemIds)) n.cableSystemIds = [];
    });

    // Restore presets if snapshot carries them; otherwise keep current
    state.stylePresets = snap.stylePresets || state.stylePresets || { node: {}, edge: {}, group: {} };
    state.styleBrush = null;

    // Restore canvas dimensions
    if (typeof snap.canvasWidth === 'number') state.canvasWidth = snap.canvasWidth;
    if (typeof snap.canvasHeight === 'number') state.canvasHeight = snap.canvasHeight;
    if (typeof snap.showCanvasBorder === 'boolean') state.showCanvasBorder = snap.showCanvasBorder;
    svg.setAttribute('viewBox', `0 0 ${state.canvasWidth} ${state.canvasHeight}`);
    syncGlobalToggles();

    // Clear transient UI state
    state.selected = null;
    state.connectFrom = null;
    state.dragging = null;
    state.resizingGroup = null;
    state.resizingNode = null;
    state.placingGroup = false;
    state.placingGroupType = 'country';

    refreshAllMemberships();
    render();
    updateInspector();
    updateCableSystemNavigator && updateCableSystemNavigator();
  }
  function pushHistory() {
    const snap = projectSnapshot();
    if (history.index < history.stack.length - 1) {
      history.stack = history.stack.slice(0, history.index + 1);
    }
    history.stack.push(snap);
    if (history.stack.length > history.max) history.stack.shift();
    else history.index++;
  }
  function commit() { dirty = true; pushHistory(); }
  function undo() {
    if (history.index <= 0) { showToast("Nothing to undo."); return; }
    history.index--;
    applySnapshot(history.stack[history.index]);
    dirty = true;
    showToast("Undo");
  }
  function redo() {
    if (history.index >= history.stack.length - 1) { showToast("Nothing to redo."); return; }
    history.index++;
    applySnapshot(history.stack[history.index]);
    dirty = true;
    showToast("Redo");
  }

  function svgLine(x1,y1,x2,y2,cls){
    const l = document.createElementNS('http://www.w3.org/2000/svg','line');
    l.setAttribute('x1', x1); l.setAttribute('y1', y1);
    l.setAttribute('x2', x2); l.setAttribute('y2', y2);
    l.setAttribute('class', cls);
    return l;
  }

  function drawCanvasBorder() {
    if (state.showCanvasBorder) {
      const border = document.createElementNS('http://www.w3.org/2000/svg','rect');
      border.setAttribute('x', 0);
      border.setAttribute('y', 0);
      border.setAttribute('width', state.canvasWidth);
      border.setAttribute('height', state.canvasHeight);
      border.setAttribute('fill', 'none');
      border.setAttribute('stroke', '#444');
      border.setAttribute('stroke-width', 2);
      border.setAttribute('stroke-dasharray', '8 4');
      border.style.pointerEvents = 'none';
      svg.appendChild(border);
    }

    // Always draw resize handle in corner
    drawCanvasResizeHandle();
  }

  function drawCanvasResizeHandle() {
    const x = state.canvasWidth - 20;
    const y = state.canvasHeight - 20;

    // Create resize handle group
    const handleGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    handleGroup.setAttribute('id', 'canvasResizeHandle');
    handleGroup.style.cursor = 'nwse-resize';

    // Background (larger hit area)
    const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    hitArea.setAttribute('x', x);
    hitArea.setAttribute('y', y);
    hitArea.setAttribute('width', 20);
    hitArea.setAttribute('height', 20);
    hitArea.setAttribute('fill', 'rgba(102, 126, 234, 0.1)');
    hitArea.setAttribute('rx', 3);
    handleGroup.appendChild(hitArea);

    // Visual handle (diagonal lines like typical resize grip)
    const grip = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    grip.setAttribute('d', `
      M${x + 6} ${y + 18} L${x + 18} ${y + 6}
      M${x + 10} ${y + 18} L${x + 18} ${y + 10}
      M${x + 14} ${y + 18} L${x + 18} ${y + 14}
    `);
    grip.setAttribute('stroke', '#888');
    grip.setAttribute('stroke-width', '1.5');
    grip.setAttribute('stroke-linecap', 'round');
    grip.setAttribute('fill', 'none');
    grip.style.pointerEvents = 'none';
    handleGroup.appendChild(grip);

    // Event handler for mousedown
    handleGroup.addEventListener('mousedown', startCanvasResize);

    svg.appendChild(handleGroup);
  }

  // Canvas resize state
  let canvasResizing = false;
  let canvasResizeStartX, canvasResizeStartY;
  let canvasStartWidth, canvasStartHeight;

  function startCanvasResize(e) {
    e.preventDefault();
    e.stopPropagation();
    canvasResizing = true;
    canvasResizeStartX = e.clientX;
    canvasResizeStartY = e.clientY;
    canvasStartWidth = state.canvasWidth;
    canvasStartHeight = state.canvasHeight;
    document.body.style.cursor = 'nwse-resize';
    document.body.style.userSelect = 'none';
  }

  document.addEventListener('mousemove', (e) => {
    if (!canvasResizing) return;

    const dx = (e.clientX - canvasResizeStartX) / state.zoom;
    const dy = (e.clientY - canvasResizeStartY) / state.zoom;

    const newWidth = Math.max(400, Math.round(canvasStartWidth + dx));
    const newHeight = Math.max(300, Math.round(canvasStartHeight + dy));

    state.canvasWidth = newWidth;
    state.canvasHeight = newHeight;

    // Update viewBox AND visual size
    updateViewBox();

    // Update inspector inputs
    if (canvasWidth) canvasWidth.value = state.canvasWidth;
    if (canvasHeight) canvasHeight.value = state.canvasHeight;

    // Redraw
    render();
  });

  document.addEventListener('mouseup', () => {
    if (canvasResizing) {
      canvasResizing = false;
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      commit();
      showToast(`Canvas: ${state.canvasWidth} Ã— ${state.canvasHeight}`);
    }
  });

  function drawGrid() {
    const w = state.canvasWidth, h = state.canvasHeight;
    // Only draw grid if enabled
    if (state.gridEnabled) {
      const step = state.gridSize || 40;
      for (let x=0; x<=w; x+=step) svg.appendChild(svgLine(x,0,x,h,'grid'));
      for (let y=0; y<=h; y+=step) svg.appendChild(svgLine(0,y,w,y,'grid'));
    }
    drawCanvasBorder();
  }


  function polygonPoints(cx, cy, r, sides, rotationRad=0){
    const pts = [];
    for (let i=0;i<sides;i++){
      const a = rotationRad + (i * 2*Math.PI / sides);
      pts.push([cx + r*Math.cos(a), cy + r*Math.sin(a)]);
    }
    return pts.map(p=>p[0].toFixed(2)+","+p[1].toFixed(2)).join(" ");
  }
  function setMultilineText(textEl, lines, fontSizePx) {
    while (textEl.firstChild) textEl.removeChild(textEl.firstChild);
    const fs = fontSizePx ?? 12;
    lines.forEach((line, i) => {
      const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      tspan.setAttribute('x', textEl.getAttribute('x'));
      if (i === 0) tspan.setAttribute('dy', '0');
      else tspan.setAttribute('dy', (fs * 1.2).toString());
      tspan.textContent = line;
      textEl.appendChild(tspan);
    });
  }

  // New function for styled multiline text (each line can have different styles)
  function setStyledMultilineText(textEl, styledLines) {
    while (textEl.firstChild) textEl.removeChild(textEl.firstChild);
    let prevFontSize = 12;
    styledLines.forEach((item, i) => {
      const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
      tspan.setAttribute('x', textEl.getAttribute('x'));
      if (i === 0) {
        tspan.setAttribute('dy', '0');
      } else {
        tspan.setAttribute('dy', (prevFontSize * 1.2).toString());
      }
      tspan.textContent = item.text;
      // Apply individual styles
      if (item.fill) tspan.setAttribute('fill', item.fill);
      if (item.fontSize) {
        tspan.style.fontSize = item.fontSize + 'px';
        prevFontSize = item.fontSize;
      }
      if (item.fontFamily) tspan.style.fontFamily = item.fontFamily;
      textEl.appendChild(tspan);
    });
  }

  function render() {
    svg.innerHTML = '';
    drawGrid();

    // Calculate heat map range if active (before drawing edges)
    if (typeof calculateHeatMapRange === 'function') {
      calculateHeatMapRange();
    }

    // Filter groups (regions first, then countries) based on tag filter
    state.groups.filter(g=>g.type==='region').forEach(g => {
      if (isGroupVisible(g)) drawGroup(g);
    });
    state.groups.filter(g=>g.type!=='region').forEach(g => {
      if (isGroupVisible(g)) drawGroup(g);
    });

    // Reset endpoint positions for handle second-pass
    _selEdgeEndpoints = {};

    // Filter edges based on node visibility and edge tags
    state.edges.forEach(e => {
      if (isEdgeVisible(e)) {
        drawEdge(e);
      }
    });

    // Filter nodes based on tag filter
    state.nodes.forEach(n => {
      if (isNodeVisible(n)) {
        drawNode(n);
      }
    });

    // Second pass: draw endpoint handles for selected edges ABOVE nodes
    for (const edgeId in _selEdgeEndpoints) {
      const ep = _selEdgeEndpoints[edgeId];
      const eid = parseInt(edgeId);
      const isDraggingThis = state.dragging?.type === 'endpointHandle' && state.dragging.edgeId === eid;

      // Don't draw the handle for the endpoint currently being dragged
      if (!isDraggingThis || state.dragging.endpoint !== 'a') {
        const ha = document.createElementNS('http://www.w3.org/2000/svg','circle');
        ha.setAttribute('cx', ep.ax); ha.setAttribute('cy', ep.ay);
        ha.setAttribute('r', 7);
        ha.setAttribute('class', 'edge-endpoint-handle');
        ha.style.cursor = 'grab';
        ha.addEventListener('mousedown', ((id) => (ev) => {
          ev.stopPropagation();
          const m = getMouse(ev);
          state.dragging = { type: 'endpointHandle', edgeId: id, endpoint: 'a', mx: m.x, my: m.y };
        })(eid));
        svg.appendChild(ha);
      }

      if (!isDraggingThis || state.dragging.endpoint !== 'b') {
        const hb = document.createElementNS('http://www.w3.org/2000/svg','circle');
        hb.setAttribute('cx', ep.bx); hb.setAttribute('cy', ep.by);
        hb.setAttribute('r', 7);
        hb.setAttribute('class', 'edge-endpoint-handle');
        hb.style.cursor = 'grab';
        hb.addEventListener('mousedown', ((id) => (ev) => {
          ev.stopPropagation();
          const m = getMouse(ev);
          state.dragging = { type: 'endpointHandle', edgeId: id, endpoint: 'b', mx: m.x, my: m.y };
        })(eid));
        svg.appendChild(hb);
      }
    }

    // During endpoint drag: show snap-ring on nearest node
    if (state.dragging?.type === 'endpointHandle') {
      const dragEdge = findEdge(state.dragging.edgeId);
      const fixedEndpoint = state.dragging.endpoint === 'a' ? 'b' : 'a';
      const fixedNodeId = dragEdge ? dragEdge[fixedEndpoint] : null;
      let bestNode = null, bestDist = Infinity;
      state.nodes.forEach(n => {
        if (!isNodeVisible(n)) return;
        if (n.id === fixedNodeId) return; // don't snap to the other end (would create self-loop)
        const dx = n.x - state.dragging.mx;
        const dy = n.y - state.dragging.my;
        const d = Math.sqrt(dx*dx + dy*dy);
        if (d < bestDist) { bestDist = d; bestNode = n; }
      });
      if (bestNode && bestDist < 80) {
        const ring = document.createElementNS('http://www.w3.org/2000/svg','circle');
        ring.setAttribute('cx', bestNode.x); ring.setAttribute('cy', bestNode.y);
        ring.setAttribute('r', (bestNode.r || 18) + 8);
        ring.setAttribute('class', 'endpoint-snap-ring');
        svg.appendChild(ring);
      }
    }

    // During link drag (Alt+drag): draw rubber-band line and snap ring on target
    if (state.dragging?.type === 'linkDrag') {
      const srcNode = findNode(state.dragging.sourceId);
      if (srcNode) {
        // Draw rubber-band line from source node to cursor
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', srcNode.x); line.setAttribute('y1', srcNode.y);
        line.setAttribute('x2', state.dragging.mx); line.setAttribute('y2', state.dragging.my);
        line.setAttribute('stroke', '#0096D6');
        line.setAttribute('stroke-width', '2');
        line.setAttribute('stroke-dasharray', '6 4');
        line.setAttribute('pointer-events', 'none');
        line.setAttribute('opacity', '0.8');
        svg.appendChild(line);

        // Show snap ring on nearest target node
        let bestNode = null, bestDist = Infinity;
        state.nodes.forEach(n => {
          if (!isNodeVisible(n)) return;
          if (n.id === srcNode.id) return; // can't link to self
          const dx = n.x - state.dragging.mx;
          const dy = n.y - state.dragging.my;
          const d = Math.sqrt(dx*dx + dy*dy);
          if (d < bestDist) { bestDist = d; bestNode = n; }
        });
        if (bestNode && bestDist < 80) {
          const ring = document.createElementNS('http://www.w3.org/2000/svg','circle');
          ring.setAttribute('cx', bestNode.x); ring.setAttribute('cy', bestNode.y);
          ring.setAttribute('r', (bestNode.r || 18) + 8);
          ring.setAttribute('class', 'endpoint-snap-ring');
          svg.appendChild(ring);
          // Snap the rubber-band line to the target node center
          line.setAttribute('x2', bestNode.x);
          line.setAttribute('y2', bestNode.y);
        }

        // Show source node highlight ring
        const srcRing = document.createElementNS('http://www.w3.org/2000/svg','circle');
        srcRing.setAttribute('cx', srcNode.x); srcRing.setAttribute('cy', srcNode.y);
        srcRing.setAttribute('r', (srcNode.r || 18) + 6);
        srcRing.setAttribute('fill', 'none');
        srcRing.setAttribute('stroke', '#ff9800');
        srcRing.setAttribute('stroke-width', '2.5');
        srcRing.setAttribute('pointer-events', 'none');
        svg.appendChild(srcRing);
      }
    }

    if (state.connectFrom) {
      const n = findNode(state.connectFrom);
      if (n && isNodeVisible(n)) {
        const hint = document.createElementNS('http://www.w3.org/2000/svg','text');
        hint.setAttribute('x', n.x);
        hint.setAttribute('y', n.y - 40);
        hint.setAttribute('class', 'edge-label');
        hint.style.fontSize = "12px";
        hint.textContent = "Select target nodeâ€¦";
        svg.appendChild(hint);
      }
    }
    if (state.marquee) {
      const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
      r.setAttribute('class','marquee');
      r.setAttribute('x', state.marquee.x);
      r.setAttribute('y', state.marquee.y);
      r.setAttribute('width', state.marquee.w);
      r.setAttribute('height', state.marquee.h);
      svg.appendChild(r);
    }
    updateInspector();
    // Refresh Label Manager if visible
    if (window.labelManagerState?.visible && typeof window.refreshLabelManager === 'function') {
      window.refreshLabelManager();
    }
  }

  function drawGroup(g) {
    const grp = document.createElementNS('http://www.w3.org/2000/svg','g');
    const isSel = (state.selected?.type==='group' && state.selected?.id===g.id) || state.selection.groups.has(g.id);
    if (isSel) grp.classList.add('group-selected');

    // Check if this is a shape-based container
    const isShapeContainer = g.shapeContainer && g.decorativeShape && g.decorativeShape.pathData;

    // Create invisible rect for bounds/interaction (always needed for dragging)
    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('x', g.x);
    rect.setAttribute('y', g.y);
    rect.setAttribute('width', g.w);
    rect.setAttribute('height', g.h);
    rect.setAttribute('class', 'group-rect');

    if (isShapeContainer) {
      // For shape containers, make rect invisible - shape will be the visual
      rect.setAttribute('fill', 'transparent');
      rect.setAttribute('stroke', 'none');
    } else {
      rect.setAttribute('fill', g.fill || "rgba(54, 76, 140, 0.12)");
      rect.setAttribute('stroke', g.stroke || "#6073b8");
      rect.setAttribute('stroke-width', (g.strokeW ?? 2));
      // Apply line style to container border
      if (g.lineStyle && g.lineStyle !== 'solid') {
        rect.setAttribute('stroke-dasharray', getStrokeDasharray(g.lineStyle, g.strokeW ?? 2));
      }
    }
    rect.style.pointerEvents = "auto";  // Make clickable for selection and dragging
    rect.style.cursor = "grab";  // Show hand cursor

    // Render shape as container visual (for shape containers) or decorative overlay
    let shapeEl = null;
    if (g.decorativeShape && g.decorativeShape.pathData) {
      const padding = isShapeContainer ? 0 : 10;
      const innerW = g.w - padding * 2;
      const innerH = g.h - padding * 2;

      // Parse viewBox to get original dimensions
      const vbParts = (g.decorativeShape.viewBox || '0 0 100 100').split(/\s+/).map(parseFloat);
      const origW = vbParts[2] || 100;
      const origH = vbParts[3] || 100;

      // Calculate scale to fit within container while maintaining aspect ratio
      const scaleX = innerW / origW;
      const scaleY = innerH / origH;
      const scale = Math.min(scaleX, scaleY);

      // Calculate offset to center the shape
      const scaledW = origW * scale;
      const scaledH = origH * scale;
      const offsetX = g.x + padding + (innerW - scaledW) / 2 - vbParts[0] * scale;
      const offsetY = g.y + padding + (innerH - scaledH) / 2 - vbParts[1] * scale;

      shapeEl = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      shapeEl.setAttribute('transform', `translate(${offsetX}, ${offsetY}) scale(${scale})`);

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', g.decorativeShape.pathData);

      if (isShapeContainer) {
        // Shape IS the container - draw with full styling
        path.setAttribute('fill', g.fill || 'rgba(54, 76, 140, 0.15)');
        path.setAttribute('stroke', g.stroke || '#6073b8');
        path.setAttribute('stroke-width', (g.strokeW ?? 2) / scale); // Adjust for scale
        if (g.lineStyle && g.lineStyle !== 'solid') {
          const dashArray = getStrokeDasharray(g.lineStyle, g.strokeW ?? 2);
          // Scale dash array
          const scaledDash = dashArray.split(',').map(v => parseFloat(v) / scale).join(',');
          path.setAttribute('stroke-dasharray', scaledDash);
        }
        // Make shape clickable for dragging
        path.style.pointerEvents = 'auto';
        path.style.cursor = 'grab';

        // Add mousedown handler to shape path for dragging
        path.addEventListener('mousedown', (ev) => {
          ev.stopPropagation();
          const m = getMouse(ev);

          if (window.routeFinderState && window.routeFinderState.active) return;
          if (linkMode) return;
          if (ev.shiftKey && !(ev.ctrlKey || ev.metaKey)) return;

          if (state.selection.groups.has(g.id) && (state.selection.groups.size > 1 || state.selection.nodes.size > 0)) {
            const origNodes = [...state.selection.nodes].map(id => {
              const nn = findNode(id); return nn ? {id, x: nn.x, y: nn.y} : null;
            }).filter(Boolean);
            const origGroups = [...state.selection.groups].map(id => {
              const gg = findGroup(id); return gg ? {id, x: gg.x, y: gg.y} : null;
            }).filter(Boolean);
            state.dragging = { type:'selection', mx0: m.x, my0: m.y, origNodes, origGroups };
            state.selected = null;
          } else {
            if (!state.selection.groups.has(g.id)) {
              setSingleSelection({type:'group', id:g.id});
            }
            state.dragging = { type:'group', id:g.id, dx: g.x - m.x, dy: g.y - m.y, origX: g.x, origY: g.y };
          }
          path.style.cursor = 'grabbing';
          state.connectFrom = null;
        });

        // Selection is now handled by CSS glow filter on .group-selected
        // No need to change stroke color here - preserves original colors
      } else {
        // Decorative overlay only
        path.setAttribute('fill', g.stroke || '#6073b8');
        path.setAttribute('fill-opacity', '0.08');
        path.setAttribute('stroke', 'none');
        path.style.pointerEvents = 'none';
      }

      shapeEl.appendChild(path);
    }

    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('x', g.x + 14 + (g.titleDx || 0));
    label.setAttribute('y', g.y + 22 + (g.titleDy || 0));
    label.setAttribute('class', 'group-label');
    label.setAttribute('fill', g.titleColor || "#eaeaea");
    label.style.fontSize = (g.titleSize || 14) + "px";
    label.style.fontFamily = g.titleFont || 'Arial';
    // Only show title if globally enabled AND per-container enabled (defaults to true)
    if (state.ui.showContainerTitle !== false && g.showTitle !== false) {
      label.textContent = g.title || (g.type==='region' ? `Group${g.id}` : g.type==='dc' ? `DC${g.id}` : `Container${g.id}`);
    } else {
      label.textContent = '';
    }
    label.style.pointerEvents = "auto";

    // Create 4 resize handles (one for each corner)
    const handleSize = 10;
    const handlePositions = [
      { corner: 'nw', x: g.x, y: g.y },
      { corner: 'ne', x: g.x + g.w - handleSize, y: g.y },
      { corner: 'sw', x: g.x, y: g.y + g.h - handleSize },
      { corner: 'se', x: g.x + g.w - handleSize, y: g.y + g.h - handleSize }
    ];

    const handles = handlePositions.map(pos => {
      const handle = document.createElementNS('http://www.w3.org/2000/svg','rect');
      handle.setAttribute('x', pos.x);
      handle.setAttribute('y', pos.y);
      handle.setAttribute('width', handleSize);
      handle.setAttribute('height', handleSize);
      handle.setAttribute('class', `group-handle handle-${pos.corner}`);
      handle.setAttribute('data-corner', pos.corner);

      handle.addEventListener('mousedown', (ev) => {
        ev.stopPropagation();
        const m = getMouse(ev);
        select({type:'group', id:g.id});
        state.resizingGroup = {
          id: g.id,
          corner: pos.corner,
          startX: g.x,
          startY: g.y,
          startW: g.w,
          startH: g.h,
          mx0: m.x,
          my0: m.y
        };
        state.connectFrom = null;
        render();
      });

      return handle;
    });

    rect.addEventListener('mousedown', (ev) => {
      ev.stopPropagation();
      const m = getMouse(ev);

      // In calculation mode, don't allow group dragging/selection
      if (window.routeFinderState && window.routeFinderState.active) {
        return;
      }

      // In link mode, don't allow group dragging
      if (linkMode) {
        return;
      }

      // Shift+click without Ctrl - let mouseup/click handle multi-selection, don't set up dragging
      if (ev.shiftKey && !(ev.ctrlKey || ev.metaKey)) {
        console.log(`[GROUP MOUSEDOWN] Group ${g.id} - Shift+click, letting click handler handle multi-select`);
        return;
      }

      // Check BEFORE calling select() to preserve multi-selection if dragging
      // If the clicked group is part of a multi-selection, drag entire selection
      if (state.selection.groups.has(g.id) && (state.selection.groups.size > 1 || state.selection.nodes.size > 0)) {
        console.log(`[MULTI-DRAG] Group ${g.id} is part of multi-selection (${state.selection.nodes.size} nodes, ${state.selection.groups.size} groups) - setting up multi-drag`);
        const origNodes = [...state.selection.nodes].map(id => {
          const nn = findNode(id); return nn ? {id, x: nn.x, y: nn.y} : null;
        }).filter(Boolean);
        const origGroups = [...state.selection.groups].map(id => {
          const gg = findGroup(id); return gg ? {id, x: gg.x, y: gg.y} : null;
        }).filter(Boolean);
        state.dragging = { type:'selection', mx0: m.x, my0: m.y, origNodes, origGroups };
        state.selected = null; // Clear single selection when dragging multiple
        console.log(`[MULTI-DRAG] Dragging ${origNodes.length} nodes and ${origGroups.length} groups`);
      } else {
        console.log(`[SINGLE-DRAG] Group ${g.id} - single selection drag setup`);
        // Don't call select() here - it may trigger render() which recreates DOM
        if (!state.selection.groups.has(g.id)) {
          setSingleSelection({type:'group', id:g.id});
        }
        state.dragging = { type:'group', id:g.id, dx: g.x - m.x, dy: g.y - m.y, origX: g.x, origY: g.y };
      }
      rect.style.cursor = "grabbing";
      state.connectFrom = null;
    });

    label.addEventListener('mousedown', (ev) => {
      if (!(ev.ctrlKey || ev.metaKey)) return;
      ev.stopPropagation();
      const m = getMouse(ev);
      state.dragging = { type:'groupTitleLabel', id:g.id,
        dx: (g.x + 14 + (g.titleDx||0)) - m.x,
        dy: (g.y + 22 + (g.titleDy||0)) - m.y,
        origDx: g.titleDx||0, origDy: g.titleDy||0
      };
      select({type:'group', id:g.id});
      state.connectFrom = null;
      render();
    });

    rect.addEventListener('mouseup', (ev) => {
      // Don't stop propagation - let global handler clear dragging state
      // Just restore cursor
      rect.style.cursor = "grab";
    });

    rect.addEventListener('click', (ev) => {
      ev.stopPropagation();
      if (ev.shiftKey) {
        // Shift+click toggles multi-selection for this group
        if (state.selection.groups.has(g.id)) {
          state.selection.groups.delete(g.id);
          state.selected = null;
        } else {
          state.selection.groups.add(g.id);
          state.selected = null;
        }
        render();
        return;
      }
      select({type:'group', id:g.id});
      state.connectFrom=null;
      render();
    });
    label.addEventListener('click', (ev) => {
      ev.stopPropagation();
      if (ev.shiftKey) {
        // Shift+click toggles multi-selection for this group
        if (state.selection.groups.has(g.id)) {
          state.selection.groups.delete(g.id);
          state.selected = null;
        } else {
          state.selection.groups.add(g.id);
          state.selected = null;
        }
        render();
        return;
      }
      select({type:'group', id:g.id});
      state.connectFrom=null;
      render();
    });

    // Add selection glow overlay FIRST (behind everything) if selected
    if (isSel) {
      const glowOffset = 4;
      const selectionGlow = document.createElementNS('http://www.w3.org/2000/svg','rect');
      selectionGlow.setAttribute('x', g.x - glowOffset);
      selectionGlow.setAttribute('y', g.y - glowOffset);
      selectionGlow.setAttribute('width', g.w + glowOffset * 2);
      selectionGlow.setAttribute('height', g.h + glowOffset * 2);
      selectionGlow.setAttribute('rx', 10);
      selectionGlow.setAttribute('ry', 10);
      selectionGlow.setAttribute('class', 'group-selection-glow');
      selectionGlow.style.pointerEvents = 'none';
      grp.appendChild(selectionGlow);
    }

    grp.appendChild(rect);
    if (shapeEl) grp.appendChild(shapeEl);

    // DC container building icon (top-right corner)
    if (g.type === 'dc') {
      const iconG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      const iconX = g.x + g.w - 30;
      const iconY = g.y + 4;
      const iconScale = 0.8;
      iconG.setAttribute('transform', `translate(${iconX}, ${iconY}) scale(${iconScale})`);
      iconG.style.pointerEvents = 'none';
      const iconColor = g.stroke || '#ec4899';

      if (g.dcFacilityType === 'cable_station') {
        // Cable station icon: anchor/cable landing motif
        const cableColor = g.stroke || '#2563eb';
        // Vertical mast
        const mast = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        mast.setAttribute('x1', '12'); mast.setAttribute('y1', '2');
        mast.setAttribute('x2', '12'); mast.setAttribute('y2', '18');
        mast.setAttribute('stroke', cableColor); mast.setAttribute('stroke-width', '2');
        iconG.appendChild(mast);
        // Top circle (ring)
        const ring = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        ring.setAttribute('cx', '12'); ring.setAttribute('cy', '4');
        ring.setAttribute('r', '3'); ring.setAttribute('fill', 'none');
        ring.setAttribute('stroke', cableColor); ring.setAttribute('stroke-width', '1.5');
        iconG.appendChild(ring);
        // Crossbar
        const bar = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        bar.setAttribute('x1', '4'); bar.setAttribute('y1', '12');
        bar.setAttribute('x2', '20'); bar.setAttribute('y2', '12');
        bar.setAttribute('stroke', cableColor); bar.setAttribute('stroke-width', '1.5');
        iconG.appendChild(bar);
        // Left fluke (curved arm)
        const flukeL = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        flukeL.setAttribute('d', 'M 4 18 Q 4 12, 8 12');
        flukeL.setAttribute('fill', 'none');
        flukeL.setAttribute('stroke', cableColor); flukeL.setAttribute('stroke-width', '1.5');
        iconG.appendChild(flukeL);
        // Right fluke
        const flukeR = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        flukeR.setAttribute('d', 'M 20 18 Q 20 12, 16 12');
        flukeR.setAttribute('fill', 'none');
        flukeR.setAttribute('stroke', cableColor); flukeR.setAttribute('stroke-width', '1.5');
        iconG.appendChild(flukeR);
        // Wave lines at bottom (water)
        const wave = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        wave.setAttribute('d', 'M 1 22 Q 6 19, 12 22 Q 18 25, 23 22');
        wave.setAttribute('fill', 'none');
        wave.setAttribute('stroke', cableColor); wave.setAttribute('stroke-width', '1');
        wave.setAttribute('stroke-opacity', '0.5');
        iconG.appendChild(wave);
      } else {
        // Datacenter / Carrier Hotel icon: server rack
        const body = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        body.setAttribute('x', '2'); body.setAttribute('y', '0');
        body.setAttribute('width', '20'); body.setAttribute('height', '24');
        body.setAttribute('rx', '1'); body.setAttribute('fill', 'none');
        body.setAttribute('stroke', iconColor); body.setAttribute('stroke-width', '1.5');
        iconG.appendChild(body);
        // Rack lines
        [6, 12, 18].forEach(ly => {
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', '2'); line.setAttribute('y1', ly);
          line.setAttribute('x2', '22'); line.setAttribute('y2', ly);
          line.setAttribute('stroke', iconColor); line.setAttribute('stroke-width', '0.8');
          line.setAttribute('stroke-opacity', '0.5');
          iconG.appendChild(line);
        });
        // LED dots
        [3, 9, 15, 21].forEach(dy => {
          const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          dot.setAttribute('cx', '19'); dot.setAttribute('cy', dy);
          dot.setAttribute('r', '1.2'); dot.setAttribute('fill', iconColor);
          iconG.appendChild(dot);
        });
      }
      grp.appendChild(iconG);
    }

    grp.appendChild(label);
    // Append all 4 corner handles
    handles.forEach(h => grp.appendChild(h));
    svg.appendChild(grp);
  }

  function orthogonalPath(x1,y1,x2,y2, route){
    if (route === 'vh') return `M ${x1} ${y1} L ${x1} ${y2} L ${x2} ${y2}`;
    return `M ${x1} ${y1} L ${x2} ${y1} L ${x2} ${y2}`;
  }
  function orthogonalBaseLabelPoint(x1,y1,x2,y2, route){
    if (route === 'vh') return { x: x1 + 8, y: y2 - 8 };
    return { x: x2 + 8, y: y1 - 8 };
  }
  function getEdgeLabelLines(e) {
    const lines = [];
    // Link Code - show if globally enabled AND per-link enabled (defaults to true)
    if (state.ui.showLinkCode && e.showCode !== false && e.code && e.code.trim()) {
      lines.push(e.code.trim());
    }
    // Link Tag - show if globally enabled AND per-link enabled (defaults to true)
    if (state.ui.showLinkTag !== false && e.showTag !== false) {
      lines.push((e.tag && e.tag.trim()) ? e.tag.trim() : "â€”");
    }
    // Latency - show if globally enabled AND per-link enabled (defaults to true)
    if (state.ui.showLatency && e.showLatency !== false && typeof e.latencyMs === "number" && isFinite(e.latencyMs)) {
      lines.push(`${e.latencyMs} ms`);
    }
    // Capacity - show if per-link enabled (defaults to false)
    if (e.showCapacity && e.capacity && e.capacity.trim()) {
      lines.push(e.capacity.trim());
    }
    // Additional Tags - show if per-link enabled (defaults to false)
    if (e.showExtraTags && e.extraTags && e.extraTags.trim()) {
      lines.push(e.extraTags.trim());
    }
    return lines;
  }

  function quadraticCurvePath(x1, y1, x2, y2, arch) {
    // Create bezier curve path
    // arch controls how much the curve bends (0.3 = moderate, 0 = straight, 0.6 = extreme)
    const mx = (x1 + x2) / 2;
    const my = (y1 + y2) / 2;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const offset = dist * arch * 0.5;
    const cpx = mx - dy/dist * offset;
    const cpy = my + dx/dist * offset;
    return `M ${x1} ${y1} Q ${cpx} ${cpy} ${x2} ${y2}`;
  }

  function curveBaseLabelPoint(x1, y1, x2, y2, arch) {
    // Label position on curve (midpoint adjusted)
    const mx = (x1 + x2) / 2;
    const my = (y1 + y2) / 2;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const offset = dist * arch * 0.25;
    return { x: mx - dy/dist * offset + 8, y: my + dx/dist * offset - 8 };
  }

  function getCurveControlPoint(x1, y1, x2, y2, arch) {
    // Returns the bezier control point (used for draggable handle position)
    const mx = (x1 + x2) / 2;
    const my = (y1 + y2) / 2;
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const offset = dist * arch * 0.5;
    const cpx = mx - dy/dist * offset;
    const cpy = my + dx/dist * offset;
    return { x: cpx, y: cpy };
  }

  // Temporary storage for selected-edge endpoint positions, populated during drawEdge,
  // consumed in render() second-pass to draw draggable handles above nodes.
  let _selEdgeEndpoints = {};

  function drawEdge(e) {
    const a = findNode(e.a), b = findNode(e.b);
    if (!a || !b) {
      console.log(`[DRAW EDGE] Edge ${e.id} NOT drawn - missing nodes: a=${!!a}, b=${!!b}`);
      return;
    }
    console.log(`[DRAW EDGE] Drawing edge ${e.id} from node ${e.a} to node ${e.b}, style=${e.style}`);
    const isSel = (state.selected?.type==='edge' && state.selected?.id===e.id) || state.selection.edges.has(e.id);

    // Check if this edge should be highlighted (cable system selection or temporary highlight)
    const isCSHighlighted = state.selectedCableSystem && e.cableSystemId === state.selectedCableSystem;
    const isTempHighlighted = state._highlightedLinks && state._highlightedLinks.has(e.id);
    const isHighlighted = isCSHighlighted || isTempHighlighted;

    // Calculate offset for parallel edges between same nodes
    // Normalize node pair to ensure consistent ordering (smaller id first)
    const nodeA = Math.min(e.a, e.b);
    const nodeB = Math.max(e.a, e.b);
    const isReversed = e.a > e.b; // Track if this edge is in reverse direction

    const parallelEdges = state.edges.filter(edge => {
      const edgeNodeA = Math.min(edge.a, edge.b);
      const edgeNodeB = Math.max(edge.a, edge.b);
      return edgeNodeA === nodeA && edgeNodeB === nodeB;
    });

    // Sort parallel edges by id for consistent ordering
    parallelEdges.sort((x, y) => x.id - y.id);

    const edgeIndex = parallelEdges.findIndex(edge => edge.id === e.id);
    const totalParallel = parallelEdges.length;

    console.log(`[PARALLEL] Edge ${e.id}: index=${edgeIndex}, total=${totalParallel}`);

    // Calculate perpendicular offset
    let offsetX = 0, offsetY = 0;
    if (totalParallel > 1) {
      // Always calculate direction from lower node id to higher node id for consistency
      const lowNode = findNode(nodeA);
      const highNode = findNode(nodeB);
      const dx = highNode.x - lowNode.x;
      const dy = highNode.y - lowNode.y;
      const len = Math.sqrt(dx*dx + dy*dy) || 1;
      // Perpendicular unit vector
      const perpX = -dy / len;
      const perpY = dx / len;
      // Spread edges evenly: offset from center
      const spacing = 15; // pixels between parallel edges
      const offsetAmount = (edgeIndex - (totalParallel - 1) / 2) * spacing;
      offsetX = perpX * offsetAmount;
      offsetY = perpY * offsetAmount;

      console.log(`[PARALLEL] Edge ${e.id}: offsetAmount=${offsetAmount}, offsetX=${offsetX.toFixed(2)}, offsetY=${offsetY.toFixed(2)}`);
    }

    // Offset node positions for this edge
    let ax = a.x + offsetX;
    let ay = a.y + offsetY;
    let bx = b.x + offsetX;
    let by = b.y + offsetY;

    // Override endpoint position during endpoint-handle drag
    if (state.dragging?.type === 'endpointHandle' && state.dragging.edgeId === e.id) {
      if (state.dragging.endpoint === 'a') { ax = state.dragging.mx; ay = state.dragging.my; }
      if (state.dragging.endpoint === 'b') { bx = state.dragging.mx; by = state.dragging.my; }
    }

    // Get heat map color if active (overrides normal stroke color)
    const heatMapColor = (typeof getHeatMapColor === 'function') ? getHeatMapColor(e) : null;
    if (heatMapColor) {
      console.log('[HeatMap] Render using heatMapColor for edge', e.id, ':', heatMapColor);
    }
    const effectiveStrokeColor = heatMapColor || e.strokeColor || "#7f8aa6";

    // Draw highlight glow behind edge if highlighted
    if (isHighlighted) {
      const glowPath = document.createElementNS('http://www.w3.org/2000/svg','path');
      if (e.style === 'orthogonal') {
        glowPath.setAttribute('d', orthogonalPath(ax,ay,bx,by, e.route || 'hv'));
      } else if (e.style === 'curve') {
        glowPath.setAttribute('d', quadraticCurvePath(ax, ay, bx, by, e.curveArch || 0.3));
      } else {
        glowPath.setAttribute('d', `M${ax},${ay} L${bx},${by}`);
      }
      glowPath.setAttribute('stroke', '#00d4ff');
      glowPath.setAttribute('stroke-width', (e.strokeW ?? 2) + 8);
      glowPath.setAttribute('fill', 'none');
      glowPath.setAttribute('opacity', '0.5');
      glowPath.style.pointerEvents = 'none';
      svg.appendChild(glowPath);
    }

    let baseLabel = null;
    if (e.style === 'orthogonal') {
      // Draw selection glow FIRST (behind the edge) if selected
      if (isSel) {
        const glowPath = document.createElementNS('http://www.w3.org/2000/svg','path');
        glowPath.setAttribute('d', orthogonalPath(ax,ay,bx,by, e.route || 'hv'));
        glowPath.setAttribute('class', 'edge-selection-glow');
        glowPath.setAttribute('stroke-width', (e.strokeW ?? 2) + 6);
        glowPath.setAttribute('fill', 'none');
        if (e.lineStyle && e.lineStyle !== 'solid') {
          glowPath.setAttribute('stroke-dasharray', getStrokeDasharray(e.lineStyle, e.strokeW ?? 2));
        }
        svg.appendChild(glowPath);
      }

      // Draw the visible edge
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', orthogonalPath(ax,ay,bx,by, e.route || 'hv'));
      p.setAttribute('class', 'edge' + (isSel ? ' selected' : ''));
      p.setAttribute('data-edge-id', e.id);
      p.setAttribute('stroke-width', (e.strokeW ?? 2));
      p.setAttribute('stroke', effectiveStrokeColor);
      // Apply line style
      if (e.lineStyle && e.lineStyle !== 'solid') {
        p.setAttribute('stroke-dasharray', getStrokeDasharray(e.lineStyle, e.strokeW ?? 2));
      }
      p.style.pointerEvents = 'none'; // Disable clicks on visible edge
      svg.appendChild(p);

      // Add invisible wide hit area for easier clicking
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg','path');
      hitArea.setAttribute('d', orthogonalPath(ax,ay,bx,by, e.route || 'hv'));
      hitArea.setAttribute('stroke', 'transparent');
      hitArea.setAttribute('stroke-width', 20); // Wide invisible hit area
      hitArea.setAttribute('fill', 'none');
      hitArea.style.cursor = 'pointer';
      hitArea.addEventListener('click', (ev) => {
        ev.stopPropagation();
        // Handle routing overlap pick mode
        if (window.routingOverlapPickMode && window.routingOverlapPickMode()) {
          if (window.handleRoutingOverlapPick && window.handleRoutingOverlapPick(e.id)) {
            return;
          }
        }
        // Handle link pick modes in calculation mode
        if (window.routeFinderState && window.routeFinderState.active) {
          if (window.routeFinderState.pickMode === 'excludeLink') {
            addExcludedLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          if (window.routeFinderState.pickMode === 'mustUseLink') {
            addMustUseLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          if (window.routeFinderState.pickMode === 'diverseFromLink') {
            if (typeof addDiverseFromLink === 'function') addDiverseFromLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          return;
        }
        // Handle cable system add mode
        if (typeof handleAddModeClick === 'function' && handleAddModeClick('edge', e.id)) {
          return;
        }
        // Handle multilink group link picking
        if (typeof handleMLGLinkClick === 'function' && handleMLGLinkClick(e.id)) {
          return;
        }
        if (ev.shiftKey) {
          if (state.selection.edges.has(e.id)) {
            state.selection.edges.delete(e.id);
            state.selected = null;
          } else {
            state.selection.edges.add(e.id);
            state.selected = null;
          }
          render();
          return;
        }
        select({type:'edge', id:e.id});
        state.connectFrom=null;
        render();
      });
      svg.appendChild(hitArea);

      baseLabel = orthogonalBaseLabelPoint(ax,ay,bx,by, e.route || 'hv');
    } else if (e.style === 'curve') {
      // Draw selection glow FIRST (behind the edge) if selected
      if (isSel) {
        const glowPath = document.createElementNS('http://www.w3.org/2000/svg','path');
        glowPath.setAttribute('d', quadraticCurvePath(ax, ay, bx, by, e.curveArch || 0.3));
        glowPath.setAttribute('class', 'edge-selection-glow');
        glowPath.setAttribute('stroke-width', (e.strokeW ?? 2) + 6);
        glowPath.setAttribute('fill', 'none');
        if (e.lineStyle && e.lineStyle !== 'solid') {
          glowPath.setAttribute('stroke-dasharray', getStrokeDasharray(e.lineStyle, e.strokeW ?? 2));
        }
        svg.appendChild(glowPath);
      }

      // Draw the visible edge
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', quadraticCurvePath(ax, ay, bx, by, e.curveArch || 0.3));
      p.setAttribute('class', 'edge' + (isSel ? ' selected' : ''));
      p.setAttribute('data-edge-id', e.id);
      p.setAttribute('stroke-width', (e.strokeW ?? 2));
      p.setAttribute('stroke', effectiveStrokeColor);
      p.setAttribute('fill', 'none');
      // Apply line style
      if (e.lineStyle && e.lineStyle !== 'solid') {
        p.setAttribute('stroke-dasharray', getStrokeDasharray(e.lineStyle, e.strokeW ?? 2));
      }
      p.style.pointerEvents = 'none'; // Disable clicks on visible edge
      svg.appendChild(p);

      // Add invisible wide hit area for easier clicking
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg','path');
      hitArea.setAttribute('d', quadraticCurvePath(ax, ay, bx, by, e.curveArch || 0.3));
      hitArea.setAttribute('stroke', 'transparent');
      hitArea.setAttribute('stroke-width', 20); // Wide invisible hit area
      hitArea.setAttribute('fill', 'none');
      hitArea.style.cursor = 'pointer';
      hitArea.addEventListener('click', (ev) => {
        ev.stopPropagation();
        // Handle routing overlap pick mode
        if (window.routingOverlapPickMode && window.routingOverlapPickMode()) {
          if (window.handleRoutingOverlapPick && window.handleRoutingOverlapPick(e.id)) {
            return;
          }
        }
        // Handle link pick modes in calculation mode
        if (window.routeFinderState && window.routeFinderState.active) {
          if (window.routeFinderState.pickMode === 'excludeLink') {
            addExcludedLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          if (window.routeFinderState.pickMode === 'mustUseLink') {
            addMustUseLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          if (window.routeFinderState.pickMode === 'diverseFromLink') {
            if (typeof addDiverseFromLink === 'function') addDiverseFromLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          return;
        }
        // Handle cable system add mode
        if (typeof handleAddModeClick === 'function' && handleAddModeClick('edge', e.id)) {
          return;
        }
        // Handle multilink group link picking
        if (typeof handleMLGLinkClick === 'function' && handleMLGLinkClick(e.id)) {
          return;
        }
        if (ev.shiftKey) {
          if (state.selection.edges.has(e.id)) {
            state.selection.edges.delete(e.id);
            state.selected = null;
          } else {
            state.selection.edges.add(e.id);
            state.selected = null;
          }
          render();
          return;
        }
        select({type:'edge', id:e.id});
        state.connectFrom=null;
        render();
      });
      svg.appendChild(hitArea);

      baseLabel = curveBaseLabelPoint(ax, ay, bx, by, e.curveArch || 0.3);

      // Draw draggable handle at curve midpoint when selected
      if (isSel) {
        const cp = getCurveControlPoint(ax, ay, bx, by, e.curveArch || 0.3);
        const handle = document.createElementNS('http://www.w3.org/2000/svg','circle');
        handle.setAttribute('cx', cp.x);
        handle.setAttribute('cy', cp.y);
        handle.setAttribute('r', 6);
        handle.setAttribute('fill', '#ff6b6b');
        handle.setAttribute('stroke', '#ffffff');
        handle.setAttribute('stroke-width', 2);
        handle.style.cursor = 'grab';
        handle.addEventListener('mousedown', (ev) => {
          ev.stopPropagation();
          state.dragging = {type: 'curveHandle', edgeId: e.id, startX: ev.clientX, startY: ev.clientY, baseArch: e.curveArch || 0.3};
          handle.style.cursor = 'grabbing';
        });
        svg.appendChild(handle);
      }
    } else {
      console.log(`[DRAW EDGE] Creating STRAIGHT line from (${ax}, ${ay}) to (${bx}, ${by}), color: ${e.strokeColor || "#7f8aa6"}, strokeW: ${e.strokeW ?? 2}`);

      // Draw selection glow FIRST (behind the edge) if selected
      if (isSel) {
        const glowLine = document.createElementNS('http://www.w3.org/2000/svg','line');
        glowLine.setAttribute('x1', ax); glowLine.setAttribute('y1', ay);
        glowLine.setAttribute('x2', bx); glowLine.setAttribute('y2', by);
        glowLine.setAttribute('class', 'edge-selection-glow');
        glowLine.setAttribute('stroke-width', (e.strokeW ?? 2) + 6);
        // Apply same line style to glow
        if (e.lineStyle && e.lineStyle !== 'solid') {
          glowLine.setAttribute('stroke-dasharray', getStrokeDasharray(e.lineStyle, e.strokeW ?? 2));
        }
        svg.appendChild(glowLine);
      }

      // Draw the visible edge
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', ax); line.setAttribute('y1', ay);
      line.setAttribute('x2', bx); line.setAttribute('y2', by);
      line.setAttribute('class', 'edge' + (isSel ? ' selected' : ''));
      line.setAttribute('data-edge-id', e.id);
      line.setAttribute('stroke-width', (e.strokeW ?? 2));
      line.setAttribute('stroke', effectiveStrokeColor);
      // Apply line style
      if (e.lineStyle && e.lineStyle !== 'solid') {
        line.setAttribute('stroke-dasharray', getStrokeDasharray(e.lineStyle, e.strokeW ?? 2));
      }
      line.style.pointerEvents = 'none'; // Disable clicks on visible edge
      console.log(`[DRAW EDGE] Line element created and appending to SVG`);
      svg.appendChild(line);

      // Add invisible wide hit area for easier clicking
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg','line');
      hitArea.setAttribute('x1', ax); hitArea.setAttribute('y1', ay);
      hitArea.setAttribute('x2', bx); hitArea.setAttribute('y2', by);
      hitArea.setAttribute('stroke', 'transparent');
      hitArea.setAttribute('stroke-width', 20); // Wide invisible hit area
      hitArea.style.cursor = 'pointer';
      hitArea.addEventListener('click', (ev) => {
        ev.stopPropagation();
        // Handle routing overlap pick mode
        if (window.routingOverlapPickMode && window.routingOverlapPickMode()) {
          if (window.handleRoutingOverlapPick && window.handleRoutingOverlapPick(e.id)) {
            return;
          }
        }
        // Handle link pick modes in calculation mode
        if (window.routeFinderState && window.routeFinderState.active) {
          if (window.routeFinderState.pickMode === 'excludeLink') {
            addExcludedLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          if (window.routeFinderState.pickMode === 'mustUseLink') {
            addMustUseLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          if (window.routeFinderState.pickMode === 'diverseFromLink') {
            if (typeof addDiverseFromLink === 'function') addDiverseFromLink(e.id);
            window.routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }
          return;
        }
        // Handle cable system add mode
        if (typeof handleAddModeClick === 'function' && handleAddModeClick('edge', e.id)) {
          return;
        }
        // Handle multilink group link picking
        if (typeof handleMLGLinkClick === 'function' && handleMLGLinkClick(e.id)) {
          return;
        }
        if (ev.shiftKey) {
          if (state.selection.edges.has(e.id)) {
            state.selection.edges.delete(e.id);
            state.selected = null;
          } else {
            state.selection.edges.add(e.id);
            state.selected = null;
          }
          render();
          return;
        }
        select({type:'edge', id:e.id});
        state.connectFrom=null;
        render();
      });
      svg.appendChild(hitArea);

      console.log(`[DRAW EDGE] Line appended to SVG`);
      baseLabel = { x:(ax+bx)/2, y:(ay+by)/2 };
    }

    // Store endpoint positions for selected edges so handles can be drawn above nodes
    if (isSel) {
      _selEdgeEndpoints[e.id] = { ax, ay, bx, by };
    }

    const lx = baseLabel.x + (e.labelDx || 0);
    const ly = baseLabel.y + (e.labelDy || 0);

    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('x', lx);
    label.setAttribute('y', ly);
    label.setAttribute('class', 'edge-label');
    label.setAttribute('fill', e.tagColor || "#eaeaea");
    label.style.fontSize = (e.tagSize || 12) + "px";
    label.style.fontFamily = e.tagFont || 'Arial';
    label.style.pointerEvents = "auto";
    setMultilineText(label, getEdgeLabelLines(e), (e.tagSize || 12));

    label.addEventListener('click', (ev) => {
      ev.stopPropagation();
      if (ev.shiftKey) {
        if (state.selection.edges.has(e.id)) {
          state.selection.edges.delete(e.id);
          state.selected = null;
        } else {
          state.selection.edges.add(e.id);
          state.selected = null;
        }
        render();
        return;
      }
      select({type:'edge', id:e.id});
      state.connectFrom=null;
      render();
    });
    label.addEventListener('mousedown', (ev) => {
      if (!(ev.ctrlKey || ev.metaKey)) return;
      ev.stopPropagation();
      const m = getMouse(ev);
      state.dragging = { type:'edgeLabel', id:e.id, dx: lx - m.x, dy: ly - m.y };
      select({type:'edge', id:e.id});
      state.connectFrom = null;
      render();
    });

    svg.appendChild(label);
  }

  // Calculate node bounding box based on shape and size
  function getNodeBounds(n) {
    const r = n.r ?? 24;
    const shape = n.shape || 'circle';

    let x, y, w, h;

    switch (shape) {
      case 'square':
        x = n.x - r;
        y = n.y - r;
        w = r * 2;
        h = r * 2;
        break;
      case 'rectangle':
        x = n.x - r * 1.35;
        y = n.y - r * 0.85;
        w = r * 2.7;
        h = r * 1.7;
        break;
      case 'ellipse':
        x = n.x - r * 1.35;
        y = n.y - r * 0.9;
        w = r * 2.7;
        h = r * 1.8;
        break;
      case 'triangle':
        x = n.x - r * 1.25;
        y = n.y - r * 1.25;
        w = r * 2.5;
        h = r * 2.5;
        break;
      case 'hexagon':
        x = n.x - r * 1.2;
        y = n.y - r * 1.2;
        w = r * 2.4;
        h = r * 2.4;
        break;
      default: // circle
        x = n.x - r;
        y = n.y - r;
        w = r * 2;
        h = r * 2;
    }

    return { x, y, w, h };
  }

  function drawNode(n) {
    // console.log(`[DRAW] Creating node ${n.id} at (${n.x}, ${n.y})`);
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.dataset.nodeId = n.id; // For context menu lookup
    const isSelected = (state.selected?.type==='node' && state.selected.id===n.id) || state.selection.nodes.has(n.id);
    const isLinkSource = linkMode && linkSourceNode === n.id;
    const isInLinkMode = linkMode && isSelected; // In link mode, all selected nodes show as potential sources

    // Check if this node should be highlighted (cable system selection or temporary highlight)
    const nodeCSIds = n.cableSystemIds || [];
    const isCSHighlighted = state.selectedCableSystem && nodeCSIds.includes(state.selectedCableSystem);
    const isTempHighlighted = state._highlightedNodes && state._highlightedNodes.has(n.id);
    const isHighlighted = isCSHighlighted || isTempHighlighted;

    let classes = 'node';
    // In link mode, show orange for source (pulsing) or any selected node (ready to be source)
    if (isLinkSource) {
      classes += ' link-source'; // Orange pulsing
    } else if (isInLinkMode) {
      classes += ' link-source'; // Orange (same style, shows it's ready to be selected as source)
    } else if (isSelected) {
      classes += ' selected'; // Normal cyan selection (when not in link mode)
    }
    g.setAttribute('class', classes);

    const r = (n.r ?? 24);
    const sw = (n.strokeW ?? 2);

    // Draw highlight glow behind node if highlighted
    if (isHighlighted) {
      const shape = (n.shape || 'circle');
      let glow = null;
      if (shape === 'square') {
        glow = document.createElementNS('http://www.w3.org/2000/svg','rect');
        glow.setAttribute('x', n.x - r - 4);
        glow.setAttribute('y', n.y - r - 4);
        glow.setAttribute('width', r*2 + 8);
        glow.setAttribute('height', r*2 + 8);
        glow.setAttribute('rx', 6);
        glow.setAttribute('ry', 6);
      } else if (shape === 'rectangle') {
        glow = document.createElementNS('http://www.w3.org/2000/svg','rect');
        glow.setAttribute('x', n.x - r*1.35 - 4);
        glow.setAttribute('y', n.y - r*0.85 - 4);
        glow.setAttribute('width', r*2.7 + 8);
        glow.setAttribute('height', r*1.7 + 8);
        glow.setAttribute('rx', 8);
        glow.setAttribute('ry', 8);
      } else if (shape === 'ellipse') {
        glow = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
        glow.setAttribute('cx', n.x);
        glow.setAttribute('cy', n.y);
        glow.setAttribute('rx', r*1.35 + 4);
        glow.setAttribute('ry', r*0.9 + 4);
      } else {
        glow = document.createElementNS('http://www.w3.org/2000/svg','circle');
        glow.setAttribute('cx', n.x);
        glow.setAttribute('cy', n.y);
        glow.setAttribute('r', r + 4);
      }
      glow.setAttribute('fill', 'none');
      glow.setAttribute('stroke', '#00d4ff');
      glow.setAttribute('stroke-width', 6);
      glow.setAttribute('opacity', '0.6');
      glow.style.pointerEvents = 'none';
      g.appendChild(glow);
    }

    let c = null;
    const shape = (n.shape || 'circle');

    // Check for custom SVG shape from library
    if (n.customSvg) {
      // Create a group to hold the custom SVG
      c = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      c.setAttribute('class', 'node-circle custom-svg-node');

      // Parse and insert the SVG
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(n.customSvg, 'image/svg+xml');
      const svgEl = svgDoc.querySelector('svg');

      if (svgEl) {
        // Get viewBox or create one
        let vb = svgEl.getAttribute('viewBox');
        if (!vb) {
          const w = parseFloat(svgEl.getAttribute('width')) || 64;
          const h = parseFloat(svgEl.getAttribute('height')) || 64;
          vb = `0 0 ${w} ${h}`;
        }
        const [vbX, vbY, vbW, vbH] = vb.split(/[\s,]+/).map(Number);

        // Calculate scale and position
        const size = r * 2;
        const scale = size / Math.max(vbW, vbH);
        const offsetX = n.x - (vbW * scale) / 2;
        const offsetY = n.y - (vbH * scale) / 2;

        c.setAttribute('transform', `translate(${offsetX}, ${offsetY}) scale(${scale})`);

        // Clone child elements into our group
        Array.from(svgEl.childNodes).forEach(child => {
          if (child.nodeType === 1) { // Element node
            c.appendChild(child.cloneNode(true));
          }
        });
      }

      // Set pointerEvents to none on the visual, hitArea will handle clicks
      c.style.pointerEvents = 'none';

      // Add hit area AFTER c so it's on top in the DOM (but visually transparent)
      // This is handled below after c is appended to g
    } else if (shape === 'square') {
      c = document.createElementNS('http://www.w3.org/2000/svg','rect');
      c.setAttribute('x', n.x - r);
      c.setAttribute('y', n.y - r);
      c.setAttribute('width', r*2);
      c.setAttribute('height', r*2);
      c.setAttribute('rx', 4);
      c.setAttribute('ry', 4);
    } else if (shape === 'rectangle') {
      c = document.createElementNS('http://www.w3.org/2000/svg','rect');
      c.setAttribute('x', n.x - r*1.35);
      c.setAttribute('y', n.y - r*0.85);
      c.setAttribute('width', r*2.7);
      c.setAttribute('height', r*1.7);
      c.setAttribute('rx', 6);
      c.setAttribute('ry', 6);
    } else if (shape === 'ellipse') {
      c = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
      c.setAttribute('cx', n.x);
      c.setAttribute('cy', n.y);
      c.setAttribute('rx', r*1.35);
      c.setAttribute('ry', r*0.9);
    } else if (shape === 'triangle') {
      c = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      c.setAttribute('points', polygonPoints(n.x, n.y, r*1.25, 3, -Math.PI/2));
    } else if (shape === 'hexagon') {
      c = document.createElementNS('http://www.w3.org/2000/svg','polygon');
      c.setAttribute('points', polygonPoints(n.x, n.y, r*1.2, 6, Math.PI/6));
    } else {
      c = document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('cx', n.x);
      c.setAttribute('cy', n.y);
      c.setAttribute('r', r);
    }

    // Apply styling only to built-in shapes (not custom SVGs)
    if (!n.customSvg) {
      c.setAttribute('class', 'node-circle');
      c.setAttribute('fill', n.fill || "#1b2030");
      c.setAttribute('stroke', n.stroke || "#9fb3ff");
      c.setAttribute('stroke-width', sw);
      // Apply line style to node border
      if (n.lineStyle && n.lineStyle !== 'solid') {
        c.setAttribute('stroke-dasharray', getStrokeDasharray(n.lineStyle, sw));
      }
      c.style.pointerEvents = "auto";
      c.style.cursor = "pointer";
    }

    // Attach click listener directly to circle for better event capture
    // This is now handled by the group click listener above
    // console.log(`[DRAW] Attaching click listener to node ${n.id}`, {tagName: c.tagName, class: c.getAttribute('class'), r, x: n.x, y: n.y});
    // (old click listener code removed - now using group click handler)

    const nameX = n.x + (n.nameDx || 0);
    const nameY = n.y + (n.nameDy || 0);

    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x', nameX);
    t.setAttribute('y', nameY);
    t.setAttribute('class', 'node-text');
    // Default fill (will be overridden by tspan styles)
    t.setAttribute('fill', n.nameColor || "#eaeaea");

    const styledLines = [];
    // Node Code - show if globally enabled AND per-node enabled (defaults to true)
    if (state.ui.showNodeCode && n.showCode !== false && n.code && n.code.trim()) {
      styledLines.push({
        text: n.code.trim(),
        fill: n.codeColor || "#000000",
        fontSize: n.codeSize || 13,
        fontFamily: n.codeFont || 'Arial'
      });
    }
    // Node Name - show if globally enabled AND per-node enabled (defaults to true)
    if (state.ui.showNodeName !== false && n.showName !== false) {
      styledLines.push({
        text: n.name || `N${n.id}`,
        fill: n.nameColor || "#eaeaea",
        fontSize: n.nameSize || 13,
        fontFamily: n.nameFont || 'Arial'
      });
    }
    setStyledMultilineText(t, styledLines);
    t.style.pointerEvents = "auto";  // Enable pointer events for Ctrl+drag
    t.style.cursor = "default";

    const tagX = n.x + (n.tagDx || 0);
    const tagY = n.y + 26 + (n.tagDy || 0);

    const tags = document.createElementNS('http://www.w3.org/2000/svg','text');
    tags.setAttribute('x', tagX);
    tags.setAttribute('y', tagY);
    tags.setAttribute('class', 'tag-text');
    tags.setAttribute('fill', n.extraTagsColor || "#b7c0df");
    tags.style.fontSize = (n.extraTagsSize || 11) + "px";
    tags.style.fontFamily = n.extraTagsFont || 'Arial';

    // Build tag text based on visibility settings
    const tagParts = [];
    // Show node tags if globally enabled AND per-node enabled
    if (state.ui.showNodeTags && n.tags?.length) {
      tagParts.push(n.tags.join(', '));
    }
    // Show extra tags if per-node enabled (defaults to false)
    if (n.showExtraTags && n.extraTags?.trim()) {
      tagParts.push(n.extraTags.trim());
    }
    tags.textContent = tagParts.join(' | ');

    tags.style.pointerEvents = "auto";  // Enable pointer events for Ctrl+drag
    tags.style.cursor = "default";

    // Add selection glow ring overlay BEFORE the main node (behind it) - preserves original colors
    if (isSelected && !isLinkSource && !isInLinkMode) {
      let selectionGlow = null;
      const glowOffset = 4; // Gap between node and glow ring
      if (shape === 'square') {
        selectionGlow = document.createElementNS('http://www.w3.org/2000/svg','rect');
        selectionGlow.setAttribute('x', n.x - r - glowOffset);
        selectionGlow.setAttribute('y', n.y - r - glowOffset);
        selectionGlow.setAttribute('width', r*2 + glowOffset*2);
        selectionGlow.setAttribute('height', r*2 + glowOffset*2);
        selectionGlow.setAttribute('rx', 6);
        selectionGlow.setAttribute('ry', 6);
      } else if (shape === 'rectangle') {
        selectionGlow = document.createElementNS('http://www.w3.org/2000/svg','rect');
        selectionGlow.setAttribute('x', n.x - r*1.35 - glowOffset);
        selectionGlow.setAttribute('y', n.y - r*0.85 - glowOffset);
        selectionGlow.setAttribute('width', r*2.7 + glowOffset*2);
        selectionGlow.setAttribute('height', r*1.7 + glowOffset*2);
        selectionGlow.setAttribute('rx', 8);
        selectionGlow.setAttribute('ry', 8);
      } else if (shape === 'ellipse') {
        selectionGlow = document.createElementNS('http://www.w3.org/2000/svg','ellipse');
        selectionGlow.setAttribute('cx', n.x);
        selectionGlow.setAttribute('cy', n.y);
        selectionGlow.setAttribute('rx', r*1.35 + glowOffset);
        selectionGlow.setAttribute('ry', r*0.9 + glowOffset);
      } else if (shape === 'triangle') {
        // For triangle, use a slightly larger triangle outline
        selectionGlow = document.createElementNS('http://www.w3.org/2000/svg','polygon');
        selectionGlow.setAttribute('points', polygonPoints(n.x, n.y, r*1.25 + glowOffset, 3, -Math.PI/2));
      } else if (shape === 'hexagon') {
        selectionGlow = document.createElementNS('http://www.w3.org/2000/svg','polygon');
        selectionGlow.setAttribute('points', polygonPoints(n.x, n.y, r*1.2 + glowOffset, 6, Math.PI/6));
      } else {
        // Circle (default)
        selectionGlow = document.createElementNS('http://www.w3.org/2000/svg','circle');
        selectionGlow.setAttribute('cx', n.x);
        selectionGlow.setAttribute('cy', n.y);
        selectionGlow.setAttribute('r', r + glowOffset);
      }
      selectionGlow.setAttribute('class', 'node-selection-glow');
      selectionGlow.style.pointerEvents = 'none';
      g.insertBefore(selectionGlow, g.firstChild); // Insert at beginning so it's behind everything
    }

    g.appendChild(c); g.appendChild(t); g.appendChild(tags);

    // For custom SVG nodes, add hit area on top for click detection
    if (n.customSvg) {
      const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      hitArea.setAttribute('cx', n.x);
      hitArea.setAttribute('cy', n.y);
      hitArea.setAttribute('r', r);
      hitArea.setAttribute('fill', 'transparent');
      hitArea.setAttribute('class', 'node-circle node-circle-hit');
      hitArea.style.pointerEvents = 'auto';
      hitArea.style.cursor = 'pointer';
      g.appendChild(hitArea);
    }

    // Add resize handles at corners (invisible but functional)
    const handleSize = 8;
    const nodeBounds = getNodeBounds(n);
    const nodeHandlePositions = [
      { corner: 'nw', x: nodeBounds.x, y: nodeBounds.y },
      { corner: 'ne', x: nodeBounds.x + nodeBounds.w - handleSize, y: nodeBounds.y },
      { corner: 'sw', x: nodeBounds.x, y: nodeBounds.y + nodeBounds.h - handleSize },
      { corner: 'se', x: nodeBounds.x + nodeBounds.w - handleSize, y: nodeBounds.y + nodeBounds.h - handleSize }
    ];

    nodeHandlePositions.forEach(pos => {
      const resizeHandle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      resizeHandle.setAttribute('x', pos.x);
      resizeHandle.setAttribute('y', pos.y);
      resizeHandle.setAttribute('width', handleSize);
      resizeHandle.setAttribute('height', handleSize);
      resizeHandle.setAttribute('rx', 2);
      resizeHandle.setAttribute('ry', 2);
      resizeHandle.setAttribute('class', `node-resize-handle handle-${pos.corner}`);
      resizeHandle.setAttribute('data-corner', pos.corner);

      resizeHandle.addEventListener('mousedown', (ev) => {
        ev.stopPropagation();
        const m = getMouse(ev);
        select({type:'node', id:n.id});
        state.resizingNode = {
          id: n.id,
          corner: pos.corner,
          startR: r,
          startX: n.x,
          startY: n.y,
          mx0: m.x,
          my0: m.y
        };
        state.connectFrom = null;
        render();
      });

      g.appendChild(resizeHandle);
    });

    // Handle clicks on the node group (for link mode and regular selection)
    // Use mouseup instead of click to ensure it fires even after mousedown's stopPropagation
    console.log(`[NODE LISTENER] Attaching mouseup listener to node ${n.id}`);
    g.addEventListener('mouseup', (ev) => {
      const isWithinGroup = g.contains(ev.target);
      const isCircle = ev.target === c;
      const isGroup = ev.target === g;
      console.log(`[NODE CLICK] Node ${n.id} - mouseup target: ${ev.target.tagName}/${ev.target.getAttribute?.('class') ?? 'none'}, isCircle: ${isCircle}, isGroup: ${isGroup}, withinGroup: ${isWithinGroup}, linkMode: ${linkMode}, dragging: ${!!state.dragging}`);

      // Process if clicked on circle, group, or any child within the group
      if (isCircle || isGroup || isWithinGroup) {
        console.log(`[NODE CLICK] Node ${n.id} clicked (mouseup) - linkMode: ${linkMode}, linkSourceNode: ${linkSourceNode}`);

        // Handle link mode clicks - these take priority over drag detection
        if (linkMode) {
          ev.stopPropagation(); // Only stop propagation in link mode
          if (linkSourceNode === null) {
            // First click - set source node
            linkSourceNode = n.id;
            window.linkSourceNode = linkSourceNode;
            console.log(`[LINK MODE] Node ${n.id} set as SOURCE - waiting for target click`);
            select({type:'node', id:n.id});
            render(); // Show the orange highlight for the source node
            showToast(`Link source selected: ${n.name || `N${n.id}`} â†’ Now click target node`);
            return;
          } else {
            // Second click - create link
            if (linkSourceNode === n.id) {
              console.log(`[LINK MODE] Node ${n.id} - ERROR: Cannot link to itself`);
              showToast('âŒ Cannot link node to itself - click a different target node');
              return;
            }
            console.log(`[LINK MODE] Node ${n.id} set as TARGET - Creating link from ${linkSourceNode} to ${n.id}`);
            const sourceId = linkSourceNode;
            linkSourceNode = null;  // Reset for next link - ready to select new source
            window.linkSourceNode = null;
            createEdge(sourceId, n.id, true); // Skip edge selection in link mode
            clearSelection(); // Clear any selection to show we're ready for next source
            render(); // Update display to show cleared selection
            showToast(`âœ“ Link created! Click a node to be the source for the next link`);
            return;
          }
        }

        // Handle cable system add mode
        if (typeof handleAddModeClick === 'function' && handleAddModeClick('node', n.id)) {
          ev.stopPropagation();
          return;
        }

        // Handle calculation mode (Route Finder) - intercept clicks to set origin/destination
        if (window.routeFinderState && window.routeFinderState.active) {
          ev.stopPropagation();
          if (typeof handleCalculationModeNodeClick === 'function') {
            handleCalculationModeNodeClick(n.id);
          }
          return;
        }

        // Check if this was actually a drag operation (only matters outside link mode)
        if (state.dragging) {
          console.log(`[NODE CLICK] Node ${n.id} - Was dragging, letting global handler clear state`);
          // Don't stop propagation - let the global mouseup handler clear state.dragging
          return;
        }

        // Not in link mode and not dragging - regular selection click
        console.log(`[NODE CLICK] Node ${n.id} - Normal selection`);
        ev.stopPropagation();

        // Handle shift-click for multi-selection
        if (ev.shiftKey) {
          if (state.selection.nodes.has(n.id)) {
            state.selection.nodes.delete(n.id);
            state.selected = null;
          } else {
            state.selection.nodes.add(n.id);
            state.selected = null;
          }
          render();
          return;
        }

        // Normal click - select this node
        select({type:'node', id:n.id});
        render();
      }
    });

    g.addEventListener('mousedown', (ev) => {
      // In link mode, don't set up dragging or select - let mouseup handle everything
      if (linkMode) {
        ev.stopPropagation();
        console.log(`[NODE MOUSEDOWN] Node ${n.id} - in link mode, skipping drag setup`);
        return;
      }

      // In calculation mode (Route Finder), don't drag - let mouseup handle selection
      if (window.routeFinderState && window.routeFinderState.active) {
        ev.stopPropagation();
        return;
      }

      // Shift+click without Ctrl - let mouseup handle multi-selection, don't set up dragging
      if (ev.shiftKey && !(ev.ctrlKey || ev.metaKey)) {
        ev.stopPropagation();
        console.log(`[NODE MOUSEDOWN] Node ${n.id} - Shift+click, letting mouseup handle multi-select`);
        return;
      }

      // Alt+drag from node to create a new link (drag-to-link)
      if (ev.altKey && !(ev.ctrlKey || ev.metaKey)) {
        ev.stopPropagation();
        ev.preventDefault();
        const m = getMouse(ev);
        state.dragging = { type: 'linkDrag', sourceId: n.id, mx: m.x, my: m.y };
        console.log(`[LINK DRAG] Started from node ${n.id} (Alt+drag)`);
        return;
      }

      // Normal mode - set up dragging
      ev.stopPropagation();
      const m = getMouse(ev);
      state.lastMouse = { x: m.x, y: m.y };

      // Ctrl+Shift+drag duplicates current selection and drags the copy
      if ((ev.ctrlKey || ev.metaKey) && ev.shiftKey) {
        if (!state.selection.nodes.has(n.id) && !state.selection.groups.size && !state.selection.edges.size) {
          setSingleSelection({type:'node', id:n.id});
        }
        copySelection();
        pasteSelection();
        // start dragging the pasted selection as a block
        const origNodes = [...state.selection.nodes].map(id => {
          const nn = findNode(id); return nn ? {id, x: nn.x, y: nn.y} : null;
        }).filter(Boolean);
        const origGroups = [...state.selection.groups].map(id => {
          const gg = findGroup(id); return gg ? {id, x: gg.x, y: gg.y} : null;
        }).filter(Boolean);
        state.dragging = { type:'selection', mx0: m.x, my0: m.y, origNodes, origGroups };
        state.connectFrom = null;
        render();
        return;
      }

      // Check BEFORE calling select() to preserve multi-selection if dragging
      // If the clicked node is part of a multi-selection, drag entire selection
      if (state.selection.nodes.has(n.id) && (state.selection.nodes.size > 1 || state.selection.groups.size > 0)) {
        console.log(`[MULTI-DRAG] Node ${n.id} is part of multi-selection (${state.selection.nodes.size} nodes, ${state.selection.groups.size} groups) - setting up multi-drag`);
        const origNodes = [...state.selection.nodes].map(id => {
          const nn = findNode(id); return nn ? {id, x: nn.x, y: nn.y} : null;
        }).filter(Boolean);
        const origGroups = [...state.selection.groups].map(id => {
          const gg = findGroup(id); return gg ? {id, x: gg.x, y: gg.y} : null;
        }).filter(Boolean);
        state.dragging = { type:'selection', mx0: m.x, my0: m.y, origNodes, origGroups };
        state.selected = null; // Clear single selection when dragging multiple
        console.log(`[MULTI-DRAG] Dragging ${origNodes.length} nodes and ${origGroups.length} groups`);
      } else {
        console.log(`[SINGLE-DRAG] Node ${n.id} - single selection drag setup`);
        // Don't call select() here - it triggers render() which recreates DOM and breaks drag
        // Just add to selection set for visual feedback
        if (!state.selection.nodes.has(n.id)) {
          setSingleSelection({type:'node', id:n.id});
        }
        state.dragging = { type:'node', id:n.id, dx: n.x - m.x, dy: n.y - m.y, origX: n.x, origY: n.y };
      }
      state.connectFrom = null;
    });

    t.addEventListener('mousedown', (ev) => {
      console.log(`[TEXT MOUSEDOWN] Node ${n.id} name label - Ctrl: ${ev.ctrlKey}, Meta: ${ev.metaKey}`);
      // Ctrl+drag to move the label
      if (ev.ctrlKey || ev.metaKey) {
        console.log(`[TEXT MOUSEDOWN] Node ${n.id} - Setting up name label drag`);
        ev.stopPropagation();
        const m = getMouse(ev);
        state.dragging = { type:'nodeNameLabel', id:n.id, dx: nameX - m.x, dy: nameY - m.y, origDx: n.nameDx||0, origDy: n.nameDy||0 };
        select({type:'node', id:n.id});
        state.connectFrom = null;
        render();
        return;
      }
      // Normal click - don't handle it here, let it bubble to parent group
    });

    tags.addEventListener('mousedown', (ev) => {
      console.log(`[TAGS MOUSEDOWN] Node ${n.id} tags - Ctrl: ${ev.ctrlKey}, Meta: ${ev.metaKey}`);
      // Ctrl+drag to move the tags
      if (ev.ctrlKey || ev.metaKey) {
        console.log(`[TAGS MOUSEDOWN] Node ${n.id} - Setting up tags drag`);
        ev.stopPropagation();
        const m = getMouse(ev);
        state.dragging = { type:'nodeTagLabel', id:n.id, dx: tagX - m.x, dy: tagY - m.y, origDx: n.tagDx||0, origDy: n.tagDy||0 };
        select({type:'node', id:n.id});
        state.connectFrom = null;
        render();
        return;
      }
      // Normal click - don't handle it here, let it bubble to parent group
    });

    // console.log(`[DRAW] Node ${n.id} fully created, appending to SVG`);
    svg.appendChild(g);
    // Verify circle is in DOM and has proper bounds
    const circles = g.querySelectorAll('circle, polygon');
    // console.log(`[DRAW] Node ${n.id} appended - found ${circles.length} circle(s) in group`, circles[0] ? {cx: circles[0].getAttribute('cx'), cy: circles[0].getAttribute('cy'), r: circles[0].getAttribute('r')} : 'none');
  }

  const noSel = document.getElementById('noSelection');
  const nodeIns = document.getElementById('nodeInspector');
  const edgeIns = document.getElementById('edgeInspector');
  const groupIns = document.getElementById('groupInspector');

  // UUID fields (read-only)
  const nodeUUID = document.getElementById('nodeUUID');
  const edgeUUID = document.getElementById('edgeUUID');
  const edgeSourceUUID = document.getElementById('edgeSourceUUID');
  const edgeTargetUUID = document.getElementById('edgeTargetUUID');
  const groupUUID = document.getElementById('groupUUID');

  const nodeName = document.getElementById('nodeName');
  const nodeTags = document.getElementById('nodeTags');
  const nodeGroup = document.getElementById('nodeGroup');
  const nodeExtraTags = document.getElementById('nodeExtraTags');
  const nodeCode = document.getElementById('nodeCode');
  const nodeShowCode = document.getElementById('nodeShowCode');
  const nodeNameFont = document.getElementById('nodeNameFont');
  const nodeTagFont = document.getElementById('nodeTagFont');
  const nodeNameColor = document.getElementById('nodeNameColor');
  const nodeTagColor = document.getElementById('nodeTagColor');
  const nodeFill = document.getElementById('nodeFill');
  const nodeStroke = document.getElementById('nodeStroke');
  const nodeStrokeW = document.getElementById('nodeStrokeW');
  const nodeAddress = document.getElementById('nodeAddress');
const nodeCity = document.getElementById('nodeCity');
const nodeCountry = document.getElementById('nodeCountry');
const nodePostalCode = document.getElementById('nodePostalCode');
const nodeCounty = document.getElementById('nodeCounty');
const nodeState = document.getElementById('nodeState');
  const nodeSize = document.getElementById('nodeSize');
const edgeTag = document.getElementById('edgeTag');
  const edgeFilterTags = document.getElementById('edgeFilterTags');
  const edgeLatency = document.getElementById('edgeLatency');
  const edgeExtraTags = document.getElementById('edgeExtraTags');
  const edgeCode = document.getElementById('edgeCode');
  const edgeShowCode = document.getElementById('edgeShowCode');
  const edgeStyle = document.getElementById('edgeStyle');
  const edgeRoute = document.getElementById('edgeRoute');
  const edgeLabelFont = document.getElementById('edgeLabelFont');
  const edgeLabelColor = document.getElementById('edgeLabelColor');
  const edgeStrokeW = document.getElementById('edgeStrokeW');
  const edgePriority = document.getElementById('edgePriority');
  const edgeStrokeColor = document.getElementById('edgeStrokeColor');
const groupTitle = document.getElementById('groupTitle');
  const groupFilterTags = document.getElementById('groupFilterTags');
  const groupType = document.getElementById('groupType');
  const groupParent = document.getElementById('groupParent');
  const groupExtraTags = document.getElementById('groupExtraTags');
  const groupW = document.getElementById('groupW');
  const groupH = document.getElementById('groupH');
  const groupTitleFont = document.getElementById('groupTitleFont');
  const groupTitleColor = document.getElementById('groupTitleColor');
  const groupFill = document.getElementById('groupFill');
  const groupStroke = document.getElementById('groupStroke');
  const groupStrokeW = document.getElementById('groupStrokeW');

  // Preset controls
  const btnNodePresetSave = document.getElementById('btnNodePresetSave');
  const btnNodePresetApply = document.getElementById('btnNodePresetApply');
  const btnNodePresetDelete = document.getElementById('btnNodePresetDelete');

  const btnEdgePresetSave = document.getElementById('btnEdgePresetSave');
  const btnEdgePresetApply = document.getElementById('btnEdgePresetApply');
  const btnEdgePresetDelete = document.getElementById('btnEdgePresetDelete');

  const btnGroupPresetSave = document.getElementById('btnGroupPresetSave');
  const btnGroupPresetApply = document.getElementById('btnGroupPresetApply');
  const btnGroupPresetDelete = document.getElementById('btnGroupPresetDelete');



  function clearSelection(keepSingle=false) {
    state.selection.nodes.clear();
    state.selection.edges.clear();
    state.selection.groups.clear();
    if (!keepSingle) state.selected = null;
  }

  function setSingleSelection(sel) {
    clearSelection(true);
    state.selected = sel;
    if (sel) {
      console.log(`[SELECTION] ${sel.type.toUpperCase()} selected: id=${sel.id}`);
    }
    if (!sel) return;

    // Apply format painter if armed (single-click targets)
    if (state.styleBrush && state.styleBrush.type === sel.type) {
      if (sel.type === 'node') {
        const n = findNode(sel.id); if (n) applyStyle('node', n, state.styleBrush.style);
      } else if (sel.type === 'edge') {
        const e = findEdge(sel.id); if (e) applyStyle('edge', e, state.styleBrush.style);
      } else if (sel.type === 'group') {
        const g = findGroup(sel.id); if (g) applyStyle('group', g, state.styleBrush.style);
      }
      commit();
    }

    if (sel.type === 'node') state.selection.nodes.add(sel.id);
    if (sel.type === 'edge') state.selection.edges.add(sel.id);
    if (sel.type === 'group') state.selection.groups.add(sel.id);
  }

  function setMultiSelection({nodes=[], edges=[], groups=[]}) {
    state.selected = null;
    state.selection.nodes = new Set(nodes);
    state.selection.edges = new Set(edges);
    state.selection.groups = new Set(groups);
  }

  function deleteSelection() {
    const nIds = new Set(state.selection.nodes);
    const eIds = new Set(state.selection.edges);
    const gIds = new Set(state.selection.groups);
    if (nIds.size===0 && eIds.size===0 && gIds.size===0) return;

    // Delete edges explicitly selected
    if (eIds.size) state.edges = state.edges.filter(e => !eIds.has(e.id));

    // Delete nodes and any edges attached to them
    if (nIds.size) {
      state.nodes = state.nodes.filter(n => !nIds.has(n.id));
      state.edges = state.edges.filter(e => !nIds.has(e.a) && !nIds.has(e.b));
    }

    // Delete groups (country/region)
    if (gIds.size) {
      state.groups = state.groups.filter(g => !gIds.has(g.id));
      // Clear node membership to deleted groups
      state.nodes.forEach(n => { if (n.groupId && gIds.has(n.groupId)) n.groupId = null; });
      // Clear parentId links pointing to deleted regions
      state.groups.forEach(g => { if (g.parentId && gIds.has(g.parentId)) g.parentId = null; });
    }

    clearSelection();
    state.connectFrom = null;
    refreshAllMemberships();
    commit();
    render();
    showToast('Deleted selection.');
  }

  function select(sel) { setSingleSelection(sel); }


  function updateInspector() {
    refreshPresetSelects();
    noSel.style.display='none'; nodeIns.style.display='none'; edgeIns.style.display='none'; groupIns.style.display='none';
    noSel.textContent = 'Nothing selected.';

    // Update format toolbar indicators
    if (typeof updateFormatIndicators === 'function') updateFormatIndicators();

    // Update data table selection filter if data table is open
    if (typeof syncDataTableWithSelection === 'function') syncDataTableWithSelection();

    // Update capacity editor selection filter if open
    if (typeof syncCapacityEditorWithSelection === 'function') syncCapacityEditorWithSelection();

    if (!state.selected) {
      const c = state.selection.nodes.size + state.selection.edges.size + state.selection.groups.size;
      if (c === 0) { noSel.style.display='block'; return; }
      noSel.style.display='block';
      noSel.textContent = `Multiple selected: ${c} item(s). (Ctrl+C to copy, Ctrl+V to paste)`;
      return;
    }

    if (state.selected.type === 'node') {
      const n = findNode(state.selected.id); if (!n) return;
      nodeIns.style.display='block';
      // Show UUID (generate if missing for legacy data)
      if (!n.uuid) n.uuid = generateUUID();
      if (nodeUUID) nodeUUID.value = n.uuid;
      nodeName.value = n.name || '';
      // Ensure 'default' tag is shown in tags field
      let tagsArray = n.tags || [];
      if (!tagsArray.some(t => t.trim().toLowerCase() === 'default')) {
        tagsArray = ['default', ...tagsArray];
      }
      nodeTags.value = tagsArray.join(', ');
      nodeExtraTags.value = n.extraTags || '';
      nodeCode.value = n.code || '';
      if (nodeShowCode) nodeShowCode.value = (n.showCode !== false) ? '1' : '0';
      nodeNameFont.value = n.nameFont ?? 13;
      nodeTagFont.value = n.tagFont ?? 11;
      nodeNameColor.value = n.nameColor || "#333333";
      nodeTagColor.value = n.tagColor || "#666666";
      nodeFill.value = n.fill || "#dae8fc";
      nodeStroke.value = n.stroke || "#6c8ebf";
      // Update palette color swatches
      const nodeFillSwatch = document.getElementById('nodeFillSwatch');
      const nodeStrokeSwatch = document.getElementById('nodeStrokeSwatch');
      const nodeFillHex = document.getElementById('nodeFillHex');
      const nodeStrokeHex = document.getElementById('nodeStrokeHex');
      const nodeFillCustom = document.getElementById('nodeFillCustom');
      const nodeStrokeCustom = document.getElementById('nodeStrokeCustom');
      if (nodeFillSwatch) nodeFillSwatch.style.backgroundColor = n.fill || '#dae8fc';
      if (nodeStrokeSwatch) nodeStrokeSwatch.style.backgroundColor = n.stroke || '#6c8ebf';
      if (nodeFillHex) nodeFillHex.value = n.fill || '#dae8fc';
      if (nodeStrokeHex) nodeStrokeHex.value = n.stroke || '#6c8ebf';
      if (nodeFillCustom) nodeFillCustom.value = n.fill || '#dae8fc';
      if (nodeStrokeCustom) nodeStrokeCustom.value = n.stroke || '#6c8ebf';
      if (nodeStrokeW) nodeStrokeW.value = n.strokeW ?? 2;
      if (nodeSize) nodeSize.value = n.r ?? 24;
      if (nodeStrokeW) nodeStrokeW.value = n.strokeW ?? 2;
      const g = n.groupId ? findGroup(n.groupId) : null;
      nodeGroup.value = g ? g.title : '(none)';
      // Update cable systems checkboxes
      updateNodeCableSystemsCheckboxes(n.id);
      // Update color pickers
      if (window.updateColorPickers) window.updateColorPickers();

      // Sync inline controls
      const nodeNameColorSwatch = document.getElementById('nodeNameColorSwatch');
      const nodeNameColorInline = document.getElementById('nodeNameColorInline');
      const nodeNameVisibility = document.getElementById('nodeNameVisibility');
      const nodeNameFontInline = document.getElementById('nodeNameFontInline');
      if (nodeNameColorSwatch) nodeNameColorSwatch.style.backgroundColor = n.nameColor || '#eaeaea';
      if (nodeNameColorInline) nodeNameColorInline.value = n.nameColor || '#eaeaea';
      if (nodeNameFontInline) nodeNameFontInline.value = n.nameSize || 13;
      if (nodeNameVisibility) {
        nodeNameVisibility.classList.toggle('hidden', n.showName === false);
      }

      const nodeCodeColorSwatch = document.getElementById('nodeCodeColorSwatch');
      const nodeCodeColorInline = document.getElementById('nodeCodeColorInline');
      const nodeCodeVisibility = document.getElementById('nodeCodeVisibility');
      const nodeCodeFontInline = document.getElementById('nodeCodeFontInline');
      if (nodeCodeColorSwatch) nodeCodeColorSwatch.style.backgroundColor = n.codeColor || '#000000';
      if (nodeCodeColorInline) nodeCodeColorInline.value = n.codeColor || '#000000';
      if (nodeCodeFontInline) nodeCodeFontInline.value = n.codeSize || 13;
      if (nodeCodeVisibility) {
        nodeCodeVisibility.classList.toggle('hidden', n.showCode === false);
      }

      const nodeExtraTagsColorSwatch = document.getElementById('nodeExtraTagsColorSwatch');
      const nodeExtraTagsColorInline = document.getElementById('nodeExtraTagsColorInline');
      const nodeExtraTagsVisibility = document.getElementById('nodeExtraTagsVisibility');
      const nodeExtraTagsFontInline = document.getElementById('nodeExtraTagsFontInline');
      if (nodeExtraTagsColorSwatch) nodeExtraTagsColorSwatch.style.backgroundColor = n.extraTagsColor || '#b7c0df';
      if (nodeExtraTagsColorInline) nodeExtraTagsColorInline.value = n.extraTagsColor || '#b7c0df';
      if (nodeExtraTagsFontInline) nodeExtraTagsFontInline.value = n.extraTagsSize || 11;
      if (nodeExtraTagsVisibility) {
        nodeExtraTagsVisibility.classList.toggle('hidden', n.showExtraTags === false);
      }

      // Update location fields
      if (nodeAddress) nodeAddress.value = n.address || '';
      if (nodeCity) nodeCity.value = n.city || '';
      if (nodeCountry) nodeCountry.value = n.country || '';
      if (nodePostalCode) nodePostalCode.value = n.postalCode || '';
      if (nodeCounty) nodeCounty.value = n.county || '';
      if (nodeState) nodeState.value = n.state || '';

      // Update GPS coordinate fields
      if (typeof updateGpsFields === 'function') {
        updateGpsFields(n);
      }

      return;
    }

    if (state.selected.type === 'edge') {
      const e = findEdge(state.selected.id); if (!e) return;
      edgeIns.style.display='block';
      // Show UUIDs (generate if missing for legacy data)
      if (!e.uuid) e.uuid = generateUUID();
      if (edgeUUID) edgeUUID.value = e.uuid;
      // Show source and target node UUIDs
      const sourceNode = findNode(e.a);
      const targetNode = findNode(e.b);
      if (edgeSourceUUID) {
        if (sourceNode) {
          if (!sourceNode.uuid) sourceNode.uuid = generateUUID();
          edgeSourceUUID.value = sourceNode.uuid;
        } else {
          edgeSourceUUID.value = '(unknown)';
        }
      }
      if (edgeTargetUUID) {
        if (targetNode) {
          if (!targetNode.uuid) targetNode.uuid = generateUUID();
          edgeTargetUUID.value = targetNode.uuid;
        } else {
          edgeTargetUUID.value = '(unknown)';
        }
      }

      // Update cable system dropdown
      updateEdgeCableSystemDropdown();
      const edgeCableSystemEl = document.getElementById('edgeCableSystem');
      if (edgeCableSystemEl) {
        edgeCableSystemEl.value = e.cableSystemId || '';
        const infoEl = document.getElementById('edgeCableSystemInfo');
        if (infoEl) {
          if (e.cableSystemId) {
            const cs = findCableSystem(e.cableSystemId);
            infoEl.textContent = cs ? cs.name : '';
          } else {
            infoEl.textContent = '';
          }
        }
      }

      edgeTag.value = e.tag || '';
      // Ensure 'default' tag is shown in filter tags field
      let edgeTagsArray = e.filterTags || [];
      if (!edgeTagsArray.some(t => t.trim().toLowerCase() === 'default')) {
        edgeTagsArray = ['default', ...edgeTagsArray];
      }
      if (edgeFilterTags) edgeFilterTags.value = edgeTagsArray.join(', ');
      edgeLatency.value = (typeof e.latencyMs === "number" && isFinite(e.latencyMs)) ? e.latencyMs : '';
      if (edgePriority) edgePriority.value = (typeof e.priority === "number" && isFinite(e.priority)) ? e.priority : 0;

      // Populate capacity inventory fields
      const edgeDesignCapacity = document.getElementById('edgeDesignCapacity');
      const edgeCap1G = document.getElementById('edgeCap1G');
      const edgeCap10G = document.getElementById('edgeCap10G');
      const edgeCap100G = document.getElementById('edgeCap100G');
      const edgeCap400G = document.getElementById('edgeCap400G');
      const edgeCapTbps = document.getElementById('edgeCapTbps');
      if (edgeDesignCapacity) edgeDesignCapacity.value = e.designCapacityGbps || 0;
      if (edgeCap1G) edgeCap1G.value = e.cap1G || 0;
      if (edgeCap10G) edgeCap10G.value = e.cap10G || 0;
      if (edgeCap100G) edgeCap100G.value = e.cap100G || 0;
      if (edgeCap400G) edgeCap400G.value = e.cap400G || 0;
      if (edgeCapTbps) edgeCapTbps.value = e.capTbps || 0;
      updateEdgeCapacityTotal();

      // Populate commercial cost fields - TIER BASED
      const tiers = ['1G', '10G', '100G', '400G'];

      // Populate Lease NRC/MRC for each tier
      tiers.forEach(tier => {
        const nrcEl = document.getElementById(`edgeLeaseNRC_${tier}`);
        const mrcEl = document.getElementById(`edgeLeaseMRC_${tier}`);
        if (nrcEl) nrcEl.value = getValueForTier(e.leaseNRC, tier, 0);
        if (mrcEl) mrcEl.value = getValueForTier(e.leaseMRC, tier, state.financialSettings?.defaultMRC || 1);
      });

      // Populate IRU Fee for each tier
      tiers.forEach(tier => {
        const feeEl = document.getElementById(`edgeIRUFee_${tier}`);
        if (feeEl) feeEl.value = getValueForTier(e.iruFee, tier, state.financialSettings?.defaultIRU || 1);
      });

      // Common IRU fields (same for all tiers)
      const edgeIRUTerm = document.getElementById('edgeIRUTerm');
      const edgeIRUOAM = document.getElementById('edgeIRUOAM');
      const edgeIRUOAMIncrement = document.getElementById('edgeIRUOAMIncrement');
      const edgeCostModeLease = document.getElementById('edgeCostModeLease');
      const edgeCostModeIRU = document.getElementById('edgeCostModeIRU');

      if (edgeIRUTerm) edgeIRUTerm.value = e.iruTerm || state.financialSettings?.defaultIRUTerm || 15;
      if (edgeIRUOAM) edgeIRUOAM.value = e.iruOamPercent ?? state.financialSettings?.defaultOAM ?? 3;
      if (edgeIRUOAMIncrement) edgeIRUOAMIncrement.value = e.iruOamAnnualIncrement ?? state.financialSettings?.defaultOAMIncrement ?? 2;

      // Set cost mode radio
      const costMode = e.commercialCostMode || 'lease';
      if (edgeCostModeLease) edgeCostModeLease.checked = (costMode === 'lease');
      if (edgeCostModeIRU) edgeCostModeIRU.checked = (costMode === 'iru');

      // Update calculated cost displays
      if (typeof updateEdgeCostDisplay === 'function') {
        updateEdgeCostDisplay();
      }

      edgeExtraTags.value = e.extraTags || '';
      edgeCode.value = e.code || '';
      edgeStyle.value = e.style || 'straight';
      edgeRoute.value = e.route || 'hv';
      edgeLabelFont.value = e.labelFont ?? 12;
      edgeLabelColor.value = e.labelColor || "#333333";
      if (edgeStrokeW) edgeStrokeW.value = e.strokeW ?? 2;
      if (edgeStrokeColor) edgeStrokeColor.value = e.strokeColor || "#666666";
      // Update edge stroke color palette swatch
      const edgeStrokeColorSwatch = document.getElementById('edgeStrokeColorSwatch');
      const edgeStrokeColorHex = document.getElementById('edgeStrokeColorHex');
      const edgeStrokeColorCustom = document.getElementById('edgeStrokeColorCustom');
      if (edgeStrokeColorSwatch) edgeStrokeColorSwatch.style.backgroundColor = e.strokeColor || '#666666';
      if (edgeStrokeColorHex) edgeStrokeColorHex.value = e.strokeColor || '#666666';
      if (edgeStrokeColorCustom) edgeStrokeColorCustom.value = e.strokeColor || '#666666';
      // Update color pickers
      if (window.updateColorPickers) window.updateColorPickers();

      // Update Routing Overlap section
      updateRoutingOverlapUI(e);

      // Sync inline controls
      const edgeTagColorSwatch = document.getElementById('edgeTagColorSwatch');
      const edgeTagColorInline = document.getElementById('edgeTagColorInline');
      const edgeTagVisibility = document.getElementById('edgeTagVisibility');
      const edgeLabelFontInline = document.getElementById('edgeLabelFontInline');
      if (edgeTagColorSwatch) edgeTagColorSwatch.style.backgroundColor = e.tagColor || '#333333';
      if (edgeTagColorInline) edgeTagColorInline.value = e.tagColor || '#333333';
      if (edgeLabelFontInline) edgeLabelFontInline.value = e.labelFont || 12;
      if (edgeTagVisibility) {
        edgeTagVisibility.classList.toggle('hidden', e.showTag === false);
      }

      const edgeLatencyVisibility = document.getElementById('edgeLatencyVisibility');
      if (edgeLatencyVisibility) {
        edgeLatencyVisibility.classList.toggle('hidden', e.showLatency === false);
      }

      const edgeCodeVisibility = document.getElementById('edgeCodeVisibility');
      if (edgeCodeVisibility) {
        edgeCodeVisibility.classList.toggle('hidden', e.showCode === false);
      }

      // Show/hide curve arch control based on style
      const curveArchControl = document.getElementById('curveArchControl');
      if (e.style === 'curve') {
        curveArchControl.style.display = 'block';
        edgeCurveArch.value = (e.curveArch || 0.3);
        document.getElementById('curveArchValue').textContent = (e.curveArch || 0.3).toFixed(2);
      } else {
        curveArchControl.style.display = 'none';
      }

      // Update Path Geometry section
      updatePathGeometryUI(e);

      return;
    }

    if (state.selected.type === 'group') {
      const g = findGroup(state.selected.id); if (!g) return;
      groupIns.style.display='block';
      // Show UUID (generate if missing for legacy data)
      if (!g.uuid) g.uuid = generateUUID();
      if (groupUUID) groupUUID.value = g.uuid;
      groupTitle.value = g.title || '';
      // Ensure 'default' tag is shown in filter tags field
      let groupTagsArray = g.filterTags || [];
      if (!groupTagsArray.some(t => t.trim().toLowerCase() === 'default')) {
        groupTagsArray = ['default', ...groupTagsArray];
      }
      if (groupFilterTags) groupFilterTags.value = groupTagsArray.join(', ');
      groupType.value = g.type || 'country';
      // Parent Region dropdown
      while (groupParent.firstChild) groupParent.removeChild(groupParent.firstChild);
      const optNone = document.createElement('option');
      optNone.value = '';
      optNone.textContent = '(none)';
      groupParent.appendChild(optNone);
      state.groups.filter(r => r.type === 'region').forEach(r => {
        const opt = document.createElement('option');
        opt.value = String(r.id);
        opt.textContent = r.title || `Group${r.id}`;
        groupParent.appendChild(opt);
      });
      groupParent.value = g.parentId ? String(g.parentId) : '';
      groupParent.disabled = (g.type !== 'country' && g.type !== 'dc');

      groupExtraTags.value = g.extraTags || '';
      groupW.value = Math.round(g.w);
      groupH.value = Math.round(g.h);

      // Transit latency
      const groupTransitLatency = document.getElementById('groupTransitLatency');
      if (groupTransitLatency) {
        groupTransitLatency.value = g.transitLatency !== undefined && g.transitLatency !== null ? g.transitLatency : '';
      }

      // Update Datacenter Info section visibility and values
      const dcInfoSection = document.getElementById('groupDCInfoSection');
      if (dcInfoSection) {
        if (g.type === 'dc') {
          dcInfoSection.style.display = '';
          const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val || ''; };
          setVal('groupDCOrgName', g.dcOrgName);
          setVal('groupDCPeeringDbId', g.dcPeeringDbId);
          setVal('groupDCAddress', g.dcAddress);
          setVal('groupDCCity', g.dcCity);
          setVal('groupDCZipcode', g.dcZipcode);
          setVal('groupDCState', g.dcState);
          setVal('groupDCCountry', g.dcCountry);
          setVal('groupDCRegion', g.dcRegion);
          setVal('groupDCWebsite', g.dcWebsite);
          setVal('groupDCLatitude', g.dcLatitude != null ? g.dcLatitude : '');
          setVal('groupDCLongitude', g.dcLongitude != null ? g.dcLongitude : '');
          const setTxt = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = val; };
          setTxt('groupDCNetCount', g.dcNetCount || 0);
          setTxt('groupDCIxCount', g.dcIxCount || 0);
          setTxt('groupDCCarrierCount', g.dcCarrierCount || 0);
          // Facility type
          setVal('groupDCFacilityType', g.dcFacilityType || 'datacenter');
          // Update section title based on type
          const sectionTitle = document.getElementById('groupDCInfoSectionTitle');
          if (sectionTitle) {
            const ft = g.dcFacilityType || 'datacenter';
            sectionTitle.textContent = ft === 'cable_station' ? 'Cable Station Info' : 'Datacenter Info';
          }
          // Cable systems (show only for cable_station type)
          const csSection = document.getElementById('groupDCCableSystemsSection');
          if (csSection) {
            csSection.style.display = (g.dcFacilityType === 'cable_station') ? '' : 'none';
          }
          const csTextarea = document.getElementById('groupDCCableSystems');
          if (csTextarea) {
            csTextarea.value = Array.isArray(g.dcCableSystems) ? g.dcCableSystems.join('\n') : '';
          }
        } else {
          dcInfoSection.style.display = 'none';
        }
      }

      groupTitleFont.value = g.titleFont ?? 14;
      groupTitleColor.value = g.titleColor || "#333333";
      groupFill.value = g.fill || "#ffffff";
      groupStroke.value = g.stroke || "#666666";
      if (groupStrokeW) groupStrokeW.value = g.strokeW ?? 1;
      // Update color pickers
      if (window.updateColorPickers) window.updateColorPickers();

      // Sync fill color picker and opacity slider
      const groupFillColor = document.getElementById('groupFillColor');
      const groupFillOpacity = document.getElementById('groupFillOpacity');
      const groupFillOpacityValue = document.getElementById('groupFillOpacityValue');
      const groupFillColorSwatch = document.getElementById('groupFillColorSwatch');
      const groupFillColorHex = document.getElementById('groupFillColorHex');
      const groupFillColorCustom = document.getElementById('groupFillColorCustom');
      if (groupFillColor && groupFillOpacity) {
        const parsed = parseColorWithOpacity(g.fill || '#ffffff');
        groupFillColor.value = parsed.color;
        groupFillOpacity.value = Math.round(parsed.opacity * 100);
        if (groupFillOpacityValue) groupFillOpacityValue.textContent = Math.round(parsed.opacity * 100) + '%';
        // Update palette swatch
        if (groupFillColorSwatch) groupFillColorSwatch.style.backgroundColor = parsed.color;
        if (groupFillColorHex) groupFillColorHex.value = parsed.color;
        if (groupFillColorCustom) groupFillColorCustom.value = parsed.color;
      }

      // Update group stroke palette swatch
      const groupStrokeSwatch = document.getElementById('groupStrokeSwatch');
      const groupStrokeHex = document.getElementById('groupStrokeHex');
      const groupStrokeCustom = document.getElementById('groupStrokeCustom');
      if (groupStrokeSwatch) groupStrokeSwatch.style.backgroundColor = g.stroke || '#666666';
      if (groupStrokeHex) groupStrokeHex.value = g.stroke || '#666666';
      if (groupStrokeCustom) groupStrokeCustom.value = g.stroke || '#666666';

      // Sync inline controls
      const groupTitleColorSwatch = document.getElementById('groupTitleColorSwatch');
      const groupTitleColorInline = document.getElementById('groupTitleColorInline');
      const groupTitleVisibility = document.getElementById('groupTitleVisibility');
      const groupTitleFontInline = document.getElementById('groupTitleFontInline');
      if (groupTitleColorSwatch) groupTitleColorSwatch.style.backgroundColor = g.titleColor || '#333333';
      if (groupTitleColorInline) groupTitleColorInline.value = g.titleColor || '#333333';
      if (groupTitleFontInline) groupTitleFontInline.value = g.titleFont || 14;
      if (groupTitleVisibility) {
        groupTitleVisibility.classList.toggle('hidden', g.showTitle === false);
      }

      // Update commercial cost display
      if (typeof updateGroupCostDisplay === 'function') {
        updateGroupCostDisplay(g);
      }

      // Update container shape info
      const groupShapeInfo = document.getElementById('groupShapeInfo');
      const btnRemoveGroupShape = document.getElementById('btnRemoveGroupShape');
      if (groupShapeInfo) {
        if (g.shapeContainer && g.decorativeShape && g.decorativeShape.name) {
          // This is a shape-based container
          groupShapeInfo.innerHTML = `
            <div style="display:flex; align-items:center; gap:8px;">
              <div style="width:32px; height:32px; background:#e8f4ff; border:1px solid #2563eb; border-radius:4px; display:flex; align-items:center; justify-content:center; overflow:hidden;">
                ${g.decorativeShape.svgData || 'ðŸ—ºï¸'}
              </div>
              <div>
                <div style="font-weight:600; font-size:11px; color:#2563eb;">${g.decorativeShape.name}</div>
                <div style="font-size:10px; color:#666;">Shape container</div>
              </div>
            </div>
          `;
          if (btnRemoveGroupShape) btnRemoveGroupShape.disabled = false;
        } else if (g.decorativeShape && g.decorativeShape.name) {
          // Decorative overlay on rectangular container
          groupShapeInfo.innerHTML = `
            <div style="display:flex; align-items:center; gap:8px;">
              <div style="width:32px; height:32px; background:#f0f0ff; border-radius:4px; display:flex; align-items:center; justify-content:center; overflow:hidden;">
                ${g.decorativeShape.svgData || 'ðŸ—ºï¸'}
              </div>
              <div>
                <div style="font-weight:600; font-size:11px;">${g.decorativeShape.name}</div>
                <div style="font-size:10px; color:#888;">Decorative overlay</div>
              </div>
            </div>
          `;
          if (btnRemoveGroupShape) btnRemoveGroupShape.disabled = false;
        } else {
          groupShapeInfo.innerHTML = '<div style="font-size:11px; color:#666;">Standard rectangular container</div>';
          if (btnRemoveGroupShape) btnRemoveGroupShape.disabled = true;
        }
      }
    }
  }

  nodeName.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.name = nodeName.value; commit(); render();
  });
  nodeTags.addEventListener('change', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    let tags = nodeTags.value.split(',').map(s=>s.trim()).filter(Boolean);
    // Ensure 'default' is always present
    if (!tags.some(t => t.toLowerCase() === 'default')) {
      tags = ['default', ...tags];
    }
    n.tags = tags;
    commit(); render();
  });
  nodeExtraTags.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.extraTags = nodeExtraTags.value; commit(); render();
  });
  nodeCode.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.code = nodeCode.value; commit(); render();
  });
  if (nodeShowCode) nodeShowCode.addEventListener('change', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.showCode = nodeShowCode.value === '1'; commit(); render();
  });

  nodeNameFont.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.nameFont = clamp(Number(nodeNameFont.value||13),6,72); commit(); render();
  });
  nodeTagFont.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.tagFont = clamp(Number(nodeTagFont.value||11),6,72); commit(); render();
  });
  nodeNameColor.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.nameColor = nodeNameColor.value; commit(); render();
  });
  nodeTagColor.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.tagColor = nodeTagColor.value; commit(); render();
  });
  nodeFill.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.fill = nodeFill.value; commit(); render();
  });
  nodeStroke.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.stroke = nodeStroke.value; commit(); render();
  });
  if (nodeStrokeW) nodeStrokeW.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.strokeW = clamp(Number(nodeStrokeW.value||2),0.5,12);
    commit(); render();
  });

if (edgeStrokeColor) edgeStrokeColor.addEventListener('input', () => {
  if (state.selected?.type!=='edge') return;
  const e = findEdge(state.selected.id); if (!e) return;
  e.strokeColor = edgeStrokeColor.value;
  commit(); render();
});

  if (nodeSize) nodeSize.addEventListener('input', () => {
    if (state.selected?.type!=='node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.r = clamp(Number(nodeSize.value||24),10,80);
    commit(); render();
  });

// Node address/city/country listeners
if (nodeAddress) nodeAddress.addEventListener('input', () => {
  if (state.selected?.type!=='node') return;
  const n = findNode(state.selected.id); if (!n) return;
  n.address = nodeAddress.value; commit(); render();
});

if (nodeCity) nodeCity.addEventListener('input', () => {
  if (state.selected?.type!=='node') return;
  const n = findNode(state.selected.id); if (!n) return;
  n.city = nodeCity.value; commit(); render();
});

if (nodeCountry) nodeCountry.addEventListener('input', () => {
  if (state.selected?.type!=='node') return;
  const n = findNode(state.selected.id); if (!n) return;
  n.country = nodeCountry.value; commit(); render();
});

if (nodePostalCode) nodePostalCode.addEventListener('input', () => {
  if (state.selected?.type!=='node') return;
  const n = findNode(state.selected.id); if (!n) return;
  n.postalCode = nodePostalCode.value; commit(); render();
});

if (nodeCounty) nodeCounty.addEventListener('input', () => {
  if (state.selected?.type!=='node') return;
  const n = findNode(state.selected.id); if (!n) return;
  n.county = nodeCounty.value; commit(); render();
});

if (nodeState) nodeState.addEventListener('input', () => {
  if (state.selected?.type!=='node') return;
  const n = findNode(state.selected.id); if (!n) return;
  n.state = nodeState.value; commit(); render();
});

// Edge Design Maximum Capacity listener
const edgeDesignCapacity = document.getElementById('edgeDesignCapacity');
if (edgeDesignCapacity) edgeDesignCapacity.addEventListener('input', () => {
  if (state.selected?.type!=='edge') return;
  const e = findEdge(state.selected.id); if (!e) return;
  const val = parseFloat(edgeDesignCapacity.value) || 0;
  e.designCapacityGbps = val;
  commit();
});

// Edge priority listener
if (edgePriority) edgePriority.addEventListener('input', () => {
  if (state.selected?.type!=='edge') return;
  const e = findEdge(state.selected.id); if (!e) return;
  const val = parseFloat(edgePriority.value);
  e.priority = isNaN(val) ? 0 : val;
  commit(); render();
});

// ============== CAPACITY INVENTORY HANDLERS ==============

// Calculate and display total capacity in Gbps
function updateEdgeCapacityTotal() {
  const cap1G = parseFloat(document.getElementById('edgeCap1G')?.value) || 0;
  const cap10G = parseFloat(document.getElementById('edgeCap10G')?.value) || 0;
  const cap100G = parseFloat(document.getElementById('edgeCap100G')?.value) || 0;
  const cap400G = parseFloat(document.getElementById('edgeCap400G')?.value) || 0;
  const capTbps = parseFloat(document.getElementById('edgeCapTbps')?.value) || 0;

  const totalGbps = cap1G + (10 * cap10G) + (100 * cap100G) + (400 * cap400G) + (1000 * capTbps);

  const totalEl = document.getElementById('edgeCapTotalGbps');
  if (totalEl) {
    // Format nicely: show Tbps if >= 1000, otherwise Gbps
    if (totalGbps >= 1000) {
      const tbps = totalGbps / 1000;
      totalEl.textContent = tbps % 1 === 0 ? `${tbps} Tbps` : `${tbps.toFixed(2)} Tbps`;
    } else {
      totalEl.textContent = totalGbps % 1 === 0 ? `${totalGbps} Gbps` : `${totalGbps.toFixed(2)} Gbps`;
    }
  }

  return totalGbps;
}

// Save capacity to edge and update total
function saveEdgeCapacity(field, value) {
  if (state.selected?.type !== 'edge') return;
  const e = findEdge(state.selected.id);
  if (!e) return;

  const val = parseFloat(value) || 0;
  e[field] = val;

  // Also update the calculated total on the edge object
  e.totalCapacityGbps = updateEdgeCapacityTotal();

  // Update any MLGs containing this link (capacity change)
  if (typeof updateMLGsForLinkChange === 'function') updateMLGsForLinkChange(e.id);

  commit();
}

// Capacity inventory input listeners
const edgeCap1G = document.getElementById('edgeCap1G');
const edgeCap10G = document.getElementById('edgeCap10G');
const edgeCap100G = document.getElementById('edgeCap100G');
const edgeCap400G = document.getElementById('edgeCap400G');
const edgeCapTbps = document.getElementById('edgeCapTbps');

if (edgeCap1G) edgeCap1G.addEventListener('input', () => saveEdgeCapacity('cap1G', edgeCap1G.value));
if (edgeCap10G) edgeCap10G.addEventListener('input', () => saveEdgeCapacity('cap10G', edgeCap10G.value));
if (edgeCap100G) edgeCap100G.addEventListener('input', () => saveEdgeCapacity('cap100G', edgeCap100G.value));
if (edgeCap400G) edgeCap400G.addEventListener('input', () => saveEdgeCapacity('cap400G', edgeCap400G.value));
if (edgeCapTbps) edgeCapTbps.addEventListener('input', () => saveEdgeCapacity('capTbps', edgeCapTbps.value));

// ============== END CAPACITY INVENTORY HANDLERS ==============

// ============== INLINE CONTROL HANDLERS ==============

// Node Name inline controls
const nodeNameColorInline = document.getElementById('nodeNameColorInline');
const nodeNameVisibility = document.getElementById('nodeNameVisibility');
if (nodeNameColorInline) {
  nodeNameColorInline.addEventListener('input', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.nameColor = nodeNameColorInline.value;
    const swatch = document.getElementById('nodeNameColorSwatch');
    if (swatch) swatch.style.backgroundColor = nodeNameColorInline.value;
    commit(); render();
  });
}
if (nodeNameVisibility) {
  nodeNameVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.showName = n.showName === false ? true : false;
    nodeNameVisibility.classList.toggle('hidden', n.showName === false);
    commit(); render();
  });
}

// Node Code inline controls
const nodeCodeColorInline = document.getElementById('nodeCodeColorInline');
const nodeCodeVisibility = document.getElementById('nodeCodeVisibility');
if (nodeCodeColorInline) {
  nodeCodeColorInline.addEventListener('input', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.codeColor = nodeCodeColorInline.value;
    const swatch = document.getElementById('nodeCodeColorSwatch');
    if (swatch) swatch.style.backgroundColor = nodeCodeColorInline.value;
    commit(); render();
  });
}
if (nodeCodeVisibility) {
  nodeCodeVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.showCode = n.showCode === false ? true : false;
    nodeCodeVisibility.classList.toggle('hidden', n.showCode === false);
    commit(); render();
  });
}

// Node Extra Tags inline controls
const nodeExtraTagsColorInline = document.getElementById('nodeExtraTagsColorInline');
const nodeExtraTagsVisibility = document.getElementById('nodeExtraTagsVisibility');
if (nodeExtraTagsColorInline) {
  nodeExtraTagsColorInline.addEventListener('input', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.extraTagsColor = nodeExtraTagsColorInline.value;
    const swatch = document.getElementById('nodeExtraTagsColorSwatch');
    if (swatch) swatch.style.backgroundColor = nodeExtraTagsColorInline.value;
    commit(); render();
  });
}
if (nodeExtraTagsVisibility) {
  nodeExtraTagsVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.showExtraTags = !n.showExtraTags;
    nodeExtraTagsVisibility.classList.toggle('hidden', !n.showExtraTags);
    commit(); render();
  });
}

// Edge Tag inline controls
const edgeTagColorInline = document.getElementById('edgeTagColorInline');
const edgeTagVisibility = document.getElementById('edgeTagVisibility');
if (edgeTagColorInline) {
  edgeTagColorInline.addEventListener('input', () => {
    if (state.selected?.type !== 'edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.tagColor = edgeTagColorInline.value;
    const swatch = document.getElementById('edgeTagColorSwatch');
    if (swatch) swatch.style.backgroundColor = edgeTagColorInline.value;
    commit(); render();
  });
}
if (edgeTagVisibility) {
  edgeTagVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.showTag = e.showTag === false ? true : false;
    edgeTagVisibility.classList.toggle('hidden', e.showTag === false);
    commit(); render();
  });
}

// Edge Latency inline controls
const edgeLatencyVisibility = document.getElementById('edgeLatencyVisibility');
if (edgeLatencyVisibility) {
  edgeLatencyVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.showLatency = e.showLatency === false ? true : false;
    edgeLatencyVisibility.classList.toggle('hidden', e.showLatency === false);
    commit(); render();
  });
}

// Edge Code inline controls
const edgeCodeVisibility = document.getElementById('edgeCodeVisibility');
if (edgeCodeVisibility) {
  edgeCodeVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.showCode = e.showCode === false ? true : false;
    edgeCodeVisibility.classList.toggle('hidden', e.showCode === false);
    commit(); render();
  });
}

// Group Title inline controls
const groupTitleColorInline = document.getElementById('groupTitleColorInline');
const groupTitleVisibility = document.getElementById('groupTitleVisibility');
if (groupTitleColorInline) {
  groupTitleColorInline.addEventListener('input', () => {
    if (state.selected?.type !== 'group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.titleColor = groupTitleColorInline.value;
    const swatch = document.getElementById('groupTitleColorSwatch');
    if (swatch) swatch.style.backgroundColor = groupTitleColorInline.value;
    commit(); render();
  });
}
if (groupTitleVisibility) {
  groupTitleVisibility.addEventListener('click', () => {
    if (state.selected?.type !== 'group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.showTitle = g.showTitle === false ? true : false;
    groupTitleVisibility.classList.toggle('hidden', g.showTitle === false);
    commit(); render();
  });
}

// ============== INLINE FONT SIZE HANDLERS ==============

// Node Name Font Size
const nodeNameFontInline = document.getElementById('nodeNameFontInline');
if (nodeNameFontInline) {
  nodeNameFontInline.addEventListener('change', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.nameSize = parseInt(nodeNameFontInline.value) || 13;
    commit(); render();
  });
}

// Node Code Font Size
const nodeCodeFontInline = document.getElementById('nodeCodeFontInline');
if (nodeCodeFontInline) {
  nodeCodeFontInline.addEventListener('change', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.codeSize = parseInt(nodeCodeFontInline.value) || 13;
    commit(); render();
  });
}

// Node Extra Tags Font Size
const nodeExtraTagsFontInline = document.getElementById('nodeExtraTagsFontInline');
if (nodeExtraTagsFontInline) {
  nodeExtraTagsFontInline.addEventListener('change', () => {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id); if (!n) return;
    n.extraTagsSize = parseInt(nodeExtraTagsFontInline.value) || 11;
    commit(); render();
  });
}

// Edge Label Font Size
const edgeLabelFontInline = document.getElementById('edgeLabelFontInline');
if (edgeLabelFontInline) {
  edgeLabelFontInline.addEventListener('change', () => {
    if (state.selected?.type !== 'edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.labelFont = parseInt(edgeLabelFontInline.value) || 12;
    commit(); render();
  });
}

// Group Title Font Size
const groupTitleFontInline = document.getElementById('groupTitleFontInline');
if (groupTitleFontInline) {
  groupTitleFontInline.addEventListener('change', () => {
    if (state.selected?.type !== 'group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.titleFont = parseInt(groupTitleFontInline.value) || 14;
    commit(); render();
  });
}

// ============== END INLINE CONTROL HANDLERS ==============

  edgeTag.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.tag = edgeTag.value; commit(); render();
  });
  if (edgeFilterTags) {
    edgeFilterTags.addEventListener('change', () => {
      if (state.selected?.type!=='edge') return;
      const e = findEdge(state.selected.id); if (!e) return;
      let tags = edgeFilterTags.value.split(',').map(s=>s.trim()).filter(Boolean);
      // Ensure 'default' is always present
      if (!tags.some(t => t.toLowerCase() === 'default')) {
        tags = ['default', ...tags];
      }
      e.filterTags = tags;
      commit(); render();
    });
  }
  edgeLatency.addEventListener('change', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    const raw = String(edgeLatency.value ?? '').trim();
    if (raw === '') {
      e.latencyMs = null;
      // Update any MLGs containing this link
      if (typeof updateMLGsForLinkChange === 'function') updateMLGsForLinkChange(e.id);
      commit(); render(); return;
    }
    // Replace comma with period for locales that use comma as decimal separator
    const v = parseFloat(raw.replace(',', '.'));
    if (Number.isFinite(v) && v >= 0) {
      e.latencyMs = v;
      edgeLatency.value = v; // Normalize the display
      // Update any MLGs containing this link
      if (typeof updateMLGsForLinkChange === 'function') updateMLGsForLinkChange(e.id);
      commit();
      render();
    } else {
      // Invalid input - revert to previous value
      edgeLatency.value = (typeof e.latencyMs === "number" && isFinite(e.latencyMs)) ? e.latencyMs : '';
    }
  });
  edgeExtraTags.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.extraTags = edgeExtraTags.value; commit(); render();
  });
  edgeCode.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.code = edgeCode.value; commit(); render();
  });
  if (edgeShowCode) edgeShowCode.addEventListener('change', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.showCode = edgeShowCode.value === '1'; commit(); render();
  });

  edgeStyle.addEventListener('change', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.style = edgeStyle.value;
    // Show/hide curve arch control
    const curveArchControl = document.getElementById('curveArchControl');
    if (e.style === 'curve') {
      curveArchControl.style.display = 'block';
      if (!e.curveArch) e.curveArch = 0.3;
      edgeCurveArch.value = e.curveArch;
      document.getElementById('curveArchValue').textContent = e.curveArch.toFixed(2);
    } else {
      curveArchControl.style.display = 'none';
    }
    commit(); render();
  });
  edgeRoute.addEventListener('change', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.route = edgeRoute.value; commit(); render();
  });
  edgeCurveArch.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.curveArch = clamp(Number(edgeCurveArch.value||0.3), 0, 0.6);
    document.getElementById('curveArchValue').textContent = e.curveArch.toFixed(2);
    commit(); render();
  });
  edgeLabelFont.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.labelFont = clamp(Number(edgeLabelFont.value||12),6,72); commit(); render();
  });
  edgeLabelColor.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.labelColor = edgeLabelColor.value; commit(); render();
  });
  if (edgeStrokeW) edgeStrokeW.addEventListener('input', () => {
    if (state.selected?.type!=='edge') return;
    const e = findEdge(state.selected.id); if (!e) return;
    e.strokeW = clamp(Number(edgeStrokeW.value||2),0.5,12);
    commit(); render();
  });

  groupTitle.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.title = groupTitle.value; commit(); render();
  });
  if (groupFilterTags) {
    groupFilterTags.addEventListener('change', () => {
      if (state.selected?.type!=='group') return;
      const g = findGroup(state.selected.id); if (!g) return;
      let tags = groupFilterTags.value.split(',').map(s=>s.trim()).filter(Boolean);
      // Ensure 'default' is always present
      if (!tags.some(t => t.toLowerCase() === 'default')) {
        tags = ['default', ...tags];
      }
      g.filterTags = tags;
      commit(); render();
    });
  }
  groupType.addEventListener('change', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.type = groupType.value;
    // If switching away from country, clear parent + node memberships will recompute
    if (g.type !== 'country') g.parentId = null;
    refreshAllMemberships();
    commit(); render();
  });

  groupParent.addEventListener('change', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g || g.type !== 'country') return;
    g.parentId = groupParent.value ? Number(groupParent.value) : null;
    commit(); render();
  });

  groupExtraTags.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.extraTags = groupExtraTags.value; commit(); render();
  });

  // Transit latency
  const groupTransitLatency = document.getElementById('groupTransitLatency');
  if (groupTransitLatency) {
    groupTransitLatency.addEventListener('input', () => {
      if (state.selected?.type!=='group') return;
      const g = findGroup(state.selected.id); if (!g) return;
      const val = groupTransitLatency.value.trim();
      if (val === '') {
        delete g.transitLatency; // Use global default
      } else {
        g.transitLatency = parseFloat(val) || 0;
      }
      commit();
    });
  }

  // ============== GROUP DATACENTER INFO HANDLERS ==============
  ['groupDCOrgName:dcOrgName', 'groupDCAddress:dcAddress', 'groupDCCity:dcCity',
   'groupDCZipcode:dcZipcode', 'groupDCState:dcState', 'groupDCCountry:dcCountry',
   'groupDCRegion:dcRegion', 'groupDCWebsite:dcWebsite'].forEach(pair => {
    const [elId, prop] = pair.split(':');
    const el = document.getElementById(elId);
    if (el) {
      el.addEventListener('input', () => {
        if (state.selected?.type !== 'group') return;
        const g = findGroup(state.selected.id); if (!g) return;
        g[prop] = el.value;
        commit();
      });
    }
  });
  ['groupDCLatitude:dcLatitude', 'groupDCLongitude:dcLongitude'].forEach(pair => {
    const [elId, prop] = pair.split(':');
    const el = document.getElementById(elId);
    if (el) {
      el.addEventListener('input', () => {
        if (state.selected?.type !== 'group') return;
        const g = findGroup(state.selected.id); if (!g) return;
        const val = el.value.trim();
        g[prop] = val === '' ? null : parseFloat(val) || null;
        commit();
      });
    }
  });

  // Facility type dropdown
  const groupDCFacilityType = document.getElementById('groupDCFacilityType');
  if (groupDCFacilityType) {
    groupDCFacilityType.addEventListener('change', () => {
      if (state.selected?.type !== 'group') return;
      const g = findGroup(state.selected.id); if (!g) return;
      g.dcFacilityType = groupDCFacilityType.value;
      // Show/hide cable systems section
      const csSection = document.getElementById('groupDCCableSystemsSection');
      if (csSection) csSection.style.display = (g.dcFacilityType === 'cable_station') ? '' : 'none';
      // Update section title
      const sectionTitle = document.getElementById('groupDCInfoSectionTitle');
      if (sectionTitle) {
        const ft = g.dcFacilityType;
        sectionTitle.textContent = ft === 'cable_station' ? 'Cable Station Info' : 'Datacenter Info';
      }
      commit(); render();
    });
  }
  // Cable systems textarea
  const groupDCCableSystems = document.getElementById('groupDCCableSystems');
  if (groupDCCableSystems) {
    groupDCCableSystems.addEventListener('input', () => {
      if (state.selected?.type !== 'group') return;
      const g = findGroup(state.selected.id); if (!g) return;
      g.dcCableSystems = groupDCCableSystems.value.split('\n').map(s => s.trim()).filter(Boolean);
      commit();
    });
  }

  // ============== GROUP COMMERCIAL COST HANDLERS ==============

  // Cost mode radio buttons
  document.querySelectorAll('input[name="groupCostMode"]').forEach(radio => {
    radio.addEventListener('change', () => {
      if (state.selected?.type !== 'group') return;
      const g = findGroup(state.selected.id);
      if (g) {
        g.commercialCostMode = radio.value;
        commit();
      }
    });
  });

  // Tier pricing inputs - Lease NRC, MRC
  const tiers = ['1G', '10G', '100G', '400G'];
  tiers.forEach(tier => {
    const nrcEl = document.getElementById(`groupLeaseNRC_${tier}`);
    const mrcEl = document.getElementById(`groupLeaseMRC_${tier}`);
    const iruFeeEl = document.getElementById(`groupIRUFee_${tier}`);

    if (nrcEl) {
      nrcEl.addEventListener('input', () => {
        if (state.selected?.type !== 'group') return;
        const g = findGroup(state.selected.id);
        if (g) {
          if (!g.leaseNRC) g.leaseNRC = {};
          g.leaseNRC[tier] = parseFloat(nrcEl.value) || 0;
          g.commercialCostOverride = true;
          commit();
          updateGroupCostDisplay(g);
        }
      });
    }

    if (mrcEl) {
      mrcEl.addEventListener('input', () => {
        if (state.selected?.type !== 'group') return;
        const g = findGroup(state.selected.id);
        if (g) {
          if (!g.leaseMRC) g.leaseMRC = {};
          g.leaseMRC[tier] = parseFloat(mrcEl.value) || 0;
          g.commercialCostOverride = true;
          commit();
          updateGroupCostDisplay(g);
        }
      });
    }

    if (iruFeeEl) {
      iruFeeEl.addEventListener('input', () => {
        if (state.selected?.type !== 'group') return;
        const g = findGroup(state.selected.id);
        if (g) {
          if (!g.iruFee) g.iruFee = {};
          g.iruFee[tier] = parseFloat(iruFeeEl.value) || 0;
          g.commercialCostOverride = true;
          commit();
          updateGroupCostDisplay(g);
        }
      });
    }
  });

  // IRU common terms
  const groupIRUTerm = document.getElementById('groupIRUTerm');
  const groupIRUOAM = document.getElementById('groupIRUOAM');
  const groupIRUOAMIncrement = document.getElementById('groupIRUOAMIncrement');

  if (groupIRUTerm) {
    groupIRUTerm.addEventListener('input', () => {
      if (state.selected?.type !== 'group') return;
      const g = findGroup(state.selected.id);
      if (g) {
        g.iruTerm = parseInt(groupIRUTerm.value) || 15;
        g.commercialCostOverride = true;
        commit();
        updateGroupCostDisplay(g);
      }
    });
  }

  if (groupIRUOAM) {
    groupIRUOAM.addEventListener('input', () => {
      if (state.selected?.type !== 'group') return;
      const g = findGroup(state.selected.id);
      if (g) {
        g.iruOamPercent = parseFloat(groupIRUOAM.value) || 3;
        g.commercialCostOverride = true;
        commit();
        updateGroupCostDisplay(g);
      }
    });
  }

  if (groupIRUOAMIncrement) {
    groupIRUOAMIncrement.addEventListener('input', () => {
      if (state.selected?.type !== 'group') return;
      const g = findGroup(state.selected.id);
      if (g) {
        g.iruOamAnnualIncrement = parseFloat(groupIRUOAMIncrement.value) || 2;
        g.commercialCostOverride = true;
        commit();
        updateGroupCostDisplay(g);
      }
    });
  }

  // Reset to calculated button
  const btnGroupResetCost = document.getElementById('btnGroupResetCost');
  if (btnGroupResetCost) {
    btnGroupResetCost.addEventListener('click', () => {
      if (state.selected?.type !== 'group') return;
      const g = findGroup(state.selected.id);
      if (g) {
        g.commercialCostOverride = false;
        // Recalculate values
        const result = calculateContainerCost(g);
        g.leaseNRC = result.costs.leaseNRC;
        g.leaseMRC = result.costs.leaseMRC;
        g.iruFee = result.costs.iruFee;
        g.iruTerm = result.costs.iruTerm;
        g.iruOamPercent = result.costs.iruOamPercent;
        g.iruOamAnnualIncrement = result.costs.iruOamAnnualIncrement;
        commit();
        updateGroupCostDisplay(g);
        showToast('Cost values reset to calculated');
      }
    });
  }

  // Auto-fill tier buttons
  const btnGroupAutoFillLeaseTiers = document.getElementById('btnGroupAutoFillLeaseTiers');
  if (btnGroupAutoFillLeaseTiers) {
    btnGroupAutoFillLeaseTiers.addEventListener('click', () => {
      if (state.selected?.type !== 'group') return;
      const g = findGroup(state.selected.id);
      if (g) {
        const tierMults = state.financialSettings?.tierMultipliers || { '10G': 2.5, '100G': 6.25, '400G': 15.625 };
        const nrc1G = parseFloat(document.getElementById('groupLeaseNRC_1G')?.value) || 0;
        const mrc1G = parseFloat(document.getElementById('groupLeaseMRC_1G')?.value) || 1;

        g.leaseNRC = {
          '1G': nrc1G,
          '10G': Math.round(nrc1G * tierMults['10G'] * 100) / 100,
          '100G': Math.round(nrc1G * tierMults['100G'] * 100) / 100,
          '400G': Math.round(nrc1G * tierMults['400G'] * 100) / 100
        };
        g.leaseMRC = {
          '1G': mrc1G,
          '10G': Math.round(mrc1G * tierMults['10G'] * 100) / 100,
          '100G': Math.round(mrc1G * tierMults['100G'] * 100) / 100,
          '400G': Math.round(mrc1G * tierMults['400G'] * 100) / 100
        };
        g.commercialCostOverride = true;
        commit();
        updateGroupCostDisplay(g);
        showToast('Lease tiers auto-filled from 1G');
      }
    });
  }

  const btnGroupAutoFillIRUTiers = document.getElementById('btnGroupAutoFillIRUTiers');
  if (btnGroupAutoFillIRUTiers) {
    btnGroupAutoFillIRUTiers.addEventListener('click', () => {
      if (state.selected?.type !== 'group') return;
      const g = findGroup(state.selected.id);
      if (g) {
        const tierMults = state.financialSettings?.tierMultipliers || { '10G': 2.5, '100G': 6.25, '400G': 15.625 };
        const iruFee1G = parseFloat(document.getElementById('groupIRUFee_1G')?.value) || 1;

        g.iruFee = {
          '1G': iruFee1G,
          '10G': Math.round(iruFee1G * tierMults['10G'] * 100) / 100,
          '100G': Math.round(iruFee1G * tierMults['100G'] * 100) / 100,
          '400G': Math.round(iruFee1G * tierMults['400G'] * 100) / 100
        };
        g.commercialCostOverride = true;
        commit();
        updateGroupCostDisplay(g);
        showToast('IRU tiers auto-filled from 1G');
      }
    });
  }

  // Financial settings link
  const groupCostSettingsLink = document.getElementById('groupCostSettingsLink');
  if (groupCostSettingsLink) {
    groupCostSettingsLink.addEventListener('click', (e) => {
      e.preventDefault();
      const modal = document.getElementById('financialSettingsModal');
      if (modal) {
        if (typeof openFinancialSettings === 'function') {
          openFinancialSettings();
        } else {
          modal.classList.add('show');
        }
      }
    });
  }

  // ============== END GROUP COMMERCIAL COST HANDLERS ==============

  groupW.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.w = clamp(Number(groupW.value||g.w),120,1600); refreshAllMemberships(); commit(); render();
  });
  groupH.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.h = clamp(Number(groupH.value||g.h),90,900); refreshAllMemberships(); commit(); render();
  });

  // Decorative shape buttons
  const btnOpenLibraryForShape = document.getElementById('btnOpenLibraryForShape');
  const btnRemoveGroupShape = document.getElementById('btnRemoveGroupShape');

  if (btnOpenLibraryForShape) {
    btnOpenLibraryForShape.addEventListener('click', () => {
      // Open library and switch to containers tab
      state.libraryTab = 'containers';
      const panel = document.getElementById('shapeLibraryPanel');
      if (panel) {
        panel.classList.add('visible');
        if (btnToggleLibrary) btnToggleLibrary.classList.add('active');
        localStorage.setItem('netmap-library-visible', 'true');
      }
      renderLibraryPanel();
    });
  }

  if (btnRemoveGroupShape) {
    btnRemoveGroupShape.addEventListener('click', () => {
      if (state.selected?.type !== 'group') return;
      const g = findGroup(state.selected.id);
      if (g && (g.decorativeShape || g.shapeContainer)) {
        const wasShapeContainer = g.shapeContainer;
        delete g.decorativeShape;
        delete g.shapeContainer;

        // Restore default fill/stroke if it was a shape container
        if (wasShapeContainer) {
          g.fill = g.fill || 'rgba(54, 76, 140, 0.12)';
          g.stroke = g.stroke || '#6073b8';
        }

        refreshAllMemberships();
        commit();
        render();
        showToast(wasShapeContainer ? 'Converted to rectangular container' : 'Shape removed');
      }
    });
  }

  groupTitleFont.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.titleFont = clamp(Number(groupTitleFont.value||14),6,72); commit(); render();
  });
  groupTitleColor.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.titleColor = groupTitleColor.value; commit(); render();
  });

  // Group Fill Color and Opacity handlers
  const groupFillColor = document.getElementById('groupFillColor');
  const groupFillOpacity = document.getElementById('groupFillOpacity');
  const groupFillOpacityValue = document.getElementById('groupFillOpacityValue');

  function updateGroupFill() {
    if (state.selected?.type !== 'group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    const color = groupFillColor ? groupFillColor.value : '#ffffff';
    const opacity = groupFillOpacity ? parseInt(groupFillOpacity.value) / 100 : 1;
    g.fill = combineColorWithOpacity(color, opacity);
    if (groupFill) groupFill.value = g.fill;
    commit(); render();
  }

  if (groupFillColor) {
    groupFillColor.addEventListener('input', updateGroupFill);
  }
  if (groupFillOpacity) {
    groupFillOpacity.addEventListener('input', () => {
      if (groupFillOpacityValue) {
        groupFillOpacityValue.textContent = groupFillOpacity.value + '%';
      }
      updateGroupFill();
    });
  }
  // Keep legacy handler for compatibility
  groupFill.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.fill = groupFill.value; commit(); render();
  });

  groupStroke.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.stroke = groupStroke.value; commit(); render();
  });
  if (groupStrokeW) groupStrokeW.addEventListener('input', () => {
    if (state.selected?.type!=='group') return;
    const g = findGroup(state.selected.id); if (!g) return;
    g.strokeW = clamp(Number(groupStrokeW.value||2),0.5,12);
    commit(); render();
  });


  // Preset buttons
  btnNodePresetSave.addEventListener('click', () => {
    console.log(`[PRESET SAVE] Button clicked - state.selected:`, state.selected);
    console.log(`[PRESET SAVE] state.selected?.type:`, state.selected?.type);
    if (state.selected?.type!=='node') {
      showToast("Select a node first.");
      console.log(`[PRESET SAVE] FAILED - not a node or no selection`);
      return;
    }
    const n = findNode(state.selected.id);
    console.log(`[PRESET SAVE] Found node:`, n);
    if (!n) return;
    savePreset('node', n);
  });
  btnNodePresetApply.addEventListener('click', () => {
    if (state.selected?.type!=='node') { showToast("Select a node first."); return; }
    const n = findNode(state.selected.id); if (!n) return;
    applyPreset('node', n, nodePresetSel.value);
  });
  btnNodePresetDelete.addEventListener('click', () => deletePreset('node', nodePresetSel.value));

  btnEdgePresetSave.addEventListener('click', () => {
    if (state.selected?.type!=='edge') { showToast("Select a link first."); return; }
    const e = findEdge(state.selected.id); if (!e) return;
    savePreset('edge', e);
  });
  btnEdgePresetApply.addEventListener('click', () => {
    if (state.selected?.type!=='edge') { showToast("Select a link first."); return; }
    const e = findEdge(state.selected.id); if (!e) return;
    applyPreset('edge', e, edgePresetSel.value);
  });
  btnEdgePresetDelete.addEventListener('click', () => deletePreset('edge', edgePresetSel.value));

  btnGroupPresetSave.addEventListener('click', () => {
    if (state.selected?.type!=='group') { showToast("Select a box first."); return; }
    const g = findGroup(state.selected.id); if (!g) return;
    savePreset('group', g);
  });
  btnGroupPresetApply.addEventListener('click', () => {
    if (state.selected?.type!=='group') { showToast("Select a box first."); return; }
    const g = findGroup(state.selected.id); if (!g) return;
    applyPreset('group', g, groupPresetSel.value);
  });
  btnGroupPresetDelete.addEventListener('click', () => deletePreset('group', groupPresetSel.value));

  function makeNode(id, x, y) {
    const ns = state.defaultNodeStyle || {};
    return {
      id,
      uuid: generateUUID(),
      x: x,
      y: y,
      shape: ns.shape || state.defaultNodeShape || 'circle',
      r: ns.r || 24,
      strokeW: ns.strokeWidth || 2,
      address:'', city:'', country:'',
      name: `Node${id}`,
      code: `N-${id}`,
      showCode: true,
      tags: ['default'],
      extraTags:"",
      groupId:null,
      cableSystemIds: [],  // Array of cable system IDs (node can belong to multiple)
      fill: ns.fill || "#dae8fc",
      stroke: ns.stroke || "#6c8ebf",
      nameColor: ns.labelColor || "#333333",
      tagColor:"#666666",
      nameFont: ns.labelFont || 13,
      tagFont:11,
      nameDx:0, nameDy:0, tagDx:0, tagDy:0
    };
  }

  function makeCableSystem(id) {
    return {
      id,
      uuid: generateUUID(),
      shortName: `CS${id}`,
      name: `Cable System ${id}`,
      type: 'wet',              // 'wet' | 'terrestrial'
      rfsYear: new Date().getFullYear(),
      fiberPairs: 1,
      status: 'planned',        // 'planned' | 'operational'
      capacityTbps: 0,
      owners: '',
      notes: '',
      filterTags: ['default']
    };
  }

  function findCableSystem(id) {
    return state.cableSystems.find(cs => cs.id === id);
  }

  function getCableSystemByUUID(uuid) {
    return state.cableSystems.find(cs => cs.uuid === uuid);
  }

  function makeEdge(id, a, b) {
    // Get default values from financial settings
    const defaultNRC = state.financialSettings?.defaultNRC || 0;
    const defaultMRC = state.financialSettings?.defaultMRC || 1;
    const defaultIRU = state.financialSettings?.defaultIRU || 1;
    const defaultIRUTerm = state.financialSettings?.defaultIRUTerm || 15;
    const defaultOAM = state.financialSettings?.defaultOAM || 3;
    const defaultOAMInc = state.financialSettings?.defaultOAMIncrement || 2;
    const tierMults = state.financialSettings?.tierMultipliers || { '10G': 2.5, '100G': 6.25, '400G': 15.625 };

    // Get default link style
    const ls = state.defaultLinkStyle || {};

    // Calculate tier-based default values
    const leaseNRC = {
      '1G': defaultNRC,
      '10G': Math.round(defaultNRC * tierMults['10G'] * 100) / 100,
      '100G': Math.round(defaultNRC * tierMults['100G'] * 100) / 100,
      '400G': Math.round(defaultNRC * tierMults['400G'] * 100) / 100
    };
    const leaseMRC = {
      '1G': defaultMRC,
      '10G': Math.round(defaultMRC * tierMults['10G'] * 100) / 100,
      '100G': Math.round(defaultMRC * tierMults['100G'] * 100) / 100,
      '400G': Math.round(defaultMRC * tierMults['400G'] * 100) / 100
    };
    const iruFee = {
      '1G': defaultIRU,
      '10G': Math.round(defaultIRU * tierMults['10G'] * 100) / 100,
      '100G': Math.round(defaultIRU * tierMults['100G'] * 100) / 100,
      '400G': Math.round(defaultIRU * tierMults['400G'] * 100) / 100
    };

    return {
      id, a, b,
      uuid: generateUUID(),
      tag:'',
      filterTags: ['default'],
      latencyMs:null,
      strokeW: ls.strokeWidth || 2,
      strokeColor: ls.stroke || "#666666",
      dashArray: ls.dashArray || '',
      capacity:'Up to 10G WL',
      priority: 0,
      cableSystemId: null,  // ID of associated cable system (null = unmapped)
      routingOverlap: [],   // Array of link IDs that share physical routing with this link
      code: `L-${id}`,
      showCode: true,
      extraTags:"",
      style: ls.lineType || 'straight',
      route:'hv',
      curveArch: ls.curveArch || 0.3,
      glow: ls.glow || false,
      glowColor: ls.glowColor || '#0096D6',
      arrowStart: ls.arrowStart || false,
      arrowEnd: ls.arrowEnd || false,
      labelDx:0, labelDy:0,
      labelFont: ls.labelFont || 12,
      labelColor: ls.labelColor || "#333333",
      // Commercial cost fields with tier-based defaults
      leaseNRC,
      leaseMRC,
      iruFee,
      iruTerm: defaultIRUTerm,
      iruOamPercent: defaultOAM,
      iruOamAnnualIncrement: defaultOAMInc,
      commercialCostMode: 'lease',
      // Cable geometry (unified field for geographic cable routing on map)
      // Stores GeoJSON geometry object {type: 'LineString'|'MultiLineString', coordinates: ...}
      // Source can be manual dots, KML/GeoJSON import, or TeleGeography Cable Database
      cableGeometry: null,
      pathSource: null,         // 'manual' | 'telegeography' | 'kml-import' | null
      pathCableRef: null        // Reference name if from Cable Database
    };
  }

  function makeGroup(id, x, y, type) {
    const isRegion = type === 'region';
    const isDC = type === 'dc';
    const tierMults = state.financialSettings?.tierMultipliers || { '10G': 2.5, '100G': 6.25, '400G': 15.625 };

    // Get container defaults from financial settings
    const defaultNRC = state.financialSettings?.containerDefaultNRC || 0;
    const defaultMRC = state.financialSettings?.containerDefaultMRC || 1;
    const defaultIRU = state.financialSettings?.containerDefaultIRU || 1;

    // Create tier-based pricing (same structure as links)
    const leaseNRC = {
      '1G': defaultNRC,
      '10G': Math.round(defaultNRC * tierMults['10G'] * 100) / 100,
      '100G': Math.round(defaultNRC * tierMults['100G'] * 100) / 100,
      '400G': Math.round(defaultNRC * tierMults['400G'] * 100) / 100
    };
    const leaseMRC = {
      '1G': defaultMRC,
      '10G': Math.round(defaultMRC * tierMults['10G'] * 100) / 100,
      '100G': Math.round(defaultMRC * tierMults['100G'] * 100) / 100,
      '400G': Math.round(defaultMRC * tierMults['400G'] * 100) / 100
    };
    const iruFee = {
      '1G': defaultIRU,
      '10G': Math.round(defaultIRU * tierMults['10G'] * 100) / 100,
      '100G': Math.round(defaultIRU * tierMults['100G'] * 100) / 100,
      '400G': Math.round(defaultIRU * tierMults['400G'] * 100) / 100
    };

    const base = {
      id,
      uuid: generateUUID(),
      type: isDC ? 'dc' : (isRegion ? 'region' : 'country'),
      parentId: null,
      x: clamp(x,20,1400),
      y: clamp(y,20,760),
      w: isDC ? 280 : (isRegion ? 520 : 320),
      h: isDC ? 200 : (isRegion ? 320 : 220),
      title: isDC ? 'Datacenter' : (isRegion ? `Group${id}` : "Container"),
      filterTags: ['default'],
      extraTags:"",
      fill: isDC ? "rgba(253, 242, 248, 0.95)" : (isRegion ? "rgba(245, 245, 245, 0.9)" : "rgba(255, 255, 255, 0.95)"),
      stroke: isDC ? "#ec4899" : (isRegion ? "#999999" : "#666666"),
      strokeW: isDC ? 2 : 1,
      titleColor: isDC ? "#831843" : "#333333",
      titleFont: isRegion ? 15 : 14,
      titleDx:0, titleDy:0,
      // Transit latency (null = use global default)
      transitLatency: null,
      // Commercial cost properties (same structure as links)
      leaseNRC,
      leaseMRC,
      iruFee,
      iruTerm: state.financialSettings?.containerDefaultIRUTerm || 15,
      iruOamPercent: state.financialSettings?.containerDefaultOAM || 3,
      iruOamAnnualIncrement: state.financialSettings?.containerDefaultOAMIncrement || 2,
      commercialCostMode: 'lease',
      // Override flag - when true, user has manually set values (don't recalculate)
      commercialCostOverride: false
    };

    // DC-specific fields for PeeringDB data
    if (isDC) {
      base.dcPeeringDbId = null;
      base.dcOrgName = '';
      base.dcAddress = '';
      base.dcCity = '';
      base.dcCountry = '';
      base.dcState = '';
      base.dcZipcode = '';
      base.dcLatitude = null;
      base.dcLongitude = null;
      base.dcWebsite = '';
      base.dcRegion = '';
      base.dcNetCount = 0;
      base.dcIxCount = 0;
      base.dcCarrierCount = 0;
      base.dcNetworks = [];
      base.dcFacilityType = 'datacenter'; // datacenter | cable_station
      base.dcCableSystems = []; // cable system names (for cable stations)
    }

    return base;
  }

  function makeCableSystem(id) {
    return {
      id,
      uuid: generateUUID(),
      shortName: `CS${id}`,
      name: `Cable System ${id}`,
      type: 'wet',              // 'wet' or 'terrestrial'
      rfsYear: new Date().getFullYear() + 1,
      fiberPairs: 8,
      status: 'planned',        // 'planned' or 'operational'
      capacityTbps: 100,
      owners: '',
      filterTags: ['default'],
      notes: ''
    };
  }

  function createCableSystem() {
    const id = state.nextCableSystem++;
    const cs = makeCableSystem(id);
    state.cableSystems.push(cs);
    commit();
    updateCableNavigatorList();
    selectCableSystem(cs.id);
    showToast(`Created cable system "${cs.shortName}".`);
    return cs;
  }

  function findCableSystem(id) {
    return state.cableSystems.find(cs => cs.id === id);
  }

  function deleteCableSystem(id, mode = 'cancel') {
    // mode: 'deleteAll' - delete CS and all its links/nodes
    //       'unmapOnly' - delete CS but keep links/nodes (unmapped)
    //       'cancel' - don't delete
    if (mode === 'cancel') return;

    const cs = findCableSystem(id);
    if (!cs) return;

    if (mode === 'deleteAll') {
      // Delete all links belonging to this cable system
      state.edges = state.edges.filter(e => e.cableSystemId !== id);
      // Remove this cable system from all nodes and delete nodes that only belonged to this system
      state.nodes.forEach(n => {
        if (n.cableSystemIds) {
          n.cableSystemIds = n.cableSystemIds.filter(csId => csId !== id);
        }
      });
    } else if (mode === 'unmapOnly') {
      // Just unmap - set links' cableSystemId to null
      state.edges.forEach(e => {
        if (e.cableSystemId === id) e.cableSystemId = null;
      });
      // Remove from nodes' cableSystemIds
      state.nodes.forEach(n => {
        if (n.cableSystemIds) {
          n.cableSystemIds = n.cableSystemIds.filter(csId => csId !== id);
        }
      });
    }

    // Remove the cable system
    state.cableSystems = state.cableSystems.filter(c => c.id !== id);

    // Clear selection if this was selected
    if (state.selectedCableSystem === id) {
      state.selectedCableSystem = null;
    }

    commit();
    render();
    updateCableNavigatorList();
    updateInspector();
    showToast(`Deleted cable system "${cs.shortName}".`);
  }

  // Get links belonging to a cable system
  function getCableSystemLinks(csId) {
    return state.edges.filter(e => e.cableSystemId === csId);
  }

  // Get nodes belonging to a cable system
  function getCableSystemNodes(csId) {
    return state.nodes.filter(n => n.cableSystemIds && n.cableSystemIds.includes(csId));
  }

  function createNode(x, y) {
    const id = state.nextNode++;
    const node = makeNode(id, x, y);
    state.nodes.push(node);
    updateNodeGroupMembership(node);
    select({type:'node', id});
    commit(); render();
    showToast(`Created node ${node.name}.`);
  }

  function createEdge(a, b, skipSelection = false) {
    // Allow multiple links between same nodes - no uniqueness check
    console.log(`[CREATE EDGE] Creating edge from node ${a} to node ${b}`);
    const id = state.nextEdge++;
    const newEdge = makeEdge(id, a, b);
    console.log(`[CREATE EDGE] Edge ${id} created, adding to state.edges. Total edges: ${state.edges.length + 1}`);
    state.edges.push(newEdge);
    if (!skipSelection) {
      select({type:'edge', id});
    }
    commit(); render();
    if (!skipSelection) {
      showToast('Created link. Edit fields in Inspector.');
    }
  }

  function createGroup(x, y, type='country') {
    const id = state.nextGroup++;
    const g = makeGroup(id, x, y, type);
    state.groups.push(g);

    if (g.type === 'country' || g.type === 'dc') updateCountryRegionMembership(g);
    refreshAllMemberships();

    select({type:'group', id});
    commit(); render();
    const typeLabel = g.type === 'region' ? 'group box' : g.type === 'dc' ? (g.dcFacilityType === 'cable_station' ? 'cable station' : 'datacenter container') : 'container box';
    showToast(`Created ${typeLabel}. Rename in Inspector.`);
  }

    function deleteSelected() {
    const hasMulti = (state.selection.nodes.size + state.selection.edges.size + state.selection.groups.size) > 0;
    if (!state.selected && !hasMulti) return;

    // If single selection exists, ensure it's in sets
    if (state.selected) {
      if (state.selected.type==='node') state.selection.nodes.add(state.selected.id);
      if (state.selected.type==='edge') state.selection.edges.add(state.selected.id);
      if (state.selected.type==='group') state.selection.groups.add(state.selected.id);
      state.selected = null;
    }

    const nodeIds = new Set(state.selection.nodes);
    const edgeIds = new Set(state.selection.edges);
    const groupIds = new Set(state.selection.groups);

    // If deleting groups: remove them and clear node memberships
    if (groupIds.size) {
      state.groups = state.groups.filter(g => !groupIds.has(g.id));
      state.nodes.forEach(n => { if (groupIds.has(n.groupId)) n.groupId = null; });
    }

    // Delete nodes and any edges connected to them
    if (nodeIds.size) {
      state.nodes = state.nodes.filter(n => !nodeIds.has(n.id));
      state.edges = state.edges.filter(e => !nodeIds.has(e.a) && !nodeIds.has(e.b));
    }

    // Delete explicitly selected edges (if still present)
    if (edgeIds.size) {
      state.edges = state.edges.filter(e => !edgeIds.has(e.id));
    }

    refreshAllMemberships();
    clearSelection();
    commit();
    render();
    showToast('Deleted selected item(s).');
  }


  // Track if spacebar is held for pan mode
  let spacebarHeld = false;
  let _altKeyHeld = false;

  window.addEventListener('keydown', (ev) => {
    if (ev.key === 'Alt') _altKeyHeld = true;
    if (ev.code === 'Space' && !ev.repeat && !spacebarHeld) {
      // Don't activate space-pan if focus is in a text input
      const tag = document.activeElement?.tagName?.toLowerCase();
      if (tag === 'input' || tag === 'textarea') return;

      spacebarHeld = true;
      svg.style.cursor = 'grab';
      ev.preventDefault(); // Prevent page scroll
    }
  });

  window.addEventListener('keyup', (ev) => {
    if (ev.key === 'Alt') _altKeyHeld = false;
    if (ev.code === 'Space') {
      spacebarHeld = false;
      if (!state.dragging || state.dragging.type !== 'canvasPan') {
        svg.style.cursor = '';
      }
    }
  });

  window.addEventListener('blur', () => { _altKeyHeld = false; });

  svg.addEventListener('mousedown', (ev) => {
    // For geo view, clear selection on mousedown if clicking on empty space
    // This happens BEFORE any drag starts
    if (window.geoViewState && window.geoViewState.active) {
      window._geoClickHandled = false;
      window._geoMouseDownPos = { x: ev.clientX, y: ev.clientY };

      // Check if clicking on a node or edge (they will set _geoClickHandled in their own handlers)
      // But those handlers use click, not mousedown, so we need to check the target
      const target = ev.target;
      const isNode = target.classList.contains('geo-node') || target.closest('.geo-node');
      const isEdgeHitArea = target.getAttribute && target.getAttribute('stroke') === 'transparent' &&
                           target.getAttribute('stroke-width') === '20';

      if (!isNode && !isEdgeHitArea && ev.button === 0) {
        // Clicking on empty canvas - clear selection immediately
        console.log(`[GEO MOUSEDOWN] Clearing selection - clicked on empty canvas`);
        state.selected = null;
        state.selection.nodes.clear();
        state.selection.edges.clear();
        state.selection.groups.clear();
        state.connectFrom = null;
        // Re-render after a tiny delay to allow the mousedown to complete
        setTimeout(() => {
          if (window.geoViewState && window.geoViewState.active) {
            renderGeoView();
            updateInspector();
          }
        }, 0);
      }
    }

    // Middle mouse button for panning
    if (ev.button === 1) {
      ev.preventDefault();
      const wrap = document.getElementById('wrap');
      state.dragging = {
        type: 'canvasPan',
        startScrollX: wrap.scrollLeft,
        startScrollY: wrap.scrollTop,
        startMouseX: ev.clientX,
        startMouseY: ev.clientY
      };
      svg.style.cursor = 'grabbing';
      return;
    }

    // Space+drag for panning from anywhere on the canvas
    if (spacebarHeld && ev.button === 0) {
      ev.preventDefault();
      ev.stopPropagation();
      const wrap = document.getElementById('wrap');
      state.dragging = {
        type: 'canvasPan',
        startScrollX: wrap.scrollLeft,
        startScrollY: wrap.scrollTop,
        startMouseX: ev.clientX,
        startMouseY: ev.clientY
      };
      svg.style.cursor = 'grabbing';
      return;
    }

    // Only left button from here on
    if (ev.button !== 0) return;
    if (state.placingGroup) return;

    // In geo view, allow panning when clicking on the map background
    const inGeoView = window.geoViewState && window.geoViewState.active;
    const isGeoMapBackground = ev.target.id === 'geoMapImage' || ev.target.id === 'geoOcean' ||
                               ev.target.closest('.geo-continents') ||
                               ev.target.closest('#geoMapGroup');

    // Check if clicking on empty space or geo map background
    // Allow Alt+drag marquee to start on any SVG child (grid lines, edge hit areas, etc.)
    const isAltHeld = ev.altKey || _altKeyHeld;
    const isInsideSvg = ev.target === svg || svg.contains(ev.target);
    if (ev.target !== svg && !isGeoMapBackground && !(isAltHeld && isInsideSvg)) {
      return;
    }

    const m = getMouse(ev);
    state.lastMouse = { x: m.x, y: m.y };

    // Alt+drag for marquee selection (disabled in calculation mode and geo view)
    if (isAltHeld && !inGeoView && !(window.routeFinderState && window.routeFinderState.active)) {
      state.marquee = { x0: m.x, y0: m.y, x: m.x, y: m.y, w: 0, h: 0, additive: ev.shiftKey };
      if (!state.marquee.additive) clearSelection();
      state.connectFrom = null;
      render();
      return;
    }

    // Default: click and drag to pan the canvas
    const wrap = document.getElementById('wrap');
    state.dragging = {
      type: 'canvasPan',
      startScrollX: wrap.scrollLeft,
      startScrollY: wrap.scrollTop,
      startMouseX: ev.clientX,
      startMouseY: ev.clientY
    };
    svg.style.cursor = 'grabbing';
  });

  svg.addEventListener('dblclick', (ev) => {
    const m = getMouse(ev);
    if (state.placingGroup) return;
    // Skip if we just placed a group (prevents node creation on double-click when placing container)
    if (state._justPlacedGroup) {
      state._justPlacedGroup = false;
      return;
    }
    createNode(m.x, m.y);
  });

  // Consolidated SVG canvas click handler: group placement + selection clearing + debug alt+click
  svg.addEventListener('click', (ev) => {
    const target = ev.target;
    const tagName = target?.tagName ?? 'unknown';
    const className = target?.getAttribute?.('class') ?? 'none';
    const isDirectSvg = ev.target === svg;
    console.log(`[CANVAS CLICK] target: ${tagName}/${className}, directSVG: ${isDirectSvg}, linkMode: ${linkMode}`);

    // Handle group placement
    if (state.placingGroup) {
      const m = getMouse(ev);
      createGroup(m.x, m.y, state.placingGroupType || 'country');
      state.placingGroup = false;
      state.placingGroupType = 'country';
      state._justPlacedGroup = true; // Flag to prevent dblclick from creating node
      state.stylePresets = state.stylePresets || { node: {}, edge: {}, group: {} };
      state.styleBrush = null;
      document.getElementById('btnAddGroup').classList.remove('primary');
      document.getElementById('btnAddRegion').classList.remove('primary');
      render();
      return;
    }

    // Debug: Alt+click on canvas shows coordinates (helps confirm handlers are active)
    if (ev.altKey) {
      const m = getMouse(ev);
      showToast(`Canvas click @ ${Math.round(m.x)}, ${Math.round(m.y)}`);
    }

    // Check if in geo view
    const inGeoView = window.geoViewState && window.geoViewState.active;

    // For geo view, always clear selection when clicking on canvas (not on node/edge)
    // This ensures deselection happens even when starting a drag
    if (inGeoView) {
      if (!window._geoClickHandled) {
        // Click/drag started on empty space - clear selection
        console.log(`[CANVAS CLICK] Geo view - clearing selection`);
        clearSelection();
        state.connectFrom = null;
        render();
      }
      // Reset flag for next click
      window._geoClickHandled = false;
      window._geoMouseDownPos = null;
      return;
    }

    // For standard canvas view
    const isGeoMapBackground = ev.target.id === 'geoMapImage' || ev.target.id === 'geoOcean' ||
                               ev.target.closest('.geo-continents') ||
                               ev.target.closest('#geoMapGroup');

    // Clear selection if clicking directly on the SVG background or geo map background
    // Skip if marquee selection just completed (click fires after mouseup)
    if (window._marqueeJustFinalized) {
      window._marqueeJustFinalized = false;
      return;
    }
    if (ev.target === svg || isGeoMapBackground) {
      clearSelection(); state.connectFrom=null; render();
    }
  });

  svg.addEventListener('mousemove', (ev) => {
    const m = getMouse(ev);
    state.lastMouse = { x: m.x, y: m.y };

    // Handle canvas panning
    if (state.dragging && state.dragging.type === 'canvasPan') {
      const wrap = document.getElementById('wrap');
      const dx = ev.clientX - state.dragging.startMouseX;
      const dy = ev.clientY - state.dragging.startMouseY;
      wrap.scrollLeft = state.dragging.startScrollX - dx;
      wrap.scrollTop = state.dragging.startScrollY - dy;
      return;
    }

    if (state.marquee) {
      const x1 = state.marquee.x0, y1 = state.marquee.y0;
      const x2 = m.x, y2 = m.y;
      const x = Math.min(x1, x2);
      const y = Math.min(y1, y2);
      const w = Math.abs(x2 - x1);
      const h = Math.abs(y2 - y1);
      state.marquee.x = x; state.marquee.y = y; state.marquee.w = w; state.marquee.h = h;
      render();
      return;
    }


    if (state.resizingGroup) {
      const g = findGroup(state.resizingGroup.id);
      if (!g) return;
      const dx = m.x - state.resizingGroup.mx0;
      const dy = m.y - state.resizingGroup.my0;
      const corner = state.resizingGroup.corner || 'se';
      const minW = 120;
      const minH = 90;

      switch (corner) {
        case 'se': // Bottom-right: just resize width and height
          g.w = Math.max(minW, state.resizingGroup.startW + dx);
          g.h = Math.max(minH, state.resizingGroup.startH + dy);
          break;
        case 'sw': // Bottom-left: move x, resize width inversely, resize height
          {
            const newW = Math.max(minW, state.resizingGroup.startW - dx);
            const newX = state.resizingGroup.startX + state.resizingGroup.startW - newW;
            g.x = newX;
            g.w = newW;
            g.h = Math.max(minH, state.resizingGroup.startH + dy);
          }
          break;
        case 'ne': // Top-right: move y, resize width, resize height inversely
          {
            const newH = Math.max(minH, state.resizingGroup.startH - dy);
            const newY = state.resizingGroup.startY + state.resizingGroup.startH - newH;
            g.y = newY;
            g.h = newH;
            g.w = Math.max(minW, state.resizingGroup.startW + dx);
          }
          break;
        case 'nw': // Top-left: move both x and y, resize both inversely
          {
            const newW = Math.max(minW, state.resizingGroup.startW - dx);
            const newH = Math.max(minH, state.resizingGroup.startH - dy);
            const newX = state.resizingGroup.startX + state.resizingGroup.startW - newW;
            const newY = state.resizingGroup.startY + state.resizingGroup.startH - newH;
            g.x = newX;
            g.y = newY;
            g.w = newW;
            g.h = newH;
          }
          break;
      }
      refreshAllMemberships();
      render();
      return;
    }

    // Handle node resizing
    if (state.resizingNode) {
      const n = findNode(state.resizingNode.id);
      if (!n) return;
      const dx = m.x - state.resizingNode.mx0;
      const dy = m.y - state.resizingNode.my0;
      const corner = state.resizingNode.corner || 'se';
      const minR = 10;
      const maxR = 80;

      // Calculate the distance moved (use the larger of dx or dy for uniform scaling)
      let delta;
      switch (corner) {
        case 'se':
          delta = Math.max(dx, dy);
          break;
        case 'sw':
          delta = Math.max(-dx, dy);
          break;
        case 'ne':
          delta = Math.max(dx, -dy);
          break;
        case 'nw':
          delta = Math.max(-dx, -dy);
          break;
      }

      // Scale the radius based on the drag distance
      const newR = Math.min(maxR, Math.max(minR, state.resizingNode.startR + delta / 2));
      n.r = newR;

      render();
      return;
    }

    if (!state.dragging) return;

    if (state.dragging.type === 'selection') {
      const dx = m.x - state.dragging.mx0;
      const dy = m.y - state.dragging.my0;
      state.dragging.origGroups.forEach(o => {
        const g = findGroup(o.id); if (!g) return;
        g.x = o.x + dx;
        g.y = o.y + dy;
      });
      state.dragging.origNodes.forEach(o => {
        const n = findNode(o.id); if (!n) return;
        n.x = o.x + dx;
        n.y = o.y + dy;
      });
      refreshAllMemberships();
      render();
      return;
    }

    if (state.dragging.type === 'edgeLabel') {
      const e = findEdge(state.dragging.id); if (!e) return;
      const a = findNode(e.a), b = findNode(e.b); if (!a || !b) return;
      let base = (e.style==='orthogonal') ? orthogonalBaseLabelPoint(a.x,a.y,b.x,b.y,e.route||'hv') : {x:(a.x+b.x)/2,y:(a.y+b.y)/2};
      const targetX = m.x + state.dragging.dx;
      const targetY = m.y + state.dragging.dy;
      e.labelDx = targetX - base.x;
      e.labelDy = targetY - base.y;
      render();
      return;
    }

    if (state.dragging.type === 'curveHandle') {
      const e = findEdge(state.dragging.edgeId); if (!e) return;
      const a = findNode(e.a), b = findNode(e.b); if (!a || !b) return;
      // Calculate perpendicular distance from line AB
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist === 0) return;
      // Vector from A to current mouse
      const mx = m.x - a.x;
      const my = m.y - a.y;
      // Project onto perpendicular to AB
      const perpDist = (mx * (-dy) + my * dx) / dist;
      // Convert perpendicular distance to arch value
      // arch = perpDist / (dist * 0.5)
      e.curveArch = clamp(perpDist / (dist * 0.5), -0.6, 0.6);
      // Update slider to match
      edgeCurveArch.value = e.curveArch;
      document.getElementById('curveArchValue').textContent = e.curveArch.toFixed(2);
      render();
      return;
    }

    if (state.dragging.type === 'endpointHandle') {
      state.dragging.mx = m.x;
      state.dragging.my = m.y;
      render();
      return;
    }

    if (state.dragging.type === 'linkDrag') {
      state.dragging.mx = m.x;
      state.dragging.my = m.y;
      render();
      return;
    }

    if (state.dragging.type === 'nodeNameLabel') {
      const n = findNode(state.dragging.id); if (!n) return;
      const targetX = m.x + state.dragging.dx;
      const targetY = m.y + state.dragging.dy;
      n.nameDx = targetX - n.x;
      n.nameDy = targetY - n.y;
      render();
      return;
    }

    if (state.dragging.type === 'nodeTagLabel') {
      const n = findNode(state.dragging.id); if (!n) return;
      const targetX = m.x + state.dragging.dx;
      const targetY = m.y + state.dragging.dy;
      n.tagDx = targetX - n.x;
      n.tagDy = targetY - (n.y + 26);
      render();
      return;
    }

    if (state.dragging.type === 'groupTitleLabel') {
      const g = findGroup(state.dragging.id); if (!g) return;
      const targetX = m.x + state.dragging.dx;
      const targetY = m.y + state.dragging.dy;
      g.titleDx = targetX - (g.x + 14);
      g.titleDy = targetY - (g.y + 22);
      render();
      return;
    }

    if (state.dragging.type === 'node') {
      const n = findNode(state.dragging.id); if (!n) return;
      n.x = m.x + state.dragging.dx;
      n.y = m.y + state.dragging.dy;
      updateNodeGroupMembership(n);
      render();
      return;
    }

    if (state.dragging.type === 'group') {
      const g = findGroup(state.dragging.id); if (!g) return;
      const oldX = g.x, oldY = g.y;
      g.x = m.x + state.dragging.dx;
      g.y = m.y + state.dragging.dy;
      const dx = g.x - oldX;
      const dy = g.y - oldY;

      if (g.type === 'region') {
        // Move all child countries (and their nodes) along with the region
        state.groups.forEach(c => {
          if (c.type === 'country' && c.parentId === g.id) {
            c.x = c.x + dx;
            c.y = c.y + dy;
          }
        });
        state.nodes.forEach(n => {
          const country = n.groupId ? findGroup(n.groupId) : null;
          if (country && country.type === 'country' && country.parentId === g.id) {
            n.x = n.x + dx;
            n.y = n.y + dy;
          }
        });
      } else {
        // Move nodes inside the country box along with it
        state.nodes.forEach(n => {
          if (n.groupId === g.id) {
            n.x = n.x + dx;
            n.y = n.y + dy;
          }
        });
      }

      refreshAllMemberships();
      render();
    }
  });

  window.addEventListener('mouseup', () => {
    // finalize marquee selection
    if (state.marquee) {
      const box = { x: state.marquee.x, y: state.marquee.y, w: state.marquee.w, h: state.marquee.h };
      const insideNode = (n) => n.x >= box.x && n.x <= box.x + box.w && n.y >= box.y && n.y <= box.y + box.h;
      const rectsIntersect = (a, b) => !(a.x+a.w < b.x || b.x+b.w < a.x || a.y+a.h < b.y || b.y+b.h < a.y);

      const nodes = state.nodes.filter(insideNode).map(n=>n.id);
      const groups = state.groups.filter(g => rectsIntersect({x:g.x,y:g.y,w:g.w,h:g.h}, box)).map(g=>g.id);

      // edges where both endpoints are selected (node selection)
      const nodeSet = new Set([...state.selection.nodes, ...nodes]);
      const edges = state.edges.filter(e => nodeSet.has(e.a) && nodeSet.has(e.b)).map(e=>e.id);

      // apply selection (additive if shift held at start)
      if (state.marquee.additive) {
        nodes.forEach(id => state.selection.nodes.add(id));
        groups.forEach(id => state.selection.groups.add(id));
        edges.forEach(id => state.selection.edges.add(id));
      } else {
        setMultiSelection({ nodes, groups, edges });
      }

      state.marquee = null;
      state.dragging = null;
      state.resizingGroup = null;
      state.resizingNode = null;
      window._marqueeJustFinalized = true;
      render();
      return;
    }

    // Commit changes if we were dragging
    const wasDragging = state.dragging !== null;

    // Restore cursor after canvas panning
    if (state.dragging?.type === 'canvasPan') {
      // If spacebar is still held, show grab cursor; otherwise reset
      svg.style.cursor = spacebarHeld ? 'grab' : '';
    }

    // Commit changes if we were dragging curve handle
    if (state.dragging?.type === 'curveHandle') {
      commit();
    }

    // Finalize endpoint handle drag: reassign edge endpoint to nearest node
    if (state.dragging?.type === 'endpointHandle') {
      const edge = findEdge(state.dragging.edgeId);
      if (edge) {
        const fixedEnd = state.dragging.endpoint === 'a' ? 'b' : 'a';
        const fixedNodeId = edge[fixedEnd];
        let bestNode = null, bestDist = Infinity;
        state.nodes.forEach(n => {
          if (!isNodeVisible(n)) return;
          if (n.id === fixedNodeId) return; // prevent self-loop
          const dx = n.x - state.dragging.mx;
          const dy = n.y - state.dragging.my;
          const d = Math.sqrt(dx*dx + dy*dy);
          if (d < bestDist) { bestDist = d; bestNode = n; }
        });
        if (bestNode && bestDist < 80) {
          const oldNodeId = edge[state.dragging.endpoint];
          if (bestNode.id !== oldNodeId) {
            edge[state.dragging.endpoint] = bestNode.id;
            showToast(`Re-routed link endpoint to "${bestNode.name || 'Node ' + bestNode.id}"`);
            commit();
          }
        } else {
          showToast('No node nearby â€” link unchanged');
        }
      }
    }

    // Finalize link drag (Alt+drag): create a new link to the nearest node
    if (state.dragging?.type === 'linkDrag') {
      const sourceId = state.dragging.sourceId;
      let bestNode = null, bestDist = Infinity;
      state.nodes.forEach(n => {
        if (!isNodeVisible(n)) return;
        if (n.id === sourceId) return; // can't link to self
        const dx = n.x - state.dragging.mx;
        const dy = n.y - state.dragging.my;
        const d = Math.sqrt(dx*dx + dy*dy);
        if (d < bestDist) { bestDist = d; bestNode = n; }
      });
      if (bestNode && bestDist < 80) {
        const srcNode = findNode(sourceId);
        createEdge(sourceId, bestNode.id, false);
        showToast(`âœ“ Link created: "${srcNode?.name || 'Node ' + sourceId}" â†’ "${bestNode.name || 'Node ' + bestNode.id}"`);
      } else {
        showToast('No target node nearby â€” drag cancelled');
      }
    }

    // Commit changes if we were resizing a node
    if (state.resizingNode) {
      commit();
    }

    // Commit changes if we were dragging a single node (only if it actually moved)
    if (state.dragging?.type === 'node') {
      const n = findNode(state.dragging.id);
      if (n && (n.x !== state.dragging.origX || n.y !== state.dragging.origY)) {
        commit();
      }
    }

    // Commit changes if we were dragging a selection (only if anything moved)
    if (state.dragging?.type === 'selection') {
      const moved = state.dragging.origNodes.some(o => {
        const n = findNode(o.id);
        return n && (n.x !== o.x || n.y !== o.y);
      }) || state.dragging.origGroups.some(o => {
        const g = findGroup(o.id);
        return g && (g.x !== o.x || g.y !== o.y);
      });
      if (moved) commit();
    }

    // Commit changes if we were dragging a group (only if it actually moved)
    if (state.dragging?.type === 'group') {
      const g = findGroup(state.dragging.id);
      if (g && (g.x !== state.dragging.origX || g.y !== state.dragging.origY)) {
        commit();
      }
    }

    // Commit changes if we were dragging a label (only if it actually moved)
    if (state.dragging?.type === 'nodeNameLabel') {
      const n = findNode(state.dragging.id);
      if (n && ((n.nameDx||0) !== state.dragging.origDx || (n.nameDy||0) !== state.dragging.origDy)) {
        commit();
      }
    }
    if (state.dragging?.type === 'nodeTagLabel') {
      const n = findNode(state.dragging.id);
      if (n && ((n.tagDx||0) !== state.dragging.origDx || (n.tagDy||0) !== state.dragging.origDy)) {
        commit();
      }
    }
    if (state.dragging?.type === 'groupTitleLabel') {
      const g = findGroup(state.dragging.id);
      if (g && ((g.titleDx||0) !== state.dragging.origDx || (g.titleDy||0) !== state.dragging.origDy)) {
        commit();
      }
    }

    state.dragging = null;
    state.resizingGroup = null;
    state.resizingNode = null;

    // Check if canvas needs to expand to fit elements
    if (wasDragging && typeof checkAndAutoExpandCanvas === 'function') {
      checkAndAutoExpandCanvas();
    }

    // Render if we were dragging to update cursor/state
    if (wasDragging) {
      render();
    }
  });

  window.addEventListener('keydown', (ev) => {
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'z') {
      ev.preventDefault();
      if (ev.shiftKey) redo(); else undo();
      return;
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'y') {
      ev.preventDefault(); redo(); return;
    }

    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'c') {
      ev.preventDefault();
      copySelection();
      return;
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'x') {
      ev.preventDefault();
      copySelection();
      deleteSelected();
      return;
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'v') {
      ev.preventDefault();
      pasteSelection();
      return;
    }

    if ((ev.key === 'Backspace' || ev.key === 'Delete') && !['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) {
      ev.preventDefault(); deleteSelected();
    }
    if (ev.key === 'Escape') {
      clearBrush();
      clearLinkMode();
      state.placingGroup=false;
      document.getElementById('btnAddGroup').classList.remove('primary');
      document.getElementById('btnAddRegion').classList.remove('primary');
      render();
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 's') {
      ev.preventDefault(); saveProject(false);
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'o') {
      ev.preventDefault(); openProjectWithFilePicker();
    }
    if ((ev.ctrlKey || ev.metaKey) && ev.key.toLowerCase() === 'n') {
      ev.preventDefault(); newDiagram();
    }
  });

  document.getElementById('btnAddGroup').addEventListener('click', (ev) => {
    state.placingGroupType = 'country';
    state.placingGroup = !state.placingGroup;
    document.getElementById('btnAddGroup').classList.toggle('primary', state.placingGroup && state.placingGroupType==='country');
    document.getElementById('btnAddRegion').classList.toggle('primary', state.placingGroup && state.placingGroupType==='region');
    showToast(state.placingGroup ? 'Click the canvas to place a container box.' : 'Placement cancelled.');
  });

  document.getElementById('btnAddRegion').addEventListener('click', (ev) => {
    state.placingGroupType = 'region';
    state.placingGroup = !state.placingGroup;
    document.getElementById('btnAddRegion').classList.toggle('primary', state.placingGroup && state.placingGroupType==='region');
    document.getElementById('btnAddGroup').classList.remove('primary');
    document.getElementById('btnAddDCContainer').classList.remove('primary');
    showToast(state.placingGroup ? 'Click the canvas to place a group box.' : 'Placement cancelled.');
  });

  document.getElementById('btnAddDCContainer').addEventListener('click', (ev) => {
    state.placingGroupType = 'dc';
    state.placingGroup = !state.placingGroup;
    document.getElementById('btnAddDCContainer').classList.toggle('primary', state.placingGroup && state.placingGroupType==='dc');
    document.getElementById('btnAddGroup').classList.remove('primary');
    document.getElementById('btnAddRegion').classList.remove('primary');
    showToast(state.placingGroup ? 'Click the canvas to place a datacenter container.' : 'Placement cancelled.');
  });

// ============== CSV EXPORT WITH OPTIONS ==============

// Define all available fields for export
const csvExportFields = {
  links: [
    { key: 'uuid', label: 'Link UUID', default: true, getValue: (e) => e.uuid || '' },
    { key: 'aUuid', label: 'A-End Node UUID', default: true, getValue: (e, a) => a?.uuid || '' },
    { key: 'aName', label: 'A-End Node Name', default: true, getValue: (e, a) => a?.name || '' },
    { key: 'aCode', label: 'A-End Node Code', default: true, getValue: (e, a) => a?.code || '' },
    { key: 'bUuid', label: 'B-End Node UUID', default: true, getValue: (e, a, b) => b?.uuid || '' },
    { key: 'bName', label: 'B-End Node Name', default: true, getValue: (e, a, b) => b?.name || '' },
    { key: 'bCode', label: 'B-End Node Code', default: true, getValue: (e, a, b) => b?.code || '' },
    { key: 'tag', label: 'Link Tag', default: true, getValue: (e) => e.tag || '' },
    { key: 'code', label: 'Link Code', default: true, getValue: (e) => e.code || '' },
    { key: 'latency', label: 'Latency (ms)', default: true, getValue: (e) => (typeof e.latencyMs === 'number' && isFinite(e.latencyMs)) ? e.latencyMs : '' },
    { key: 'priority', label: 'Priority', default: true, getValue: (e) => (typeof e.priority === 'number' && isFinite(e.priority)) ? e.priority : 0 },
    { key: 'designCapacity', label: 'Design Max Capacity (Gbps)', default: true, getValue: (e) => e.designCapacityGbps || 0 },
    { key: 'cap1G', label: 'Available 1G Units', default: true, getValue: (e) => e.cap1G || 0 },
    { key: 'cap10G', label: 'Available 10G Units', default: true, getValue: (e) => e.cap10G || 0 },
    { key: 'cap100G', label: 'Available 100G Units', default: true, getValue: (e) => e.cap100G || 0 },
    { key: 'cap400G', label: 'Available 400G Units', default: true, getValue: (e) => e.cap400G || 0 },
    { key: 'capTbps', label: 'Available Tbps Units', default: true, getValue: (e) => e.capTbps || 0 },
    { key: 'totalCapacity', label: 'Total Available (Gbps)', default: true, getValue: (e) => {
      const c1 = e.cap1G || 0;
      const c10 = e.cap10G || 0;
      const c100 = e.cap100G || 0;
      const c400 = e.cap400G || 0;
      const cT = e.capTbps || 0;
      return c1 + (10 * c10) + (100 * c100) + (400 * c400) + (1000 * cT);
    }},
    { key: 'cableSystem', label: 'Cable System', default: false, getValue: (e) => {
      if (e.cableSystemId) {
        const cs = state.cableSystems.find(c => c.id === e.cableSystemId);
        return cs?.name || '';
      }
      return '';
    }},
    { key: 'filterTags', label: 'Filter Tags', default: false, getValue: (e) => (e.filterTags || []).join('|') },
    { key: 'extraTags', label: 'Additional Tags/Notes', default: true, getValue: (e) => e.extraTags || '' },
    { key: 'strokeColor', label: 'Line Color', default: false, getValue: (e) => e.strokeColor || e.stroke || '' },
    { key: 'strokeWidth', label: 'Line Width', default: false, getValue: (e) => e.strokeW || e.strokeWidth || '' }
  ],
  nodes: [
    { key: 'uuid', label: 'Node UUID', default: true, getValue: (n) => n.uuid || '' },
    { key: 'name', label: 'Node Name', default: true, getValue: (n) => n.name || '' },
    { key: 'code', label: 'Node Code', default: true, getValue: (n) => n.code || '' },
    { key: 'tags', label: 'Tags', default: true, getValue: (n) => (n.tags || []).join('|') },
    { key: 'extraTags', label: 'Additional Tags', default: true, getValue: (n) => n.extraTags || '' },
    { key: 'address', label: 'Address', default: true, getValue: (n) => n.address || '' },
    { key: 'city', label: 'City', default: true, getValue: (n) => n.city || '' },
    { key: 'postalCode', label: 'Postal Code', default: false, getValue: (n) => n.postalCode || '' },
    { key: 'county', label: 'County', default: false, getValue: (n) => n.county || '' },
    { key: 'state', label: 'State', default: false, getValue: (n) => n.state || '' },
    { key: 'country', label: 'Country', default: true, getValue: (n) => n.country || '' },
    { key: 'gpsLat', label: 'GPS Latitude', default: true, getValue: (n) => (n.gpsLat !== null && n.gpsLat !== undefined) ? n.gpsLat : '' },
    { key: 'gpsLon', label: 'GPS Longitude', default: true, getValue: (n) => (n.gpsLon !== null && n.gpsLon !== undefined) ? n.gpsLon : '' },
    { key: 'containerName', label: 'Container Box', default: true, getValue: (n) => {
      const g = n.groupId ? findGroup(n.groupId) : null;
      return g?.title || '';
    }},
    { key: 'containerUuid', label: 'Container UUID', default: true, getValue: (n) => {
      const g = n.groupId ? findGroup(n.groupId) : null;
      return g?.uuid || '';
    }},
    { key: 'x', label: 'X Position', default: false, getValue: (n) => Math.round(n.x) },
    { key: 'y', label: 'Y Position', default: false, getValue: (n) => Math.round(n.y) },
    { key: 'fill', label: 'Fill Color', default: false, getValue: (n) => n.fill || '' },
    { key: 'stroke', label: 'Stroke Color', default: false, getValue: (n) => n.stroke || '' },
    { key: 'radius', label: 'Radius', default: false, getValue: (n) => n.r || '' }
  ]
};

// Store user's field selection preferences
let csvExportPrefs = {
  links: { separator: ';', fields: null },
  nodes: { separator: ';', fields: null }
};

function showCSVExportDialog(type) {
  const fields = csvExportFields[type];
  const prefs = csvExportPrefs[type];

  // Initialize field selection if not set
  if (!prefs.fields) {
    prefs.fields = new Set(fields.filter(f => f.default).map(f => f.key));
  }

  const modal = document.createElement('div');
  modal.id = 'csvExportModal';
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.5); z-index: 10000;
    display: flex; align-items: center; justify-content: center;
  `;

  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: white; border-radius: 8px; padding: 0;
    min-width: 450px; max-width: 550px; max-height: 80vh;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    display: flex; flex-direction: column;
  `;

  // Header
  const header = document.createElement('div');
  header.style.cssText = `
    padding: 16px 20px; border-bottom: 1px solid #e0e0e0;
    font-size: 16px; font-weight: 600; color: #333;
    display: flex; justify-content: space-between; align-items: center;
  `;
  header.innerHTML = `
    <span>ðŸ“Š Export ${type === 'links' ? 'Links' : 'Nodes'} CSV</span>
    <button id="closeCSVExport" style="background:none; border:none; font-size:20px; cursor:pointer; color:#666;">Ã—</button>
  `;
  dialog.appendChild(header);

  // Content
  const content = document.createElement('div');
  content.style.cssText = `padding: 16px 20px; overflow-y: auto; flex: 1;`;

  // Separator selection
  content.innerHTML = `
    <div style="margin-bottom: 16px;">
      <label style="font-weight: 600; font-size: 12px; color: #555; display: block; margin-bottom: 6px;">Field Separator</label>
      <div style="display: flex; gap: 16px;">
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
          <input type="radio" name="csvSeparator" value=";" ${prefs.separator === ';' ? 'checked' : ''} style="accent-color: #0096D6;" />
          <span style="font-size: 13px;">Semicolon (;)</span>
          <span style="font-size: 10px; color: #888;">Excel EU</span>
        </label>
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
          <input type="radio" name="csvSeparator" value="," ${prefs.separator === ',' ? 'checked' : ''} style="accent-color: #0096D6;" />
          <span style="font-size: 13px;">Comma (,)</span>
          <span style="font-size: 10px; color: #888;">Excel US</span>
        </label>
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
          <input type="radio" name="csvSeparator" value="\t" ${prefs.separator === '\t' ? 'checked' : ''} style="accent-color: #0096D6;" />
          <span style="font-size: 13px;">Tab</span>
        </label>
      </div>
    </div>

    <div style="margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center;">
      <label style="font-weight: 600; font-size: 12px; color: #555;">Fields to Export</label>
      <div style="display: flex; gap: 8px;">
        <button id="csvSelectAll" style="font-size: 10px; padding: 3px 8px; cursor: pointer; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px;">Select All</button>
        <button id="csvSelectNone" style="font-size: 10px; padding: 3px 8px; cursor: pointer; background: #f0f0f0; border: 1px solid #ccc; border-radius: 3px;">Select None</button>
        <button id="csvSelectDefault" style="font-size: 10px; padding: 3px 8px; cursor: pointer; background: #e8f4fc; border: 1px solid #0096D6; border-radius: 3px; color: #0096D6;">Reset Default</button>
      </div>
    </div>

    <div id="csvFieldsList" style="border: 1px solid #e0e0e0; border-radius: 6px; max-height: 300px; overflow-y: auto;">
      ${fields.map(f => `
        <label style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; border-bottom: 1px solid #f0f0f0; cursor: pointer; font-size: 12px;">
          <input type="checkbox" class="csv-field-cb" data-key="${f.key}" ${prefs.fields.has(f.key) ? 'checked' : ''} style="accent-color: #0096D6;" />
          <span style="flex: 1;">${f.label}</span>
          ${f.default ? '<span style="font-size: 9px; background: #e8f4fc; color: #0096D6; padding: 1px 4px; border-radius: 2px;">default</span>' : ''}
        </label>
      `).join('')}
    </div>

    <div style="margin-top: 12px; font-size: 11px; color: #666;">
      <span id="csvFieldCount">${prefs.fields.size}</span> of ${fields.length} fields selected â€¢
      ${type === 'links' ? state.edges.length + ' links' : state.nodes.length + ' nodes'} to export
    </div>
  `;
  dialog.appendChild(content);

  // Footer
  const footer = document.createElement('div');
  footer.style.cssText = `
    padding: 12px 20px; border-top: 1px solid #e0e0e0;
    display: flex; justify-content: flex-end; gap: 10px;
  `;
  footer.innerHTML = `
    <button id="csvCancelBtn" style="padding: 8px 16px; font-size: 13px; cursor: pointer; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px;">Cancel</button>
    <button id="csvExportBtn" style="padding: 8px 16px; font-size: 13px; cursor: pointer; background: #0096D6; border: 1px solid #0096D6; border-radius: 4px; color: white; font-weight: 500;">Export CSV</button>
  `;
  dialog.appendChild(footer);

  modal.appendChild(dialog);
  document.body.appendChild(modal);

  // Event handlers
  const closeModal = () => modal.remove();

  modal.querySelector('#closeCSVExport').addEventListener('click', closeModal);
  modal.querySelector('#csvCancelBtn').addEventListener('click', closeModal);
  modal.addEventListener('click', (ev) => { if (ev.target === modal) closeModal(); });

  // Field count update
  const updateFieldCount = () => {
    const count = modal.querySelectorAll('.csv-field-cb:checked').length;
    modal.querySelector('#csvFieldCount').textContent = count;
  };

  // Checkbox handlers
  modal.querySelectorAll('.csv-field-cb').forEach(cb => {
    cb.addEventListener('change', updateFieldCount);
  });

  modal.querySelector('#csvSelectAll').addEventListener('click', () => {
    modal.querySelectorAll('.csv-field-cb').forEach(cb => cb.checked = true);
    updateFieldCount();
  });

  modal.querySelector('#csvSelectNone').addEventListener('click', () => {
    modal.querySelectorAll('.csv-field-cb').forEach(cb => cb.checked = false);
    updateFieldCount();
  });

  modal.querySelector('#csvSelectDefault').addEventListener('click', () => {
    modal.querySelectorAll('.csv-field-cb').forEach(cb => {
      const field = fields.find(f => f.key === cb.dataset.key);
      cb.checked = field?.default || false;
    });
    updateFieldCount();
  });

  // Export button
  modal.querySelector('#csvExportBtn').addEventListener('click', () => {
    // Get selected separator
    const separator = modal.querySelector('input[name="csvSeparator"]:checked').value;
    prefs.separator = separator;

    // Get selected fields
    prefs.fields = new Set();
    modal.querySelectorAll('.csv-field-cb:checked').forEach(cb => {
      prefs.fields.add(cb.dataset.key);
    });

    if (prefs.fields.size === 0) {
      showToast('âš ï¸ Please select at least one field');
      return;
    }

    // Build CSV
    const selectedFields = fields.filter(f => prefs.fields.has(f.key));
    const headers = selectedFields.map(f => f.label);
    let csv = headers.join(separator) + '\r\n';

    if (type === 'links') {
      for (const e of state.edges) {
        const a = findNode(e.a);
        const b = findNode(e.b);
        if (!a || !b) continue;

        // Ensure UUIDs
        if (!e.uuid) e.uuid = generateUUID();
        if (!a.uuid) a.uuid = generateUUID();
        if (!b.uuid) b.uuid = generateUUID();

        const row = selectedFields.map(f => escapeCSV(f.getValue(e, a, b), separator));
        csv += row.join(separator) + '\r\n';
      }
      downloadText('links.csv', csv, 'text/csv;charset=utf-8');
      showToast(`âœ“ Exported ${state.edges.length} links to links.csv`);
    } else {
      for (const n of state.nodes) {
        if (!n.uuid) n.uuid = generateUUID();
        const g = n.groupId ? findGroup(n.groupId) : null;
        if (g && !g.uuid) g.uuid = generateUUID();

        const row = selectedFields.map(f => escapeCSV(f.getValue(n), separator));
        csv += row.join(separator) + '\r\n';
      }
      downloadText('nodes.csv', csv, 'text/csv;charset=utf-8');
      showToast(`âœ“ Exported ${state.nodes.length} nodes to nodes.csv`);
    }

    closeModal();
  });
}

// Updated escapeCSV to handle different separators
function escapeCSV(value, separator = ';') {
  if (value === null || value === undefined) return '';
  const str = String(value);
  // Need quotes if contains separator, quotes, or newlines
  if (str.includes(separator) || str.includes('"') || str.includes('\n') || str.includes('\r')) {
    return '"' + str.replace(/"/g, '""') + '"';
  }
  return str;
}

document.getElementById('btnExportLinks').addEventListener('click', () => {
  showCSVExportDialog('links');
});

document.getElementById('btnExportNodes').addEventListener('click', () => {
  showCSVExportDialog('nodes');
});

// ============== IMPORT TEMPLATE & PROJECT IMPORT ==============

// City GPS database for auto-positioning
const cityGPSDatabase = {
  // Major world cities - add more as needed
  'london': { lat: 51.5074, lon: -0.1278 },
  'new york': { lat: 40.7128, lon: -74.0060 },
  'paris': { lat: 48.8566, lon: 2.3522 },
  'tokyo': { lat: 35.6762, lon: 139.6503 },
  'singapore': { lat: 1.3521, lon: 103.8198 },
  'hong kong': { lat: 22.3193, lon: 114.1694 },
  'sydney': { lat: -33.8688, lon: 151.2093 },
  'dubai': { lat: 25.2048, lon: 55.2708 },
  'frankfurt': { lat: 50.1109, lon: 8.6821 },
  'amsterdam': { lat: 52.3676, lon: 4.9041 },
  'madrid': { lat: 40.4168, lon: -3.7038 },
  'barcelona': { lat: 41.3874, lon: 2.1686 },
  'milan': { lat: 45.4642, lon: 9.1900 },
  'zurich': { lat: 47.3769, lon: 8.5417 },
  'geneva': { lat: 46.2044, lon: 6.1432 },
  'brussels': { lat: 50.8503, lon: 4.3517 },
  'vienna': { lat: 48.2082, lon: 16.3738 },
  'berlin': { lat: 52.5200, lon: 13.4050 },
  'munich': { lat: 48.1351, lon: 11.5820 },
  'dublin': { lat: 53.3498, lon: -6.2603 },
  'lisbon': { lat: 38.7223, lon: -9.1393 },
  'stockholm': { lat: 59.3293, lon: 18.0686 },
  'oslo': { lat: 59.9139, lon: 10.7522 },
  'copenhagen': { lat: 55.6761, lon: 12.5683 },
  'helsinki': { lat: 60.1699, lon: 24.9384 },
  'warsaw': { lat: 52.2297, lon: 21.0122 },
  'prague': { lat: 50.0755, lon: 14.4378 },
  'budapest': { lat: 47.4979, lon: 19.0402 },
  'athens': { lat: 37.9838, lon: 23.7275 },
  'istanbul': { lat: 41.0082, lon: 28.9784 },
  'moscow': { lat: 55.7558, lon: 37.6173 },
  'mumbai': { lat: 19.0760, lon: 72.8777 },
  'delhi': { lat: 28.6139, lon: 77.2090 },
  'bangalore': { lat: 12.9716, lon: 77.5946 },
  'chennai': { lat: 13.0827, lon: 80.2707 },
  'beijing': { lat: 39.9042, lon: 116.4074 },
  'shanghai': { lat: 31.2304, lon: 121.4737 },
  'seoul': { lat: 37.5665, lon: 126.9780 },
  'taipei': { lat: 25.0330, lon: 121.5654 },
  'bangkok': { lat: 13.7563, lon: 100.5018 },
  'jakarta': { lat: -6.2088, lon: 106.8456 },
  'kuala lumpur': { lat: 3.1390, lon: 101.6869 },
  'manila': { lat: 14.5995, lon: 120.9842 },
  'ho chi minh': { lat: 10.8231, lon: 106.6297 },
  'cairo': { lat: 30.0444, lon: 31.2357 },
  'johannesburg': { lat: -26.2041, lon: 28.0473 },
  'cape town': { lat: -33.9249, lon: 18.4241 },
  'lagos': { lat: 6.5244, lon: 3.3792 },
  'nairobi': { lat: -1.2921, lon: 36.8219 },
  'sao paulo': { lat: -23.5505, lon: -46.6333 },
  'rio de janeiro': { lat: -22.9068, lon: -43.1729 },
  'buenos aires': { lat: -34.6037, lon: -58.3816 },
  'santiago': { lat: -33.4489, lon: -70.6693 },
  'bogota': { lat: 4.7110, lon: -74.0721 },
  'lima': { lat: -12.0464, lon: -77.0428 },
  'mexico city': { lat: 19.4326, lon: -99.1332 },
  'toronto': { lat: 43.6532, lon: -79.3832 },
  'montreal': { lat: 45.5017, lon: -73.5673 },
  'vancouver': { lat: 49.2827, lon: -123.1207 },
  'los angeles': { lat: 34.0522, lon: -118.2437 },
  'san francisco': { lat: 37.7749, lon: -122.4194 },
  'chicago': { lat: 41.8781, lon: -87.6298 },
  'miami': { lat: 25.7617, lon: -80.1918 },
  'dallas': { lat: 32.7767, lon: -96.7970 },
  'seattle': { lat: 47.6062, lon: -122.3321 },
  'denver': { lat: 39.7392, lon: -104.9903 },
  'atlanta': { lat: 33.7490, lon: -84.3880 },
  'washington': { lat: 38.9072, lon: -77.0369 },
  'boston': { lat: 42.3601, lon: -71.0589 },
  'ashburn': { lat: 39.0438, lon: -77.4874 },
  'silicon valley': { lat: 37.3875, lon: -122.0575 },
  'palo alto': { lat: 37.4419, lon: -122.1430 },
  'marseille': { lat: 43.2965, lon: 5.3698 },
  'lyon': { lat: 45.7640, lon: 4.8357 },
  'manchester': { lat: 53.4808, lon: -2.2426 },
  'birmingham': { lat: 52.4862, lon: -1.8904 },
  'edinburgh': { lat: 55.9533, lon: -3.1883 },
  'hamburg': { lat: 53.5511, lon: 9.9937 },
  'dusseldorf': { lat: 51.2277, lon: 6.7735 },
  'cologne': { lat: 50.9375, lon: 6.9603 },
  'rome': { lat: 41.9028, lon: 12.4964 },
  'turin': { lat: 45.0703, lon: 7.6869 },
  'melbourne': { lat: -37.8136, lon: 144.9631 },
  'perth': { lat: -31.9505, lon: 115.8605 },
  'auckland': { lat: -36.8509, lon: 174.7645 },
  'wellington': { lat: -41.2865, lon: 174.7762 }
};

// Lookup city GPS from database
function lookupCityGPS(cityName) {
  if (!cityName) return null;
  const normalized = cityName.toLowerCase().trim();
  return cityGPSDatabase[normalized] || null;
}

// Download Import Template
document.getElementById('btnDownloadTemplate')?.addEventListener('click', () => {
  showTemplateDownloadDialog();
});

function showTemplateDownloadDialog() {
  const modal = document.createElement('div');
  modal.id = 'templateDownloadModal';
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.5); z-index: 10000;
    display: flex; align-items: center; justify-content: center;
  `;

  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: white; border-radius: 8px; padding: 0;
    min-width: 500px; max-width: 600px; max-height: 85vh;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    display: flex; flex-direction: column;
  `;

  dialog.innerHTML = `
    <div style="padding: 16px 20px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center;">
      <span style="font-size: 16px; font-weight: 600; color: #333;">ðŸ“‹ Download Import Template</span>
      <button id="closeTemplateModal" style="background:none; border:none; font-size:20px; cursor:pointer; color:#666;">Ã—</button>
    </div>

    <div style="padding: 20px; overflow-y: auto; flex: 1;">
      <div style="background: #eff6ff; border: 1px solid #bfdbfe; border-radius: 6px; padding: 12px; margin-bottom: 16px;">
        <div style="font-weight: 600; color: #1e40af; margin-bottom: 4px;">ðŸ“Œ Template Instructions</div>
        <div style="font-size: 12px; color: #1e40af;">
          Download a spreadsheet template with 5 tabs: Instructions, Nodes, Links, Containers, and MLGs.
          Fill in your data and import it back to create your network diagram.
        </div>
      </div>

      <div style="margin-bottom: 16px;">
        <label style="font-weight: 600; font-size: 12px; color: #555; display: block; margin-bottom: 8px;">Template Format</label>
        <div style="display: flex; gap: 12px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px; border: 2px solid #e0e0e0; border-radius: 6px; flex: 1;">
            <input type="radio" name="templateFormat" value="xlsx" checked style="accent-color: #0096D6;" />
            <div>
              <div style="font-weight: 600; font-size: 13px;">Excel (.xlsx)</div>
              <div style="font-size: 10px; color: #888;">Microsoft Excel format</div>
            </div>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px; border: 2px solid #e0e0e0; border-radius: 6px; flex: 1;">
            <input type="radio" name="templateFormat" value="ods" style="accent-color: #0096D6;" />
            <div>
              <div style="font-weight: 600; font-size: 13px;">ODS (.ods)</div>
              <div style="font-size: 10px; color: #888;">LibreOffice/OpenOffice</div>
            </div>
          </label>
        </div>
      </div>

      <div style="margin-bottom: 16px;">
        <label style="font-weight: 600; font-size: 12px; color: #555; display: block; margin-bottom: 8px;">Include Current Data</label>
        <label style="display: flex; align-items: flex-start; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="templateIncludeData" style="accent-color: #0096D6; margin-top: 2px;" />
          <div>
            <div style="font-size: 12px;">Export current diagram data in template</div>
            <div style="font-size: 10px; color: #888;">Useful for editing existing data in a spreadsheet</div>
          </div>
        </label>
      </div>

      <div style="background: #f8fafc; border-radius: 6px; padding: 12px;">
        <div style="font-weight: 600; font-size: 11px; color: #555; margin-bottom: 8px;">Template Contents:</div>
        <div style="font-size: 11px; color: #666; line-height: 1.6;">
          <div><strong>Tab 1 - Instructions:</strong> How to fill the template, field descriptions</div>
          <div><strong>Tab 2 - Nodes:</strong> Node Name*, Code, City, Country, GPS, Tags, etc.</div>
          <div><strong>Tab 3 - Links:</strong> A-End*, B-End*, Latency, Capacity, Cost, Diversity, etc.</div>
          <div><strong>Tab 4 - Containers:</strong> Container Name*, Type, Parent, etc.</div>
          <div><strong>Tab 5 - MLGs:</strong> MLG Name*, Origin, Dest, Paths, Protection, Costs, etc.</div>
          <div style="margin-top: 6px; font-size: 10px; color: #888;">* Required fields</div>
        </div>
      </div>
    </div>

    <div style="padding: 12px 20px; border-top: 1px solid #e0e0e0; display: flex; justify-content: flex-end; gap: 10px;">
      <button id="templateCancelBtn" style="padding: 8px 16px; font-size: 13px; cursor: pointer; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px;">Cancel</button>
      <button id="templateDownloadBtn" style="padding: 8px 16px; font-size: 13px; cursor: pointer; background: #0096D6; border: 1px solid #0096D6; border-radius: 4px; color: white; font-weight: 500;">Download Template</button>
    </div>
  `;

  modal.appendChild(dialog);
  document.body.appendChild(modal);

  const closeModal = () => modal.remove();

  modal.querySelector('#closeTemplateModal').addEventListener('click', closeModal);
  modal.querySelector('#templateCancelBtn').addEventListener('click', closeModal);
  modal.addEventListener('click', (ev) => { if (ev.target === modal) closeModal(); });

  modal.querySelector('#templateDownloadBtn').addEventListener('click', async () => {
    const format = modal.querySelector('input[name="templateFormat"]:checked').value;
    const includeData = modal.querySelector('#templateIncludeData').checked;

    showToast('â³ Generating template...');
    closeModal();

    // Generate template data
    const templateData = generateTemplateData(includeData);

    // Download as CSV files (we'll create XLSX/ODS on server or use a library)
    downloadTemplateAsCSV(templateData, format);
  });
}

function generateTemplateData(includeData) {
  const data = {
    instructions: [
      ['NEXIMAP STUDIO - IMPORT TEMPLATE'],
      [''],
      ['HOW TO USE THIS TEMPLATE:'],
      ['1. Fill in the Nodes tab with your network nodes (data centers, PoPs, etc.)'],
      ['2. Fill in the Links tab to connect nodes together'],
      ['3. Optionally fill Containers tab to group nodes into regions/countries'],
      ['4. Save the file and use File â†’ Import from Spreadsheet in NexiMap Studio'],
      [''],
      ['NODE IDENTIFICATION:'],
      ['- Nodes are identified by Code (priority) or Name'],
      ['- Use the same identifier in Links tab A-End and B-End columns'],
      ['- Code must be unique if used; Name must be unique if Code is not provided'],
      [''],
      ['GPS COORDINATES:'],
      ['- If GPS Lat/Lon provided, nodes appear in Geographic views'],
      ['- If City name matches our database, GPS is auto-filled'],
      ['- Otherwise, nodes only appear in Canvas view'],
      [''],
      ['POSITIONING:'],
      ['- Canvas X/Y can be left empty for auto-layout'],
      ['- Auto-layout uses GPS coordinates for geographic positioning'],
      [''],
      ['CONTAINER RELATIONSHIPS:'],
      ['- Use "Container Name" column in Nodes tab to place nodes inside a container'],
      ['- The container name must match exactly a name in the Containers tab'],
      ['- Use "Parent Container" column in Containers tab to nest containers'],
      ['- Example: Country "France" can have Parent "Europe" (a region)'],
      [''],
      ['DEFAULT COLORS (leave blank to use these):'],
      ['- Nodes Fill: #dae8fc (light blue)'],
      ['- Nodes Stroke: #6c8ebf (blue)'],
      ['- Links Color: #666666 (gray)'],
      ['- Containers Fill: #fff2cc (light yellow)'],
      ['- Containers Stroke: #d6b656 (gold)'],
      [''],
      ['FIELDS MARKED WITH * ARE REQUIRED'],
      [''],
      ['--- NODES TAB FIELDS ---'],
      ['Node Name* - Display name (required)'],
      ['Node Code - Short identifier (used for matching if provided)'],
      ['Tags - Pipe-separated: default|onnet|europe'],
      ['Additional Tags - Free text notes'],
      ['Address - Street address'],
      ['City - City name (auto-lookup GPS if matched)'],
      ['Postal Code - Zip/postal code'],
      ['State - State/province'],
      ['Country - Country name'],
      ['GPS Latitude - Decimal degrees (-90 to 90)'],
      ['GPS Longitude - Decimal degrees (-180 to 180)'],
      ['Container Name - Parent container (must match a name in Containers tab)'],
      ['Fill Color - Hex color #RRGGBB (default: #dae8fc)'],
      ['Stroke Color - Hex color #RRGGBB (default: #6c8ebf)'],
      [''],
      ['--- LINKS TAB FIELDS ---'],
      ['A-End Node* - Source node (Code or Name)'],
      ['B-End Node* - Target node (Code or Name)'],
      ['Link Tag - Display label'],
      ['Link Code - Circuit identifier'],
      ['Latency (ms) - Numeric'],
      ['Priority - -100 (avoid) to +100 (prefer)'],
      ['Design Max Capacity (Gbps) - Maximum capacity'],
      ['Available 1G/10G/100G/400G/Tbps Units - Capacity inventory'],
      ['Cable System - Name of cable system'],
      ['Tags - Pipe-separated filter tags'],
      ['Additional Tags - Free text notes'],
      ['Line Color - Hex color #RRGGBB (default: #666666)'],
      [''],
      ['--- LINKS COMMERCIAL FIELDS ---'],
      ['Lease NRC - Non-Recurring Cost (one-time fee)'],
      ['Lease MRC - Monthly Recurring Cost'],
      ['IRU Fee - Indefeasible Right of Use fee'],
      ['IRU Term (years) - Duration of IRU agreement'],
      ['IRU O&M % - Operations & Maintenance percentage'],
      ['IRU O&M Annual Increment % - Yearly O&M increase'],
      ['Physical Routing Overlap - Pipe-separated link codes sharing physical path'],
      [''],
      ['--- MLG (MULTILINK GROUP) TAB FIELDS ---'],
      ['MLG Name* - Display name for the protected path'],
      ['MLG Code - Short identifier'],
      ['Origin Node* - Starting node (Code or Name)'],
      ['Destination Node* - Ending node (Code or Name)'],
      ['Capacity Tier - 1G, 10G, 100G, or 400G'],
      ['Topology Type - unprotected, 1+1, ring, mesh'],
      ['Total Latency (ms) - End-to-end latency'],
      ['Total Links - Number of links in path'],
      ['Path Links - Pipe-separated codes for primary/working path'],
      ['Protection Links - Pipe-separated codes for protection path'],
      ['Override NRC/MRC/IRU Fee - Manual cost overrides'],
      ['IRU Term (years) - IRU duration for MLG'],
      ['Notes - Free text notes'],
      [''],
      ['--- CONTAINERS TAB FIELDS ---'],
      ['Container Name* - Display title'],
      ['Type - "country", "region", or "dc" (datacenter)'],
      ['Parent Container - Name of parent container (for nesting)'],
      ['Tags - Pipe-separated: default|Imported Datacenter'],
      ['Organization - DC operator (e.g. Equinix)'],
      ['Address - Street address'],
      ['City - City name'],
      ['Postal Code - Zip/postal code'],
      ['State - State/province'],
      ['Country - Country name'],
      ['Facility Type - datacenter or cable_station (default: datacenter)'],
      ['Continent - Region/continent (e.g. Europe, North America)'],
      ['GPS Latitude - Decimal degrees (-90 to 90)'],
      ['GPS Longitude - Decimal degrees (-180 to 180)'],
      ['Website - URL of the datacenter facility'],
      ['Cable Systems - Pipe-separated cable system names (for cable stations): MAREA|Dunant'],
      ['Fill Color - Hex color #RRGGBB (default: #fff2cc)'],
      ['Stroke Color - Hex color #RRGGBB (default: #d6b656)'],
    ],
    nodes: {
      headers: [
        'Node Name', 'Node Code', 'Tags', 'Additional Tags',
        'Address', 'City', 'Postal Code', 'State', 'Country',
        'GPS Latitude', 'GPS Longitude', 'Container Name', 'Fill Color', 'Stroke Color'
      ],
      rows: includeData ? state.nodes.map(n => {
        const g = n.groupId ? findGroup(n.groupId) : null;
        return [
          n.name || '',
          n.code || '',
          (n.tags || []).join('|'),
          n.extraTags || '',
          n.address || '',
          n.city || '',
          n.postalCode || '',
          n.state || '',
          n.country || '',
          (n.gpsLat !== null && n.gpsLat !== undefined) ? n.gpsLat : '',
          (n.gpsLon !== null && n.gpsLon !== undefined) ? n.gpsLon : '',
          g?.title || '',
          n.fill || '',
          n.stroke || ''
        ];
      }) : [
        ['London DC', 'LON-DC1', 'default|production', 'Primary datacenter', '10 Downing St', 'London', 'SW1A 2AA', 'England', 'UK', '51.5074', '-0.1278', 'Europe', '', ''],
        ['Paris DC', 'PAR-DC1', 'default|production', '', '', 'Paris', '', 'Ile-de-France', 'France', '48.8566', '2.3522', 'Europe', '', ''],
        ['New York DC', 'NYC-DC1', 'default|production', 'Main US hub', '', 'New York', '10001', 'NY', 'USA', '40.7128', '-74.0060', 'North America', '', ''],
        ['Los Angeles DC', 'LAX-DC1', 'default|production', '', '', 'Los Angeles', '90001', 'CA', 'USA', '34.0522', '-118.2437', 'North America', '', ''],
        ['(Leave Fill/Stroke blank for defaults)', '', '', 'Fill default=#dae8fc, Stroke default=#6c8ebf', '', '', '', '', '', '', '', '', '#dae8fc', '#6c8ebf']
      ]
    },
    links: {
      headers: [
        'A-End Node', 'B-End Node', 'Link Tag', 'Link Code', 'Latency (ms)', 'Priority',
        'Design Max Capacity (Gbps)', 'Available 1G Units', 'Available 10G Units',
        'Available 100G Units', 'Available 400G Units', 'Available Tbps Units',
        'Cable System', 'Tags', 'Additional Tags', 'Line Color',
        'Lease NRC', 'Lease MRC', 'IRU Fee', 'IRU Term (years)', 'IRU O&M %', 'IRU O&M Annual Inc %',
        'Physical Routing Overlap (Link Codes)'
      ],
      rows: includeData ? state.edges.map(e => {
        const a = findNode(e.a);
        const b = findNode(e.b);
        const cs = e.cableSystemId ? state.cableSystems.find(c => c.id === e.cableSystemId) : null;
        // Get cost values - handle tiered pricing (use 10G tier as default for export)
        const nrc = getValueForTier(e.leaseNRC, '10G', 0);
        const mrc = getValueForTier(e.leaseMRC, '10G', 0);
        const iruFee = getValueForTier(e.iruFee, '10G', 0);
        return [
          a?.code || a?.name || '',
          b?.code || b?.name || '',
          e.tag || '',
          e.code || '',
          (typeof e.latencyMs === 'number' && isFinite(e.latencyMs)) ? e.latencyMs : '',
          (typeof e.priority === 'number' && isFinite(e.priority)) ? e.priority : 0,
          e.designCapacityGbps || 0,
          e.cap1G || 0,
          e.cap10G || 0,
          e.cap100G || 0,
          e.cap400G || 0,
          e.capTbps || 0,
          cs?.name || '',
          (e.filterTags || []).join('|'),
          e.extraTags || '',
          e.strokeColor || e.stroke || '',
          nrc || '',
          mrc || '',
          iruFee || '',
          e.iruTerm || '',
          e.iruOamPercent ?? '',
          e.iruOamAnnualIncrement ?? '',
          // Physical routing overlap - export as pipe-separated link codes
          (Array.isArray(e.routingOverlap) ? e.routingOverlap.map(ro => {
            const overlapEdge = state.edges.find(ed => ed.id === (ro.linkId || ro));
            return overlapEdge?.code || `Link-${ro.linkId || ro}`;
          }).join('|') : '')
        ];
      }) : [
        ['LON-DC1', 'PAR-DC1', 'London-Paris', 'CKT-EU-001', '10', '0', '400', '0', '0', '4', '0', '0', '', 'default|backbone', '', '', '0', '500', '10000', '15', '3', '2', 'CKT-TA-001'],
        ['LON-DC1', 'NYC-DC1', 'Transatlantic', 'CKT-TA-001', '70', '0', '800', '0', '0', '8', '0', '0', 'TAT-14', 'default|submarine', 'Main transatlantic link', '', '0', '2000', '50000', '20', '3', '2', 'CKT-EU-001'],
        ['NYC-DC1', 'LAX-DC1', 'US Cross-country', 'CKT-US-001', '60', '0', '400', '0', '0', '4', '0', '0', '', 'default|terrestrial', '', '', '0', '800', '20000', '15', '3', '2', ''],
        ['(Physical Routing Overlap: pipe-separated link codes sharing physical path)', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '#666666', '', '', '', '', '', '', '']
      ]
    },
    containers: {
      headers: [
        'Container Name', 'Type', 'Parent Container', 'Tags',
        'Facility Type', 'Organization', 'Address', 'City', 'Postal Code', 'State', 'Country', 'Continent',
        'GPS Latitude', 'GPS Longitude', 'Website', 'Cable Systems',
        'Fill Color', 'Stroke Color'
      ],
      rows: includeData ? state.groups.map(g => {
        const parent = g.parentId ? findGroup(g.parentId) : null;
        return [
          g.title || '',
          g.type || 'country',
          parent?.title || '',
          (g.filterTags || []).join('|'),
          g.dcFacilityType || 'datacenter',
          g.dcOrgName || '',
          g.dcAddress || '',
          g.dcCity || '',
          g.dcZipcode || '',
          g.dcState || '',
          g.dcCountry || '',
          g.dcRegion || '',
          (g.dcLatitude != null) ? g.dcLatitude : '',
          (g.dcLongitude != null) ? g.dcLongitude : '',
          g.dcWebsite || '',
          (g.dcCableSystems || []).join('|'),
          g.fill || '',
          g.stroke || ''
        ];
      }) : [
        ['Europe', 'region', '', 'default', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
        ['North America', 'region', '', 'default', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
        ['UK', 'country', 'Europe', 'default', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
        ['Equinix FR5', 'dc', 'Europe', 'default|Imported Datacenter', 'datacenter', 'Equinix', 'Kleyerstr. 90', 'Frankfurt', '60326', 'Hesse', 'Germany', 'Europe', '50.1047', '8.6378', 'https://equinix.com', '', '', ''],
        ['Bude CLS', 'dc', 'UK', 'default|Imported Cable Station', 'cable_station', '', '', 'Bude', '', 'Cornwall', 'UK', 'Europe', '50.8296', '-4.5432', '', 'TAT-14|Apollo|Hibernia Atlantic', '', ''],
        ['(Facility Type: datacenter, cable_station. Cable Systems: pipe-separated.)', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '#fff2cc', '#d6b656']
      ]
    },
    mlgs: {
      headers: [
        'MLG Name', 'MLG Code', 'Origin Node', 'Destination Node', 'Capacity Tier',
        'Topology Type', 'Total Latency (ms)', 'Total Links',
        'Path Links (pipe-separated codes)', 'Protection Links (pipe-separated codes)',
        'Override NRC', 'Override MRC', 'Override IRU Fee', 'IRU Term (years)',
        'Notes'
      ],
      rows: includeData ? state.multilinkGroups.map(mlg => {
        const origin = findNode(mlg.originNodeId);
        const dest = findNode(mlg.destinationNodeId);

        // Collect path and protection links
        const pathLinks = [];
        const protectionLinks = [];
        (mlg.segments || []).forEach(seg => {
          (seg.paths || []).forEach(path => {
            const linkCodes = (path.links || []).map(linkId => {
              const edge = state.edges.find(e => e.id === linkId);
              return edge?.code || `Link-${linkId}`;
            });
            if (path.type === 'primary' || path.type === 'working') {
              pathLinks.push(...linkCodes);
            } else {
              protectionLinks.push(...linkCodes);
            }
          });
        });

        return [
          mlg.name || '',
          mlg.code || '',
          origin?.code || origin?.name || '',
          dest?.code || dest?.name || '',
          mlg.capacityTier || '10G',
          mlg.topologyType || 'unprotected',
          mlg.totalLatency ?? '',
          mlg.totalLinks ?? '',
          pathLinks.join('|'),
          protectionLinks.join('|'),
          mlg.overrideLeaseNRC ?? '',
          mlg.overrideLeaseMRC ?? '',
          mlg.overrideIRUFee ?? '',
          mlg.iruTerm ?? '',
          mlg.notes || ''
        ];
      }) : [
        ['London-NYC Primary', 'MLG-001', 'LON-DC1', 'NYC-DC1', '10G', 'protected', '70', '1', 'CKT-TA-001', 'CKT-EU-001|CKT-US-001', '', '', '', '15', 'Main transatlantic service'],
        ['(MLG = Multilink Group / Protected Path)', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
      ]
    }
  };

  return data;
}

function downloadTemplateAsCSV(templateData, format) {
  // Use SheetJS to create multi-sheet workbook
  // Load SheetJS dynamically if not already loaded
  if (typeof XLSX === 'undefined') {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
    script.onload = () => createAndDownloadWorkbook(templateData, format);
    script.onerror = () => {
      showToast('âš ï¸ Could not load spreadsheet library. Downloading as CSV files instead.');
      downloadAsCSVFallback(templateData);
    };
    document.head.appendChild(script);
  } else {
    createAndDownloadWorkbook(templateData, format);
  }
}

function createAndDownloadWorkbook(templateData, format) {
  try {
    // Create workbook
    const wb = XLSX.utils.book_new();

    // 1. Instructions sheet
    const instructionsWS = XLSX.utils.aoa_to_sheet(templateData.instructions);
    // Style the header
    instructionsWS['!cols'] = [{ wch: 80 }]; // Wide column for instructions
    XLSX.utils.book_append_sheet(wb, instructionsWS, 'Instructions');

    // 2. Nodes sheet
    const nodesData = [templateData.nodes.headers, ...templateData.nodes.rows];
    const nodesWS = XLSX.utils.aoa_to_sheet(nodesData);
    // Set column widths
    nodesWS['!cols'] = templateData.nodes.headers.map(h => ({ wch: Math.max(12, h.length + 2) }));
    XLSX.utils.book_append_sheet(wb, nodesWS, 'Nodes');

    // 3. Links sheet
    const linksData = [templateData.links.headers, ...templateData.links.rows];
    const linksWS = XLSX.utils.aoa_to_sheet(linksData);
    linksWS['!cols'] = templateData.links.headers.map(h => ({ wch: Math.max(12, h.length + 2) }));
    XLSX.utils.book_append_sheet(wb, linksWS, 'Links');

    // 4. Containers sheet
    const containersData = [templateData.containers.headers, ...templateData.containers.rows];
    const containersWS = XLSX.utils.aoa_to_sheet(containersData);
    containersWS['!cols'] = templateData.containers.headers.map(h => ({ wch: Math.max(12, h.length + 2) }));
    XLSX.utils.book_append_sheet(wb, containersWS, 'Containers');

    // 5. MLGs sheet
    if (templateData.mlgs) {
      const mlgsData = [templateData.mlgs.headers, ...templateData.mlgs.rows];
      const mlgsWS = XLSX.utils.aoa_to_sheet(mlgsData);
      mlgsWS['!cols'] = templateData.mlgs.headers.map(h => ({ wch: Math.max(12, h.length + 2) }));
      XLSX.utils.book_append_sheet(wb, mlgsWS, 'MLGs');
    }

    // Generate file
    const fileExtension = format === 'ods' ? 'ods' : 'xlsx';
    const bookType = format === 'ods' ? 'ods' : 'xlsx';
    const fileName = `neximap_import_template.${fileExtension}`;

    // Write and download
    XLSX.writeFile(wb, fileName, { bookType: bookType });

    showToast(`âœ“ Template downloaded: ${fileName}`);
  } catch (err) {
    console.error('Error creating workbook:', err);
    showToast('âš ï¸ Error creating workbook. Downloading as CSV files instead.');
    downloadAsCSVFallback(templateData);
  }
}

function downloadAsCSVFallback(templateData) {
  const separator = ';';

  // Instructions
  downloadText('1_Instructions.csv', templateData.instructions.map(row => row.join(separator)).join('\r\n'), 'text/csv;charset=utf-8');

  // Nodes
  const nodesCsv = [templateData.nodes.headers.join(separator)];
  templateData.nodes.rows.forEach(row => nodesCsv.push(row.map(v => escapeCSV(v, separator)).join(separator)));
  downloadText('2_Nodes.csv', nodesCsv.join('\r\n'), 'text/csv;charset=utf-8');

  // Links
  const linksCsv = [templateData.links.headers.join(separator)];
  templateData.links.rows.forEach(row => linksCsv.push(row.map(v => escapeCSV(v, separator)).join(separator)));
  downloadText('3_Links.csv', linksCsv.join('\r\n'), 'text/csv;charset=utf-8');

  // Containers
  const containersCsv = [templateData.containers.headers.join(separator)];
  templateData.containers.rows.forEach(row => containersCsv.push(row.map(v => escapeCSV(v, separator)).join(separator)));
  downloadText('4_Containers.csv', containersCsv.join('\r\n'), 'text/csv;charset=utf-8');

  // MLGs
  if (templateData.mlgs) {
    const mlgsCsv = [templateData.mlgs.headers.join(separator)];
    templateData.mlgs.rows.forEach(row => mlgsCsv.push(row.map(v => escapeCSV(v, separator)).join(separator)));
    downloadText('5_MLGs.csv', mlgsCsv.join('\r\n'), 'text/csv;charset=utf-8');
  }

  showToast('âœ“ Template CSV files downloaded. Combine them in a spreadsheet app for multi-tab format.');
}

// Import from Spreadsheet
document.getElementById('btnImportProject')?.addEventListener('click', () => {
  showImportDialog();
});

function showImportDialog() {
  const modal = document.createElement('div');
  modal.id = 'importProjectModal';
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.5); z-index: 10000;
    display: flex; align-items: center; justify-content: center;
  `;

  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: white; border-radius: 8px; padding: 0;
    min-width: 550px; max-width: 650px; max-height: 85vh;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    display: flex; flex-direction: column;
  `;

  dialog.innerHTML = `
    <div style="padding: 16px 20px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center;">
      <span style="font-size: 16px; font-weight: 600; color: #333;">ðŸ“¥ Import from Spreadsheet</span>
      <button id="closeImportModal" style="background:none; border:none; font-size:20px; cursor:pointer; color:#666;">Ã—</button>
    </div>

    <div style="padding: 20px; overflow-y: auto; flex: 1;">
      <div style="background: #fef3c7; border: 1px solid #fcd34d; border-radius: 6px; padding: 12px; margin-bottom: 16px;">
        <div style="font-weight: 600; color: #92400e; margin-bottom: 4px;">âš ï¸ Import will modify your diagram</div>
        <div style="font-size: 12px; color: #92400e;">
          New nodes/links will be added. Existing items with matching Code/Name will be updated.
        </div>
      </div>

      <div style="margin-bottom: 16px;">
        <label style="font-weight: 600; font-size: 12px; color: #555; display: block; margin-bottom: 8px;">Import Mode</label>
        <div style="display: flex; gap: 12px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; flex: 1;">
            <input type="radio" name="importMode" value="merge" checked style="accent-color: #0096D6;" />
            <div>
              <div style="font-weight: 600; font-size: 12px;">Merge</div>
              <div style="font-size: 10px; color: #888;">Add new, update existing</div>
            </div>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 10px; border: 2px solid #e0e0e0; border-radius: 6px; flex: 1;">
            <input type="radio" name="importMode" value="replace" style="accent-color: #0096D6;" />
            <div>
              <div style="font-weight: 600; font-size: 12px;">Replace All</div>
              <div style="font-size: 10px; color: #888;">Clear diagram first</div>
            </div>
          </label>
        </div>
      </div>

      <div style="margin-bottom: 16px;">
        <label style="font-weight: 600; font-size: 12px; color: #555; display: block; margin-bottom: 8px;">Select File</label>

        <!-- Tabs for file type selection -->
        <div style="display: flex; border-bottom: 1px solid #e0e0e0; margin-bottom: 12px;">
          <button class="import-tab active" data-tab="workbook" style="padding: 8px 16px; border: none; background: none; font-size: 12px; cursor: pointer; border-bottom: 2px solid #0096D6; color: #0096D6; font-weight: 600;">
            ðŸ“Š Workbook (XLSX/ODS)
          </button>
          <button class="import-tab" data-tab="csv" style="padding: 8px 16px; border: none; background: none; font-size: 12px; cursor: pointer; border-bottom: 2px solid transparent; color: #666;">
            ðŸ“„ CSV Files
          </button>
        </div>

        <!-- Workbook import -->
        <div id="importTabWorkbook" class="import-tab-content">
          <div style="font-size: 11px; color: #666; margin-bottom: 8px;">
            Select an Excel (.xlsx) or OpenDocument (.ods) file with Nodes, Links, and Containers sheets
          </div>
          <div style="display: flex; align-items: center; gap: 8px;">
            <label style="width: 100px; font-size: 11px; font-weight: 500;">Workbook*:</label>
            <input type="file" id="importWorkbookFile" accept=".xlsx,.xls,.ods" style="flex: 1; font-size: 11px;" />
          </div>
          <div style="font-size: 10px; color: #888; margin-top: 6px;">
            Expected sheets: <strong>Nodes</strong>, <strong>Links</strong>, <strong>Containers</strong> (optional)
          </div>
        </div>

        <!-- CSV import -->
        <div id="importTabCSV" class="import-tab-content" style="display: none;">
          <div style="font-size: 11px; color: #666; margin-bottom: 8px;">
            Select separate CSV files for Nodes, Links, and optionally Containers
          </div>
          <div style="display: flex; flex-direction: column; gap: 8px;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <label style="width: 100px; font-size: 11px; font-weight: 500;">Nodes CSV*:</label>
              <input type="file" id="importNodesFile" accept=".csv,.txt" style="flex: 1; font-size: 11px;" />
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label style="width: 100px; font-size: 11px; font-weight: 500;">Links CSV*:</label>
              <input type="file" id="importLinksFile" accept=".csv,.txt" style="flex: 1; font-size: 11px;" />
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
              <label style="width: 100px; font-size: 11px; font-weight: 500; color: #888;">Containers:</label>
              <input type="file" id="importContainersFile" accept=".csv,.txt" style="flex: 1; font-size: 11px;" />
            </div>
          </div>

          <div style="margin-top: 12px;">
            <label style="font-weight: 500; font-size: 11px; color: #555; display: block; margin-bottom: 6px;">CSV Separator</label>
            <div style="display: flex; gap: 12px;">
              <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                <input type="radio" name="importSeparator" value=";" checked style="accent-color: #0096D6;" />
                <span style="font-size: 11px;">Semicolon (;)</span>
              </label>
              <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                <input type="radio" name="importSeparator" value="," style="accent-color: #0096D6;" />
                <span style="font-size: 11px;">Comma (,)</span>
              </label>
              <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                <input type="radio" name="importSeparator" value="\t" style="accent-color: #0096D6;" />
                <span style="font-size: 11px;">Tab</span>
              </label>
            </div>
          </div>
        </div>
      </div>

      <div id="importPreview" style="display: none; background: #f8fafc; border-radius: 6px; padding: 12px;">
        <div style="font-weight: 600; font-size: 11px; color: #555; margin-bottom: 8px;">Preview:</div>
        <div id="importPreviewContent" style="font-size: 11px; color: #666;"></div>
      </div>
    </div>

    <div style="padding: 12px 20px; border-top: 1px solid #e0e0e0; display: flex; justify-content: flex-end; gap: 10px;">
      <button id="importCancelBtn" style="padding: 8px 16px; font-size: 13px; cursor: pointer; background: #f0f0f0; border: 1px solid #ccc; border-radius: 4px;">Cancel</button>
      <button id="importPreviewBtn" style="padding: 8px 16px; font-size: 13px; cursor: pointer; background: #f0f9ff; border: 1px solid #0096D6; border-radius: 4px; color: #0096D6;">Preview</button>
      <button id="importExecuteBtn" style="padding: 8px 16px; font-size: 13px; cursor: pointer; background: #0096D6; border: 1px solid #0096D6; border-radius: 4px; color: white; font-weight: 500;" disabled>Import</button>
    </div>
  `;

  modal.appendChild(dialog);
  document.body.appendChild(modal);

  const closeModal = () => modal.remove();

  modal.querySelector('#closeImportModal').addEventListener('click', closeModal);
  modal.querySelector('#importCancelBtn').addEventListener('click', closeModal);
  modal.addEventListener('click', (ev) => { if (ev.target === modal) closeModal(); });

  // Tab switching
  modal.querySelectorAll('.import-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      modal.querySelectorAll('.import-tab').forEach(t => {
        t.classList.remove('active');
        t.style.borderBottomColor = 'transparent';
        t.style.color = '#666';
        t.style.fontWeight = 'normal';
      });
      tab.classList.add('active');
      tab.style.borderBottomColor = '#0096D6';
      tab.style.color = '#0096D6';
      tab.style.fontWeight = '600';

      const tabName = tab.dataset.tab;
      modal.querySelector('#importTabWorkbook').style.display = tabName === 'workbook' ? 'block' : 'none';
      modal.querySelector('#importTabCSV').style.display = tabName === 'csv' ? 'block' : 'none';

      // Reset preview
      modal.querySelector('#importPreview').style.display = 'none';
      modal.querySelector('#importExecuteBtn').disabled = true;
    });
  });

  // Preview button
  modal.querySelector('#importPreviewBtn').addEventListener('click', async () => {
    const activeTab = modal.querySelector('.import-tab.active').dataset.tab;

    if (activeTab === 'workbook') {
      const workbookFile = modal.querySelector('#importWorkbookFile').files[0];
      if (!workbookFile) {
        showToast('âš ï¸ Please select a workbook file (XLSX or ODS)');
        return;
      }

      try {
        // Load SheetJS if needed
        if (typeof XLSX === 'undefined') {
          showToast('â³ Loading spreadsheet library...');
          await loadSheetJS();
        }

        const workbookData = await parseWorkbookFile(workbookFile);

        const preview = modal.querySelector('#importPreview');
        const content = modal.querySelector('#importPreviewContent');

        content.innerHTML = `
          <div>ðŸ“¦ <strong>${workbookData.nodes?.rows?.length || 0}</strong> nodes found</div>
          <div>ðŸ”— <strong>${workbookData.links?.rows?.length || 0}</strong> links found</div>
          <div>ðŸ“ <strong>${workbookData.containers?.rows?.length || 0}</strong> containers found</div>
          <div style="margin-top: 8px; font-size: 10px; color: #888;">
            Sheets found: ${workbookData.sheetNames.join(', ')}
          </div>
        `;

        preview.style.display = 'block';
        modal.querySelector('#importExecuteBtn').disabled = false;

        // Store data for import
        modal.workbookData = workbookData;

      } catch (err) {
        showToast('âŒ Error parsing workbook: ' + err.message);
        console.error('Workbook parse error:', err);
      }
    } else {
      // CSV mode
      const nodesFile = modal.querySelector('#importNodesFile').files[0];
      const linksFile = modal.querySelector('#importLinksFile').files[0];

      if (!nodesFile || !linksFile) {
        showToast('âš ï¸ Please select both Nodes and Links CSV files');
        return;
      }

      const separator = modal.querySelector('input[name="importSeparator"]:checked').value;

      try {
        const nodesData = await parseCSVFile(nodesFile, separator);
        const linksData = await parseCSVFile(linksFile, separator);

        const preview = modal.querySelector('#importPreview');
        const content = modal.querySelector('#importPreviewContent');

        content.innerHTML = `
          <div>ðŸ“¦ <strong>${nodesData.rows.length}</strong> nodes found</div>
          <div>ðŸ”— <strong>${linksData.rows.length}</strong> links found</div>
          <div style="margin-top: 8px; font-size: 10px; color: #888;">
            Node columns: ${nodesData.headers.slice(0, 5).join(', ')}${nodesData.headers.length > 5 ? '...' : ''}
          </div>
        `;

        preview.style.display = 'block';
        modal.querySelector('#importExecuteBtn').disabled = false;

      } catch (err) {
        showToast('âŒ Error parsing files: ' + err.message);
      }
    }
  });

  // Import button
  modal.querySelector('#importExecuteBtn').addEventListener('click', async () => {
    const activeTab = modal.querySelector('.import-tab.active').dataset.tab;
    const mode = modal.querySelector('input[name="importMode"]:checked').value;

    closeModal();
    showToast('â³ Importing data...');

    try {
      if (activeTab === 'workbook' && modal.workbookData) {
        // Import from workbook data
        await executeImportFromData(modal.workbookData.nodes, modal.workbookData.links, modal.workbookData.containers, mode);
      } else {
        // Import from CSV files
        const nodesFile = modal.querySelector('#importNodesFile').files[0];
        const linksFile = modal.querySelector('#importLinksFile').files[0];
        const containersFile = modal.querySelector('#importContainersFile').files[0];
        const separator = modal.querySelector('input[name="importSeparator"]:checked').value;

        await executeImport(nodesFile, linksFile, containersFile, mode, separator);
      }
      showToast('âœ“ Import completed!');
    } catch (err) {
      showToast('âŒ Import error: ' + err.message);
      console.error('Import error:', err);
    }
  });
}

// Load SheetJS library dynamically
function loadSheetJS() {
  return new Promise((resolve, reject) => {
    if (typeof XLSX !== 'undefined') {
      resolve();
      return;
    }
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
    script.onload = resolve;
    script.onerror = () => reject(new Error('Failed to load spreadsheet library'));
    document.head.appendChild(script);
  });
}

// Parse XLSX/ODS workbook file
async function parseWorkbookFile(file) {
  const data = await file.arrayBuffer();
  const workbook = XLSX.read(data, { type: 'array' });

  const result = {
    sheetNames: workbook.SheetNames,
    nodes: null,
    links: null,
    containers: null
  };

  // Find sheets by name (case-insensitive)
  for (const sheetName of workbook.SheetNames) {
    const sheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });

    if (jsonData.length < 2) continue; // Need at least header + 1 row

    const headers = jsonData[0].map(h => String(h || '').trim());
    const rows = [];

    for (let i = 1; i < jsonData.length; i++) {
      const rowData = jsonData[i];
      if (!rowData || rowData.every(cell => cell === null || cell === undefined || cell === '')) continue;

      const row = {};
      headers.forEach((h, idx) => {
        row[h] = rowData[idx] !== undefined && rowData[idx] !== null ? String(rowData[idx]).trim() : '';
      });
      rows.push(row);
    }

    const sheetLower = sheetName.toLowerCase();
    if (sheetLower.includes('node')) {
      result.nodes = { headers, rows };
    } else if (sheetLower.includes('link')) {
      result.links = { headers, rows };
    } else if (sheetLower.includes('container')) {
      result.containers = { headers, rows };
    }
  }

  if (!result.nodes || !result.links) {
    throw new Error('Workbook must have "Nodes" and "Links" sheets');
  }

  return result;
}

// Import from pre-parsed data (for workbook import)
async function executeImportFromData(nodesData, linksData, containersData, mode) {
  // Reuse the same import logic but with pre-parsed data
  await executeImportWithData(nodesData, linksData, containersData, mode);
}

/**
 * Parse tags string supporting both "|" and "," as separators
 * Priority: "|" is checked first, then "," if no "|" found
 * @param {string} tagsStr - The tags string to parse
 * @returns {Array} Array of trimmed, non-empty tag strings
 */
function parseTagsString(tagsStr) {
  if (!tagsStr || typeof tagsStr !== 'string') return [];

  // Determine separator: use | if present, otherwise use ,
  const separator = tagsStr.includes('|') ? '|' : ',';
  return tagsStr.split(separator).map(t => t.trim()).filter(t => t);
}

async function parseCSVFile(file, separator) {
  const text = await file.text();
  const lines = text.split(/\r?\n/).filter(line => line.trim());

  if (lines.length === 0) {
    throw new Error('File is empty');
  }

  const headers = parseCSVLine(lines[0], separator);
  const rows = [];

  for (let i = 1; i < lines.length; i++) {
    const values = parseCSVLine(lines[i], separator);
    if (values.some(v => v.trim())) { // Skip empty rows
      const row = {};
      headers.forEach((h, idx) => {
        row[h.trim()] = values[idx]?.trim() || '';
      });
      rows.push(row);
    }
  }

  return { headers, rows };
}

function parseCSVLine(line, separator) {
  const result = [];
  let current = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    const nextChar = line[i + 1];

    if (inQuotes) {
      if (char === '"') {
        if (nextChar === '"') {
          current += '"';
          i++; // Skip next quote
        } else {
          inQuotes = false;
        }
      } else {
        current += char;
      }
    } else {
      if (char === '"') {
        inQuotes = true;
      } else if (char === separator) {
        result.push(current);
        current = '';
      } else {
        current += char;
      }
    }
  }

  result.push(current);
  return result;
}

async function executeImport(nodesFile, linksFile, containersFile, mode, separator) {
  // Parse files
  const nodesData = await parseCSVFile(nodesFile, separator);
  const linksData = await parseCSVFile(linksFile, separator);
  const containersData = containersFile ? await parseCSVFile(containersFile, separator) : null;

  await executeImportWithData(nodesData, linksData, containersData, mode);
}

async function executeImportWithData(nodesData, linksData, containersData, mode) {
  // Clear if replace mode
  if (mode === 'replace') {
    state.nodes = [];
    state.edges = [];
    state.groups = [];
    state.nextNode = 1;
    state.nextEdge = 1;
    state.nextGroup = 1;
  }

  // Build lookup maps for existing items
  const existingNodesByCode = new Map();
  const existingNodesByName = new Map();
  state.nodes.forEach(n => {
    if (n.code) existingNodesByCode.set(n.code.toLowerCase(), n);
    if (n.name) existingNodesByName.set(n.name.toLowerCase(), n);
  });

  const existingContainersByName = new Map();
  state.groups.forEach(g => {
    if (g.title) existingContainersByName.set(g.title.toLowerCase(), g);
  });

  // Import containers first (if provided)
  if (containersData) {
    for (const row of containersData.rows) {
      const name = row['Container Name'] || row['Name'];
      if (!name) continue;

      const existing = existingContainersByName.get(name.toLowerCase());

      if (existing) {
        // Update existing
        if (row['Type']) existing.type = row['Type'];
        if (row['Tags']) existing.filterTags = parseTagsString(row['Tags']);
        if (row['Fill Color']) existing.fill = row['Fill Color'];
        if (row['Stroke Color']) existing.stroke = row['Stroke Color'];
        // DC fields
        if (row['Facility Type']) existing.dcFacilityType = row['Facility Type'];
        if (row['Organization']) existing.dcOrgName = row['Organization'];
        if (row['Address']) existing.dcAddress = row['Address'];
        if (row['City']) existing.dcCity = row['City'];
        if (row['Postal Code']) existing.dcZipcode = row['Postal Code'];
        if (row['State']) existing.dcState = row['State'];
        if (row['Country']) existing.dcCountry = row['Country'];
        if (row['Continent']) existing.dcRegion = row['Continent'];
        if (row['GPS Latitude']) existing.dcLatitude = parseFloat(row['GPS Latitude']) || null;
        if (row['GPS Longitude']) existing.dcLongitude = parseFloat(row['GPS Longitude']) || null;
        if (row['Website']) existing.dcWebsite = row['Website'];
        if (row['Cable Systems']) existing.dcCableSystems = row['Cable Systems'].split('|').map(s => s.trim()).filter(Boolean);
      } else {
        // Create new
        const cType = row['Type'] || 'country';
        const isDC = cType === 'dc';
        const newGroup = {
          id: state.nextGroup++,
          uuid: generateUUID(),
          type: cType,
          title: name,
          x: 50,
          y: 50,
          w: isDC ? 280 : 300,
          h: isDC ? 200 : 200,
          filterTags: row['Tags'] ? parseTagsString(row['Tags']) : ['default'],
          fill: row['Fill Color'] || (isDC ? 'rgba(253, 242, 248, 0.95)' : '#fff2cc'),
          stroke: row['Stroke Color'] || (isDC ? '#ec4899' : '#d6b656'),
          titleColor: isDC ? '#831843' : '#333333',
          // DC fields
          dcOrgName: row['Organization'] || '',
          dcAddress: row['Address'] || '',
          dcCity: row['City'] || '',
          dcZipcode: row['Postal Code'] || '',
          dcState: row['State'] || '',
          dcCountry: row['Country'] || '',
          dcRegion: row['Continent'] || '',
          dcLatitude: row['GPS Latitude'] ? (parseFloat(row['GPS Latitude']) || null) : null,
          dcLongitude: row['GPS Longitude'] ? (parseFloat(row['GPS Longitude']) || null) : null,
          dcWebsite: row['Website'] || '',
          dcFacilityType: row['Facility Type'] || 'datacenter',
          dcCableSystems: row['Cable Systems'] ? row['Cable Systems'].split('|').map(s => s.trim()).filter(Boolean) : [],
          dcNetCount: 0,
          dcIxCount: 0,
          dcCarrierCount: 0,
          dcNetworks: []
        };
        state.groups.push(newGroup);
        existingContainersByName.set(name.toLowerCase(), newGroup);
      }
    }

    // Handle parent relationships
    for (const row of containersData.rows) {
      const name = row['Container Name'] || row['Name'];
      const parentName = row['Parent Container'] || row['Parent'];

      if (name && parentName) {
        const container = existingContainersByName.get(name.toLowerCase());
        const parent = existingContainersByName.get(parentName.toLowerCase());
        if (container && parent) {
          container.parentId = parent.id;
        }
      }
    }
  }

  // Import nodes
  const importedNodes = new Map(); // Track for linking

  // Calculate auto-layout bounds
  let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
  let hasGPS = false;

  // First pass: collect GPS data for layout
  for (const row of nodesData.rows) {
    let lat = parseFloat(row['GPS Latitude'] || row['Latitude']);
    let lon = parseFloat(row['GPS Longitude'] || row['Longitude']);

    // Try city lookup if no GPS
    if ((isNaN(lat) || isNaN(lon)) && row['City']) {
      const cityGPS = lookupCityGPS(row['City']);
      if (cityGPS) {
        lat = cityGPS.lat;
        lon = cityGPS.lon;
      }
    }

    if (!isNaN(lat) && !isNaN(lon)) {
      hasGPS = true;
      minLat = Math.min(minLat, lat);
      maxLat = Math.max(maxLat, lat);
      minLon = Math.min(minLon, lon);
      maxLon = Math.max(maxLon, lon);
    }
  }

  // Canvas bounds for auto-layout
  const canvasMargin = 100;
  const layoutWidth = state.canvasWidth - (2 * canvasMargin);
  const layoutHeight = state.canvasHeight - (2 * canvasMargin);

  let nodeIndex = 0;
  for (const row of nodesData.rows) {
    const name = row['Node Name'] || row['Name'];
    const code = row['Node Code'] || row['Code'];

    if (!name && !code) continue;

    // Find existing node
    let existing = null;
    if (code) existing = existingNodesByCode.get(code.toLowerCase());
    if (!existing && name) existing = existingNodesByName.get(name.toLowerCase());

    // Parse GPS
    let gpsLat = parseFloat(row['GPS Latitude'] || row['Latitude']);
    let gpsLon = parseFloat(row['GPS Longitude'] || row['Longitude']);

    // City lookup
    if ((isNaN(gpsLat) || isNaN(gpsLon)) && row['City']) {
      const cityGPS = lookupCityGPS(row['City']);
      if (cityGPS) {
        gpsLat = cityGPS.lat;
        gpsLon = cityGPS.lon;
      }
    }

    // Calculate canvas position
    let x, y;
    if (hasGPS && !isNaN(gpsLat) && !isNaN(gpsLon)) {
      // Geographic projection (simple Mercator-like)
      const lonRange = maxLon - minLon || 1;
      const latRange = maxLat - minLat || 1;
      x = canvasMargin + ((gpsLon - minLon) / lonRange) * layoutWidth;
      y = canvasMargin + ((maxLat - gpsLat) / latRange) * layoutHeight; // Flip Y for north-up
    } else {
      // Grid layout for nodes without GPS
      const cols = Math.ceil(Math.sqrt(nodesData.rows.length));
      const col = nodeIndex % cols;
      const rowNum = Math.floor(nodeIndex / cols);
      x = canvasMargin + (col + 0.5) * (layoutWidth / cols);
      y = canvasMargin + (rowNum + 0.5) * (layoutHeight / Math.ceil(nodesData.rows.length / cols));
    }

    // Find container
    let groupId = null;
    const containerName = row['Container Name'] || row['Container'];
    if (containerName) {
      const container = existingContainersByName.get(containerName.toLowerCase());
      if (container) groupId = container.id;
    }

    if (existing) {
      // Update existing node
      if (name) existing.name = name;
      if (code) existing.code = code;
      if (row['Tags']) existing.tags = parseTagsString(row['Tags']);
      if (row['Additional Tags']) existing.extraTags = row['Additional Tags'];
      if (row['Address']) existing.address = row['Address'];
      if (row['City']) existing.city = row['City'];
      if (row['Postal Code']) existing.postalCode = row['Postal Code'];
      if (row['State']) existing.state = row['State'];
      if (row['Country']) existing.country = row['Country'];
      if (!isNaN(gpsLat)) existing.gpsLat = gpsLat;
      if (!isNaN(gpsLon)) existing.gpsLon = gpsLon;
      if (groupId) existing.groupId = groupId;
      if (row['Fill Color']) existing.fill = row['Fill Color'];
      if (row['Stroke Color']) existing.stroke = row['Stroke Color'];

      importedNodes.set(code?.toLowerCase() || name?.toLowerCase(), existing);
    } else {
      // Create new node
      const newNode = {
        id: state.nextNode++,
        uuid: generateUUID(),
        name: name || '',
        code: code || '',
        x: x,
        y: y,
        r: 20,
        fill: row['Fill Color'] || '#dae8fc',
        stroke: row['Stroke Color'] || '#6c8ebf',
        tags: row['Tags'] ? parseTagsString(row['Tags']) : ['default'],
        extraTags: row['Additional Tags'] || '',
        address: row['Address'] || '',
        city: row['City'] || '',
        postalCode: row['Postal Code'] || '',
        state: row['State'] || '',
        country: row['Country'] || '',
        gpsLat: !isNaN(gpsLat) ? gpsLat : null,
        gpsLon: !isNaN(gpsLon) ? gpsLon : null,
        groupId: groupId
      };

      state.nodes.push(newNode);
      if (code) existingNodesByCode.set(code.toLowerCase(), newNode);
      if (name) existingNodesByName.set(name.toLowerCase(), newNode);
      importedNodes.set(code?.toLowerCase() || name?.toLowerCase(), newNode);
    }

    nodeIndex++;
  }

  // Import links
  for (const row of linksData.rows) {
    const aEnd = row['A-End Node'] || row['A-End'] || row['Source'];
    const bEnd = row['B-End Node'] || row['B-End'] || row['Target'];

    if (!aEnd || !bEnd) continue;

    // Find nodes by code or name
    let nodeA = existingNodesByCode.get(aEnd.toLowerCase()) || existingNodesByName.get(aEnd.toLowerCase());
    let nodeB = existingNodesByCode.get(bEnd.toLowerCase()) || existingNodesByName.get(bEnd.toLowerCase());

    if (!nodeA || !nodeB) {
      console.warn(`Link skipped: could not find nodes "${aEnd}" or "${bEnd}"`);
      continue;
    }

    // Check if edge already exists
    let existing = state.edges.find(e =>
      (e.a === nodeA.id && e.b === nodeB.id) || (e.a === nodeB.id && e.b === nodeA.id)
    );

    const latency = parseFloat(row['Latency (ms)'] || row['Latency']);
    const priority = parseFloat(row['Priority']);
    const designCap = parseFloat(row['Design Max Capacity (Gbps)'] || row['Design Capacity']);
    const cap1G = parseFloat(row['Available 1G Units'] || row['1G Units']);
    const cap10G = parseFloat(row['Available 10G Units'] || row['10G Units']);
    const cap100G = parseFloat(row['Available 100G Units'] || row['100G Units']);
    const cap400G = parseFloat(row['Available 400G Units'] || row['400G Units']);
    const capTbps = parseFloat(row['Available Tbps Units'] || row['Tbps Units']);

    // Cost fields
    const leaseNRC = parseFloat(row['Lease NRC'] || row['NRC']);
    const leaseMRC = parseFloat(row['Lease MRC'] || row['MRC']);
    const iruFee = parseFloat(row['IRU Fee'] || row['IRU']);
    const iruTerm = parseFloat(row['IRU Term (years)'] || row['IRU Term']);
    const iruOamPercent = parseFloat(row['IRU O&M %'] || row['O&M %']);
    const iruOamIncrement = parseFloat(row['IRU O&M Annual Inc %'] || row['O&M Inc %']);

    if (existing) {
      // Update existing edge
      if (row['Link Tag'] || row['Tag']) existing.tag = row['Link Tag'] || row['Tag'];
      if (row['Link Code'] || row['Code']) existing.code = row['Link Code'] || row['Code'];
      if (!isNaN(latency)) existing.latencyMs = latency;
      if (!isNaN(priority)) existing.priority = priority;
      if (!isNaN(designCap)) existing.designCapacityGbps = designCap;
      if (!isNaN(cap1G)) existing.cap1G = cap1G;
      if (!isNaN(cap10G)) existing.cap10G = cap10G;
      if (!isNaN(cap100G)) existing.cap100G = cap100G;
      if (!isNaN(cap400G)) existing.cap400G = cap400G;
      if (!isNaN(capTbps)) existing.capTbps = capTbps;
      // Cost fields - store as tiered pricing (apply to all tiers for simplicity on import)
      if (!isNaN(leaseNRC)) existing.leaseNRC = { '1G': leaseNRC, '10G': leaseNRC, '100G': leaseNRC, '400G': leaseNRC };
      if (!isNaN(leaseMRC)) existing.leaseMRC = { '1G': leaseMRC, '10G': leaseMRC, '100G': leaseMRC, '400G': leaseMRC };
      if (!isNaN(iruFee)) existing.iruFee = { '1G': iruFee, '10G': iruFee, '100G': iruFee, '400G': iruFee };
      if (!isNaN(iruTerm)) existing.iruTerm = iruTerm;
      if (!isNaN(iruOamPercent)) existing.iruOamPercent = iruOamPercent;
      if (!isNaN(iruOamIncrement)) existing.iruOamAnnualIncrement = iruOamIncrement;
      if (row['Tags']) existing.filterTags = parseTagsString(row['Tags']);
      if (row['Additional Tags']) existing.extraTags = row['Additional Tags'];
      if (row['Line Color']) existing.strokeColor = row['Line Color'];
    } else {
      // Create new edge
      const newEdge = {
        id: state.nextEdge++,
        uuid: generateUUID(),
        a: nodeA.id,
        b: nodeB.id,
        tag: row['Link Tag'] || row['Tag'] || '',
        code: row['Link Code'] || row['Code'] || '',
        latencyMs: !isNaN(latency) ? latency : null,
        priority: !isNaN(priority) ? priority : 0,
        designCapacityGbps: !isNaN(designCap) ? designCap : 0,
        cap1G: !isNaN(cap1G) ? cap1G : 0,
        cap10G: !isNaN(cap10G) ? cap10G : 0,
        cap100G: !isNaN(cap100G) ? cap100G : 0,
        cap400G: !isNaN(cap400G) ? cap400G : 0,
        capTbps: !isNaN(capTbps) ? capTbps : 0,
        // Cost fields
        leaseNRC: !isNaN(leaseNRC) ? { '1G': leaseNRC, '10G': leaseNRC, '100G': leaseNRC, '400G': leaseNRC } : { '1G': 0, '10G': 0, '100G': 0, '400G': 0 },
        leaseMRC: !isNaN(leaseMRC) ? { '1G': leaseMRC, '10G': leaseMRC, '100G': leaseMRC, '400G': leaseMRC } : { '1G': 1, '10G': 1, '100G': 1, '400G': 1 },
        iruFee: !isNaN(iruFee) ? { '1G': iruFee, '10G': iruFee, '100G': iruFee, '400G': iruFee } : { '1G': 1, '10G': 1, '100G': 1, '400G': 1 },
        iruTerm: !isNaN(iruTerm) ? iruTerm : 15,
        iruOamPercent: !isNaN(iruOamPercent) ? iruOamPercent : null,
        iruOamAnnualIncrement: !isNaN(iruOamIncrement) ? iruOamIncrement : null,
        filterTags: row['Tags'] ? parseTagsString(row['Tags']) : ['default'],
        extraTags: row['Additional Tags'] || '',
        strokeColor: row['Line Color'] || '#666666',
        strokeW: 2,
        style: 'straight'
      };

      state.edges.push(newEdge);
    }
  }

  // Commit and render
  commit();
  render();
}

// ============== END IMPORT TEMPLATE & PROJECT IMPORT ==============

  const NDG_FILETYPE = "NDG_PROJECT";
  const NDG_VERSION = 2;
  const LS_AUTOSAVE_KEY = "ndg_autosave_v2";
  const LS_LASTNAME_KEY = "ndg_last_filename_v2";
  const AUTOSAVE_INTERVAL_MS = 5000;

  function buildProjectObject() {
    return {
      fileType: NDG_FILETYPE,
      version: NDG_VERSION,
      savedAt: new Date().toISOString(),
      nodes: state.nodes,
      edges: state.edges,
      groups: state.groups,
      cableSystems: state.cableSystems,
      multilinkGroups: state.multilinkGroups,
      nextNode: state.nextNode,
      nextEdge: state.nextEdge,
      nextGroup: state.nextGroup,
      nextCableSystem: state.nextCableSystem,
      nextMultilinkGroup: state.nextMultilinkGroup,
      stylePresets: state.stylePresets,
      canvasWidth: state.canvasWidth,
      canvasHeight: state.canvasHeight,
      showCanvasBorder: state.showCanvasBorder,
      gridEnabled: state.gridEnabled,
      gridSize: state.gridSize,
      tagFilter: {
        mode: state.tagFilter.mode,
        selectedTags: Array.from(state.tagFilter.selectedTags)
      },
      cableSystemFilter: {
        mode: state.cableSystemFilter.mode,
        selectedSystems: Array.from(state.cableSystemFilter.selectedSystems),
        showUnmapped: state.cableSystemFilter.showUnmapped
      },
      nodeFilter: {
        mode: state.nodeFilter.mode,
        selectedNodes: Array.from(state.nodeFilter.selectedNodes),
        displayMode: state.nodeFilter.displayMode
      },
      containerFilter: {
        mode: state.containerFilter.mode,
        selectedBoxes: Array.from(state.containerFilter.selectedBoxes),
        selectedGroups: Array.from(state.containerFilter.selectedGroups)
      },
      ui: state.ui,
      viewSettings: state.viewSettings,
      financialSettings: state.financialSettings,
      pathfinderSettings: state.pathfinderSettings,
      defaultNodeStyle: state.defaultNodeStyle,
      defaultLinkStyle: state.defaultLinkStyle
    };
  }

  function sanitizeBaseName(name) {
    let trimmed = (name || "").trim();
    if (!trimmed) return null;

    // Remove leading dots (".", "..") to avoid browser/OS normalization to underscores
    trimmed = trimmed.replace(/^\.+/, "");

    // Replace invalid filename characters
    trimmed = trimmed.replace(/[<>:"/\\|?*\x00-\x1F]/g, "_");

    // Avoid empty or underscore-only names
    if (!trimmed || /^_+$/.test(trimmed)) return "project";

    return trimmed.slice(0, 80);
  }
  function getLastFilename() { return localStorage.getItem(LS_LASTNAME_KEY) || ""; }
  function setLastFilename(filename) { localStorage.setItem(LS_LASTNAME_KEY, filename); }

  // File System Access API support for true save-in-place
  let currentFileHandle = null;

  // Check if File System Access API is supported
  const hasFileSystemAccess = 'showSaveFilePicker' in window && 'showOpenFilePicker' in window;

  async function saveProject(forcePrompt) {
    const project = buildProjectObject();
    const jsonContent = JSON.stringify(project, null, 2);

    // If File System Access API is supported
    if (hasFileSystemAccess) {
      try {
        // If Save As requested OR no existing file handle, prompt for new location
        if (forcePrompt || !currentFileHandle) {
          const suggestedName = getLastFilename() || 'project.ndg';
          currentFileHandle = await window.showSaveFilePicker({
            suggestedName: suggestedName,
            types: [{
              description: 'NDG Project Files',
              accept: { 'application/x-ndg+json': ['.ndg'] }
            }]
          });
        }

        // Write to the file handle (overwrites existing content)
        const writable = await currentFileHandle.createWritable();
        await writable.write(jsonContent);
        await writable.close();

        // Update stored filename
        const filename = currentFileHandle.name;
        setLastFilename(filename);
        dirty = false;
        showToast(`Saved ${filename}`);

      } catch (err) {
        if (err.name === 'AbortError') {
          showToast('Save cancelled.');
        } else {
          console.error('Save error:', err);
          showToast('Save failed: ' + err.message);
        }
      }
    } else {
      // Fallback for browsers without File System Access API (Firefox, Safari)
      let filename = getLastFilename();
      if (forcePrompt || !filename) {
        const base = sanitizeBaseName(prompt("Save project as (without extension):", filename.replace(/\.ndg$/i, "") || "project"));
        if (!base) { showToast("Save cancelled."); return; }
        filename = base.toLowerCase().endsWith(".ndg") ? base : `${base}.ndg`;
        setLastFilename(filename);
      }
      downloadText(filename, jsonContent, "application/x-ndg+json");
      dirty = false;
      showToast(`Saved ${filename} (download)`);
    }
  }

  async function openProjectWithFilePicker() {
    if (hasFileSystemAccess) {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'NDG Project Files',
            accept: { 'application/x-ndg+json': ['.ndg'], 'application/json': ['.json'] }
          }],
          multiple: false
        });

        currentFileHandle = handle;
        const file = await handle.getFile();
        const text = await file.text();
        loadProjectObject(JSON.parse(text));
        setLastFilename(file.name);
        showToast(`Opened ${file.name}`);

      } catch (err) {
        if (err.name === 'AbortError') {
          // User cancelled - do nothing
        } else {
          console.error('Open error:', err);
          showToast('Open failed: ' + err.message);
        }
      }
    } else {
      // Fallback: trigger the hidden file input
      document.getElementById('fileLoad').click();
    }
  }


// Helper function to normalize tier-based pricing (handles both old single-value and new tier-based formats)
function normalizeTierPricing(value, defaultValue = 0) {
  if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
    // New format - already tier-based, ensure all tiers exist
    return {
      '1G': (typeof value['1G'] === 'number') ? value['1G'] : defaultValue,
      '10G': (typeof value['10G'] === 'number') ? value['10G'] : defaultValue,
      '100G': (typeof value['100G'] === 'number') ? value['100G'] : defaultValue,
      '400G': (typeof value['400G'] === 'number') ? value['400G'] : defaultValue
    };
  }
  // Old format - single value, apply to all tiers
  const v = (typeof value === 'number') ? value : defaultValue;
  return {
    '1G': v,
    '10G': v,
    '100G': v,
    '400G': v
  };
}

// Helper function to get value for a specific tier (handles both old and new formats)
function getValueForTier(field, tier, defaultValue = 0) {
  if (typeof field === 'object' && field !== null && !Array.isArray(field)) {
    return (typeof field[tier] === 'number') ? field[tier] : defaultValue;
  }
  // Legacy single value
  return (typeof field === 'number') ? field : defaultValue;
}

// Expose globally for use in other scripts
window.normalizeTierPricing = normalizeTierPricing;
window.getValueForTier = getValueForTier;

function loadProjectObject(obj) {
  if (!obj) throw new Error('Empty project');
  if (obj.fileType && obj.fileType !== 'NDG_PROJECT') throw new Error('Not an NDG project');

  const nn = Array.isArray(obj.nodes) ? obj.nodes : [];
  const ee = Array.isArray(obj.edges) ? obj.edges : [];
  const gg = Array.isArray(obj.groups) ? obj.groups : [];

  state.nodes = nn.map(n => ({
    id: n.id,
    x: n.x, y: n.y,
    shape: n.shape || 'circle',
    r: (typeof n.r === 'number') ? n.r : 24,
    strokeW: (typeof n.strokeW === 'number') ? n.strokeW : 2,
    address: n.address || '',
    city: n.city || '',
    postalCode: n.postalCode || '',
    county: n.county || '',
    state: n.state || '',
    country: n.country || '',
    // GPS coordinates (stored as decimal degrees)
    gpsLat: (typeof n.gpsLat === 'number') ? n.gpsLat : null,
    gpsLon: (typeof n.gpsLon === 'number') ? n.gpsLon : null,
    name: n.name || ('Node' + n.id),
    code: n.code || ('N-' + n.id),
    showCode: (n.showCode !== false),
    tags: Array.isArray(n.tags) ? n.tags : [],
    extraTags: n.extraTags || '',
    groupId: (typeof n.groupId === 'number') ? n.groupId : null,
    cableSystemIds: Array.isArray(n.cableSystemIds) ? n.cableSystemIds : [],  // Backward compatible
    fill: n.fill || '#1b2030',
    stroke: n.stroke || '#9fb3ff',
    nameColor: n.nameColor || '#eaeaea',
    tagColor: n.tagColor || '#b7c0df',
    nameFont: (typeof n.nameFont === 'number') ? n.nameFont : 13,
    tagFont: (typeof n.tagFont === 'number') ? n.tagFont : 11,
    nameDx: (typeof n.nameDx === 'number') ? n.nameDx : 0,
    nameDy: (typeof n.nameDy === 'number') ? n.nameDy : 0,
    tagDx: (typeof n.tagDx === 'number') ? n.tagDx : 0,
    tagDy: (typeof n.tagDy === 'number') ? n.tagDy : 0,
    uuid: n.uuid || generateUUID(),
    // Custom SVG shape data - embedded for library independence
    customSvg: n.customSvg || null,
    libraryShapeId: n.libraryShapeId || null,
    // Additional properties
    lineStyle: n.lineStyle || 'solid',
    showName: n.showName !== false,
    showTag: n.showTag !== false
  }));

  state.edges = ee.map(e => ({
    id: e.id,
    a: e.a, b: e.b,
    tag: e.tag || '',
    latencyMs: (typeof e.latencyMs === 'number') ? e.latencyMs : null,
    code: e.code || ('L-' + e.id),
    showCode: (e.showCode !== false),
    extraTags: e.extraTags || '',
    style: e.style || 'straight',
    route: e.route || 'hv',
    labelDx: (typeof e.labelDx === 'number') ? e.labelDx : 0,
    labelDy: (typeof e.labelDy === 'number') ? e.labelDy : 0,
    labelFont: (typeof e.labelFont === 'number') ? e.labelFont : 12,
    labelColor: e.labelColor || '#eaeaea',
    strokeW: (typeof e.strokeW === 'number') ? e.strokeW : 2,
    strokeColor: e.strokeColor || '#7f8aa6',
    capacity: e.capacity || 'Up to 10G WL',
    priority: (typeof e.priority === 'number') ? e.priority : 0,
    cableSystemId: (e.cableSystemId !== undefined) ? e.cableSystemId : null,  // Backward compatible
    routingOverlap: Array.isArray(e.routingOverlap) ? e.routingOverlap : [],  // Links sharing physical routing
    curveArch: (typeof e.curveArch === 'number') ? e.curveArch : 0.3,
    uuid: e.uuid || generateUUID(),
    filterTags: Array.isArray(e.filterTags) ? e.filterTags : ['default'],
    lineStyle: e.lineStyle || 'solid',
    // Additional label properties
    tagColor: e.tagColor || '#eaeaea',
    tagSize: (typeof e.tagSize === 'number') ? e.tagSize : 12,
    tagFont: e.tagFont || 'Arial',
    showLatency: e.showLatency !== false,
    showTag: e.showTag !== false,
    // Commercial Cost - Lease (tier-based pricing)
    leaseNRC: normalizeTierPricing(e.leaseNRC, 0),
    leaseMRC: normalizeTierPricing(e.leaseMRC, state.financialSettings?.defaultMRC || 1),
    // Commercial Cost - IRU (tier-based pricing)
    iruFee: normalizeTierPricing(e.iruFee, state.financialSettings?.defaultIRU || 1),
    iruTerm: (typeof e.iruTerm === 'number') ? e.iruTerm : (state.financialSettings?.defaultIRUTerm || 15),
    iruOamPercent: (typeof e.iruOamPercent === 'number') ? e.iruOamPercent : (state.financialSettings?.defaultOAM || 5),
    iruOamAnnualIncrement: (typeof e.iruOamAnnualIncrement === 'number') ? e.iruOamAnnualIncrement : 0,
    // Cost mode for pathfinding
    commercialCostMode: e.commercialCostMode || 'lease',
    // Cable geometry (unified field - migrate old pathGeometry for backward compatibility)
    cableGeometry: (e.cableGeometry && e.cableGeometry.type && e.cableGeometry.coordinates)
      ? e.cableGeometry
      : (Array.isArray(e.pathGeometry) && e.pathGeometry.length > 0)
        ? { type: 'LineString', coordinates: e.pathGeometry }
        : null,
    pathSource: e.pathSource || null
  }));

  // Load cable systems (backward compatible - empty array if not present)
  const cs = Array.isArray(obj.cableSystems) ? obj.cableSystems : [];
  state.cableSystems = cs.map(c => {
    // Parse rfsYear: prefer stored number, then try parsing rfs string, then null
    let rfsYear = null;
    if (typeof c.rfsYear === 'number') {
      rfsYear = c.rfsYear;
    } else if (c.rfs && typeof c.rfs === 'string') {
      const parsed = parseInt(c.rfs);
      if (!isNaN(parsed) && parsed > 1990 && parsed < 2100) rfsYear = parsed;
    }

    return {
    id: c.id,
    uuid: c.uuid || generateUUID(),
    shortName: c.shortName || `CS${c.id}`,
    name: c.name || `Cable System ${c.id}`,
    type: c.type || 'wet',
    rfsYear: rfsYear,
    rfs: c.rfs || '',
    fiberPairs: (typeof c.fiberPairs === 'number') ? c.fiberPairs : 1,
    status: c.status || 'planned',
    capacityTbps: (typeof c.capacityTbps === 'number') ? c.capacityTbps : 0,
    owners: c.owners || '',
    notes: c.notes || '',
    filterTags: Array.isArray(c.filterTags) ? c.filterTags : ['default'],
    // Restore additional metadata fields
    region: c.region || '',
    color: c.color || '#0077b6',
    length_km: c.length_km || null,
    url: c.url || null,
    geometry: c.geometry || null,
    source: c.source || '',
    description: c.description || '',
    // Restore FiberAtlantic fields
    fiberAtlanticId: c.fiberAtlanticId || null,
    fiberAtlanticName: c.fiberAtlanticName || null,
    fiberAtlanticConfidence: c.fiberAtlanticConfidence || null,
    faLiveStatus: c.faLiveStatus || null
  };
  });

  // Data migration: fix cables with incorrect rfsYear/status from older saves
  // If a cable has faLiveStatus='online'/'outage' or status looks operational but rfsYear is wrong, fix it
  const migrationYear = new Date().getFullYear();
  state.cableSystems.forEach(csItem => {
    // Ensure rfsYear is populated from rfs string if missing
    if (!csItem.rfsYear && csItem.rfs && typeof csItem.rfs === 'string') {
      const parsed = parseInt(csItem.rfs);
      if (!isNaN(parsed) && parsed > 1990 && parsed < 2100) {
        csItem.rfsYear = parsed;
      }
    }

    // If FA says it's online, has an outage, or is active â€” it's clearly operational
    // (an outage means it WAS in service, so status should be operational)
    const faStatus = (csItem.faLiveStatus || '').toLowerCase();
    if (faStatus === 'online' || faStatus === 'outage' || faStatus === 'active' || faStatus === 'out' || faStatus === 'up') {
      if (csItem.status !== 'operational') {
        csItem.status = 'operational';
      }
    }
    // If status is 'planned' but rfsYear is in the past, the cable is already in service (or decommissioned if 20+ years)
    if (csItem.status === 'planned' && csItem.rfsYear && csItem.rfsYear <= migrationYear) {
      if ((migrationYear - csItem.rfsYear) >= 20) {
        csItem.status = 'decommissioned';
      } else {
        csItem.status = 'operational';
      }
    }
    // If status is 'planned' but rfsYear is within 2 years, mark as under-construction
    if (csItem.status === 'planned' && csItem.rfsYear && csItem.rfsYear > migrationYear && csItem.rfsYear <= migrationYear + 2) {
      csItem.status = 'under-construction';
    }
    // If status is 'operational' but rfsYear is in the future, rfsYear was guessed wrong â€” clear it
    if (csItem.status === 'operational' && csItem.rfsYear && csItem.rfsYear > migrationYear) {
      csItem.rfsYear = null;
    }
  });

  // Load multilink groups (backward compatible - empty array if not present)
  const mlgs = Array.isArray(obj.multilinkGroups) ? obj.multilinkGroups : [];
  state.multilinkGroups = mlgs.map(mlg => ({
    id: mlg.id,
    name: mlg.name || `MLG${mlg.id}`,
    type: mlg.type || 'linear',
    segments: Array.isArray(mlg.segments) ? mlg.segments.map(seg => ({
      id: seg.id,
      fromNode: seg.fromNode,
      toNode: seg.toNode,
      paths: Array.isArray(seg.paths) ? seg.paths.map(p => ({
        id: p.id,
        type: p.type || 'primary',
        links: Array.isArray(p.links) ? p.links : [],
        latency: (typeof p.latency === 'number') ? p.latency : 0
      })) : [],
      latency: (typeof seg.latency === 'number') ? seg.latency : 0,
      isDiverse: seg.isDiverse !== false,
      diversityWarning: seg.diversityWarning || null
    })) : [],
    originNode: mlg.originNode || null,
    destinationNode: mlg.destinationNode || null,
    totalLatency: (typeof mlg.totalLatency === 'number') ? mlg.totalLatency : 0,
    isDiverse: mlg.isDiverse !== false,
    diversityWarning: mlg.diversityWarning || null,
    warnings: Array.isArray(mlg.warnings) ? mlg.warnings : [],
    tags: Array.isArray(mlg.tags) ? mlg.tags : [],
    color: mlg.color || '#f59e0b',
    description: mlg.description || '',
    created: mlg.created || new Date().toISOString(),
    modified: mlg.modified || new Date().toISOString(),
    // Phase 1 fields: source tracking
    source: mlg.source || 'manual',
    // Phase 1 fields: calculated capacity (MIN cascade)
    calcCap1G: (typeof mlg.calcCap1G === 'number') ? mlg.calcCap1G : 0,
    calcCap10G: (typeof mlg.calcCap10G === 'number') ? mlg.calcCap10G : 0,
    calcCap100G: (typeof mlg.calcCap100G === 'number') ? mlg.calcCap100G : 0,
    calcCap400G: (typeof mlg.calcCap400G === 'number') ? mlg.calcCap400G : 0,
    calcCapTbps: (typeof mlg.calcCapTbps === 'number') ? mlg.calcCapTbps : 0,
    // Phase 1 fields: user override capacity (prevails when not null)
    overrideCap1G: mlg.overrideCap1G ?? null,
    overrideCap10G: mlg.overrideCap10G ?? null,
    overrideCap100G: mlg.overrideCap100G ?? null,
    overrideCap400G: mlg.overrideCap400G ?? null,
    overrideCapTbps: mlg.overrideCapTbps ?? null,
    // Commercial Cost fields - calculated sums from member links
    calcLeaseNRC: (typeof mlg.calcLeaseNRC === 'number') ? mlg.calcLeaseNRC : 0,
    calcLeaseMRC: (typeof mlg.calcLeaseMRC === 'number') ? mlg.calcLeaseMRC : 0,
    calcIRUFee: (typeof mlg.calcIRUFee === 'number') ? mlg.calcIRUFee : 0,
    calcIRUOAM: (typeof mlg.calcIRUOAM === 'number') ? mlg.calcIRUOAM : 0,
    // Commercial Cost fields - user overrides (null = use calculated)
    overrideLeaseNRC: mlg.overrideLeaseNRC ?? null,
    overrideLeaseMRC: mlg.overrideLeaseMRC ?? null,
    overrideIRUFee: mlg.overrideIRUFee ?? null,
    overrideIRUOAM: mlg.overrideIRUOAM ?? null,
    // IRU terms (user-specified for MLG)
    iruTerm: (typeof mlg.iruTerm === 'number') ? mlg.iruTerm : 15,
    iruOamAnnualIncrement: (typeof mlg.iruOamAnnualIncrement === 'number') ? mlg.iruOamAnnualIncrement : 0,
    // Cost mode for pathfinding
    commercialCostMode: mlg.commercialCostMode || 'lease'
  }));

  state.groups = gg.map(g => {
    // Get tier multipliers for default calculation
    const tierMults = state.financialSettings?.tierMultipliers || { '10G': 2.5, '100G': 6.25, '400G': 15.625 };
    const defaultNRC = state.financialSettings?.containerDefaultNRC || 0;
    const defaultMRC = state.financialSettings?.containerDefaultMRC || 1;
    const defaultIRU = state.financialSettings?.containerDefaultIRU || 1;

    // Initialize default tier pricing if not present
    const defaultLeaseNRC = {
      '1G': defaultNRC,
      '10G': Math.round(defaultNRC * tierMults['10G'] * 100) / 100,
      '100G': Math.round(defaultNRC * tierMults['100G'] * 100) / 100,
      '400G': Math.round(defaultNRC * tierMults['400G'] * 100) / 100
    };
    const defaultLeaseMRC = {
      '1G': defaultMRC,
      '10G': Math.round(defaultMRC * tierMults['10G'] * 100) / 100,
      '100G': Math.round(defaultMRC * tierMults['100G'] * 100) / 100,
      '400G': Math.round(defaultMRC * tierMults['400G'] * 100) / 100
    };
    const defaultIruFee = {
      '1G': defaultIRU,
      '10G': Math.round(defaultIRU * tierMults['10G'] * 100) / 100,
      '100G': Math.round(defaultIRU * tierMults['100G'] * 100) / 100,
      '400G': Math.round(defaultIRU * tierMults['400G'] * 100) / 100
    };

    return {
      id: g.id,
      type: g.type || 'country',
      parentId: g.parentId ?? null,
      x: g.x, y: g.y, w: g.w, h: g.h,
      title: g.title || ((g.type==='region') ? ('Group' + g.id) : 'Container'),
      extraTags: g.extraTags || '',
      fill: g.fill || (g.type==='region' ? 'rgba(120, 140, 180, 0.10)' : 'rgba(54, 76, 140, 0.12)'),
      stroke: g.stroke || (g.type==='region' ? '#7f8aa6' : '#6073b8'),
      strokeW: (typeof g.strokeW === 'number') ? g.strokeW : 2,
      titleColor: g.titleColor || '#eaeaea',
      titleFont: (typeof g.titleFont === 'number') ? g.titleFont : (g.type==='region' ? 15 : 14),
      titleDx: (typeof g.titleDx === 'number') ? g.titleDx : 0,
      titleDy: (typeof g.titleDy === 'number') ? g.titleDy : 0,
      // Shape container properties - embedded shape data for library independence
      shapeContainer: g.shapeContainer || false,
      decorativeShape: g.decorativeShape ? {
        id: g.decorativeShape.id,
        svgData: g.decorativeShape.svgData,
        pathData: g.decorativeShape.pathData,
        viewBox: g.decorativeShape.viewBox,
        name: g.decorativeShape.name,
        aspectRatio: g.decorativeShape.aspectRatio
      } : null,
      // Additional properties
      filterTags: Array.isArray(g.filterTags) ? g.filterTags : ['default'],
      showTitle: g.showTitle !== false,
      lineStyle: g.lineStyle || 'solid',
      transitLatency: (typeof g.transitLatency === 'number') ? g.transitLatency : null,
      // Commercial cost properties - use saved values or defaults
      leaseNRC: g.leaseNRC || defaultLeaseNRC,
      leaseMRC: g.leaseMRC || defaultLeaseMRC,
      iruFee: g.iruFee || defaultIruFee,
      iruTerm: (typeof g.iruTerm === 'number') ? g.iruTerm : (state.financialSettings?.containerDefaultIRUTerm || 15),
      iruOamPercent: (typeof g.iruOamPercent === 'number') ? g.iruOamPercent : (state.financialSettings?.containerDefaultOAM || 3),
      iruOamAnnualIncrement: (typeof g.iruOamAnnualIncrement === 'number') ? g.iruOamAnnualIncrement : (state.financialSettings?.containerDefaultOAMIncrement || 2),
      commercialCostMode: g.commercialCostMode || 'lease',
      commercialCostOverride: g.commercialCostOverride || false,
      // UUID
      uuid: g.uuid || generateUUID(),
      // Datacenter-specific properties
      dcPeeringDbId: g.dcPeeringDbId ?? null,
      dcOrgName: g.dcOrgName || '',
      dcAddress: g.dcAddress || '',
      dcCity: g.dcCity || '',
      dcCountry: g.dcCountry || '',
      dcState: g.dcState || '',
      dcZipcode: g.dcZipcode || '',
      dcLatitude: (typeof g.dcLatitude === 'number') ? g.dcLatitude : null,
      dcLongitude: (typeof g.dcLongitude === 'number') ? g.dcLongitude : null,
      dcWebsite: g.dcWebsite || '',
      dcRegion: g.dcRegion || '',
      dcNetCount: (typeof g.dcNetCount === 'number') ? g.dcNetCount : 0,
      dcIxCount: (typeof g.dcIxCount === 'number') ? g.dcIxCount : 0,
      dcCarrierCount: (typeof g.dcCarrierCount === 'number') ? g.dcCarrierCount : 0,
      dcNetworks: Array.isArray(g.dcNetworks) ? g.dcNetworks : [],
      dcFacilityType: g.dcFacilityType || 'datacenter',
      dcCableSystems: Array.isArray(g.dcCableSystems) ? g.dcCableSystems : []
    };
  });

  state.nextNode = (typeof obj.nextNode === 'number') ? obj.nextNode : (Math.max(0, ...state.nodes.map(n=>n.id)) + 1);
  state.nextEdge = (typeof obj.nextEdge === 'number') ? obj.nextEdge : (Math.max(0, ...state.edges.map(e=>e.id)) + 1);
  state.nextGroup = (typeof obj.nextGroup === 'number') ? obj.nextGroup : (Math.max(0, ...state.groups.map(g=>g.id)) + 1);
  state.nextCableSystem = (typeof obj.nextCableSystem === 'number') ? obj.nextCableSystem : (Math.max(0, ...state.cableSystems.map(cs=>cs.id)) + 1);
  // Filter out string IDs (like "mlg_123") when calculating next numeric ID
  state.nextMultilinkGroup = (typeof obj.nextMultilinkGroup === 'number') ? obj.nextMultilinkGroup : (Math.max(0, ...state.multilinkGroups.filter(mlg => typeof mlg.id === 'number').map(mlg=>mlg.id)) + 1);

  // Restore canvas dimensions
  if (typeof obj.canvasWidth === 'number') state.canvasWidth = obj.canvasWidth;
  if (typeof obj.canvasHeight === 'number') state.canvasHeight = obj.canvasHeight;
  if (typeof obj.showCanvasBorder === 'boolean') state.showCanvasBorder = obj.showCanvasBorder;

  // Restore grid settings
  if (typeof obj.gridEnabled === 'boolean') state.gridEnabled = obj.gridEnabled;
  if (typeof obj.gridSize === 'number') state.gridSize = obj.gridSize;
  // Update grid UI
  const gridEnabledCb = document.getElementById('gridEnabled');
  const btnGridToggle = document.getElementById('btnGridToggle');
  const gridMenu = document.getElementById('gridMenu');
  if (gridEnabledCb) gridEnabledCb.checked = state.gridEnabled;
  if (btnGridToggle) btnGridToggle.classList.toggle('active', state.gridEnabled);
  if (gridMenu) {
    gridMenu.querySelectorAll('.grid-size').forEach(item => {
      item.classList.toggle('active', parseInt(item.dataset.size) === state.gridSize);
    });
  }

  // Restore tag filter settings
  if (obj.tagFilter) {
    state.tagFilter.mode = obj.tagFilter.mode || 'all';
    state.tagFilter.selectedTags = new Set(obj.tagFilter.selectedTags || []);
  } else {
    state.tagFilter.mode = 'all';
    state.tagFilter.selectedTags = new Set();
  }
  // Update tag filter UI
  const tagFilterAccordionLoad = document.getElementById('tagFilterAccordion');
  if (tagFilterAccordionLoad) {
    const modeRadio = tagFilterAccordionLoad.querySelector(`input[name="filterMode"][value="${state.tagFilter.mode}"]`);
    if (modeRadio) modeRadio.checked = true;
  }
  // Update unified filter button badge
  if (typeof updateFilterButtonState === 'function') {
    updateFilterButtonState();
  }

  // Restore UI settings
  if (obj.ui) {
    state.ui = { ...state.ui, ...obj.ui };
  }

  // Restore per-view label settings
  if (obj.viewSettings) {
    state.viewSettings = { ...state.viewSettings, ...obj.viewSettings };
  }

  // Restore financial settings
  if (obj.financialSettings) {
    state.financialSettings = { ...state.financialSettings, ...obj.financialSettings };
  }

  // Restore pathfinder settings
  if (obj.pathfinderSettings) {
    state.pathfinderSettings = { ...state.pathfinderSettings, ...obj.pathfinderSettings };
  }

  // Restore default node style
  if (obj.defaultNodeStyle) {
    state.defaultNodeStyle = { ...state.defaultNodeStyle, ...obj.defaultNodeStyle };
    // Sync defaultNodeShape
    state.defaultNodeShape = state.defaultNodeStyle.shape || 'circle';
  }

  // Restore default link style
  if (obj.defaultLinkStyle) {
    state.defaultLinkStyle = { ...state.defaultLinkStyle, ...obj.defaultLinkStyle };
  }

  // Sync UI toggles
  const tglShowNodeTags = document.getElementById('tglShowNodeTags');
  const tglShowExtraTags = document.getElementById('tglShowExtraTags');
  const tglShowLatency = document.getElementById('tglShowLatency');
  const tglShowNodeCode = document.getElementById('tglShowNodeCode');
  const tglShowLinkCode = document.getElementById('tglShowLinkCode');
  const tglShowNodeName = document.getElementById('tglShowNodeName');
  const tglShowLinkTag = document.getElementById('tglShowLinkTag');
  const tglShowContainerTitle = document.getElementById('tglShowContainerTitle');
  if (tglShowLatency) tglShowLatency.checked = !!state.ui.showLatency;
  if (tglShowNodeCode) tglShowNodeCode.checked = !!state.ui.showNodeCode;
  if (tglShowLinkCode) tglShowLinkCode.checked = !!state.ui.showLinkCode;
  if (tglShowNodeTags) tglShowNodeTags.checked = !!state.ui.showNodeTags;
  if (tglShowExtraTags) tglShowExtraTags.checked = !!state.ui.showExtraTags;
  if (tglShowNodeName) tglShowNodeName.checked = state.ui.showNodeName !== false;
  if (tglShowLinkTag) tglShowLinkTag.checked = state.ui.showLinkTag !== false;
  if (tglShowContainerTitle) tglShowContainerTitle.checked = state.ui.showContainerTitle !== false;

  svg.setAttribute('viewBox', `0 0 ${state.canvasWidth} ${state.canvasHeight}`);

  // Restore style presets
  state.stylePresets = obj.stylePresets || { node:{}, edge:{}, group:{} };

  // Clear transient state
  state.selected = null;
  state.connectFrom = null;
  state.dragging = null;
  state.resizingGroup = null;
  state.resizingNode = null;
  state.placingGroup = false;
  state.placingGroupType = 'country';
  state.styleBrush = null;
  clearSelection();

  // CRITICAL: Refresh all memberships
  refreshAllMemberships();

  // Recalculate MLG capacities after load (in case link capacities have changed)
  if (typeof recalculateAllMLGCapacities === 'function') {
    recalculateAllMLGCapacities();
  }

  // Reset history
  history.stack = [];
  history.index = -1;
  pushHistory();

  // Sync UI toggles
  syncGlobalToggles();

  // Render and update UI
  render();
  updateCableNavigatorList();
  dirty = false;
}


  function autosaveNow() {
    try {
      localStorage.setItem(LS_AUTOSAVE_KEY, JSON.stringify(buildProjectObject()));
      dirty = false;
    } catch (e) { console.warn("Autosave failed:", e); }
  }
  setInterval(() => { if (dirty) autosaveNow(); }, AUTOSAVE_INTERVAL_MS);

  function recoverAutosave() {
    const raw = localStorage.getItem(LS_AUTOSAVE_KEY);
    if (!raw) { showToast("No autosave found."); return; }
    try { loadProjectObject(JSON.parse(raw)); showToast("Recovered autosave."); }
    catch (e) { showToast("Autosave recovery failed: " + e.message); }
  }
  function clearAutosave() { localStorage.removeItem(LS_AUTOSAVE_KEY); showToast("Autosave cleared."); }

  document.getElementById('fileLoad').addEventListener('change', async (ev) => {
    const f = ev.target.files?.[0];
    if (!f) return;
    try {
      const text = await f.text();
      loadProjectObject(JSON.parse(text));
      setLastFilename(f.name);
      // Clear file handle since we can't save back to this file via fallback method
      currentFileHandle = null;
      showToast(`Opened ${f.name}`);
    } catch (e) {
      showToast('Open failed: ' + e.message);
    } finally {
      ev.target.value = '';
    }
  });

  function clearDiagram() {
    state.nodes=[]; state.edges=[]; state.groups=[];
    state.nextNode=1; state.nextEdge=1; state.nextGroup=1;
    state.selected=null; state.connectFrom=null; state.placingGroup=false; state.placingGroupType='country';
    state.selection.nodes.clear(); state.selection.edges.clear(); state.selection.groups.clear();
    history.stack=[]; history.index=-1; pushHistory();
    // Clear file handle so next save prompts for new location
    currentFileHandle = null;
    setLastFilename('');
    commit(); render();
    showToast('Cleared.');
  }

  function newDiagram() {
    if (dirty && !confirm('You have unsaved changes. Create a new diagram anyway?')) {
      return;
    }
    clearDiagram();
    showToast('New diagram created.');
  }

  // (legacy button)
  document.getElementById('btnClear')?.addEventListener('click', () => { clearDiagram(); });
  (function autosaveStartupHint(){
    const raw = localStorage.getItem(LS_AUTOSAVE_KEY);
    if (raw) showToast("Autosave available â€” click â€œRecover Autosaveâ€ if needed.");
  })();

  // Inspector panel controls (draggable, minimizable, closeable)
  const inspector = document.getElementById('inspector');
  const inspectorHeader = document.getElementById('inspectorHeader');
  const btnMinimizeInspector = document.getElementById('btnMinimizeInspector');
  const btnCloseInspector = document.getElementById('btnCloseInspector');
  const btnToggleInspector = document.getElementById('btnToggleInspector');

  let inspectorDragging = false;
  let inspectorDragOffset = { x: 0, y: 0 };
  let inspectorMinimized = false;

  // Toggle inspector from header button
  if (btnToggleInspector) {
    btnToggleInspector.addEventListener('click', () => {
      if (inspector.style.display === 'none') {
        inspector.style.display = 'flex';
        btnToggleInspector.classList.add('primary');
      } else {
        inspector.style.display = 'none';
        btnToggleInspector.classList.remove('primary');
      }
    });
  }

  // Make inspector draggable
  inspectorHeader.addEventListener('mousedown', (ev) => {
    if (ev.target.tagName === 'BUTTON' || ev.target.closest('button')) return;
    inspectorDragging = true;
    const rect = inspector.getBoundingClientRect();
    inspectorDragOffset.x = ev.clientX - rect.left;
    inspectorDragOffset.y = ev.clientY - rect.top;
    inspector.style.cursor = 'grabbing';
    ev.preventDefault();
  });

  window.addEventListener('mousemove', (ev) => {
    if (!inspectorDragging) return;
    const layout = document.getElementById('layout');
    const layoutRect = layout.getBoundingClientRect();

    let newLeft = ev.clientX - layoutRect.left - inspectorDragOffset.x;
    let newTop = ev.clientY - layoutRect.top - inspectorDragOffset.y;

    // Keep inspector within bounds
    const maxLeft = layoutRect.width - inspector.offsetWidth;
    const maxTop = layoutRect.height - 44; // At least show header

    newLeft = Math.max(0, Math.min(newLeft, maxLeft));
    newTop = Math.max(0, Math.min(newTop, maxTop));

    inspector.style.left = newLeft + 'px';
    inspector.style.top = newTop + 'px';
    inspector.style.right = 'auto'; // Remove right positioning
  });

  window.addEventListener('mouseup', () => {
    if (inspectorDragging) {
      inspectorDragging = false;
      inspector.style.cursor = '';
    }
  });

  // Minimize/Maximize toggle
  btnMinimizeInspector.addEventListener('click', () => {
    inspectorMinimized = !inspectorMinimized;
    inspector.classList.toggle('minimized', inspectorMinimized);
    btnMinimizeInspector.textContent = inspectorMinimized ? '+' : 'âˆ’';
    btnMinimizeInspector.title = inspectorMinimized ? 'Maximize' : 'Minimize';
  });

  // Close inspector
  btnCloseInspector.addEventListener('click', () => {
    inspector.style.display = 'none';
    if (btnToggleInspector) btnToggleInspector.classList.remove('primary');
    showToast('Inspector hidden. Press "I" to show it again.');
  });

  // Keyboard shortcut to toggle inspector visibility
  window.addEventListener('keydown', (ev) => {
    if (ev.key.toLowerCase() === 'i' && !['INPUT','TEXTAREA'].includes(document.activeElement.tagName)) {
      if (inspector.style.display === 'none') {
        inspector.style.display = 'flex';
        if (btnToggleInspector) btnToggleInspector.classList.add('primary');
        showToast('Inspector shown.');
      } else {
        inspector.style.display = 'none';
        if (btnToggleInspector) btnToggleInspector.classList.remove('primary');
        showToast('Inspector hidden. Press "I" to show it again.');
      }
    }
  });

  refreshPresetSelects();
  syncGlobalToggles();
  pushHistory();
  updateViewBox(); // Initialize pan and zoom
  render();

  // Initialize color pickers with palette
  const colorInputs = [
    'nodeFill', 'nodeStroke', 'nodeNameColor', 'nodeTagColor',
    'edgeStrokeColor', 'edgeLabelColor',
    'groupFill', 'groupStroke', 'groupTitleColor'
  ];
  const colorPickers = {};
  colorInputs.forEach(id => {
    const input = document.getElementById(id);
    if (input && input.type === 'color') {
      colorPickers[id] = createColorPicker(input);
    }
  });

  // Update color pickers when inspector is populated
  const originalSyncInspector = window.syncInspector || (() => {});
  window.updateColorPickers = function() {
    Object.values(colorPickers).forEach(cp => {
      if (cp && cp.update) cp.update();
    });
  };

  // ===== CABLE SYSTEM NAVIGATOR & INSPECTOR UI =====

  const cableNavigator = document.getElementById('cableNavigator');
  const cableNavigatorHeader = document.getElementById('cableNavigatorHeader');
  const cableInspectorPanel = document.getElementById('cableSystemInspectorPanel');
  const cableInspectorHeader = document.getElementById('cableInspectorHeader');
  const btnToggleCableNavigator = document.getElementById('btnToggleCableNavigator');
  const btnToggleCableInspector = document.getElementById('btnToggleCableInspector');
  const btnNewCableSystem = document.getElementById('btnNewCableSystem');
  const btnDeleteCableSystem = document.getElementById('btnDeleteCableSystem');
  const cableNavSearch = document.getElementById('cableNavSearch');
  const cableSystemList = document.getElementById('cableSystemList');

  // Add mode state
  let csAddMode = null; // null, 'links', or 'nodes'
  let csPendingItems = new Set(); // IDs of items to add

  // Make cable navigator draggable
  if (cableNavigatorHeader && cableNavigator) {
    let isDragging = false;
    let offsetX, offsetY;

    cableNavigatorHeader.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'BUTTON') return;
      isDragging = true;
      offsetX = e.clientX - cableNavigator.offsetLeft;
      offsetY = e.clientY - cableNavigator.offsetTop;
      cableNavigator.style.cursor = 'move';
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      cableNavigator.style.left = (e.clientX - offsetX) + 'px';
      cableNavigator.style.top = (e.clientY - offsetY) + 'px';
      cableNavigator.style.right = 'auto';
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
      cableNavigator.style.cursor = '';
    });
  }

  // Make cable inspector draggable
  if (cableInspectorHeader && cableInspectorPanel) {
    let isDragging = false;
    let offsetX, offsetY;

    cableInspectorHeader.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'BUTTON') return;
      isDragging = true;
      offsetX = e.clientX - cableInspectorPanel.offsetLeft;
      offsetY = e.clientY - cableInspectorPanel.offsetTop;
      cableInspectorPanel.style.cursor = 'move';
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      cableInspectorPanel.style.left = (e.clientX - offsetX) + 'px';
      cableInspectorPanel.style.top = (e.clientY - offsetY) + 'px';
      cableInspectorPanel.style.right = 'auto';
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
      cableInspectorPanel.style.cursor = '';
    });
  }

  // Toggle cable navigator visibility
  if (btnToggleCableNavigator) {
    btnToggleCableNavigator.addEventListener('click', () => {
      if (cableNavigator.style.display === 'none' || !cableNavigator.style.display) {
        cableNavigator.style.display = 'flex';
        btnToggleCableNavigator.classList.add('active');
        updateCableNavigatorList();
      } else {
        cableNavigator.style.display = 'none';
        btnToggleCableNavigator.classList.remove('active');
        // Clear cable system selection when hiding the list
        state.selectedCableSystem = null;
        updateCableSystemInspector();
        render();
      }
    });
  }

  // Toggle cable system inspector visibility
  if (btnToggleCableInspector) {
    btnToggleCableInspector.addEventListener('click', () => {
      if (cableInspectorPanel.style.display === 'none' || !cableInspectorPanel.style.display) {
        cableInspectorPanel.style.display = 'flex';
        btnToggleCableInspector.classList.add('active');
        updateCableSystemInspector();
      } else {
        cableInspectorPanel.style.display = 'none';
        btnToggleCableInspector.classList.remove('active');
      }
    });
  }

  // Minimize/close cable navigator
  const btnMinimizeCableNav = document.getElementById('btnMinimizeCableNav');
  const btnCloseCableNav = document.getElementById('btnCloseCableNav');

  if (btnMinimizeCableNav) {
    btnMinimizeCableNav.addEventListener('click', () => {
      cableNavigator.classList.toggle('minimized');
      btnMinimizeCableNav.textContent = cableNavigator.classList.contains('minimized') ? '+' : 'âˆ’';
    });
  }

  if (btnCloseCableNav) {
    btnCloseCableNav.addEventListener('click', () => {
      cableNavigator.style.display = 'none';
      btnToggleCableNavigator.classList.remove('active');
      // Clear cable system selection when closing the list
      state.selectedCableSystem = null;
      updateCableSystemInspector();
      render();
    });
  }

  // Minimize/close cable inspector
  const btnMinimizeCableInspector = document.getElementById('btnMinimizeCableInspector');
  const btnCloseCableInspector = document.getElementById('btnCloseCableInspector');

  if (btnMinimizeCableInspector) {
    btnMinimizeCableInspector.addEventListener('click', () => {
      cableInspectorPanel.classList.toggle('minimized');
      btnMinimizeCableInspector.textContent = cableInspectorPanel.classList.contains('minimized') ? '+' : 'âˆ’';
    });
  }

  if (btnCloseCableInspector) {
    btnCloseCableInspector.addEventListener('click', () => {
      cableInspectorPanel.style.display = 'none';
      btnToggleCableInspector.classList.remove('active');
      cancelAddMode();
    });
  }

  // New cable system button
  if (btnNewCableSystem) {
    btnNewCableSystem.addEventListener('click', () => {
      createCableSystem();
    });
  }

  // Import cable systems button
  const btnImportCableSystems = document.getElementById('btnImportCableSystems');
  if (btnImportCableSystems) {
    btnImportCableSystems.addEventListener('click', () => {
      showCableSystemBulkImportModal();
    });
  }

  // Export cable systems button (default = GeoJSON)
  const btnExportCableSystems = document.getElementById('btnExportCableSystems');
  if (btnExportCableSystems) {
    btnExportCableSystems.addEventListener('click', () => {
      exportCableSystemsAsGeoJSON();
    });
  }
  // Export dropdown toggle
  const btnExportCableDropdown = document.getElementById('btnExportCableDropdown');
  const exportCableDropdownMenu = document.getElementById('exportCableDropdownMenu');
  if (btnExportCableDropdown && exportCableDropdownMenu) {
    btnExportCableDropdown.addEventListener('click', (e) => {
      e.stopPropagation();
      exportCableDropdownMenu.style.display = exportCableDropdownMenu.style.display === 'none' ? 'block' : 'none';
    });
    document.addEventListener('click', () => { exportCableDropdownMenu.style.display = 'none'; });
  }
  const btnExportCableGeoJSON = document.getElementById('btnExportCableGeoJSON');
  if (btnExportCableGeoJSON) btnExportCableGeoJSON.addEventListener('click', () => { exportCableDropdownMenu.style.display = 'none'; exportCableSystemsAsGeoJSON(); });
  const btnExportCableJSON = document.getElementById('btnExportCableJSON');
  if (btnExportCableJSON) btnExportCableJSON.addEventListener('click', () => { exportCableDropdownMenu.style.display = 'none'; exportCableSystems(); });

  // Delete cable system button
  if (btnDeleteCableSystem) {
    btnDeleteCableSystem.addEventListener('click', () => {
      if (!state.selectedCableSystem) {
        showToast('Select a cable system first.');
        return;
      }
      showDeleteCableSystemDialog(state.selectedCableSystem);
    });
  }

  // Search filter for cable navigator
  if (cableNavSearch) {
    cableNavSearch.addEventListener('input', () => {
      updateCableNavigatorList();
    });
  }

  function updateCableNavigatorList() {
    if (!cableSystemList) return;

    const searchTerm = (cableNavSearch?.value || '').toLowerCase();
    const groupByRegion = document.getElementById('cableNavGroupByRegion')?.checked ?? true;

    const filtered = state.cableSystems.filter(cs => {
      if (!searchTerm) return true;
      return (cs.shortName || '').toLowerCase().includes(searchTerm) ||
             (cs.name || '').toLowerCase().includes(searchTerm) ||
             (cs.filterTags || []).join(' ').toLowerCase().includes(searchTerm);
    });

    if (filtered.length === 0) {
      cableSystemList.innerHTML = '<div class="muted" style="padding:12px; text-align:center;">No cable systems found.</div>';
      return;
    }

    // Helper to get status class based on RFS year
    function getStatusClass(cs) {
      const currentYear = new Date().getFullYear();
      // Check explicit status first (but only trust non-planned statuses blindly)
      if (cs.status === 'decommissioned') return 'decommissioned';
      if (cs.status === 'operational' || cs.status === 'Active') return 'operational';
      if (cs.status === 'under-construction' || cs.status === 'Under Construction') return 'under-construction';
      // For 'planned' or unknown status, ALWAYS cross-check against rfsYear / rfs string
      // A cable with rfsYear <= currentYear should be operational regardless of stored status
      let rfsYear = cs.rfsYear;
      // Fallback: try parsing the rfs string if rfsYear is not set
      if ((rfsYear === null || rfsYear === undefined) && cs.rfs && typeof cs.rfs === 'string') {
        const parsed = parseInt(cs.rfs);
        if (!isNaN(parsed) && parsed > 1990 && parsed < 2100) rfsYear = parsed;
      }
      if (rfsYear !== null && rfsYear !== undefined && !isNaN(rfsYear)) {
        if (rfsYear <= currentYear) {
          // If cable is 20+ years old, likely decommissioned
          if ((currentYear - rfsYear) >= 20) return 'decommissioned';
          return 'operational';
        }
        if (rfsYear <= currentYear + 2) return 'under-construction';
        return 'planned';
      }
      // No RFS data available â€” trust the stored status
      if (cs.status === 'planned' || cs.status === 'Planned') return 'planned';
      if (cs.status === 'unknown') return 'unknown';
      return 'unknown'; // Default for truly unknown
    }

    const multiSelectMode = document.getElementById('cableNavMultiSelect')?.checked || false;

    // Helper to render a single cable system item
    function renderCSItem(cs) {
      const linkCount = getCableSystemLinks(cs.id).length;
      const nodeCount = getCableSystemNodes(cs.id).length;
      const isSelected = state.selectedCableSystem === cs.id;
      const isMultiSelected = state.multiSelectedCableSystems?.has(cs.id) || false;
      const statusClass = getStatusClass(cs);
      const rfsText = cs.rfsYear ? cs.rfsYear : '';

      const checkboxHtml = multiSelectMode ?
        `<input type="checkbox" class="cs-multi-checkbox" data-cs-id="${cs.id}" ${isMultiSelected ? 'checked' : ''} style="width:14px; height:14px; accent-color:#0077b6; cursor:pointer;" />` : '';

      // Live status badge (from FiberAtlantic) OR inline link button for unlinked cables
      let liveAreaHtml;
      if (cs.fiberAtlanticId) {
        liveAreaHtml = renderLiveStatusBadge(cs);
      } else {
        // Small inline link icon to trigger manual FA matching
        liveAreaHtml = `<button class="btn-fa-inline-link" data-cs-id="${cs.id}" title="Link to Live Status for live status" style="padding:1px 4px; font-size:9px; background:#f9fafb; border:1px solid #e5e7eb; border-radius:3px; cursor:pointer; color:#9ca3af; line-height:1.2; display:flex; align-items:center; gap:2px;">ðŸ”—<span style="font-size:8px;">link</span></button>`;
      }

      return `
        <div class="cable-system-item ${isSelected ? 'selected' : ''} ${isMultiSelected ? 'multi-selected' : ''}" data-cs-id="${cs.id}" draggable="true">
          <div style="display:flex; align-items:center; gap:6px; min-width:0; flex:1;">
            ${checkboxHtml}
            <span class="cs-status-badge ${statusClass}" title="RFS: ${statusClass}"></span>
            <div style="min-width:0; flex:1;">
              <div class="cs-name">${escapeHtml(cs.shortName || cs.name)}</div>
              <div class="cs-fullname">${escapeHtml(cs.name)}${rfsText ? ` (${rfsText})` : ''}</div>
            </div>
          </div>
          <div style="display:flex; align-items:center; gap:4px;">
            ${liveAreaHtml}
            <button class="btn-show-visor" data-cs-id="${cs.id}" title="Show in Cable Visor" style="padding:2px 6px; font-size:10px; background:#e0f2fe; border:1px solid #7dd3fc; border-radius:3px; cursor:pointer;">ðŸŒ</button>
            <div class="cs-count">${linkCount}L / ${nodeCount}N</div>
          </div>
        </div>
      `;
    }

    let html = '';

    if (groupByRegion) {
      // Group by region from filterTags
      const regionGroups = {};
      const noRegion = [];

      filtered.forEach(cs => {
        // Use the corridor-based region directly from cable system
        let region = cs.region || 'Other';

        if (!regionGroups[region]) regionGroups[region] = [];
        regionGroups[region].push(cs);
      });

      // Sort regions alphabetically
      const sortedRegions = Object.keys(regionGroups).sort();

      sortedRegions.forEach(region => {
        const cables = regionGroups[region];
        // Sort cables within region by name
        cables.sort((a, b) => (a.shortName || a.name).localeCompare(b.shortName || b.name));

        const regionId = region.replace(/[^a-zA-Z0-9]/g, '_');
        html += `
          <div class="cs-region-group" data-region="${escapeHtml(region)}">
            <div class="cs-region-header" data-toggle-region="${regionId}">
              <span>${escapeHtml(region)} (${cables.length})</span>
              <span class="region-toggle">â–¼</span>
            </div>
            <div class="cs-region-items" id="region_${regionId}">
              ${cables.map(cs => renderCSItem(cs)).join('')}
            </div>
          </div>
        `;
      });
    } else {
      // Flat list sorted by name
      filtered.sort((a, b) => (a.shortName || a.name).localeCompare(b.shortName || b.name));
      html = filtered.map(cs => renderCSItem(cs)).join('');
    }

    cableSystemList.innerHTML = html;

    // Add click handlers for cable system items
    cableSystemList.querySelectorAll('.cable-system-item').forEach(item => {
      item.addEventListener('click', (e) => {
        // Don't trigger if clicking the visor button, checkbox, or FA link button
        if (e.target.classList.contains('btn-show-visor')) return;
        if (e.target.classList.contains('cs-multi-checkbox')) return;
        if (e.target.closest('.btn-fa-inline-link')) return;
        const csId = parseInt(item.dataset.csId);
        selectCableSystem(csId);
      });

      // Double-click opens the Cable System Details panel
      item.addEventListener('dblclick', (e) => {
        if (e.target.classList.contains('btn-show-visor')) return;
        if (e.target.classList.contains('cs-multi-checkbox')) return;
        if (e.target.closest('.btn-fa-inline-link')) return;
        const csId = parseInt(item.dataset.csId);
        selectCableSystem(csId);
        // Open the Cable System Details panel
        const cableInspectorPanel = document.getElementById('cableSystemInspectorPanel');
        const btnToggleCableInspector = document.getElementById('btnToggleCableInspector');
        if (cableInspectorPanel) {
          cableInspectorPanel.style.display = 'flex';
          if (btnToggleCableInspector) btnToggleCableInspector.classList.add('active');
          updateCableSystemInspector();
        }
      });
    });

    // Add click handlers for multi-select checkboxes
    cableSystemList.querySelectorAll('.cs-multi-checkbox').forEach(checkbox => {
      checkbox.addEventListener('change', (e) => {
        e.stopPropagation();
        const csId = parseInt(checkbox.dataset.csId);
        if (!state.multiSelectedCableSystems) state.multiSelectedCableSystems = new Set();

        if (checkbox.checked) {
          state.multiSelectedCableSystems.add(csId);
        } else {
          state.multiSelectedCableSystems.delete(csId);
        }
        updateCsMultiSelectCount();
      });
    });

    // Add click handlers for visor buttons
    cableSystemList.querySelectorAll('.btn-show-visor').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const csId = parseInt(btn.dataset.csId);
        showCableSystemInVisor(csId);
      });
    });

    // Add click handlers for region headers (collapse/expand)
    cableSystemList.querySelectorAll('.cs-region-header').forEach(header => {
      header.addEventListener('click', () => {
        const regionId = header.dataset.toggleRegion;
        const itemsDiv = document.getElementById('region_' + regionId);
        const toggle = header.querySelector('.region-toggle');
        if (itemsDiv) {
          itemsDiv.classList.toggle('collapsed');
          if (toggle) toggle.textContent = itemsDiv.classList.contains('collapsed') ? 'â–¶' : 'â–¼';
        }
      });
    });

    // Update multi-select count
    updateCsMultiSelectCount();
  }

  function updateCsMultiSelectCount() {
    const countEl = document.getElementById('csMultiSelectCount');
    if (countEl && state.multiSelectedCableSystems) {
      countEl.textContent = state.multiSelectedCableSystems.size;
    }
  }

  function selectCableSystem(csId) {
    state.selectedCableSystem = csId;
    updateCableNavigatorList();
    updateCableSystemInspector();
    render();
  }

  // Multi-select functions for Cable Systems
  function toggleCsMultiSelectMode() {
    const multiSelectBar = document.getElementById('cableNavMultiSelectBar');
    const checkbox = document.getElementById('cableNavMultiSelect');
    if (multiSelectBar) {
      multiSelectBar.style.display = checkbox?.checked ? 'block' : 'none';
    }
    if (!checkbox?.checked) {
      // Clear selections when disabling multi-select
      state.multiSelectedCableSystems = new Set();
    }
    updateCableNavigatorList();
  }

  function selectAllCableSystems() {
    if (!state.multiSelectedCableSystems) state.multiSelectedCableSystems = new Set();
    state.cableSystems.forEach(cs => state.multiSelectedCableSystems.add(cs.id));
    updateCableNavigatorList();
  }

  function deselectAllCableSystems() {
    state.multiSelectedCableSystems = new Set();
    updateCableNavigatorList();
  }

  function deleteSelectedCableSystems() {
    if (!state.multiSelectedCableSystems || state.multiSelectedCableSystems.size === 0) {
      showToast('No cable systems selected', 'warning');
      return;
    }

    const count = state.multiSelectedCableSystems.size;
    const confirmed = confirm(`Delete ${count} selected cable system(s)?\n\nThis will also unmap all associated links and nodes.`);

    if (confirmed) {
      const idsToDelete = Array.from(state.multiSelectedCableSystems);

      idsToDelete.forEach(csId => {
        // Unmap links
        state.edges.forEach(e => {
          if (e.cableSystemId === csId) e.cableSystemId = null;
        });
        // Unmap nodes
        state.nodes.forEach(n => {
          if (n.cableSystemId === csId) n.cableSystemId = null;
        });
        // Remove cable system
        const idx = state.cableSystems.findIndex(cs => cs.id === csId);
        if (idx !== -1) state.cableSystems.splice(idx, 1);
      });

      state.multiSelectedCableSystems = new Set();
      state.selectedCableSystem = null;

      updateCableNavigatorList();
      updateCableSystemInspector();
      render();

      showToast(`Deleted ${count} cable system(s)`, 'success');
    }
  }

  // Initialize multi-select event handlers
  document.getElementById('cableNavMultiSelect')?.addEventListener('change', toggleCsMultiSelectMode);
  document.getElementById('btnCsSelectAll')?.addEventListener('click', selectAllCableSystems);
  document.getElementById('btnCsSelectNone')?.addEventListener('click', deselectAllCableSystems);
  document.getElementById('btnCsDeleteSelected')?.addEventListener('click', deleteSelectedCableSystems);

  // Batch auto-match all cable systems with FiberAtlantic
  document.getElementById('btnBatchAutoMatchFA')?.addEventListener('click', async () => {
    const btn = document.getElementById('btnBatchAutoMatchFA');
    if (!btn) return;

    if (state.cableSystems.length === 0) {
      showToast('No cable systems to match', 'warning');
      return;
    }

    btn.disabled = true;
    btn.textContent = 'â³ Matching...';

    try {
      const result = await autoMatchAllCableSystems();
      showToast(`Linked ${result.matched} of ${result.total} cable systems to Live Status`, 'success');
    } catch (err) {
      showToast('Auto-match failed: ' + err.message, 'error');
    } finally {
      btn.disabled = false;
      btn.textContent = 'ðŸ”— Link All to Live Status';
    }
  });

  // Refresh live status for all linked cable systems from FiberAtlantic
  document.getElementById('btnRefreshLiveStatus')?.addEventListener('click', async () => {
    const btn = document.getElementById('btnRefreshLiveStatus');
    if (!btn) return;

    const linkedCables = state.cableSystems.filter(cs => cs.fiberAtlanticId);
    if (linkedCables.length === 0) {
      showToast('No cable systems linked to Live Status yet. Use "Link All" first.', 'warning');
      return;
    }

    btn.disabled = true;
    btn.textContent = 'â³ Refreshing...';

    try {
      // Force-refresh the cable list to get latest statuses
      const cables = await fetchFiberAtlanticCables(true);
      if (!cables) {
        showToast('Could not reach Live Status API', 'warning');
        return;
      }

      let updated = 0;
      linkedCables.forEach(cs => {
        // Find matching FA cable by id
        const faMatch = cables.find(c => (c.id || c.slug || c.name) === cs.fiberAtlanticId);
        if (faMatch && faMatch.status) {
          const newStatus = faMatch.status.toLowerCase().trim();
          if (newStatus !== (cs.faLiveStatus || '').toLowerCase().trim()) {
            cs.faLiveStatus = faMatch.status;
            updated++;
          } else {
            cs.faLiveStatus = faMatch.status; // Ensure it's stored even if unchanged
          }
        }
      });

      commit();
      updateCableNavigatorList();
      showToast(`Refreshed live status for ${linkedCables.length} cables (${updated} changed)`, 'success');
    } catch (err) {
      showToast('Refresh failed: ' + err.message, 'error');
    } finally {
      btn.disabled = false;
      btn.textContent = 'ðŸ”„ Refresh Live';
    }
  });

  // ======================
  // Inline FA Matching Popover (for unlinked cables in navigator)
  // ======================
  let activeInlinePopover = null;

  function closeInlinePopover() {
    if (activeInlinePopover) {
      activeInlinePopover.remove();
      activeInlinePopover = null;
    }
  }

  // Show inline FA matching popover anchored to the link button
  async function showInlineFaPopover(csId, anchorEl) {
    closeInlinePopover();

    const cs = findCableSystem(csId);
    if (!cs) return;

    // Position the popover near the button
    const rect = anchorEl.getBoundingClientRect();
    const popover = document.createElement('div');
    popover.className = 'fa-inline-popover';
    popover.style.top = (rect.bottom + 4) + 'px';
    popover.style.left = Math.max(8, rect.right - 260) + 'px';
    popover.style.position = 'fixed';

    popover.innerHTML = `
      <div class="fa-inline-popover-header">
        <span>ðŸ”— Link "${escapeHtml(cs.shortName || cs.name)}" to FA</span>
        <button class="fa-popover-close" style="background:none; border:none; cursor:pointer; font-size:14px; color:#6b7280; padding:0 2px;">âœ•</button>
      </div>
      <input class="fa-inline-popover-search" placeholder="Search Live Status cables..." autofocus />
      <div class="fa-inline-popover-list">
        <div style="padding:12px; text-align:center; color:#9ca3af; font-size:11px;">Loading cables...</div>
      </div>
    `;

    document.body.appendChild(popover);
    activeInlinePopover = popover;

    // Close button
    popover.querySelector('.fa-popover-close').addEventListener('click', closeInlinePopover);

    // Close on outside click (delayed to avoid immediate close)
    setTimeout(() => {
      const outsideHandler = (e) => {
        if (activeInlinePopover && !activeInlinePopover.contains(e.target)) {
          closeInlinePopover();
          document.removeEventListener('mousedown', outsideHandler);
        }
      };
      document.addEventListener('mousedown', outsideHandler);
    }, 100);

    // Load FA cables
    const cables = await fetchFiberAtlanticCables();
    if (!cables || !activeInlinePopover) return;

    const listEl = popover.querySelector('.fa-inline-popover-list');
    const searchInput = popover.querySelector('.fa-inline-popover-search');

    // Pre-filter: try to find best matches first, then show all
    function renderPopoverList(filter) {
      const term = (filter || '').toLowerCase().trim();
      let filtered = cables;
      if (term) {
        filtered = cables.filter(c => (c.name || '').toLowerCase().includes(term));
      }

      // Sort: best name matches first
      const csName = (cs.name || '').toLowerCase();
      const csShort = (cs.shortName || '').toLowerCase();
      filtered = filtered.slice().sort((a, b) => {
        const aName = (a.name || '').toLowerCase();
        const bName = (b.name || '').toLowerCase();
        const aMatch = aName.includes(csName) || csName.includes(aName) || aName.includes(csShort) || csShort.includes(aName);
        const bMatch = bName.includes(csName) || csName.includes(bName) || bName.includes(csShort) || csShort.includes(bName);
        if (aMatch && !bMatch) return -1;
        if (!aMatch && bMatch) return 1;
        return aName.localeCompare(bName);
      });

      if (filtered.length === 0) {
        listEl.innerHTML = '<div style="padding:12px; text-align:center; color:#9ca3af; font-size:11px;">No matches found</div>';
        return;
      }

      // Show max 50 items
      const items = filtered.slice(0, 50);
      listEl.innerHTML = items.map(c => {
        const status = (c.status || '').toLowerCase();
        let statusClass = 'other', statusLabel = c.status || 'â€”';
        if (status === 'online' || status === 'active') { statusClass = 'online'; statusLabel = 'Online'; }
        else if (status === 'outage') { statusClass = 'outage'; statusLabel = 'Outage'; }

        return `<div class="fa-inline-popover-item" data-fa-id="${escapeHtml(c.id || c.slug || c.name)}" data-fa-name="${escapeHtml(c.name)}" data-fa-status="${escapeHtml(c.status || '')}">
          <span class="fa-item-name" title="${escapeHtml(c.name)}">${escapeHtml(c.name)}</span>
          <span class="fa-item-status ${statusClass}">${statusLabel}</span>
        </div>`;
      }).join('');

      // Click handler for items
      listEl.querySelectorAll('.fa-inline-popover-item').forEach(item => {
        item.addEventListener('click', () => {
          const faId = item.dataset.faId;
          const faName = item.dataset.faName;
          const faStatus = item.dataset.faStatus;

          // Apply the link
          cs.fiberAtlanticId = faId;
          cs.fiberAtlanticName = faName;
          cs.fiberAtlanticConfidence = 'manual-inline';
          cs.faLiveStatus = faStatus || '';

          commit();
          updateCableNavigatorList();
          updateInspector();
          closeInlinePopover();
          showToast(`Linked "${cs.shortName}" â†’ "${faName}"`, 'success');
        });
      });
    }

    // Initial render with cable name as search hint
    searchInput.value = cs.shortName || cs.name || '';
    renderPopoverList(searchInput.value);
    searchInput.select();

    searchInput.addEventListener('input', () => {
      renderPopoverList(searchInput.value);
    });
  }

  // Event delegation for inline link buttons in the cable navigator
  document.getElementById('cableSystemList')?.addEventListener('click', (e) => {
    const linkBtn = e.target.closest('.btn-fa-inline-link');
    if (linkBtn) {
      e.stopPropagation();
      const csId = parseInt(linkBtn.dataset.csId);
      if (!isNaN(csId)) {
        showInlineFaPopover(csId, linkBtn);
      }
    }
  });

  // ======================
  // Cable Visor Panel
  // ======================
  const cableVisorState = {
    map: null,
    selectedCables: new Set(),
    cableDatabase: null,
    initialized: false,
    mapReady: false,
    mapStyle: 'osm'
  };

  // Cable Visor map style definitions (raster tile sources)
  const cableVisorMapStyles = {
    osm: {
      label: 'OpenStreetMap',
      tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
      tileSize: 256,
      attribution: '\u00a9 OpenStreetMap contributors',
      maxzoom: 19
    },
    satellite: {
      label: 'Satellite (ESRI)',
      tiles: ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
      tileSize: 256,
      attribution: '\u00a9 Esri, Maxar, Earthstar Geographics',
      maxzoom: 18
    },
    topo: {
      label: 'Topo (ESRI)',
      tiles: ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}'],
      tileSize: 256,
      attribution: '\u00a9 Esri, HERE, Garmin',
      maxzoom: 18
    },
    openTopo: {
      label: 'OpenTopoMap',
      tiles: ['https://tile.opentopomap.org/{z}/{x}/{y}.png'],
      tileSize: 256,
      attribution: '\u00a9 OpenTopoMap contributors',
      maxzoom: 17
    },
    cartoLight: {
      label: 'Carto Light',
      tiles: ['https://basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png'],
      tileSize: 256,
      attribution: '\u00a9 CARTO',
      maxzoom: 19
    },
    cartoDark: {
      label: 'Carto Dark',
      tiles: ['https://basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'],
      tileSize: 256,
      attribution: '\u00a9 CARTO',
      maxzoom: 19
    }
  };

  // Change the Cable Visor map style
  function changeCableVisorMapStyle(styleName) {
    if (!cableVisorState.map) return;
    const def = cableVisorMapStyles[styleName];
    if (!def) return;

    cableVisorState.mapStyle = styleName;

    const newStyle = {
      version: 8,
      sources: {
        'visor-tiles': {
          type: 'raster',
          tiles: def.tiles,
          tileSize: def.tileSize,
          attribution: def.attribution
        }
      },
      layers: [{
        id: 'visor-base-layer',
        type: 'raster',
        source: 'visor-tiles',
        minzoom: 0,
        maxzoom: def.maxzoom || 19
      }]
    };

    cableVisorState.map.setStyle(newStyle);

    // Re-render cable layers after style change
    cableVisorState.map.once('idle', () => {
      rebuildVisorMapSource();
    });

    // Save preference
    try {
      localStorage.setItem('neximap-visor-map-style', styleName);
    } catch(e) {}
  }

  // ======================
  // FiberAtlantic Live Cable Status Integration
  // ======================
  // Dedicated FA worker proxying fiberatlantic.com for live operational status
  // Endpoints: /cablelist, /cable/:id, /status-summary, /search/:name
  // Statuses: 'online', 'outage', 'in development', 'proposal', 'project'
  const FIBER_ATLANTIC_WORKER_URL = 'https://fiberatlantic-api.fcoroyse-spam.workers.dev';
  const fiberAtlanticCache = {
    cables: null,       // Cached cable list from FiberAtlantic
    details: {},        // Cached individual cable details by FA ID
    lastFetch: 0,       // Timestamp of last fetch
    cacheTTL: 3600000,  // 1 hour cache
    loading: false,
    error: null
  };

  // Render a compact live-status badge for the cable navigator list
  // Sources (in priority order): cs.faLiveStatus, fiberAtlanticCache.details, unlinked
  function renderLiveStatusBadge(cs) {
    if (!cs.fiberAtlanticId) return ''; // No FA link â€” show nothing

    // Get status: first from stored faLiveStatus, then from cache details
    let rawStatus = (cs.faLiveStatus || '').toLowerCase().trim();
    if (!rawStatus) {
      const detail = fiberAtlanticCache.details[cs.fiberAtlanticId];
      if (detail) rawStatus = (detail.status || '').toLowerCase().trim();
    }

    let badgeClass, label, title;
    if (rawStatus === 'online' || rawStatus === 'active') {
      badgeClass = 'live-online';
      label = 'UP';
      title = 'Live Status: Online';
    } else if (rawStatus === 'outage' || rawStatus === 'fault' || rawStatus === 'down') {
      badgeClass = 'live-outage';
      label = 'OUT';
      title = 'Live Status: OUTAGE';
    } else if (rawStatus === 'degraded' || rawStatus === 'partial') {
      badgeClass = 'live-degraded';
      label = 'DEG';
      title = 'Live Status: Degraded';
    } else if (rawStatus === 'in development' || rawStatus === 'proposal' || rawStatus === 'project') {
      badgeClass = 'live-unknown';
      label = rawStatus === 'in development' ? 'DEV' : rawStatus === 'proposal' ? 'PRO' : 'PRJ';
      title = `Live Status: ${rawStatus}`;
    } else if (rawStatus) {
      badgeClass = 'live-unknown';
      label = 'LS';
      title = `Live Status: ${rawStatus}`;
    } else {
      // Linked but no status fetched yet
      badgeClass = 'live-none';
      label = 'LS';
      title = 'Linked to Live Status â€” status pending';
    }

    return `<span class="cs-live-badge ${badgeClass}" title="${title}"><span class="live-dot"></span>${label}</span>`;
  }

  // Fetch FiberAtlantic cable list (live status data from fiberatlantic.com)
  async function fetchFiberAtlanticCables(forceRefresh = false) {
    if (!forceRefresh && fiberAtlanticCache.cables && (Date.now() - fiberAtlanticCache.lastFetch < fiberAtlanticCache.cacheTTL)) {
      return fiberAtlanticCache.cables;
    }
    if (fiberAtlanticCache.loading) return fiberAtlanticCache.cables;

    fiberAtlanticCache.loading = true;
    fiberAtlanticCache.error = null;

    try {
      // FA worker endpoint: /cablelist â€” returns array of {id, name, status, ...}
      const response = await fetch(`${FIBER_ATLANTIC_WORKER_URL}/cablelist`);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const data = await response.json();
      // Response is a direct array of cable objects
      fiberAtlanticCache.cables = Array.isArray(data) ? data : (data.cables || []);
      fiberAtlanticCache.lastFetch = Date.now();
      console.log('[FiberAtlantic] Fetched cable list:', fiberAtlanticCache.cables.length, 'cables');
      return fiberAtlanticCache.cables;
    } catch (err) {
      console.warn('[FiberAtlantic] Failed to fetch cables:', err.message);
      fiberAtlanticCache.error = err.message;
      return null;
    } finally {
      fiberAtlanticCache.loading = false;
    }
  }

  // Fetch details for a specific FiberAtlantic cable
  // FA worker endpoint: /cable/:id â€” returns merged basicInfo + MsgPack-decoded details
  async function fetchFiberAtlanticDetail(faId) {
    if (fiberAtlanticCache.details[faId]) return fiberAtlanticCache.details[faId];

    try {
      const response = await fetch(`${FIBER_ATLANTIC_WORKER_URL}/cable/${faId}`);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const data = await response.json();
      // The 'details' field comes as a JSON string from the MsgPack decode â€” parse it
      if (data.details && typeof data.details === 'string') {
        try {
          data.details = JSON.parse(data.details);
        } catch (e) {
          console.warn('[FiberAtlantic] Could not parse details string for', faId);
        }
      }
      fiberAtlanticCache.details[faId] = data;
      return data;
    } catch (err) {
      console.warn('[FiberAtlantic] Failed to fetch detail for', faId, ':', err.message);
      return null;
    }
  }

  // Auto-match a cable system name against FiberAtlantic cable list
  function autoMatchFiberAtlantic(csName, csList) {
    if (!csName || !csList) return null;
    const name = csName.trim().toLowerCase();
    const cables = Array.isArray(csList) ? csList : Object.values(csList);

    // Pass 1: Exact match (case-insensitive)
    let match = cables.find(c => (c.name || '').toLowerCase() === name);
    if (match) return { match, confidence: 'exact' };

    // Pass 2: Normalize and match (strip separators and common words)
    const normalize = s => s.toLowerCase()
      .replace(/[-_\s.()\/ ]/g, '')
      .replace(/cable(system)?/gi, '')
      .replace(/submarine/gi, '');
    const normName = normalize(csName);
    match = cables.find(c => normalize(c.name || '') === normName);
    if (match) return { match, confidence: 'normalized' };

    // Pass 3: Contains match (either direction, min 4 chars to avoid false positives)
    if (name.length >= 4) {
      match = cables.find(c => {
        const cName = (c.name || '').toLowerCase();
        return (cName.length >= 4) && (cName.includes(name) || name.includes(cName));
      });
      if (match) return { match, confidence: 'contains' };
    }

    // Pass 4: Alphanumeric-only match (handles abbreviations like SMW5 <-> SEAMEWE5)
    const alphaNum = s => s.replace(/[^A-Za-z0-9]/g, '').toUpperCase();
    const csAlpha = alphaNum(csName);
    if (csAlpha.length >= 3) {
      match = cables.find(c => {
        const cAlpha = alphaNum(c.name || '');
        return cAlpha.length >= 3 && (cAlpha === csAlpha || cAlpha.includes(csAlpha) || csAlpha.includes(cAlpha));
      });
      if (match) return { match, confidence: 'abbreviation' };
    }

    return null;
  }

  // Run auto-match for all cable systems and update their fiberAtlanticId
  async function autoMatchAllCableSystems() {
    const cables = await fetchFiberAtlanticCables();
    if (!cables) {
      showToast('Could not reach Live Status API', 'warning');
      return { matched: 0, total: state.cableSystems.length };
    }

    let matched = 0;
    state.cableSystems.forEach(cs => {
      if (cs.fiberAtlanticId) { matched++; return; } // Already linked

      // Try matching by name, then shortName
      let result = autoMatchFiberAtlantic(cs.name, cables);
      if (!result) result = autoMatchFiberAtlantic(cs.shortName, cables);

      if (result) {
        cs.fiberAtlanticId = result.match.id || result.match.slug || result.match.name;
        cs.fiberAtlanticName = result.match.name;
        cs.fiberAtlanticConfidence = result.confidence;
        // Store live status directly from cable list (no extra API call needed!)
        cs.faLiveStatus = result.match.status || '';
        matched++;
      }
    });

    // Also update faLiveStatus for already-linked cables that might not have it stored yet
    state.cableSystems.forEach(cs => {
      if (cs.fiberAtlanticId && !cs.faLiveStatus) {
        const faMatch = cables.find(c => (c.id || c.slug || c.name) === cs.fiberAtlanticId);
        if (faMatch) cs.faLiveStatus = faMatch.status || '';
      }
    });

    commit();
    updateCableNavigatorList();
    return { matched, total: state.cableSystems.length };
  }

  // Get live status for a cable system via FiberAtlantic
  // FA statuses: 'online', 'outage', 'in development', 'proposal', 'project', or empty
  function getFiberAtlanticStatus(cs) {
    if (!cs.fiberAtlanticId) return { status: 'unlinked', label: 'Not linked', cssClass: 'live-unknown' };

    // Primary: use stored faLiveStatus from cable list (fast, always available after linking)
    let rawStatus = (cs.faLiveStatus || '').toLowerCase().trim();

    // Fallback: check cache details
    if (!rawStatus) {
      const detail = fiberAtlanticCache.details[cs.fiberAtlanticId];
      if (detail) rawStatus = (detail.status || '').toLowerCase().trim();
    }

    if (!rawStatus) return { status: 'unknown', label: 'Linked (status pending)', cssClass: 'live-unknown' };

    if (rawStatus === 'online' || rawStatus === 'active') {
      return { status: 'active', label: 'Online', cssClass: 'live-active' };
    } else if (rawStatus === 'outage' || rawStatus === 'fault' || rawStatus === 'down') {
      return { status: 'issue', label: 'Outage', cssClass: 'live-issue' };
    } else if (rawStatus === 'degraded' || rawStatus === 'partial') {
      return { status: 'degraded', label: 'Degraded', cssClass: 'live-issue' };
    } else if (rawStatus === 'in development') {
      return { status: 'planned', label: 'In Development', cssClass: 'live-unknown' };
    } else if (rawStatus === 'proposal') {
      return { status: 'planned', label: 'Proposal', cssClass: 'live-unknown' };
    } else if (rawStatus === 'project') {
      return { status: 'planned', label: 'Project', cssClass: 'live-unknown' };
    }
    return { status: 'unknown', label: rawStatus || 'Unknown', cssClass: 'live-unknown' };
  }

  // Show detail panel for a cable in the Visor
  function showVisorCableDetail(cableId) {
    const db = cableVisorState.cableDatabase;
    if (!db || !db.cables || !db.cables[cableId]) return;

    const cable = db.cables[cableId];
    const detailPanel = document.getElementById('cableVisorDetailPanel');
    if (!detailPanel) return;

    // Header
    document.getElementById('visorDetailName').textContent = cable.name || cable.shortName || cableId;

    // Status badge
    const statusBadge = document.getElementById('visorDetailStatusBadge');
    const statusText = cable.status || 'Unknown';
    let statusCss = 'unknown';
    if (statusText.toLowerCase().includes('active') || statusText.toLowerCase().includes('service')) statusCss = 'active';
    else if (statusText.toLowerCase().includes('issue') || statusText.toLowerCase().includes('fault')) statusCss = 'issue';
    statusBadge.className = `visor-detail-status ${statusCss}`;
    statusBadge.innerHTML = `<span class="cs-status-badge live-${statusCss}" style="width:8px;height:8px;"></span> ${escapeHtml(statusText)}`;

    // Detail grid
    const grid = document.getElementById('visorDetailGrid');
    const currentYear = new Date().getFullYear();
    const items = [
      cable.region ? { label: 'Region', value: cable.region } : null,
      cable.rfs ? { label: 'RFS', value: cable.rfs } : null,
      cable.status ? { label: 'Status', value: cable.status.charAt(0).toUpperCase() + cable.status.slice(1).replace('-', ' ') } : null,
      // Show debug fields only for current-year RFS cables
      (cable.rfsYear === currentYear && cable._statusSource) ? { label: 'Status Source', value: cable._statusSource } : null,
      (cable.rfsYear === currentYear && cable._faMatchName) ? { label: 'FA Match', value: cable._faMatchName } : null,
      (cable.rfsYear === currentYear && cable._faStatus) ? { label: 'FA Live Status', value: cable._faStatus } : null,
      cable.length_km ? { label: 'Length', value: `${Math.round(cable.length_km).toLocaleString()} km` } : null,
      cable.fiberPairs ? { label: 'Fiber Pairs', value: cable.fiberPairs } : null,
      cable.designCapacity && cable.designCapacity !== 'Unknown' ? { label: 'Capacity', value: cable.designCapacity } :
        (cable.capacityTbps ? { label: 'Capacity', value: `${cable.capacityTbps} Tbps` } : null),
      cable.ownersText ? { label: 'Owners', value: cable.ownersText } :
        (cable.owners && cable.owners.length ? { label: 'Owners', value: Array.isArray(cable.owners) ? cable.owners.join(', ') : cable.owners } : null),
      cable.suppliers && cable.suppliers.length ? { label: 'Suppliers', value: Array.isArray(cable.suppliers) ? cable.suppliers.join(', ') : cable.suppliers } : null,
      cable.url ? { label: 'Website', value: cable.url } : null,
    ].filter(Boolean);

    grid.innerHTML = items.map(item => {
      let valueHtml = escapeHtml(String(item.value));

      // Color-code FA Live Status
      if (item.label === 'FA Live Status') {
        const val = String(item.value).toLowerCase();
        if (val === 'online' || val === 'active') {
          valueHtml = `<span style="color:#22c55e;font-weight:600;">â— ${escapeHtml(String(item.value))}</span>`;
        } else if (val === 'outage' || val === 'fault') {
          valueHtml = `<span style="color:#ef4444;font-weight:600;">â— ${escapeHtml(String(item.value))}</span>`;
        } else {
          valueHtml = `<span style="color:#f59e0b;">â— ${escapeHtml(String(item.value))}</span>`;
        }
      }

      // Color-code Status field
      if (item.label === 'Status') {
        const val = String(item.value).toLowerCase();
        if (val.includes('operational')) {
          valueHtml = `<span style="color:#22c55e;font-weight:600;">${escapeHtml(String(item.value))}</span>`;
        } else if (val.includes('under') || val.includes('construction')) {
          valueHtml = `<span style="color:#f59e0b;font-weight:600;">${escapeHtml(String(item.value))}</span>`;
        } else if (val.includes('planned')) {
          valueHtml = `<span style="color:#3b82f6;font-weight:600;">${escapeHtml(String(item.value))}</span>`;
        }
      }

      // Make URL clickable
      if (item.label === 'Website' && item.value) {
        valueHtml = `<a href="${escapeHtml(String(item.value))}" target="_blank" style="color:#0077b6;text-decoration:underline;word-break:break-all;">${escapeHtml(String(item.value))}</a>`;
      }

      // Style debug fields
      if (item.label === 'Status Source') {
        valueHtml = `<span style="color:#94a3b8;font-style:italic;font-size:11px;">${escapeHtml(String(item.value))}</span>`;
      }

      return `
        <div class="visor-detail-item">
          <div class="visor-detail-label">${item.label}</div>
          <div class="visor-detail-value">${valueHtml}</div>
        </div>
      `;
    }).join('');

    // Landing points
    const lpContainer = document.getElementById('visorLandingPoints');
    const lpList = document.getElementById('visorLpList');
    if (cable.landingPoints && cable.landingPoints.length > 0) {
      lpContainer.style.display = 'block';
      lpList.innerHTML = cable.landingPoints.map(lp => {
        const coordStr = lp.coordinates ? `${lp.coordinates[1].toFixed(4)}, ${lp.coordinates[0].toFixed(4)}` : (lp.lat ? `${lp.lat}, ${lp.lon}` : '');
        return `
        <span class="visor-lp-tag" title="${coordStr}">
          <span class="lp-dot"></span>
          ${escapeHtml(lp.name)}${lp.country ? ', ' + escapeHtml(lp.country) : ''}
        </span>
      `;
      }).join('');
    } else {
      lpContainer.style.display = 'none';
    }

    // Show panel (collapsed by default â€” just the header bar)
    detailPanel.classList.add('show');
  }

  function hideVisorCableDetail() {
    const panel = document.getElementById('cableVisorDetailPanel');
    if (panel) panel.classList.remove('show');
    const body = document.getElementById('visorDetailBody');
    if (body) body.classList.remove('expanded');
    const chevron = document.getElementById('visorDetailChevron');
    if (chevron) chevron.classList.remove('expanded');
  }

  // Toggle detail body expand/collapse (delegated - element is in later HTML)
  document.addEventListener('click', (e) => {
    const header = e.target.closest('#visorDetailHeaderToggle');
    if (!header) return;
    // Don't toggle if clicking the close button
    if (e.target.closest('.visor-detail-close')) return;
    const body = document.getElementById('visorDetailBody');
    const chevron = document.getElementById('visorDetailChevron');
    if (body) body.classList.toggle('expanded');
    if (chevron) chevron.classList.toggle('expanded');
  });

  // Setup detail panel close button (delegated)
  document.addEventListener('click', (e) => {
    if (e.target.closest('#btnCloseVisorDetail')) {
      hideVisorCableDetail();
    }
  });

  // Map resize handle drag logic
  (function() {
    let dragging = false;
    let startY = 0;
    let startHeight = 0;

    document.addEventListener('mousedown', (e) => {
      if (!e.target.closest('#cableVisorMapResizeHandle')) return;
      const mapEl = document.getElementById('cableVisorMap');
      if (!mapEl) return;
      dragging = true;
      startY = e.clientY;
      startHeight = mapEl.getBoundingClientRect().height;
      e.target.closest('#cableVisorMapResizeHandle').classList.add('dragging');
      document.body.style.cursor = 'ns-resize';
      document.body.style.userSelect = 'none';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const mapEl = document.getElementById('cableVisorMap');
      if (!mapEl) return;
      const delta = e.clientY - startY;
      const newHeight = Math.max(80, startHeight + delta);
      mapEl.style.flex = 'none';
      mapEl.style.height = newHeight + 'px';
      // Resize maplibre map if active
      if (cableVisorState.map) cableVisorState.map.resize();
      e.preventDefault();
    });

    document.addEventListener('mouseup', () => {
      if (!dragging) return;
      dragging = false;
      const handle = document.getElementById('cableVisorMapResizeHandle');
      if (handle) handle.classList.remove('dragging');
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      // Final map resize
      if (cableVisorState.map) cableVisorState.map.resize();
    });
  })();

  function showCableVisor() {
    const panel = document.getElementById('cableVisorPanel');
    if (!panel) return;
    panel.classList.add('show');

    // Initialize draggable on first show
    initCableVisorDraggable();

    // Load cable database first, then init map
    loadCableVisorData().then(() => {
      // Initialize map after data is loaded
      if (!cableVisorState.initialized) {
        setTimeout(() => initCableVisorMap(), 100);
      } else if (cableVisorState.map) {
        cableVisorState.map.resize();
      }
    });
  }

  function hideCableVisor() {
    const panel = document.getElementById('cableVisorPanel');
    if (panel) panel.classList.remove('show');
  }

  function toggleCableVisorMaximize() {
    const panel = document.getElementById('cableVisorPanel');
    if (!panel) return;

    panel.classList.toggle('maximized');

    if (panel.classList.contains('maximized')) {
      // Store original position/size before maximizing
      panel._originalStyle = {
        width: panel.style.width,
        height: panel.style.height,
        left: panel.style.left,
        top: panel.style.top
      };
      // Clear inline styles so CSS !important takes over
      panel.style.width = '';
      panel.style.height = '';
      panel.style.left = '';
      panel.style.top = '';
    } else {
      // Restore original position/size
      if (panel._originalStyle) {
        panel.style.width = panel._originalStyle.width;
        panel.style.height = panel._originalStyle.height;
        panel.style.left = panel._originalStyle.left;
        panel.style.top = panel._originalStyle.top;
      }
    }

    // Resize map after animation
    if (cableVisorState.map) {
      setTimeout(() => cableVisorState.map.resize(), 350);
    }
  }

  // Presentation (fullscreen) mode for Cable Visor
  let cableVisorPresentationActive = false;
  let cableVisorPresentationExitBtn = null;
  let cableVisorPresentationHint = null;

  function toggleCableVisorPresentation() {
    if (cableVisorPresentationActive) {
      exitCableVisorPresentation();
    } else {
      enterCableVisorPresentation();
    }
  }

  function enterCableVisorPresentation() {
    const panel = document.getElementById('cableVisorPanel');
    if (!panel) return;

    // Exit maximized mode if active
    if (panel.classList.contains('maximized')) {
      toggleCableVisorMaximize();
    }

    // Store original position/size
    panel._presentationOriginal = {
      width: panel.style.width,
      height: panel.style.height,
      left: panel.style.left,
      top: panel.style.top
    };

    // Clear inline styles and enter presentation mode
    panel.style.width = '';
    panel.style.height = '';
    panel.style.left = '';
    panel.style.top = '';
    panel.classList.add('presentation-mode');
    cableVisorPresentationActive = true;

    // Create close button (X)
    cableVisorPresentationExitBtn = document.createElement('button');
    cableVisorPresentationExitBtn.className = 'presentation-exit-btn';
    cableVisorPresentationExitBtn.innerHTML = '&#x2715;';
    cableVisorPresentationExitBtn.title = 'Exit Presentation (ESC)';
    cableVisorPresentationExitBtn.addEventListener('click', exitCableVisorPresentation);
    document.body.appendChild(cableVisorPresentationExitBtn);

    // Show ESC hint that fades after 3 seconds
    cableVisorPresentationHint = document.createElement('div');
    cableVisorPresentationHint.className = 'presentation-esc-hint';
    cableVisorPresentationHint.textContent = 'Press ESC to exit presentation mode';
    document.body.appendChild(cableVisorPresentationHint);
    setTimeout(() => {
      if (cableVisorPresentationHint) {
        cableVisorPresentationHint.style.opacity = '0';
        setTimeout(() => {
          if (cableVisorPresentationHint && cableVisorPresentationHint.parentNode) {
            cableVisorPresentationHint.parentNode.removeChild(cableVisorPresentationHint);
            cableVisorPresentationHint = null;
          }
        }, 1000);
      }
    }, 3000);

    // Try native fullscreen
    if (panel.requestFullscreen) {
      panel.requestFullscreen().catch(() => {});
    } else if (panel.webkitRequestFullscreen) {
      panel.webkitRequestFullscreen();
    }

    // Add ESC key listener
    document.addEventListener('keydown', handlePresentationEsc);

    // Listen for fullscreen exit via browser (e.g., F11 or native ESC)
    document.addEventListener('fullscreenchange', handleFullscreenChange);

    // Resize map after entering
    if (cableVisorState.map) {
      setTimeout(() => cableVisorState.map.resize(), 100);
    }

    console.log('[CableVisor] Entered presentation mode');
  }

  function exitCableVisorPresentation() {
    const panel = document.getElementById('cableVisorPanel');
    if (!panel) return;

    panel.classList.remove('presentation-mode');
    cableVisorPresentationActive = false;

    // Restore original position/size
    if (panel._presentationOriginal) {
      panel.style.width = panel._presentationOriginal.width;
      panel.style.height = panel._presentationOriginal.height;
      panel.style.left = panel._presentationOriginal.left;
      panel.style.top = panel._presentationOriginal.top;
    }

    // Remove close button
    if (cableVisorPresentationExitBtn && cableVisorPresentationExitBtn.parentNode) {
      cableVisorPresentationExitBtn.parentNode.removeChild(cableVisorPresentationExitBtn);
      cableVisorPresentationExitBtn = null;
    }

    // Remove hint
    if (cableVisorPresentationHint && cableVisorPresentationHint.parentNode) {
      cableVisorPresentationHint.parentNode.removeChild(cableVisorPresentationHint);
      cableVisorPresentationHint = null;
    }

    // Exit native fullscreen if active
    if (document.fullscreenElement) {
      document.exitFullscreen().catch(() => {});
    }

    // Remove listeners
    document.removeEventListener('keydown', handlePresentationEsc);
    document.removeEventListener('fullscreenchange', handleFullscreenChange);

    // Resize map after exiting
    if (cableVisorState.map) {
      setTimeout(() => cableVisorState.map.resize(), 100);
    }

    console.log('[CableVisor] Exited presentation mode');
  }

  function handlePresentationEsc(e) {
    if (e.key === 'Escape' && cableVisorPresentationActive) {
      e.preventDefault();
      e.stopPropagation();
      exitCableVisorPresentation();
    }
  }

  function handleFullscreenChange() {
    // If user exited fullscreen via browser controls, also exit our presentation mode
    if (!document.fullscreenElement && cableVisorPresentationActive) {
      exitCableVisorPresentation();
    }
  }

  function initCableVisorMap() {
    const container = document.getElementById('cableVisorMapContainer');
    const loadingEl = document.getElementById('cableVisorMapLoading');
    if (!container) return;

    // Check if map already exists
    if (cableVisorState.map) {
      cableVisorState.map.resize();
      return;
    }

    try {
      // Use saved map style preference or default to OSM
      const visorStyleKey = cableVisorState.mapStyle || 'osm';
      const visorStyleDef = cableVisorMapStyles[visorStyleKey] || cableVisorMapStyles.osm;

      cableVisorState.map = new maplibregl.Map({
        container: container,
        preserveDrawingBuffer: true,
        style: {
          version: 8,
          sources: {
            'visor-tiles': {
              type: 'raster',
              tiles: visorStyleDef.tiles,
              tileSize: visorStyleDef.tileSize,
              attribution: visorStyleDef.attribution
            }
          },
          layers: [{
            id: 'visor-base-layer',
            type: 'raster',
            source: 'visor-tiles',
            minzoom: 0,
            maxzoom: visorStyleDef.maxzoom || 19
          }]
        },
        center: [0, 20],
        zoom: 1.5,
        attributionControl: false
      });

      cableVisorState.map.addControl(new maplibregl.NavigationControl(), 'top-left');
      cableVisorState.map.addControl(new maplibregl.AttributionControl({ compact: true }), 'bottom-right');

      cableVisorState.map.on('load', () => {
        if (loadingEl) loadingEl.style.display = 'none';
        cableVisorState.initialized = true;
        cableVisorState.mapReady = true;

        // Set up hover events once
        setupCableVisorHoverEvents();

        // Rebuild unified source for any already-selected cables
        rebuildVisorMapSource();
      });

    } catch (err) {
      console.error('[CableVisor] Map init error:', err);
      if (loadingEl) loadingEl.innerHTML = '<div style="color:#c00;">Failed to load map</div>';
    }
  }

  async function loadCableVisorData(forceReload = false) {
    // If already loaded and not forcing reload, just render
    if (cableVisorState.cableDatabase && !forceReload) {
      renderCableVisorList();
      return;
    }

    const listEl = document.getElementById('cableVisorCableList');
    const titleEl = document.getElementById('cableVisorListTitle');

    // Determine source
    const srcList = document.getElementById('visorSrcList');
    const srcAPI = document.getElementById('visorSrcAPI');

    let source = 'list'; // default to Cable List
    if (srcAPI?.checked) source = 'api';

    // Update title
    const sourceLabels = { list: 'Cables from Cable List', api: 'Cables from Public Cable System DB' };
    if (titleEl) titleEl.textContent = sourceLabels[source];

    if (listEl) listEl.innerHTML = '<div style="padding:20px; text-align:center; color:#666;">Loading cables...</div>';

    try {
      let db;

      if (source === 'list') {
        // Load from Cable System List (state.cableSystems)
        db = loadCablesFromCableList();
      } else {
        // Load from local TeleGeography data
        db = await loadFromLocalTeleGeographyData();
      }

      console.log('[CableVisor] Loaded from ' + source + ':', db ? Object.keys(db.cables || {}).length : 0, 'cables');

      if (db && db.cables) {
        cableVisorState.cableDatabase = db;
        populateCableVisorRegionFilter(db);
        // Initialize CLS filter (indices from cable_stations_db)
        initCLSFilter();
        renderCableVisorList();
      } else {
        if (listEl) listEl.innerHTML = '<div style="padding:20px; text-align:center; color:#888;">No cables found</div>';
      }
    } catch (err) {
      console.error('[CableVisor] Failed to load cables:', err);
      if (listEl) {
        let errHtml = '<div style="padding:20px; text-align:center;">';
        errHtml += '<div style="color:#c00; margin-bottom:8px;">Failed to load cable data: ' + escapeHtml(err.message) + '</div>';
        if (err.message && err.message.includes('Failed to fetch')) {
          errHtml += '<div style="color:#888; font-size:11px;">This may be caused by running from a local file or network issues.<br>Try using "Refresh from API" or check your connection.</div>';
        }
        errHtml += '</div>';
        listEl.innerHTML = errHtml;
      }
    }
  }

  // Load cables from Cable System List (state.cableSystems)
  function loadCablesFromCableList() {
    const cables = {};

    if (!state.cableSystems || state.cableSystems.length === 0) {
      return { cables: {}, source: 'Cable System List' };
    }

    state.cableSystems.forEach(cs => {
      cables[cs.id] = {
        id: cs.id,
        name: cs.name,
        shortName: cs.shortName || cs.name,
        color: cs.color || '#0077b6',
        region: cs.region || 'Unknown',
        status: cs.status === 'operational' ? 'Active' : (cs.status === 'planned' ? 'Planned' : cs.status),
        rfs: cs.rfs || '',
        rfsYear: cs.rfsYear || null,
        owners: cs.owners || [],
        ownersText: Array.isArray(cs.owners) ? cs.owners.join(', ') : (cs.owners || ''),
        length_km: cs.length_km || null,
        geometry: cs.geometry || null,
        landingPoints: cs.landingPoints || [],
        description: cs.description || '',
        source: cs.source || 'Cable System List'
      };
    });

    return {
      version: '1.0',
      source: 'Cable System List',
      cables: cables
    };
  }

  // Cloudflare Worker proxy URLs for cable data sources
  const TG_GEODATA_API = 'https://submarine-cable-api.fcoroyse-spam.workers.dev';
  const CABLE_META_API = 'https://tg-cablesystem-rfs-metadata.fcoroyse-spam.workers.dev';
  // Local pre-fetched TeleGeography data (geometry + metadata combined)
  const TG_LOCAL_DATA = 'data/telegeography_cables.json';

  // Load TeleGeography data from local pre-fetched file (default, fast)
  async function loadFromLocalTeleGeographyData() {
    const listEl = document.getElementById('cableVisorCableList');
    if (listEl) listEl.innerHTML = '<div style="padding:20px; text-align:center; color:#0077b6;">ðŸŒ Loading Public Cable System DB data...</div>';

    try {
      const resp = await fetch(TG_LOCAL_DATA);
      if (!resp.ok) throw new Error(`Failed to load local data: ${resp.status}`);
      const combined = await resp.json();

      const geoData = combined.geometry;
      const metaData = combined.metadata || {};
      const totalCables = geoData.features ? geoData.features.length : 0;
      console.log(`[CableVisor] Loaded ${totalCables} cables from local file (${Object.keys(metaData).length} with metadata, updated: ${combined.lastUpdated})`);

      return await buildTeleGeographyCableDatabase(geoData, metaData, listEl);
    } catch (err) {
      console.error('[CableVisor] Local data error:', err);
      throw err;
    }
  }

  // Load TeleGeography data from live API (for refresh/update)
  async function loadFromTeleGeographyAPI() {
    const listEl = document.getElementById('cableVisorCableList');
    if (listEl) listEl.innerHTML = '<div style="padding:20px; text-align:center; color:#0077b6;">ðŸŒ Fetching live data from Public Cable System DB API...</div>';

    try {
      // Step 1: Fetch cable GeoJSON
      const geoResponse = await fetch(`${TG_GEODATA_API}/cable-geo`);
      if (!geoResponse.ok) throw new Error(`Failed to fetch cable geometry: ${geoResponse.status}`);
      const geoData = await geoResponse.json();

      const totalCables = geoData.features ? geoData.features.length : 0;
      console.log(`[CableVisor] Loaded ${totalCables} cable geometries from API`);

      // Step 2: Fetch per-cable metadata
      if (listEl) listEl.innerHTML = `<div style="padding:20px; text-align:center; color:#0077b6;">ðŸŒ Loading metadata for ${totalCables} cables... <span id="metaProgress">0</span>/${totalCables}</div>`;

      let metaData = {};
      let metaFetched = 0;
      let metaErrors = 0;
      const batchSize = 10;
      const features = geoData.features || [];
      for (let i = 0; i < features.length; i += batchSize) {
        const batch = features.slice(i, i + batchSize);
        const promises = batch.map(async (feature) => {
          const cableId = feature.properties?.id;
          if (!cableId) return;
          try {
            const resp = await fetch(`${CABLE_META_API}/cable/${cableId}`);
            if (resp.ok) {
              const data = await resp.json();
              metaData[cableId] = data;
            } else {
              metaErrors++;
            }
          } catch (e) {
            metaErrors++;
          }
          metaFetched++;
          const progEl = document.getElementById('metaProgress');
          if (progEl) progEl.textContent = metaFetched;
        });
        await Promise.all(promises);
      }

      console.log(`[CableVisor] Fetched metadata for ${Object.keys(metaData).length} cables (${metaErrors} errors) from API`);

      return await buildTeleGeographyCableDatabase(geoData, metaData, listEl);
    } catch (err) {
      console.error('[CableVisor] TeleGeography API error:', err);
      throw err;
    }
  }

  // Build cable database from geometry + metadata (shared by local and API loaders)
  async function buildTeleGeographyCableDatabase(geoData, metaData, listEl) {
      const features = geoData.features || [];

      // FiberAtlantic cross-check for current-year RFS cables
      const currentYear = new Date().getFullYear();
      const currentYearCables = features.filter(f => {
        const m = metaData[f.properties?.id];
        return m && (m.rfs_year === currentYear || (m.rfs && parseInt(m.rfs) === currentYear));
      });

      let faCables = null;
      if (currentYearCables.length > 0) {
        if (listEl) listEl.innerHTML = `<div style="padding:20px; text-align:center; color:#0077b6;">ðŸŒ Cross-checking ${currentYearCables.length} cables with RFS ${currentYear} against Live Status...</div>`;
        try {
          faCables = await fetchFiberAtlanticCables(true);
          console.log(`[CableVisor] FiberAtlantic cable list: ${faCables ? faCables.length : 0} cables (for ${currentYearCables.length} current-year RFS cross-checks)`);
        } catch (faErr) {
          console.warn('[CableVisor] FiberAtlantic unavailable for cross-check:', faErr.message);
        }
      } else {
        console.log(`[CableVisor] No cables with RFS ${currentYear} â€” skipping FiberAtlantic cross-check`);
      }

      // Step 4: Build cable database with smart status logic
      const cables = {};
      let statusDebugLog = [];

      geoData.features.forEach(feature => {
        const props = feature.properties;
        const meta = metaData[props.id] || {};

        // Determine RFS year from metadata
        let rfsYear = null;
        if (typeof meta.rfs_year === 'number') {
          rfsYear = meta.rfs_year;
        } else if (meta.rfs && typeof meta.rfs === 'string') {
          const parsed = parseInt(meta.rfs);
          if (!isNaN(parsed) && parsed > 1990 && parsed < 2100) rfsYear = parsed;
        }

        // Status logic:
        // rfs_year < currentYear  â†’ operational (green)
        // rfs_year > currentYear  â†’ planned (blue)
        // rfs_year == currentYear â†’ check FiberAtlantic: online = operational, else under-construction (pending)
        // no rfs_year             â†’ check is_planned flag
        let status = 'unknown';
        let statusSource = 'default';
        let faStatus = null;
        let faMatchName = null;

        if (rfsYear && rfsYear < currentYear) {
          // Check if cable is 20+ years old AND not in FiberAtlantic â†’ likely decommissioned
          const cableAge = currentYear - rfsYear;
          if (cableAge >= 20) {
            // Cross-check with FiberAtlantic to see if it's still active
            let faStillActive = false;
            if (faCables) {
              const faMatch = autoMatchFiberAtlantic(props.name, faCables);
              if (faMatch && faMatch.match) {
                const faS = (faMatch.match.status || '').toLowerCase().trim();
                if (faS === 'online' || faS === 'active' || faS === 'outage') {
                  faStillActive = true;
                  faMatchName = faMatch.match.name;
                  faStatus = faS;
                }
              }
            }
            if (faStillActive) {
              status = 'operational';
              statusSource = `rfs_year=${rfsYear} (${cableAge}yr old, FA confirms active)`;
            } else {
              status = 'decommissioned';
              statusSource = `rfs_year=${rfsYear} (${cableAge}yr old, no FA match â†’ decommissioned)`;
            }
          } else {
            status = 'operational';
            statusSource = 'rfs_year < current';
          }
        } else if (rfsYear && rfsYear > currentYear) {
          status = 'planned';
          statusSource = 'rfs_year > current';
        } else if (rfsYear && rfsYear === currentYear) {
          // RFS this year â€” cross-check with FiberAtlantic
          status = 'under-construction'; // Default: pending until FA confirms
          statusSource = 'rfs_year == current (pending)';

          if (faCables) {
            const faMatch = autoMatchFiberAtlantic(props.name, faCables);
            if (faMatch && faMatch.match) {
              faMatchName = faMatch.match.name;
              faStatus = (faMatch.match.status || '').toLowerCase().trim();
              if (faStatus === 'online' || faStatus === 'active') {
                status = 'operational';
                statusSource = 'FA confirms online';
              } else if (faStatus === 'outage' || faStatus === 'fault') {
                status = 'operational'; // It's RFS and known to FA, just having issues
                statusSource = `FA: ${faStatus} (RFS but fault)`;
              } else {
                statusSource = `FA: ${faStatus || 'no status'} (not yet online)`;
              }
            } else {
              statusSource = 'rfs_year == current (no FA match)';
            }
          }
        } else if (!rfsYear) {
          // No RFS year â€” use is_planned flag + FiberAtlantic cross-check
          if (meta.is_planned === false) {
            // Cable was built (not planned) but has no RFS year
            // Cross-check with FiberAtlantic to see if it's still active
            let faStillActive = false;
            if (faCables) {
              const faMatch = autoMatchFiberAtlantic(props.name, faCables);
              if (faMatch && faMatch.match) {
                const faS = (faMatch.match.status || '').toLowerCase().trim();
                faMatchName = faMatch.match.name;
                faStatus = faS;
                if (faS === 'online' || faS === 'active' || faS === 'outage') {
                  faStillActive = true;
                }
              }
            }
            if (faStillActive) {
              status = 'operational';
              statusSource = `is_planned=false, FA confirms active (${faStatus})`;
            } else {
              status = 'decommissioned';
              statusSource = 'is_planned=false, no rfs_year, no FA match â†’ decommissioned';
            }
          } else if (meta.is_planned === true) {
            status = 'planned';
            statusSource = 'is_planned=true (no rfs_year)';
          } else {
            status = 'unknown';
            statusSource = 'no rfs data';
          }
        }

        // Log debug info for current-year RFS cables
        if (rfsYear === currentYear) {
          statusDebugLog.push({
            name: props.name,
            id: props.id,
            rfsYear: rfsYear,
            rfs: meta.rfs || null,
            status: status,
            statusSource: statusSource,
            faMatch: faMatchName,
            faStatus: faStatus
          });
        }

        // Parse owners: TG API returns owners as comma-separated string
        let owners = [];
        if (typeof meta.owners === 'string' && meta.owners) {
          owners = meta.owners.split(',').map(o => o.trim()).filter(Boolean);
        } else if (Array.isArray(meta.owners) && meta.owners.length > 0) {
          owners = meta.owners;
        }

        // Parse suppliers
        let suppliers = [];
        if (typeof meta.suppliers === 'string' && meta.suppliers) {
          suppliers = meta.suppliers.split(',').map(s => s.trim()).filter(Boolean);
        } else if (Array.isArray(meta.suppliers)) {
          suppliers = meta.suppliers;
        }

        // Parse length from meta API (format: "45,000 km")
        let length_km = null;
        if (meta.length && typeof meta.length === 'string') {
          length_km = parseFloat(meta.length.replace(/,/g, '').replace(' km', ''));
          if (isNaN(length_km)) length_km = null;
        }

        cables[props.id] = {
          id: props.id,
          name: props.name,
          shortName: props.name.length > 20 ? props.name.substring(0, 18) + '...' : props.name,
          color: props.color || '#939597',
          region: inferRegionFromLandingPoints(meta.landing_points || [], feature.geometry),
          status: status,
          rfs: meta.rfs || (rfsYear ? String(rfsYear) : ''),
          rfsYear: rfsYear,
          is_planned: meta.is_planned != null ? meta.is_planned : null,
          owners: owners,
          ownersText: owners.length > 0 ? owners.join(', ') : 'Unknown',
          suppliers: suppliers,
          description: props.name + ' submarine cable',
          length_km: length_km,
          url: meta.url || null,
          landingPoints: meta.landing_points || [],
          geometry: feature.geometry,
          source: 'TeleGeography API',
          // Debug fields for current-year RFS cables
          _faStatus: faStatus,
          _faMatchName: faMatchName,
          _statusSource: statusSource
        };
      });

      // Log debug summary for current-year cables
      if (statusDebugLog.length > 0) {
        console.group(`[CableVisor] ðŸ” RFS ${currentYear} Cross-Check Debug (${statusDebugLog.length} cables)`);
        console.table(statusDebugLog);
        console.groupEnd();
      }

      const opCount = Object.values(cables).filter(c => c.status === 'operational').length;
      const ucCount = Object.values(cables).filter(c => c.status === 'under-construction').length;
      const plCount = Object.values(cables).filter(c => c.status === 'planned').length;
      const dcCount = Object.values(cables).filter(c => c.status === 'decommissioned').length;
      const ukCount = Object.values(cables).filter(c => c.status === 'unknown').length;
      console.log(`[CableVisor] Status summary: ${opCount} operational, ${ucCount} under-construction/pending, ${plCount} planned, ${dcCount} decommissioned, ${ukCount} unknown`);

      return {
        version: '1.0',
        lastUpdated: new Date().toISOString().split('T')[0],
        source: 'TeleGeography SubmarineCableMap API',
        cables: cables
      };
  }

  // Country-to-region mapping for accurate cable region classification
  const countryToRegion = {
    // Europe
    'Albania': 'Europe', 'Andorra': 'Europe', 'Austria': 'Europe', 'Belarus': 'Europe',
    'Belgium': 'Europe', 'Bosnia and Herzegovina': 'Europe', 'Bulgaria': 'Europe',
    'Croatia': 'Europe', 'Cyprus': 'Europe', 'Czech Republic': 'Europe', 'Czechia': 'Europe',
    'Denmark': 'Europe', 'Estonia': 'Europe', 'Finland': 'Europe', 'France': 'Europe',
    'Germany': 'Europe', 'Greece': 'Europe', 'Hungary': 'Europe', 'Iceland': 'Europe',
    'Ireland': 'Europe', 'Italy': 'Europe', 'Kosovo': 'Europe', 'Latvia': 'Europe',
    'Lithuania': 'Europe', 'Luxembourg': 'Europe', 'Malta': 'Europe', 'Moldova': 'Europe',
    'Monaco': 'Europe', 'Montenegro': 'Europe', 'Netherlands': 'Europe', 'North Macedonia': 'Europe',
    'Norway': 'Europe', 'Poland': 'Europe', 'Portugal': 'Europe', 'Romania': 'Europe',
    'Russia': 'Europe', 'Serbia': 'Europe', 'Slovakia': 'Europe', 'Slovenia': 'Europe',
    'Spain': 'Europe', 'Sweden': 'Europe', 'Switzerland': 'Europe', 'Turkey': 'Europe',
    'Ukraine': 'Europe', 'United Kingdom': 'Europe', 'Faroe Islands': 'Europe',
    'Gibraltar': 'Europe', 'Guernsey': 'Europe', 'Isle of Man': 'Europe', 'Jersey': 'Europe',
    'Svalbard and Jan Mayen': 'Europe',
    // North America
    'Canada': 'North America', 'United States': 'North America', 'Mexico': 'North America',
    'Greenland': 'North America', 'Saint Pierre and Miquelon': 'North America',
    'Bermuda': 'North America',
    // Central America & Caribbean
    'Belize': 'Central America & Caribbean', 'Costa Rica': 'Central America & Caribbean',
    'El Salvador': 'Central America & Caribbean', 'Guatemala': 'Central America & Caribbean',
    'Honduras': 'Central America & Caribbean', 'Nicaragua': 'Central America & Caribbean',
    'Panama': 'Central America & Caribbean', 'Antigua and Barbuda': 'Central America & Caribbean',
    'Bahamas': 'Central America & Caribbean', 'Barbados': 'Central America & Caribbean',
    'Cuba': 'Central America & Caribbean', 'Dominica': 'Central America & Caribbean',
    'Dominican Republic': 'Central America & Caribbean', 'Grenada': 'Central America & Caribbean',
    'Haiti': 'Central America & Caribbean', 'Jamaica': 'Central America & Caribbean',
    'Saint Kitts and Nevis': 'Central America & Caribbean', 'Saint Lucia': 'Central America & Caribbean',
    'Saint Vincent and the Grenadines': 'Central America & Caribbean',
    'Trinidad and Tobago': 'Central America & Caribbean',
    'Anguilla': 'Central America & Caribbean', 'Aruba': 'Central America & Caribbean',
    'Bonaire, Sint Eustatius and Saba': 'Central America & Caribbean',
    'British Virgin Islands': 'Central America & Caribbean',
    'Cayman Islands': 'Central America & Caribbean', 'Curacao': 'Central America & Caribbean',
    'Guadeloupe': 'Central America & Caribbean', 'Martinique': 'Central America & Caribbean',
    'Montserrat': 'Central America & Caribbean', 'Puerto Rico': 'Central America & Caribbean',
    'Sint Maarten': 'Central America & Caribbean', 'Turks and Caicos Islands': 'Central America & Caribbean',
    'U.S. Virgin Islands': 'Central America & Caribbean',
    // South America
    'Argentina': 'South America', 'Bolivia': 'South America', 'Brazil': 'South America',
    'Chile': 'South America', 'Colombia': 'South America', 'Ecuador': 'South America',
    'Guyana': 'South America', 'Paraguay': 'South America', 'Peru': 'South America',
    'Suriname': 'South America', 'Uruguay': 'South America', 'Venezuela': 'South America',
    'French Guiana': 'South America', 'Falkland Islands': 'South America',
    // Middle East
    'Bahrain': 'Middle East', 'Iran': 'Middle East', 'Iraq': 'Middle East',
    'Israel': 'Middle East', 'Jordan': 'Middle East', 'Kuwait': 'Middle East',
    'Lebanon': 'Middle East', 'Oman': 'Middle East', 'Palestine': 'Middle East',
    'Qatar': 'Middle East', 'Saudi Arabia': 'Middle East', 'Syria': 'Middle East',
    'United Arab Emirates': 'Middle East', 'Yemen': 'Middle East',
    // Africa
    'Algeria': 'Africa', 'Angola': 'Africa', 'Benin': 'Africa', 'Botswana': 'Africa',
    'Burkina Faso': 'Africa', 'Burundi': 'Africa', 'Cameroon': 'Africa',
    'Cape Verde': 'Africa', 'Central African Republic': 'Africa', 'Chad': 'Africa',
    'Comoros': 'Africa', 'Congo, Dem. Rep.': 'Africa', 'Congo, Rep.': 'Africa',
    "C\xc3\xb4te d'Ivoire": 'Africa', 'Djibouti': 'Africa', 'Egypt': 'Africa',
    'Equatorial Guinea': 'Africa', 'Eritrea': 'Africa', 'Eswatini': 'Africa',
    'Ethiopia': 'Africa', 'Gabon': 'Africa', 'Gambia': 'Africa', 'Ghana': 'Africa',
    'Guinea': 'Africa', 'Guinea-Bissau': 'Africa', 'Kenya': 'Africa', 'Lesotho': 'Africa',
    'Liberia': 'Africa', 'Libya': 'Africa', 'Madagascar': 'Africa', 'Malawi': 'Africa',
    'Mali': 'Africa', 'Mauritania': 'Africa', 'Mauritius': 'Africa', 'Morocco': 'Africa',
    'Mozambique': 'Africa', 'Namibia': 'Africa', 'Niger': 'Africa', 'Nigeria': 'Africa',
    'Rwanda': 'Africa', 'Sao Tome and Principe': 'Africa', 'Senegal': 'Africa',
    'Seychelles': 'Africa', 'Sierra Leone': 'Africa', 'Somalia': 'Africa',
    'South Africa': 'Africa', 'South Sudan': 'Africa', 'Sudan': 'Africa',
    'Tanzania': 'Africa', 'Togo': 'Africa', 'Tunisia': 'Africa', 'Uganda': 'Africa',
    'Zambia': 'Africa', 'Zimbabwe': 'Africa', 'Reunion': 'Africa', 'Mayotte': 'Africa',
    // South Asia
    'Afghanistan': 'South Asia', 'Bangladesh': 'South Asia', 'Bhutan': 'South Asia',
    'India': 'South Asia', 'Maldives': 'South Asia', 'Nepal': 'South Asia',
    'Pakistan': 'South Asia', 'Sri Lanka': 'South Asia',
    // East Asia
    'China': 'East Asia', 'Hong Kong': 'East Asia', 'Japan': 'East Asia',
    'Macau': 'East Asia', 'Mongolia': 'East Asia', 'North Korea': 'East Asia',
    'South Korea': 'East Asia', 'Taiwan': 'East Asia',
    // Southeast Asia
    'Brunei': 'Southeast Asia', 'Cambodia': 'Southeast Asia', 'Indonesia': 'Southeast Asia',
    'Laos': 'Southeast Asia', 'Malaysia': 'Southeast Asia', 'Myanmar': 'Southeast Asia',
    'Philippines': 'Southeast Asia', 'Singapore': 'Southeast Asia', 'Thailand': 'Southeast Asia',
    'Timor-Leste': 'Southeast Asia', 'Vietnam': 'Southeast Asia',
    // Oceania
    'Australia': 'Oceania', 'Fiji': 'Oceania', 'Kiribati': 'Oceania',
    'Marshall Islands': 'Oceania', 'Micronesia': 'Oceania', 'Nauru': 'Oceania',
    'New Zealand': 'Oceania', 'Palau': 'Oceania', 'Papua New Guinea': 'Oceania',
    'Samoa': 'Oceania', 'Solomon Islands': 'Oceania', 'Tonga': 'Oceania',
    'Tuvalu': 'Oceania', 'Vanuatu': 'Oceania',
    'American Samoa': 'Oceania', 'Christmas Island': 'Oceania', 'Cocos (Keeling) Islands': 'Oceania',
    'Cook Islands': 'Oceania', 'French Polynesia': 'Oceania', 'Guam': 'Oceania',
    'New Caledonia': 'Oceania', 'Niue': 'Oceania', 'Norfolk Island': 'Oceania',
    'Northern Mariana Islands': 'Oceania', 'Tokelau': 'Oceania',
    'Wallis and Futuna': 'Oceania',
    // Central Asia
    'Kazakhstan': 'Central Asia', 'Kyrgyzstan': 'Central Asia',
    'Tajikistan': 'Central Asia', 'Turkmenistan': 'Central Asia', 'Uzbekistan': 'Central Asia',
    // Indian Ocean territories
    'British Indian Ocean Territory': 'Indian Ocean',
    'French Southern Territories': 'Indian Ocean',
    // Additional country name variants found in TeleGeography data
    'Georgia': 'Europe', 'Monaco': 'Europe', 'Guernsey': 'Europe',
    'Isle of Man': 'Europe', 'Jersey': 'Europe',
    'Lebanon': 'Middle East', 'Syria': 'Middle East',
    'Cocos (Keeling) Islands': 'Oceania', 'Tokelau': 'Oceania',
    'R\xc3\xa9union': 'Africa',
    'Saint Helena, Ascension and Tristan da Cunha': 'Africa',
    'Saint Pierre and Miquelon': 'North America',
    'Cura\xc3\xa7ao': 'Central America & Caribbean',
    'Saint Barth\xc3\xa9lemy': 'Central America & Caribbean',
    'Saint Martin': 'Central America & Caribbean',
    'Virgin Islands (U.K.)': 'Central America & Caribbean',
    'Virgin Islands (U.S.)': 'Central America & Caribbean'
  };

  // Infer region from cable landing points (uses country data for accuracy)
  function inferRegionFromLandingPoints(landingPoints, geometry) {
    // Infer ocean-basin corridor from landing point countries
    if (landingPoints && landingPoints.length > 0) {
      const regionSet = new Set();
      landingPoints.forEach(lp => {
        const country = lp.country || '';
        const region = countryToRegion[country];
        if (region) regionSet.add(region);
      });

      const regions = Array.from(regionSet);
      if (regions.length === 0) return 'Unknown';

      const has = r => regions.includes(r);
      const hasEurope = has('Europe');
      const hasNorthAmerica = has('North America');
      const hasCAC = has('Central America & Caribbean');
      const hasSouthAmerica = has('South America');
      const hasAmericas = hasNorthAmerica || hasCAC || hasSouthAmerica;
      const hasEastAsia = has('East Asia');
      const hasSEAsia = has('Southeast Asia');
      const hasAsia = hasEastAsia || hasSEAsia;
      const hasOceania = has('Oceania');
      const hasMiddleEast = has('Middle East');
      const hasAfrica = has('Africa');
      const hasSouthAsia = has('South Asia');

      // Single-region cables = intra-regional
      if (regions.length === 1) {
        if (hasEurope) return 'Intra-Europe';
        if (hasAsia || hasOceania) return 'Intra-Asia';
        if (hasAmericas) return 'Intra-Americas';
        if (hasMiddleEast) return 'Intra-Middle East';
        if (hasAfrica) return 'Africa Coastal';
        if (hasSouthAsia) return 'Indian Ocean';
        return 'Unknown';
      }

      // Multi-region: determine corridor by ocean basin crossed
      // Transpacific: Americas to Asia/Oceania across the Pacific
      if (hasAmericas && (hasAsia || hasOceania)) return 'Transpacific';

      // Transatlantic: Europe to Americas across the Atlantic
      if (hasEurope && hasAmericas) return 'Transatlantic';

      // Indian Ocean: Europe/Middle East to India/Asia, or India-Asia, or Middle East-Africa
      if (hasEurope && (hasAsia || hasSouthAsia || hasMiddleEast)) return 'Indian Ocean';
      if (hasMiddleEast && (hasAsia || hasSouthAsia || hasAfrica)) return 'Indian Ocean';
      if (hasSouthAsia && hasAsia) return 'Indian Ocean';
      if (hasSouthAsia && hasAfrica) return 'Indian Ocean';

      // Africa Coastal: Europe to Africa (Atlantic side, no Asian/ME transit)
      if (hasEurope && hasAfrica && !hasAsia && !hasMiddleEast && !hasSouthAsia) return 'Africa Coastal';

      // Intra-Asia: within Asia + Oceania
      if ((hasAsia || hasOceania) && !hasEurope && !hasAmericas) return 'Intra-Asia';

      // Intra-Americas: within the Americas
      if (hasAmericas && !hasEurope && !hasAsia) return 'Intra-Americas';

      // Intra-Europe: Europe + nearby (e.g. North Africa via Mediterranean)
      if (hasEurope && hasAfrica && !hasAsia && !hasMiddleEast) return 'Intra-Europe';

      return 'Unknown';
    }

    // Fallback: coordinate-based inference (less accurate)
    if (!geometry || !geometry.coordinates) return 'Unknown';
    let coords = geometry.coordinates;
    if (geometry.type === 'MultiLineString' && coords[0] && coords[0][0]) {
      coords = coords[0][0];
    } else if (geometry.type === 'LineString' && coords[0]) {
      coords = coords[0];
    }
    if (!Array.isArray(coords) || coords.length < 2) return 'Unknown';
    const lon = coords[0];
    const lat = coords[1];
    if (lon >= -30 && lon <= 60 && lat >= 35) return 'Intra-Europe';
    if (lon >= 60 && lon <= 150) return 'Intra-Asia';
    if (lon >= 150 || lon <= -150) return 'Transpacific';
    if (lon >= -130 && lon <= -30 && lat >= 15) return 'Intra-Americas';
    return 'Unknown';
  }

  // Reload visor data with new source
  function reloadCableVisorData() {
    cableVisorState.cableDatabase = null;
    // Clear all selected cables from map
    clearAllVisorCables();
    loadCableVisorData();
  }

  function populateCableVisorRegionFilter(db) {
    const select = document.getElementById('cableVisorRegionFilter');
    if (!select || !db || !db.cables) return;

    const regions = new Set();
    Object.values(db.cables).forEach(cable => {
      if (cable.region) regions.add(cable.region);
    });

    const sortedRegions = Array.from(regions).sort();
    select.innerHTML = '<option value="">All Corridors</option>' +
      sortedRegions.map(r => `<option value="${escapeHtml(r)}">${escapeHtml(r)}</option>`).join('');

    console.log('[CableVisor] Regions populated:', sortedRegions.length);
  }

  // ======================
  // CLS Filter: Filter cables by Cable Landing Station, City, or Country
  // ======================

  // Country code to name mapping for display
  const CLS_COUNTRY_NAMES = {
    US:'United States',GB:'United Kingdom',JP:'Japan',AU:'Australia',DE:'Germany',FR:'France',
    BR:'Brazil',IN:'India',CN:'China',SG:'Singapore',HK:'Hong Kong',KR:'South Korea',
    TW:'Taiwan',NZ:'New Zealand',CA:'Canada',MX:'Mexico',CL:'Chile',AR:'Argentina',
    PE:'Peru',CO:'Colombia',IT:'Italy',ES:'Spain',PT:'Portugal',NL:'Netherlands',
    BE:'Belgium',DK:'Denmark',NO:'Norway',SE:'Sweden',FI:'Finland',IE:'Ireland',
    EG:'Egypt',ZA:'South Africa',KE:'Kenya',NG:'Nigeria',AE:'United Arab Emirates',
    SA:'Saudi Arabia',OM:'Oman',QA:'Qatar',MY:'Malaysia',TH:'Thailand',VN:'Vietnam',
    PH:'Philippines',ID:'Indonesia',BD:'Bangladesh',PK:'Pakistan',LK:'Sri Lanka',
    MM:'Myanmar',GR:'Greece',TR:'Turkey',CY:'Cyprus',MT:'Malta',HR:'Croatia',
    IL:'Israel',JO:'Jordan',LB:'Lebanon',GH:'Ghana',SN:'Senegal',DJ:'Djibouti',
    MZ:'Mozambique',TZ:'Tanzania',MG:'Madagascar',MU:'Mauritius',RU:'Russia',
    PL:'Poland',RO:'Romania',BG:'Bulgaria',UA:'Ukraine',IS:'Iceland',FO:'Faroe Islands',
    PA:'Panama',CR:'Costa Rica',GT:'Guatemala',HN:'Honduras',NI:'Nicaragua',
    TT:'Trinidad and Tobago',JM:'Jamaica',BB:'Barbados',CU:'Cuba',DO:'Dominican Republic',
    PR:'Puerto Rico',VI:'US Virgin Islands',GU:'Guam',FJ:'Fiji',PG:'Papua New Guinea',
    NC:'New Caledonia',PF:'French Polynesia',WS:'Samoa',TO:'Tonga',VU:'Vanuatu',
    MV:'Maldives',SC:'Seychelles',RE:'Reunion',YT:'Mayotte',KW:'Kuwait',BH:'Bahrain',
    IR:'Iran',IQ:'Iraq',AT:'Austria',CH:'Switzerland',LU:'Luxembourg',CZ:'Czech Republic',
    SK:'Slovakia',HU:'Hungary',RS:'Serbia',SI:'Slovenia',BA:'Bosnia and Herzegovina',
    ME:'Montenegro',MK:'North Macedonia',AL:'Albania',LT:'Lithuania',LV:'Latvia',EE:'Estonia',
    GE:'Georgia',AZ:'Azerbaijan',EC:'Ecuador',UY:'Uruguay',PY:'Paraguay',VE:'Venezuela',
    BO:'Bolivia',GY:'Guyana',SR:'Suriname',AO:'Angola',CM:'Cameroon',GA:'Gabon',
    CG:'Congo',CD:'DR Congo',CI:'Ivory Coast',GM:'Gambia',GN:'Guinea',SL:'Sierra Leone',
    LR:'Liberia',TG:'Togo',BJ:'Benin',MR:'Mauritania',SO:'Somalia',ER:'Eritrea',
    SD:'Sudan',ET:'Ethiopia',LY:'Libya',TN:'Tunisia',DZ:'Algeria',MA:'Morocco',
    CV:'Cape Verde',ST:'Sao Tome and Principe',KM:'Comoros',YE:'Yemen',BN:'Brunei',
    KH:'Cambodia',LA:'Laos',TL:'Timor-Leste',NP:'Nepal',BT:'Bhutan',AF:'Afghanistan',
    UZ:'Uzbekistan',TM:'Turkmenistan',KZ:'Kazakhstan',KG:'Kyrgyzstan',TJ:'Tajikistan',
    MN:'Mongolia'
  };

  function getCountryName(code) {
    if (!code) return '';
    return CLS_COUNTRY_NAMES[code.toUpperCase()] || code;
  }

  // CLS filter data indices (built once from cable_stations_db)
  const clsFilterData = {
    byName: new Map(),       // stationName -> { lat, lon, city, country, cable_systems }
    byCity: new Map(),       // "city|country" -> [{ name, lat, lon, cable_systems }, ...]
    byCountry: new Map(),    // countryCode -> [{ name, city, lat, lon, cable_systems }, ...]
    built: false
  };

  async function ensureCableStationsLoaded() {
    if (window._dcDatabase && window._dcDatabase.facilities && window._dcDatabase.facilities.some(f => f.facility_type === 'cable_station')) {
      return true;
    }
    try {
      const resp = await fetch('data/cable_stations_db.json');
      if (!resp.ok) return false;
      const csData = await resp.json();
      const csFacilities = csData.facilities || [];
      if (!window._dcDatabase) {
        window._dcDatabase = { facilities: csFacilities, loaded: true };
      } else {
        // Merge cable stations into existing DB, avoiding duplicates
        const existingIds = new Set(window._dcDatabase.facilities.map(f => f.id));
        csFacilities.forEach(f => { if (!existingIds.has(f.id)) window._dcDatabase.facilities.push(f); });
      }
      console.log('[CLS Filter] Loaded cable_stations_db.json:', csFacilities.length, 'stations');
      return true;
    } catch (err) {
      console.warn('[CLS Filter] Failed to load cable_stations_db.json:', err.message);
      return false;
    }
  }

  function buildCLSFilterIndices() {
    if (clsFilterData.built) return;
    const facilities = (window._dcDatabase && window._dcDatabase.facilities) || [];
    if (facilities.length === 0) {
      console.warn('[CLS Filter] No facilities loaded yet');
      return;
    }

    const stations = facilities.filter(f => f.facility_type === 'cable_station' && f.latitude && f.longitude);
    console.log('[CLS Filter] Building indices from', stations.length, 'cable stations');

    stations.forEach(fac => {
      const name = fac.name || `${fac.city || 'Unknown'} CLS`;
      const city = fac.city || '';
      const country = fac.country || '';
      const lat = parseFloat(fac.latitude);
      const lon = parseFloat(fac.longitude);
      const cable_systems = fac.cable_systems || [];

      // By name
      clsFilterData.byName.set(name, { lat, lon, city, country, cable_systems });

      // By city (key = "city|country" for uniqueness)
      const cityKey = `${city.toLowerCase()}|${country.toLowerCase()}`;
      if (city) {
        if (!clsFilterData.byCity.has(cityKey)) {
          clsFilterData.byCity.set(cityKey, { city, country, stations: [] });
        }
        clsFilterData.byCity.get(cityKey).stations.push({ name, lat, lon, cable_systems });
      }

      // By country
      if (country) {
        if (!clsFilterData.byCountry.has(country)) {
          clsFilterData.byCountry.set(country, []);
        }
        clsFilterData.byCountry.get(country).push({ name, city, lat, lon, cable_systems });
      }
    });

    clsFilterData.built = true;
    console.log('[CLS Filter] Indices built:', clsFilterData.byName.size, 'stations,', clsFilterData.byCity.size, 'cities,', clsFilterData.byCountry.size, 'countries');
  }

  // Resolve CLS filter to a set of cable system names
  function resolveCLSCableSystems(mode, key) {
    const cableNames = new Set();
    if (mode === 'station') {
      const station = clsFilterData.byName.get(key);
      if (station) station.cable_systems.forEach(c => cableNames.add(c.toLowerCase()));
    } else if (mode === 'city') {
      const cityData = clsFilterData.byCity.get(key);
      if (cityData) {
        cityData.stations.forEach(s => s.cable_systems.forEach(c => cableNames.add(c.toLowerCase())));
      }
    } else if (mode === 'country') {
      const countryStations = clsFilterData.byCountry.get(key);
      if (countryStations) {
        countryStations.forEach(s => s.cable_systems.forEach(c => cableNames.add(c.toLowerCase())));
      }
    }
    return cableNames;
  }

  // Check if a cable matches the CLS filter cable names set
  function cableMatchesCLSFilter(cable, allowedCableNames) {
    if (!allowedCableNames || allowedCableNames.size === 0) return false;
    const name = (cable.name || '').toLowerCase();
    const shortName = (cable.shortName || '').toLowerCase();
    // Direct match
    if (allowedCableNames.has(name) || allowedCableNames.has(shortName)) return true;
    // Check if any allowed name is contained within cable name or vice versa
    for (const allowed of allowedCableNames) {
      if (name.includes(allowed) || allowed.includes(name)) return true;
      if (shortName && (shortName.includes(allowed) || allowed.includes(shortName))) return true;
      // Handle parenthetical abbreviations: "Asia Pacific Gateway (APG)" matches "apg"
      const parenMatch = name.match(/\(([^)]+)\)/);
      if (parenMatch && parenMatch[1].toLowerCase() === allowed) return true;
    }
    return false;
  }

  // Compute bounding box for CLS filter zoom
  function computeCLSBounds(mode, key) {
    const coords = [];
    if (mode === 'station') {
      const station = clsFilterData.byName.get(key);
      if (station) coords.push([station.lon, station.lat]);
    } else if (mode === 'city') {
      const cityData = clsFilterData.byCity.get(key);
      if (cityData) cityData.stations.forEach(s => coords.push([s.lon, s.lat]));
    } else if (mode === 'country') {
      const countryStations = clsFilterData.byCountry.get(key);
      if (countryStations) countryStations.forEach(s => coords.push([s.lon, s.lat]));
    }
    if (coords.length === 0) return null;
    if (coords.length === 1) return { center: coords[0], zoom: 11 };

    let minLon = Infinity, maxLon = -Infinity, minLat = Infinity, maxLat = -Infinity;
    coords.forEach(([lon, lat]) => {
      if (lon < minLon) minLon = lon;
      if (lon > maxLon) maxLon = lon;
      if (lat < minLat) minLat = lat;
      if (lat > maxLat) maxLat = lat;
    });
    return { bounds: [[minLon, minLat], [maxLon, maxLat]] };
  }

  // Apply CLS filter
  // Automatically switches to full Public Cable System DB so ALL matching cables are shown
  async function applyCLSFilter(mode, key, displayLabel) {
    const cableSystems = resolveCLSCableSystems(mode, key);
    cableVisorState.clsFilter = { mode, key, cableSystems, label: displayLabel };

    // Show active tag
    const tagEl = document.getElementById('cableVisorCLSTag');
    if (tagEl) {
      const modeLabel = mode === 'station' ? 'Station' : mode === 'city' ? 'City' : 'Country';
      tagEl.innerHTML = `<span class="cls-active-tag"><span>${escapeHtml(modeLabel)}: ${escapeHtml(displayLabel)}</span><span class="cls-tag-close" id="btnClearCLSTag">&times;</span></span>`;
      tagEl.style.display = '';
      document.getElementById('btnClearCLSTag')?.addEventListener('click', clearCLSFilter);
    }

    // Hide search wrap, show tag
    const wrapEl = document.getElementById('cableVisorCLSWrap');
    if (wrapEl) wrapEl.style.display = 'none';

    // Close dropdown
    const dropdown = document.getElementById('cableVisorCLSDropdown');
    if (dropdown) dropdown.classList.remove('open');

    // Switch to full Public Cable System DB so user sees ALL matching cables
    const srcAPI = document.getElementById('visorSrcAPI');
    const srcList = document.getElementById('visorSrcList');
    if (srcAPI && srcList) {
      // Remember previous source so we can restore on clear
      if (!cableVisorState._clsPreFilterSource) {
        cableVisorState._clsPreFilterSource = srcList.checked ? 'list' : 'api';
      }
      if (srcList.checked) {
        // Switch to full DB
        srcAPI.checked = true;
        cableVisorState.cableDatabase = null;
        const titleEl = document.getElementById('cableVisorListTitle');
        if (titleEl) titleEl.textContent = 'Cables from Public Cable System DB';
        await loadCableVisorData(true);
        // Re-apply CLS filter after DB reload (loadCableVisorData resets it via initCLSFilter)
        cableVisorState.clsFilter = { mode, key, cableSystems, label: displayLabel };
      }
    }

    // Re-render cable list with filter
    renderCableVisorList();

    // Zoom map
    const map = cableVisorState.map;
    if (map && cableVisorState.mapReady) {
      const boundsInfo = computeCLSBounds(mode, key);
      if (boundsInfo) {
        if (boundsInfo.center) {
          map.flyTo({ center: boundsInfo.center, zoom: boundsInfo.zoom, duration: 1500 });
        } else if (boundsInfo.bounds) {
          map.fitBounds(boundsInfo.bounds, { padding: 60, duration: 1500 });
        }
      }
    }

    console.log('[CLS Filter] Applied:', mode, key, '- matching', cableSystems.size, 'cable systems');
  }

  // Clear CLS filter
  function clearCLSFilter() {
    cableVisorState.clsFilter = null;

    const tagEl = document.getElementById('cableVisorCLSTag');
    if (tagEl) { tagEl.innerHTML = ''; tagEl.style.display = 'none'; }

    const modeSelect = document.getElementById('cableVisorCLSMode');
    if (modeSelect) modeSelect.value = '';

    const wrapEl = document.getElementById('cableVisorCLSWrap');
    if (wrapEl) wrapEl.style.display = 'none';

    const inputEl = document.getElementById('cableVisorCLSInput');
    if (inputEl) inputEl.value = '';

    // Restore previous source if CLS filter switched it
    if (cableVisorState._clsPreFilterSource === 'list') {
      const srcList = document.getElementById('visorSrcList');
      if (srcList && !srcList.checked) {
        srcList.checked = true;
        cableVisorState.cableDatabase = null;
        cableVisorState._clsPreFilterSource = null;
        loadCableVisorData(true);
        return; // loadCableVisorData will call renderCableVisorList
      }
    }
    cableVisorState._clsPreFilterSource = null;

    renderCableVisorList();
  }

  // Populate dropdown items based on mode
  function getCLSDropdownItems(mode) {
    const items = [];
    if (mode === 'station') {
      clsFilterData.byName.forEach((data, name) => {
        const cableCount = data.cable_systems.length;
        items.push({
          key: name,
          label: name,
          sub: `${data.city}${data.country ? ', ' + getCountryName(data.country) : ''}`,
          badge: cableCount > 0 ? `${cableCount} cable${cableCount !== 1 ? 's' : ''}` : '',
          searchText: `${name} ${data.city} ${getCountryName(data.country)} ${data.country}`.toLowerCase()
        });
      });
    } else if (mode === 'city') {
      clsFilterData.byCity.forEach((data, cityKey) => {
        const stationCount = data.stations.length;
        const totalCables = new Set();
        data.stations.forEach(s => s.cable_systems.forEach(c => totalCables.add(c)));
        items.push({
          key: cityKey,
          label: data.city,
          sub: getCountryName(data.country),
          badge: `${stationCount} stn${stationCount !== 1 ? 's' : ''}, ${totalCables.size} cable${totalCables.size !== 1 ? 's' : ''}`,
          searchText: `${data.city} ${getCountryName(data.country)} ${data.country}`.toLowerCase()
        });
      });
    } else if (mode === 'country') {
      clsFilterData.byCountry.forEach((stations, code) => {
        const totalCables = new Set();
        const cities = new Set();
        stations.forEach(s => {
          s.cable_systems.forEach(c => totalCables.add(c));
          if (s.city) cities.add(s.city);
        });
        items.push({
          key: code,
          label: getCountryName(code),
          sub: `${code}`,
          badge: `${stations.length} stn${stations.length !== 1 ? 's' : ''}, ${totalCables.size} cable${totalCables.size !== 1 ? 's' : ''}`,
          searchText: `${getCountryName(code)} ${code}`.toLowerCase()
        });
      });
    }
    items.sort((a, b) => a.label.localeCompare(b.label));
    return items;
  }

  // CLS Filter dropdown rendering and interaction
  let _clsDropdownItems = [];
  let _clsHighlightIdx = -1;

  function renderCLSDropdown(items, query) {
    const dropdown = document.getElementById('cableVisorCLSDropdown');
    if (!dropdown) return;

    const q = (query || '').toLowerCase().trim();
    const filtered = q ? items.filter(it => it.searchText.includes(q)) : items;
    const limited = filtered.slice(0, 50);

    _clsDropdownItems = limited;
    _clsHighlightIdx = -1;

    if (limited.length === 0) {
      dropdown.innerHTML = '<div class="cls-filter-dropdown-hint">No matches found</div>';
      dropdown.classList.add('open');
      return;
    }

    let html = '';
    if (!q && filtered.length > 50) {
      html += '<div class="cls-filter-dropdown-hint">Showing first 50 â€” type to narrow results</div>';
    }
    limited.forEach((item, idx) => {
      html += `<div class="cls-filter-dropdown-item" data-idx="${idx}">
        <span class="cls-item-name">${escapeHtml(item.label)}</span>
        <span class="cls-item-sub">${escapeHtml(item.sub)}</span>
        ${item.badge ? `<span class="cls-item-badge">${escapeHtml(item.badge)}</span>` : ''}
      </div>`;
    });

    dropdown.innerHTML = html;
    dropdown.classList.add('open');

    // Click handlers
    dropdown.querySelectorAll('.cls-filter-dropdown-item').forEach(el => {
      el.addEventListener('click', () => {
        const idx = parseInt(el.dataset.idx);
        const item = _clsDropdownItems[idx];
        if (item) {
          const mode = document.getElementById('cableVisorCLSMode')?.value;
          applyCLSFilter(mode, item.key, item.label);
        }
      });
    });
  }

  function highlightCLSDropdownItem(idx) {
    const dropdown = document.getElementById('cableVisorCLSDropdown');
    if (!dropdown) return;
    dropdown.querySelectorAll('.cls-filter-dropdown-item').forEach(el => el.classList.remove('highlighted'));
    if (idx >= 0 && idx < _clsDropdownItems.length) {
      const el = dropdown.querySelector(`[data-idx="${idx}"]`);
      if (el) {
        el.classList.add('highlighted');
        el.scrollIntoView({ block: 'nearest' });
      }
    }
  }

  // Initialize CLS Filter event listeners
  let _clsFilterInitialized = false;
  async function initCLSFilter() {
    if (_clsFilterInitialized) return;
    _clsFilterInitialized = true;

    // Ensure cable stations DB is loaded before building indices
    await ensureCableStationsLoaded();
    buildCLSFilterIndices();

    const modeSelect = document.getElementById('cableVisorCLSMode');
    const wrapEl = document.getElementById('cableVisorCLSWrap');
    const inputEl = document.getElementById('cableVisorCLSInput');
    const dropdown = document.getElementById('cableVisorCLSDropdown');

    if (!modeSelect || !wrapEl || !inputEl || !dropdown) return;

    let _allItems = [];
    let _debounceTimer = null;

    // Mode change
    modeSelect.addEventListener('change', () => {
      const mode = modeSelect.value;
      // Clear any active filter when changing mode
      if (cableVisorState.clsFilter) clearCLSFilter();
      // Restore mode selection since clearCLSFilter resets it
      modeSelect.value = mode;

      if (!mode) {
        wrapEl.style.display = 'none';
        return;
      }

      // Ensure indices are built
      buildCLSFilterIndices();

      const placeholders = {
        station: 'Search station name...',
        city: 'Search city...',
        country: 'Search country...'
      };
      inputEl.placeholder = placeholders[mode] || 'Search...';
      inputEl.value = '';
      wrapEl.style.display = '';

      _allItems = getCLSDropdownItems(mode);
      renderCLSDropdown(_allItems, '');
      inputEl.focus();
    });

    // Search input
    inputEl.addEventListener('input', () => {
      clearTimeout(_debounceTimer);
      _debounceTimer = setTimeout(() => {
        renderCLSDropdown(_allItems, inputEl.value);
      }, 120);
    });

    inputEl.addEventListener('focus', () => {
      if (_allItems.length > 0) {
        renderCLSDropdown(_allItems, inputEl.value);
      }
    });

    // Keyboard navigation
    inputEl.addEventListener('keydown', (e) => {
      if (!dropdown.classList.contains('open')) return;

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        _clsHighlightIdx = Math.min(_clsHighlightIdx + 1, _clsDropdownItems.length - 1);
        highlightCLSDropdownItem(_clsHighlightIdx);
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        _clsHighlightIdx = Math.max(_clsHighlightIdx - 1, 0);
        highlightCLSDropdownItem(_clsHighlightIdx);
      } else if (e.key === 'Enter') {
        e.preventDefault();
        if (_clsHighlightIdx >= 0 && _clsHighlightIdx < _clsDropdownItems.length) {
          const item = _clsDropdownItems[_clsHighlightIdx];
          const mode = modeSelect.value;
          applyCLSFilter(mode, item.key, item.label);
        }
      } else if (e.key === 'Escape') {
        dropdown.classList.remove('open');
        inputEl.blur();
      }
    });

    // Click outside to close
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.cls-filter-wrap')) {
        dropdown.classList.remove('open');
      }
    });

    console.log('[CLS Filter] Initialized');
  }

  function renderCableVisorList() {
    const listEl = document.getElementById('cableVisorCableList');
    const countEl = document.getElementById('cableVisorCableCount');
    const selectedCountEl = document.getElementById('cableVisorSelectedCount');

    if (!listEl) return;

    if (!cableVisorState.cableDatabase || !cableVisorState.cableDatabase.cables) {
      listEl.innerHTML = '<div style="padding:20px; text-align:center; color:#666;">No cable data available</div>';
      return;
    }

    const db = cableVisorState.cableDatabase;
    const search = (document.getElementById('cableVisorSearch')?.value || '').toLowerCase().trim();
    const regionFilter = document.getElementById('cableVisorRegionFilter')?.value || '';

    // Filter cables
    let cables = Object.values(db.cables).filter(cable => {
      if (regionFilter && cable.region !== regionFilter) return false;
      if (search) {
        const name = (cable.name || '').toLowerCase();
        const shortName = (cable.shortName || '').toLowerCase();
        const owners = (cable.owners || []).join(' ').toLowerCase();
        if (!(name.includes(search) || shortName.includes(search) || owners.includes(search))) return false;
      }
      // CLS filter
      if (cableVisorState.clsFilter && cableVisorState.clsFilter.cableSystems) {
        if (!cableMatchesCLSFilter(cable, cableVisorState.clsFilter.cableSystems)) return false;
      }
      return true;
    });

    // Sort by name
    cables.sort((a, b) => (a.shortName || a.name || '').localeCompare(b.shortName || b.name || ''));

    // Generate cable colors deterministically
    function getCableColor(id) {
      const colors = ['#e63946', '#f4a261', '#2a9d8f', '#264653', '#8338ec', '#3a86ff', '#ff006e', '#fb5607', '#06d6a0', '#118ab2'];
      let hash = 0;
      for (let i = 0; i < id.length; i++) hash = ((hash << 5) - hash) + id.charCodeAt(i);
      return colors[Math.abs(hash) % colors.length];
    }

    // Get status class â€” status is already computed by loadFromTeleGeographyAPI
    function getStatusClass(cable) {
      if (cable.status === 'decommissioned') return 'decommissioned';
      if (cable.status === 'operational') return 'operational';
      if (cable.status === 'under-construction') return 'under-construction';
      if (cable.status === 'planned') return 'planned';
      if (cable.status === 'unknown') return 'unknown';
      return 'unknown';
    }

    // Build debug tooltip for status
    function getStatusTooltip(cable) {
      const parts = [`Status: ${cable.status}`];
      if (cable.rfsYear) parts.push(`RFS: ${cable.rfsYear}`);
      if (cable._statusSource) parts.push(`Source: ${cable._statusSource}`);
      if (cable._faMatchName) parts.push(`FA Match: ${cable._faMatchName}`);
      if (cable._faStatus) parts.push(`FA Status: ${cable._faStatus}`);
      return parts.join('\n');
    }

    let html = '';
    cables.forEach(cable => {
      const isSelected = cableVisorState.selectedCables.has(String(cable.id));
      const color = getCableColor(cable.id);
      const statusClass = getStatusClass(cable);
      const statusTooltip = getStatusTooltip(cable);
      // Show RFS year if numeric, otherwise show status label
      let rfsDisplay = '';
      if (cable.rfsYear) {
        rfsDisplay = `RFS ${cable.rfsYear}`;
      } else if (cable.status === 'decommissioned') {
        rfsDisplay = 'Decommissioned';
      } else if (cable.status === 'operational') {
        rfsDisplay = 'Active';
      } else if (cable.status === 'under-construction') {
        rfsDisplay = 'Under Construction';
      } else if (cable.status === 'planned') {
        rfsDisplay = 'Planned';
      } else {
        rfsDisplay = 'Unknown';
      }
      const length = cable.length_km ? `${Math.round(cable.length_km).toLocaleString()} km` : '';
      const hasGeometry = cable.geometry && cable.geometry.coordinates;

      // FA cross-check indicator for current-year RFS cables only
      const currentYear = new Date().getFullYear();
      let faIndicator = '';
      if (cable.rfsYear === currentYear) {
        if (cable._faStatus === 'online' || cable._faStatus === 'active') {
          faIndicator = '<span style="color:#22c55e;font-size:9px;font-weight:600;margin-left:4px;" title="Live Status confirms ONLINE">âœ“LS</span>';
        } else if (cable._faStatus) {
          faIndicator = `<span style="color:#f59e0b;font-size:9px;font-weight:600;margin-left:4px;" title="Live Status: ${escapeHtml(cable._faStatus)}">â³LS</span>`;
        } else {
          faIndicator = '<span style="color:#94a3b8;font-size:9px;margin-left:4px;" title="No Live Status match found">?LS</span>';
        }
      }

      html += `
        <div class="visor-cable-item ${isSelected ? 'selected' : ''}" data-cable-id="${cable.id}" title="${escapeHtml(statusTooltip)}">
          <input type="checkbox" ${isSelected ? 'checked' : ''} />
          <span class="cs-status-badge ${statusClass}"></span>
          <div class="cable-color" style="background:${color};"></div>
          <div class="visor-cable-info">
            <div class="visor-cable-name">${escapeHtml(cable.shortName || cable.name)}${faIndicator}</div>
            <div class="visor-cable-meta">${rfsDisplay}${length ? ' â€¢ ' + length : ''}${cable.rfsYear === currentYear && cable._statusSource ? ' â€¢ ' + escapeHtml(cable._statusSource) : ''}${!hasGeometry ? ' â€¢ No map data' : ''}</div>
          </div>
        </div>
      `;
    });

    if (!html) {
      // Build informative no-results message showing which filters are active
      let noResultsMsg = '<div style="padding:20px; text-align:center;">';
      noResultsMsg += '<div style="color:#f59e0b; font-size:18px; margin-bottom:8px;">No cables match current filters</div>';
      const activeFilters = [];
      if (cableVisorState.clsFilter && cableVisorState.clsFilter.label) {
        activeFilters.push('Cable Station filter: <b>' + escapeHtml(cableVisorState.clsFilter.label) + '</b>');
      }
      if (regionFilter) activeFilters.push('Region: <b>' + escapeHtml(regionFilter) + '</b>');
      if (search) activeFilters.push('Search: <b>' + escapeHtml(search) + '</b>');
      if (activeFilters.length > 0) {
        noResultsMsg += '<div style="color:#666; font-size:12px; margin-bottom:12px;">Active filters:<br>' + activeFilters.join('<br>') + '</div>';
        noResultsMsg += '<div style="color:#888; font-size:11px;">Try removing or changing filters to see results.</div>';
      } else {
        noResultsMsg += '<div style="color:#666; font-size:12px;">No cable data available.</div>';
      }
      noResultsMsg += '</div>';
      listEl.innerHTML = noResultsMsg;
    } else {
      listEl.innerHTML = html;
    }

    // Update counts
    if (countEl) countEl.textContent = `${cables.length} cables`;
    if (selectedCountEl) selectedCountEl.textContent = `${cableVisorState.selectedCables.size} selected`;

    // Add click handlers
    listEl.querySelectorAll('.visor-cable-item').forEach(item => {
      item.addEventListener('click', (e) => {
        if (e.target.type === 'checkbox') return; // Let checkbox handle itself
        const cableId = item.dataset.cableId;
        toggleCableVisorSelection(cableId);
        // Show detail panel for this cable
        showVisorCableDetail(cableId);
      });

      // Checkbox change
      const checkbox = item.querySelector('input[type="checkbox"]');
      if (checkbox) {
        checkbox.addEventListener('change', (e) => {
          e.stopPropagation();
          const cableId = item.dataset.cableId;
          toggleCableVisorSelection(cableId);
          showVisorCableDetail(cableId);
        });
      }

      item.addEventListener('dblclick', (e) => {
        const cableId = item.dataset.cableId;
        // Select and zoom to cable
        if (!cableVisorState.selectedCables.has(cableId)) {
          toggleCableVisorSelection(cableId);
        }
        zoomToCable(cableId);
      });
    });
  }

  function toggleCableVisorSelection(cableId) {
    if (cableVisorState.selectedCables.has(cableId)) {
      cableVisorState.selectedCables.delete(cableId);
    } else {
      cableVisorState.selectedCables.add(cableId);
    }
    rebuildVisorMapSource();
    renderCableVisorList();
  }

  // Unified GeoJSON source approach: all selected cables in ONE source + ONE layer.
  // This mirrors how SubmarineCableMap.com renders all 700+ cables without freezing:
  // a single data layer with data-driven styling, instead of per-cable sources/layers.
  const VISOR_SOURCE_ID = 'cable-visor-all';
  const VISOR_LINE_LAYER_ID = 'cable-visor-lines';
  const VISOR_HIT_LAYER_ID = 'cable-visor-hit';

  function rebuildVisorMapSource() {
    const map = cableVisorState.map;
    if (!map || !cableVisorState.mapReady) return;

    const db = cableVisorState.cableDatabase;
    if (!db || !db.cables) return;

    // Build FeatureCollection from all selected cables
    const features = [];
    cableVisorState.selectedCables.forEach(cableId => {
      const cable = db.cables[cableId];
      if (!cable || !cable.geometry || !cable.geometry.coordinates) return;

      features.push({
        type: 'Feature',
        properties: {
          id: cableId,
          name: cable.name || cable.shortName || 'Unknown',
          color: getCableColorById(cableId)
        },
        geometry: cable.geometry
      });
    });

    const featureCollection = {
      type: 'FeatureCollection',
      features: features
    };

    try {
      // If source exists, just update its data (fast â€” no layer recreation)
      if (map.getSource(VISOR_SOURCE_ID)) {
        map.getSource(VISOR_SOURCE_ID).setData(featureCollection);
      } else {
        // First time: create source + layers once
        map.addSource(VISOR_SOURCE_ID, {
          type: 'geojson',
          data: featureCollection
        });

        // Visible cable line layer with data-driven color from feature properties
        map.addLayer({
          id: VISOR_LINE_LAYER_ID,
          type: 'line',
          source: VISOR_SOURCE_ID,
          paint: {
            'line-color': ['get', 'color'],
            'line-width': 3,
            'line-opacity': 0.85
          }
        });

        // Invisible wider hit-area layer for easier hover detection
        map.addLayer({
          id: VISOR_HIT_LAYER_ID,
          type: 'line',
          source: VISOR_SOURCE_ID,
          paint: {
            'line-color': 'transparent',
            'line-width': 16,
            'line-opacity': 0
          }
        });
      }

      console.log('[CableVisor] Map source updated:', features.length, 'cables');
    } catch (err) {
      console.error('[CableVisor] Error updating map source:', err);
    }

    // Update labels and stations if those display modes are active
    if (typeof cableVisorDisplayState !== 'undefined') {
      if (cableVisorDisplayState.fixNames) updateFixedCableLabels();
      if (cableVisorDisplayState.showStations) updateStationMarkers();
    }
  }

  // Legacy wrappers kept for compatibility with showCableSystemInVisor etc.
  function addCableToVisorMap(cableId) {
    // Just rebuild the unified source â€” no per-cable layers
    rebuildVisorMapSource();
  }

  function removeCableFromVisorMap(cableId) {
    // Just rebuild the unified source â€” no per-cable layers
    rebuildVisorMapSource();
  }

  function zoomToCable(cableId) {
    const map = cableVisorState.map;
    const db = cableVisorState.cableDatabase;
    if (!map || !cableVisorState.mapReady || !db || !db.cables || !db.cables[cableId]) return;

    const cable = db.cables[cableId];
    if (!cable.geometry || !cable.geometry.coordinates) return;

    // Calculate bounds
    let coords = [];
    if (cable.geometry.type === 'MultiLineString') {
      cable.geometry.coordinates.forEach(line => coords.push(...line));
    } else if (cable.geometry.type === 'LineString') {
      coords = cable.geometry.coordinates;
    }

    if (coords.length === 0) return;

    let minLon = Infinity, maxLon = -Infinity, minLat = Infinity, maxLat = -Infinity;
    coords.forEach(coord => {
      const [lon, lat] = coord;
      if (lon < minLon) minLon = lon;
      if (lon > maxLon) maxLon = lon;
      if (lat < minLat) minLat = lat;
      if (lat > maxLat) maxLat = lat;
    });

    map.fitBounds([[minLon, minLat], [maxLon, maxLat]], { padding: 50, duration: 1000 });
  }

  const VISOR_SELECT_ALL_WARN_THRESHOLD = 100;

  function selectAllVisorCables() {
    const db = cableVisorState.cableDatabase;
    if (!db || !db.cables) return;

    // Collect matching cables
    const search = (document.getElementById('cableVisorSearch')?.value || '').toLowerCase().trim();
    const regionFilter = document.getElementById('cableVisorRegionFilter')?.value || '';

    const cablesToAdd = [];
    Object.values(db.cables).forEach(cable => {
      if (regionFilter && cable.region !== regionFilter) return;
      if (search) {
        const name = (cable.name || '').toLowerCase();
        const shortName = (cable.shortName || '').toLowerCase();
        if (!name.includes(search) && !shortName.includes(search)) return;
      }
      // CLS filter
      if (cableVisorState.clsFilter && cableVisorState.clsFilter.cableSystems) {
        if (!cableMatchesCLSFilter(cable, cableVisorState.clsFilter.cableSystems)) return;
      }
      if (!cableVisorState.selectedCables.has(String(cable.id))) {
        cablesToAdd.push(String(cable.id));
      }
    });

    if (cablesToAdd.length === 0) {
      showToast('All matching cables are already selected.');
      return;
    }

    // Soft warning for large selections (no hard cap â€” unified source handles all)
    if (cablesToAdd.length >= VISOR_SELECT_ALL_WARN_THRESHOLD) {
      if (!confirm(`Display ${cablesToAdd.length} cables on the map?\n\nTip: Use region or station filters to narrow your selection.`)) {
        return;
      }
    }

    // Add all at once to the selection set, then rebuild source once
    cablesToAdd.forEach(id => cableVisorState.selectedCables.add(id));
    rebuildVisorMapSource();
    renderCableVisorList();
  }

  function clearAllVisorCables() {
    cableVisorState.selectedCables.clear();
    rebuildVisorMapSource();
    renderCableVisorList();
  }

  // Show cable in visor from Cable System List selection
  function showCableSystemInVisor(csId) {
    const cs = findCableSystem(csId);
    if (!cs) return;

    // Open visor if not open
    const panel = document.getElementById('cableVisorPanel');
    if (!panel?.classList.contains('show')) {
      showCableVisor();
    }

    // Try to find matching cable in database by name
    setTimeout(() => {
      if (!cableVisorState.cableDatabase) return;

      const db = cableVisorState.cableDatabase;
      const csName = (cs.name || '').toLowerCase();
      const csShortName = (cs.shortName || '').toLowerCase();

      // Find matching cable
      let matchingCable = null;
      for (const [id, cable] of Object.entries(db.cables)) {
        const cableName = (cable.name || '').toLowerCase();
        const cableShortName = (cable.shortName || '').toLowerCase();
        if (cableName === csName || cableShortName === csShortName ||
            cableName.includes(csShortName) || cableShortName.includes(csShortName)) {
          matchingCable = cable;
          break;
        }
      }

      if (matchingCable) {
        // Select it in the visor
        if (!cableVisorState.selectedCables.has(String(matchingCable.id))) {
          toggleCableVisorSelection(String(matchingCable.id));
        }
        // Zoom to it
        setTimeout(() => zoomToCable(String(matchingCable.id)), 500);

        // Update search to show it
        const searchEl = document.getElementById('cableVisorSearch');
        if (searchEl) {
          searchEl.value = matchingCable.shortName || matchingCable.name;
          renderCableVisorList();
        }
      } else {
        showToast(`Cable "${cs.shortName}" not found in database`, 'warning');
      }
    }, 300);
  }

  // Make Cable Visor draggable
  // Initialize Cable Visor draggable - called when visor is first shown
  let cableVisorDraggableInitialized = false;
  function initCableVisorDraggable() {
    if (cableVisorDraggableInitialized) return;

    const panel = document.getElementById('cableVisorPanel');
    const header = document.getElementById('cableVisorHeader');
    if (!panel || !header) {
      console.log('[CableVisor] Draggable init failed - elements not found');
      return;
    }

    let isDragging = false;
    let startX, startY, startLeft, startTop;

    header.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'BUTTON') return;
      isDragging = true;
      const rect = panel.getBoundingClientRect();
      startX = e.clientX;
      startY = e.clientY;
      startLeft = rect.left;
      startTop = rect.top;
      panel.style.transition = 'none';
      panel.style.right = 'auto'; // Remove right positioning to allow left to work
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      panel.style.left = Math.max(0, startLeft + dx) + 'px';
      panel.style.top = Math.max(0, startTop + dy) + 'px';
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        panel.style.transition = '';
      }
    });

    cableVisorDraggableInitialized = true;
    console.log('[CableVisor] Draggable initialized');
  }

  // Initialize Cable Visor event handlers (called after DOM ready)
  function initCableVisorEventHandlers() {
    const closeBtn = document.getElementById('btnCableVisorClose');
    const maxBtn = document.getElementById('btnCableVisorMaximize');
    const presBtn = document.getElementById('btnCableVisorPresentation');
    const openBtn = document.getElementById('btnOpenCableVisor');
    const selectAllBtn = document.getElementById('btnVisorSelectAll');
    const clearAllBtn = document.getElementById('btnVisorClearAll');
    const searchInput = document.getElementById('cableVisorSearch');
    const regionFilter = document.getElementById('cableVisorRegionFilter');

    // Source toggle radio buttons
    const srcList = document.getElementById('visorSrcList');
    const srcAPI = document.getElementById('visorSrcAPI');

    if (openBtn) openBtn.addEventListener('click', showCableVisor);
    if (closeBtn) closeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      hideCableVisor();
    });
    if (maxBtn) maxBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleCableVisorMaximize();
    });
    if (presBtn) presBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleCableVisorPresentation();
    });
    if (selectAllBtn) selectAllBtn.addEventListener('click', selectAllVisorCables);
    if (clearAllBtn) clearAllBtn.addEventListener('click', clearAllVisorCables);
    if (searchInput) searchInput.addEventListener('input', () => renderCableVisorList());
    if (regionFilter) regionFilter.addEventListener('change', () => renderCableVisorList());

    // Map style selector handler
    const visorMapStyleSelect = document.getElementById('cableVisorMapStyle');
    if (visorMapStyleSelect) {
      visorMapStyleSelect.addEventListener('change', () => {
        changeCableVisorMapStyle(visorMapStyleSelect.value);
      });
      // Restore saved preference
      try {
        const savedVisorStyle = localStorage.getItem('neximap-visor-map-style');
        if (savedVisorStyle && cableVisorMapStyles[savedVisorStyle]) {
          visorMapStyleSelect.value = savedVisorStyle;
          cableVisorState.mapStyle = savedVisorStyle;
        }
      } catch(e) {}
    }

    // Source toggle handlers - reload data when source changes
    if (srcList) srcList.addEventListener('change', () => {
      if (srcList.checked) {
        cableVisorState.cableDatabase = null; // Clear cache
        if (cableVisorState.clsFilter) clearCLSFilter();
        loadCableVisorData(true);
      }
    });
    if (srcAPI) srcAPI.addEventListener('change', () => {
      if (srcAPI.checked) {
        cableVisorState.cableDatabase = null;
        if (cableVisorState.clsFilter) clearCLSFilter();
        loadCableVisorData(true);
      }
    });

    // Refresh from API button â€” fetches live data instead of local file
    const refreshBtn = document.getElementById('btnVisorRefreshAPI');
    if (refreshBtn) refreshBtn.addEventListener('click', async () => {
      refreshBtn.disabled = true;
      refreshBtn.textContent = 'â³ Fetching...';
      try {
        cableVisorState.cableDatabase = null;
        clearAllVisorCables();
        const db = await loadFromTeleGeographyAPI();
        if (db && db.cables) {
          cableVisorState.cableDatabase = db;
          populateCableVisorRegionFilter(db);
          renderCableVisorList();
        }
      } catch (err) {
        const listEl = document.getElementById('cableVisorCableList');
        if (listEl) listEl.innerHTML = '<div style="padding:20px; text-align:center; color:#c00;">API refresh failed: ' + err.message + '</div>';
      }
      refreshBtn.disabled = false;
      refreshBtn.textContent = 'ðŸ”„ Refresh from API';
    });

    console.log('[CableVisor] Event handlers initialized');
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCableVisorEventHandlers);
  } else {
    initCableVisorEventHandlers();
  }

  // ======================
  // Cable Visor Hover Tooltips, Labels & Stations
  // ======================
  // State for cable visor display options
  const cableVisorDisplayState = {
    showNames: false,       // Hover tooltip enabled (always true when names visible)
    fixNames: false,        // Pin cable names permanently on map
    showStations: false,    // Show landing station markers
    fixStationNames: false, // Pin station names permanently on map
    stationMarkers: [],     // MapLibre marker references for stations
    stationPopup: null,     // Reusable hover popup for stations
    fixedLabels: [],        // MapLibre marker references for fixed cable name labels
    fixedStationLabels: [], // MapLibre marker references for fixed station name labels
    tooltip: null           // DOM element for hover tooltip
  };

  // Create or get the hover tooltip element for the cable visor map
  function getVisorTooltip() {
    if (!cableVisorDisplayState.tooltip) {
      const el = document.createElement('div');
      el.className = 'visor-map-tooltip';
      el.style.display = 'none';
      const container = document.getElementById('cableVisorMap');
      if (container) container.appendChild(el);
      cableVisorDisplayState.tooltip = el;
    }
    return cableVisorDisplayState.tooltip;
  }

  // Setup hover events on the cable visor map (called after map loads)
  // Uses the unified source layers (VISOR_HIT_LAYER_ID / VISOR_LINE_LAYER_ID)
  // instead of querying N individual layers â€” fast regardless of cable count.
  function setupCableVisorHoverEvents() {
    const map = cableVisorState.map;
    if (!map) return;

    map.on('mousemove', (e) => {
      const layers = [];
      if (map.getLayer(VISOR_HIT_LAYER_ID)) layers.push(VISOR_HIT_LAYER_ID);
      if (map.getLayer(VISOR_LINE_LAYER_ID)) layers.push(VISOR_LINE_LAYER_ID);
      if (layers.length === 0) return;

      const features = map.queryRenderedFeatures(
        [[e.point.x - 6, e.point.y - 6], [e.point.x + 6, e.point.y + 6]],
        { layers: layers }
      );

      const tooltip = getVisorTooltip();
      if (features.length > 0) {
        const name = features[0].properties.name || 'Unknown Cable';
        tooltip.textContent = name;
        tooltip.style.display = 'block';
        tooltip.style.left = e.point.x + 'px';
        tooltip.style.top = e.point.y + 'px';
        map.getCanvas().style.cursor = 'pointer';
      } else {
        tooltip.style.display = 'none';
        map.getCanvas().style.cursor = '';
      }
    });

    map.on('mouseleave', () => {
      const tooltip = getVisorTooltip();
      tooltip.style.display = 'none';
    });

    console.log('[CableVisor] Hover events set up (unified source)');
  }

  // Calculate midpoint of a cable geometry for label placement
  function getCableMidpoint(geometry, position) {
    if (!geometry || !geometry.coordinates) return null;
    if (position === undefined) position = 0.5;

    let coords = [];
    if (geometry.type === 'MultiLineString') {
      // Use the longest segment
      let longest = geometry.coordinates[0] || [];
      geometry.coordinates.forEach(seg => { if (seg.length > longest.length) longest = seg; });
      coords = longest;
    } else if (geometry.type === 'LineString') {
      coords = geometry.coordinates;
    }

    if (coords.length === 0) return null;
    const idx = Math.min(Math.floor(coords.length * Math.max(0, Math.min(1, position))), coords.length - 1);
    const pt = coords[idx];
    return pt ? [pt[0], pt[1]] : null;
  }

  // Update fixed cable name labels on the map
  function updateFixedCableLabels() {
    const map = cableVisorState.map;
    if (!map || !cableVisorState.mapReady) return;

    // Remove existing labels
    cableVisorDisplayState.fixedLabels.forEach(m => m.remove());
    cableVisorDisplayState.fixedLabels = [];

    if (!cableVisorDisplayState.fixNames) return;

    const db = cableVisorState.cableDatabase;
    if (!db || !db.cables) return;

    const cableIds = Array.from(cableVisorState.selectedCables);
    const cableCount = cableIds.length;

    cableIds.forEach((cableId, index) => {
      const cable = db.cables[cableId];
      if (!cable || !cable.geometry) return;

      // Distribute labels along cable: spread between 30%-70% of the line to reduce overlap
      const position = cableCount <= 1 ? 0.5 : 0.3 + (0.4 * index / (cableCount - 1));
      const midpoint = getCableMidpoint(cable.geometry, position);
      if (!midpoint) return;

      const el = document.createElement('div');
      el.className = 'visor-fixed-label';
      el.textContent = cable.shortName || cable.name;
      el.style.borderLeft = `3px solid ${getCableColorById(cableId)}`;

      const marker = new maplibregl.Marker({ element: el, anchor: 'bottom', draggable: true })
        .setLngLat(midpoint)
        .addTo(map);

      cableVisorDisplayState.fixedLabels.push(marker);
    });
  }

  // Get cable color by ID (same hash logic as renderCableVisorList)
  function getCableColorById(cableId) {
    const colors = ['#e63946', '#f4a261', '#2a9d8f', '#264653', '#8338ec', '#3a86ff', '#ff006e', '#fb5607', '#06d6a0', '#118ab2'];
    let hash = 0;
    const id = String(cableId);
    for (let i = 0; i < id.length; i++) hash = ((hash << 5) - hash) + id.charCodeAt(i);
    return colors[Math.abs(hash) % colors.length];
  }

  // Update station/landing point markers on the map
  function updateStationMarkers() {
    const map = cableVisorState.map;
    if (!map || !cableVisorState.mapReady) return;

    // Remove existing station markers
    cableVisorDisplayState.stationMarkers.forEach(m => m.remove());
    cableVisorDisplayState.stationMarkers = [];
    cableVisorDisplayState.fixedStationLabels.forEach(m => m.remove());
    cableVisorDisplayState.fixedStationLabels = [];

    if (!cableVisorDisplayState.showStations) return;

    const db = cableVisorState.cableDatabase;
    if (!db || !db.cables) return;

    // Collect all landing points from selected cables
    const stationMap = new Map(); // dedup by name+coords

    cableVisorState.selectedCables.forEach(cableId => {
      const cable = db.cables[cableId];
      if (!cable) return;

      // Collect landing points with coordinates
      const lps = cable.landingPoints || [];
      let hasCoordLPs = false;

      lps.forEach(lp => {
        // Support multiple coordinate formats:
        // { lat, lon } or { coordinates: [lon, lat] }
        let lat = lp.lat, lon = lp.lon;
        if (!lat && lp.coordinates && Array.isArray(lp.coordinates)) {
          lon = lp.coordinates[0];
          lat = lp.coordinates[1];
        }
        if (!lat || !lon) return;
        hasCoordLPs = true;
        lat = parseFloat(lat);
        lon = parseFloat(lon);
        const key = `${lat.toFixed(3)}_${lon.toFixed(3)}`;
        if (!stationMap.has(key)) {
          stationMap.set(key, {
            name: lp.name || 'Unknown Station',
            country: lp.country || '',
            lat: lat,
            lon: lon,
            cables: [cable.shortName || cable.name]
          });
        } else {
          const existing = stationMap.get(key);
          if (!existing.cables.includes(cable.shortName || cable.name)) {
            existing.cables.push(cable.shortName || cable.name);
          }
        }
      });

      // If landing points have no coordinates, resolve them from cable_stations_db
      // (the same database used by the DC Visor, which has accurate lat/lon for
      // 1241 cable stations). This replaces the old approach of matching stations
      // to geometry endpoints by sequential order, which produced wrong positions
      // when the API list order didn't match geographic order (e.g. FALCON).
      if (!hasCoordLPs && lps.length > 0) {
        const cableName = cable.shortName || cable.name;
        const fullCableName = cable.name || '';
        const namedLPs = lps.filter(lp => lp.name);

        // Use cable stations database (window._dcDatabase) for accurate coordinates
        const dbFacilities = (window._dcDatabase && window._dcDatabase.facilities) || [];

        namedLPs.forEach(lp => {
          const lpCity = (lp.name || '').toLowerCase().trim();
          const lpCountry = (lp.country || '').toLowerCase().trim();

          // Strategy 1: cable_station whose cable_systems includes this cable AND city matches
          let match = dbFacilities.find(fac => {
            if (!fac.latitude || !fac.longitude) return false;
            if (fac.facility_type !== 'cable_station') return false;
            const facCables = (fac.cable_systems || []).map(c => c.toLowerCase());
            const cableNameLow = fullCableName.toLowerCase();
            if (!facCables.some(c => c === cableNameLow || cableNameLow.includes(c) || c.includes(cableNameLow))) return false;
            const facCity = (fac.city || '').toLowerCase().trim();
            return facCity === lpCity || lpCity.includes(facCity) || facCity.includes(lpCity);
          });

          // Strategy 2: any cable_station matching city + country
          if (!match) {
            match = dbFacilities.find(fac => {
              if (!fac.latitude || !fac.longitude) return false;
              if (fac.facility_type !== 'cable_station') return false;
              const facCity = (fac.city || '').toLowerCase().trim();
              if (!(facCity === lpCity || lpCity.includes(facCity) || facCity.includes(lpCity))) return false;
              if (lpCountry) {
                const facCountry = (fac.country || '').toLowerCase().trim();
                return lpCountry.includes(facCountry) || facCountry.includes(lpCountry);
              }
              return true;
            });
          }

          if (match) {
            const lat = parseFloat(match.latitude);
            const lon = parseFloat(match.longitude);
            const key = `${lat.toFixed(3)}_${lon.toFixed(3)}`;
            if (!stationMap.has(key)) {
              stationMap.set(key, {
                name: lp.name,
                country: lp.country || match.country || '',
                lat: lat,
                lon: lon,
                cables: [cableName]
              });
            } else {
              const existing = stationMap.get(key);
              if (!existing.cables.includes(cableName)) {
                existing.cables.push(cableName);
              }
            }
          }
          // If no DB match found, skip rather than guess from geometry endpoints
          // (wrong position is worse than no marker)
        });
      }
    });

    // Create markers for each station
    let stationIdx = 0;
    stationMap.forEach((station, key) => {
      // Station marker dot
      const el = document.createElement('div');
      el.style.cssText = 'width:10px; height:10px; border-radius:50%; background:#e63946; border:2px solid white; box-shadow:0 1px 4px rgba(0,0,0,0.4); cursor:pointer;';

      const marker = new maplibregl.Marker({ element: el, anchor: 'center' })
        .setLngLat([station.lon, station.lat])
        .addTo(map);

      // Hover tooltip for station
      const popup = new maplibregl.Popup({
        closeButton: false,
        closeOnClick: false,
        offset: 10,
        className: 'visor-station-popup'
      });

      el.addEventListener('mouseenter', () => {
        const cablesText = station.cables.length > 1
          ? `<br><span style="font-size:10px;color:#94a3b8;">Cables: ${station.cables.join(', ')}</span>`
          : '';
        popup.setLngLat([station.lon, station.lat])
          .setHTML(`<strong>${escapeHtml(station.name)}</strong>${station.country ? ', ' + escapeHtml(station.country) : ''}${cablesText}`)
          .addTo(map);
      });

      el.addEventListener('mouseleave', () => {
        popup.remove();
      });

      cableVisorDisplayState.stationMarkers.push(marker);

      // Fixed station name labels
      if (cableVisorDisplayState.fixStationNames) {
        const labelEl = document.createElement('div');
        labelEl.className = 'visor-fixed-label';
        labelEl.textContent = station.name;
        labelEl.style.borderLeft = '3px solid #e63946';
        labelEl.style.fontSize = '9px';

        // Alternate anchor direction to reduce overlap when stations are near each other
        const anchors = ['left', 'right', 'top', 'bottom'];
        const offsets = [[8, 0], [-8, 0], [0, -8], [0, 8]];
        const aIdx = stationIdx % anchors.length;

        const labelMarker = new maplibregl.Marker({ element: labelEl, anchor: anchors[aIdx], offset: offsets[aIdx], draggable: true })
          .setLngLat([station.lon, station.lat])
          .addTo(map);

        cableVisorDisplayState.fixedStationLabels.push(labelMarker);
      }
      stationIdx++;
    });

    console.log('[CableVisor] Station markers updated:', stationMap.size, 'stations');
  }

  // Toggle button handlers for cable visor display options
  document.addEventListener('DOMContentLoaded', () => {
    const btnShowNames = document.getElementById('btnVisorShowNames');
    const btnFixNames = document.getElementById('btnVisorFixNames');
    const btnShowStations = document.getElementById('btnVisorShowStations');
    const btnFixStationNames = document.getElementById('btnVisorFixStationNames');

    if (btnShowNames) btnShowNames.addEventListener('click', () => {
      cableVisorDisplayState.showNames = !cableVisorDisplayState.showNames;
      btnShowNames.classList.toggle('active', cableVisorDisplayState.showNames);
      // Show/hide the "Pin Names" button
      if (btnFixNames) btnFixNames.style.display = cableVisorDisplayState.showNames ? '' : 'none';
      if (!cableVisorDisplayState.showNames) {
        cableVisorDisplayState.fixNames = false;
        if (btnFixNames) btnFixNames.classList.remove('active');
        updateFixedCableLabels();
      }
    });

    if (btnFixNames) btnFixNames.addEventListener('click', () => {
      cableVisorDisplayState.fixNames = !cableVisorDisplayState.fixNames;
      btnFixNames.classList.toggle('active', cableVisorDisplayState.fixNames);
      updateFixedCableLabels();
    });

    if (btnShowStations) btnShowStations.addEventListener('click', () => {
      cableVisorDisplayState.showStations = !cableVisorDisplayState.showStations;
      btnShowStations.classList.toggle('active', cableVisorDisplayState.showStations);
      // Show/hide the "Pin Stations" button
      if (btnFixStationNames) btnFixStationNames.style.display = cableVisorDisplayState.showStations ? '' : 'none';
      if (!cableVisorDisplayState.showStations) {
        cableVisorDisplayState.fixStationNames = false;
        if (btnFixStationNames) btnFixStationNames.classList.remove('active');
      }
      updateStationMarkers();
    });

    if (btnFixStationNames) btnFixStationNames.addEventListener('click', () => {
      cableVisorDisplayState.fixStationNames = !cableVisorDisplayState.fixStationNames;
      btnFixStationNames.classList.toggle('active', cableVisorDisplayState.fixStationNames);
      updateStationMarkers();
    });
  });

  // ======================
  // Datacenter Visor Panel
  // ======================
  const dcVisorState = {
    map: null,
    selectedDCs: new Set(),
    dcDatabase: null,
    dcMarkers: {},       // { dcId: marker }
    initialized: false,
    mapReady: false,
    showNames: false,
    fixedLabels: [],     // MapLibre marker references for DC name labels
    tooltip: null        // DOM element for hover tooltip
  };

  function showDCVisor() {
    const panel = document.getElementById('dcVisorPanel');
    if (!panel) return;
    panel.classList.add('show');

    // Initialize draggable on first show
    initDCVisorDraggable();

    // Load DC database then init map
    loadDCVisorData().then(() => {
      if (!dcVisorState.initialized) {
        setTimeout(() => initDCVisorMap(), 100);
      } else if (dcVisorState.map) {
        dcVisorState.map.resize();
      }
    });
  }

  function hideDCVisor() {
    const panel = document.getElementById('dcVisorPanel');
    if (panel) panel.classList.remove('show');
  }

  function toggleDCVisorMaximize() {
    const panel = document.getElementById('dcVisorPanel');
    if (!panel) return;

    panel.classList.toggle('maximized');
    if (panel.classList.contains('maximized')) {
      panel._originalStyle = {
        width: panel.style.width,
        height: panel.style.height,
        left: panel.style.left,
        top: panel.style.top
      };
      panel.style.width = '';
      panel.style.height = '';
      panel.style.left = '';
      panel.style.top = '';
    } else if (panel._originalStyle) {
      Object.assign(panel.style, panel._originalStyle);
    }
    if (dcVisorState.map) setTimeout(() => dcVisorState.map.resize(), 100);
  }

  function initDCVisorMap() {
    const container = document.getElementById('dcVisorMapContainer');
    const loadingEl = document.getElementById('dcVisorMapLoading');
    if (!container) return;

    if (dcVisorState.map) {
      dcVisorState.map.resize();
      return;
    }

    try {
      dcVisorState.map = new maplibregl.Map({
        container: container,
        preserveDrawingBuffer: true,
        style: {
          version: 8,
          sources: {
            'osm-tiles': {
              type: 'raster',
              tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
              tileSize: 256,
              attribution: '&copy; OpenStreetMap contributors'
            }
          },
          layers: [{
            id: 'osm-layer',
            type: 'raster',
            source: 'osm-tiles',
            minzoom: 0,
            maxzoom: 19
          }]
        },
        center: [0, 20],
        zoom: 1.5,
        attributionControl: false
      });

      dcVisorState.map.addControl(new maplibregl.NavigationControl(), 'top-left');
      dcVisorState.map.addControl(new maplibregl.AttributionControl({ compact: true }), 'bottom-right');

      dcVisorState.map.on('load', () => {
        if (loadingEl) loadingEl.style.display = 'none';
        dcVisorState.initialized = true;
        dcVisorState.mapReady = true;

        // Add any already selected DCs to map
        dcVisorState.selectedDCs.forEach(dcId => {
          addDCToVisorMap(dcId);
        });

        setupDCVisorHoverEvents();
      });

    } catch (err) {
      console.error('[DCVisor] Map init error:', err);
      if (loadingEl) loadingEl.innerHTML = '<div style="color:#c00;">Failed to load map</div>';
    }
  }

  // Create or get the hover tooltip element for the DC visor map
  function getDCVisorTooltip() {
    if (!dcVisorState.tooltip) {
      const el = document.createElement('div');
      el.className = 'visor-map-tooltip';
      el.style.display = 'none';
      const container = document.getElementById('dcVisorMap');
      if (container) container.appendChild(el);
      dcVisorState.tooltip = el;
    }
    return dcVisorState.tooltip;
  }

  // Setup hover events on the DC visor map
  function setupDCVisorHoverEvents() {
    const map = dcVisorState.map;
    if (!map) return;

    // DC markers have their own mouseenter/mouseleave handlers
    console.log('[DCVisor] Hover events set up');
  }

  async function loadDCVisorData() {
    if (dcVisorState.dcDatabase) {
      renderDCVisorList();
      return;
    }

    const listEl = document.getElementById('dcVisorDCList');
    if (listEl) listEl.innerHTML = '<div style="padding:20px; text-align:center; color:#666;">Loading datacenters...</div>';

    try {
      // Load from PeeringDB facilities file + cable stations
      if (window._dcDatabase && window._dcDatabase.loaded) {
        dcVisorState.dcDatabase = window._dcDatabase;
      } else {
        const [dcResp, csResp] = await Promise.all([
          fetch('data/peeringdb_facilities.json'),
          fetch('data/cable_stations_db.json').catch(() => null)
        ]);
        if (!dcResp.ok) throw new Error(`HTTP ${dcResp.status}`);
        const dcData = await dcResp.json();
        const facilities = dcData.facilities || [];
        if (csResp && csResp.ok) {
          const csData = await csResp.json();
          facilities.push(...(csData.facilities || []));
        }
        dcVisorState.dcDatabase = {
          facilities,
          meta: dcData.meta || {},
          loaded: true
        };
        // Also store globally for DC Navigator
        if (!window._dcDatabase || !window._dcDatabase.loaded) {
          window._dcDatabase = dcVisorState.dcDatabase;
        }
        // Merge cable stations from separate file
        await mergeCableStationsDatabase();
      }

      populateDCVisorRegionFilter();
      renderDCVisorList();
      console.log('[DCVisor] Loaded', dcVisorState.dcDatabase.facilities.length, 'facilities (DCs + cable stations)');

    } catch (err) {
      console.error('[DCVisor] Failed to load DCs:', err);
      if (listEl) listEl.innerHTML = '<div style="padding:20px; text-align:center; color:#c00;">Error: ' + err.message + '</div>';
    }
  }

  function populateDCVisorRegionFilter() {
    const select = document.getElementById('dcVisorRegionFilter');
    if (!select || !dcVisorState.dcDatabase) return;

    const regions = new Set();
    dcVisorState.dcDatabase.facilities.forEach(fac => {
      if (fac.region_continent) regions.add(fac.region_continent);
    });

    const sorted = Array.from(regions).sort();
    select.innerHTML = '<option value="">All Corridors</option>' +
      sorted.map(r => `<option value="${escapeHtml(r)}">${escapeHtml(r)}</option>`).join('');
  }

  // Get density class for DC (same logic as DC Navigator)
  function getDCDensityClass(fac) {
    const count = (fac.carrier_count || 0) + (fac.ix_count || 0);
    if (count >= 50) return 'density-critical';
    if (count >= 20) return 'density-high';
    if (count >= 5) return 'density-medium';
    if (count >= 1) return 'density-low';
    return 'density-minimal';
  }

  function renderDCVisorList() {
    const listEl = document.getElementById('dcVisorDCList');
    const countEl = document.getElementById('dcVisorDCCount');
    const selectedCountEl = document.getElementById('dcVisorSelectedCount');

    if (!listEl) return;

    if (!dcVisorState.dcDatabase || !dcVisorState.dcDatabase.facilities) {
      listEl.innerHTML = '<div style="padding:20px; text-align:center; color:#666;">No datacenter data available</div>';
      return;
    }

    const search = (document.getElementById('dcVisorSearch')?.value || '').toLowerCase().trim();
    const regionFilter = document.getElementById('dcVisorRegionFilter')?.value || '';
    const typeFilter = document.getElementById('dcVisorTypeFilter')?.value || '';

    let facilities = dcVisorState.dcDatabase.facilities.filter(fac => {
      if (typeFilter && (fac.facility_type || 'datacenter') !== typeFilter) return false;
      if (regionFilter && fac.region_continent !== regionFilter) return false;
      if (search) {
        const name = (fac.name || '').toLowerCase();
        const org = (fac.org_name || '').toLowerCase();
        const city = (fac.city || '').toLowerCase();
        const country = (fac.country || '').toLowerCase();
        const cables = (fac.cable_systems || []).join(' ').toLowerCase();
        return name.includes(search) || org.includes(search) || city.includes(search) || country.includes(search) || cables.includes(search);
      }
      return true;
    });

    // Sort by name
    facilities.sort((a, b) => (a.name || '').localeCompare(b.name || ''));

    // Limit display to 500 to avoid performance issues
    const displayLimit = 500;
    const totalMatches = facilities.length;
    if (facilities.length > displayLimit) {
      facilities = facilities.slice(0, displayLimit);
    }

    let html = '';
    facilities.forEach(fac => {
      const isSelected = dcVisorState.selectedDCs.has(String(fac.id));
      const densityClass = getDCDensityClass(fac);
      const hasCoords = fac.latitude && fac.longitude;

      html += `
        <div class="dc-visor-item ${isSelected ? 'selected' : ''}" data-dc-id="${fac.id}" title="${escapeHtml(fac.name)}${!hasCoords ? ' (no coordinates)' : ''}">
          <input type="checkbox" ${isSelected ? 'checked' : ''} />
          <span class="dc-density-badge ${densityClass}" style="width:10px;height:10px;flex-shrink:0;"></span>
          <div class="dc-visor-info">
            <div class="dc-visor-name">${escapeHtml(fac.name)}</div>
            <div class="dc-visor-meta">${escapeHtml(fac.city || '')}${fac.country ? ', ' + escapeHtml(fac.country) : ''} ${fac.net_count ? ' &bull; ' + fac.net_count + ' networks' : ''}${!hasCoords ? ' &bull; No map data' : ''}</div>
          </div>
        </div>
      `;
    });

    if (totalMatches > displayLimit) {
      html += `<div style="padding:8px 12px; text-align:center; font-size:11px; color:#888;">Showing ${displayLimit} of ${totalMatches} matching datacenters. Narrow your search.</div>`;
    }

    listEl.innerHTML = html || '<div style="padding:12px; text-align:center; color:#666;">No datacenters match your filter</div>';

    if (countEl) countEl.textContent = `${totalMatches} datacenters`;
    if (selectedCountEl) selectedCountEl.textContent = `${dcVisorState.selectedDCs.size} selected`;

    // Add click handlers
    listEl.querySelectorAll('.dc-visor-item').forEach(item => {
      item.addEventListener('click', (e) => {
        if (e.target.type === 'checkbox') return;
        const dcId = item.dataset.dcId;
        toggleDCVisorSelection(dcId);
      });

      const checkbox = item.querySelector('input[type="checkbox"]');
      if (checkbox) {
        checkbox.addEventListener('change', (e) => {
          e.stopPropagation();
          const dcId = item.dataset.dcId;
          toggleDCVisorSelection(dcId);
        });
      }

      item.addEventListener('dblclick', () => {
        const dcId = item.dataset.dcId;
        if (!dcVisorState.selectedDCs.has(dcId)) {
          toggleDCVisorSelection(dcId);
        }
        zoomToDC(dcId);
      });
    });
  }

  function toggleDCVisorSelection(dcId) {
    if (dcVisorState.selectedDCs.has(dcId)) {
      dcVisorState.selectedDCs.delete(dcId);
      removeDCFromVisorMap(dcId);
    } else {
      dcVisorState.selectedDCs.add(dcId);
      addDCToVisorMap(dcId);
    }
    renderDCVisorList();
  }

  function addDCToVisorMap(dcId) {
    const map = dcVisorState.map;
    if (!map || !dcVisorState.mapReady) return;

    const fac = dcVisorState.dcDatabase?.facilities?.find(f => String(f.id) === String(dcId));
    if (!fac || !fac.latitude || !fac.longitude) return;

    // Remove existing marker if any
    if (dcVisorState.dcMarkers[dcId]) {
      dcVisorState.dcMarkers[dcId].remove();
    }

    // Create marker element
    const el = document.createElement('div');
    const densityClass = getDCDensityClass(fac);
    el.style.cssText = 'width:12px; height:12px; border-radius:2px; border:2px solid white; box-shadow:0 1px 4px rgba(0,0,0,0.4); cursor:pointer;';

    // Color based on density
    const densityColors = {
      'density-critical': '#dc2626',
      'density-high': '#f59e0b',
      'density-medium': '#3b82f6',
      'density-low': '#22c55e',
      'density-minimal': '#94a3b8'
    };
    el.style.background = densityColors[densityClass] || '#9333ea';

    const marker = new maplibregl.Marker({ element: el, anchor: 'center' })
      .setLngLat([fac.longitude, fac.latitude])
      .addTo(map);

    // Hover popup
    const popup = new maplibregl.Popup({
      closeButton: false,
      closeOnClick: false,
      offset: 10
    });

    el.addEventListener('mouseenter', () => {
      popup.setLngLat([fac.longitude, fac.latitude])
        .setHTML(`<strong>${escapeHtml(fac.name)}</strong><br><span style="font-size:10px;color:#666;">${escapeHtml(fac.org_name || '')}${fac.city ? ', ' + escapeHtml(fac.city) : ''}${fac.country ? ', ' + escapeHtml(fac.country) : ''}</span>${fac.net_count ? '<br><span style="font-size:10px;color:#3b82f6;">' + fac.net_count + ' networks</span>' : ''}`)
        .addTo(map);
    });

    el.addEventListener('mouseleave', () => {
      popup.remove();
    });

    dcVisorState.dcMarkers[dcId] = marker;

    // Update fixed labels if active
    if (dcVisorState.showNames) updateFixedDCLabels();
  }

  function removeDCFromVisorMap(dcId) {
    if (dcVisorState.dcMarkers[dcId]) {
      dcVisorState.dcMarkers[dcId].remove();
      delete dcVisorState.dcMarkers[dcId];
    }
    if (dcVisorState.showNames) updateFixedDCLabels();
  }

  function zoomToDC(dcId) {
    const map = dcVisorState.map;
    if (!map || !dcVisorState.mapReady) return;

    const fac = dcVisorState.dcDatabase?.facilities?.find(f => String(f.id) === String(dcId));
    if (!fac || !fac.latitude || !fac.longitude) return;

    map.flyTo({ center: [fac.longitude, fac.latitude], zoom: 12, duration: 1000 });
  }

  function selectAllVisorDCs() {
    if (!dcVisorState.dcDatabase) return;

    const search = (document.getElementById('dcVisorSearch')?.value || '').toLowerCase().trim();
    const regionFilter = document.getElementById('dcVisorRegionFilter')?.value || '';

    let count = 0;
    const maxSelect = 200; // Limit to prevent performance issues

    dcVisorState.dcDatabase.facilities.forEach(fac => {
      if (count >= maxSelect) return;
      if (regionFilter && fac.region_continent !== regionFilter) return;
      if (search) {
        const name = (fac.name || '').toLowerCase();
        const org = (fac.org_name || '').toLowerCase();
        const city = (fac.city || '').toLowerCase();
        if (!name.includes(search) && !org.includes(search) && !city.includes(search)) return;
      }
      if (!fac.latitude || !fac.longitude) return;
      if (!dcVisorState.selectedDCs.has(String(fac.id))) {
        dcVisorState.selectedDCs.add(String(fac.id));
        addDCToVisorMap(String(fac.id));
        count++;
      }
    });

    if (count >= maxSelect) {
      showToast(`Selected ${maxSelect} datacenters (limit). Narrow your search for more.`, 'info');
    }

    renderDCVisorList();
  }

  function clearAllVisorDCs() {
    dcVisorState.selectedDCs.forEach(dcId => {
      removeDCFromVisorMap(dcId);
    });
    dcVisorState.selectedDCs.clear();
    renderDCVisorList();
  }

  // Fixed DC name labels
  function updateFixedDCLabels() {
    const map = dcVisorState.map;
    if (!map || !dcVisorState.mapReady) return;

    // Remove existing
    dcVisorState.fixedLabels.forEach(m => m.remove());
    dcVisorState.fixedLabels = [];

    if (!dcVisorState.showNames) return;

    dcVisorState.selectedDCs.forEach(dcId => {
      const fac = dcVisorState.dcDatabase?.facilities?.find(f => String(f.id) === String(dcId));
      if (!fac || !fac.latitude || !fac.longitude) return;

      const el = document.createElement('div');
      el.className = 'visor-fixed-label';
      el.textContent = fac.name;
      el.style.borderLeft = '3px solid #9333ea';
      el.style.fontSize = '9px';
      el.style.maxWidth = '150px';
      el.style.overflow = 'hidden';
      el.style.textOverflow = 'ellipsis';

      const marker = new maplibregl.Marker({ element: el, anchor: 'left', offset: [10, 0] })
        .setLngLat([fac.longitude, fac.latitude])
        .addTo(map);

      dcVisorState.fixedLabels.push(marker);
    });
  }

  // DC Visor draggable
  let dcVisorDraggableInitialized = false;
  function initDCVisorDraggable() {
    if (dcVisorDraggableInitialized) return;

    const panel = document.getElementById('dcVisorPanel');
    const header = document.getElementById('dcVisorHeader');
    if (!panel || !header) return;

    let isDragging = false;
    let offsetX, offsetY;

    header.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'BUTTON') return;
      isDragging = true;
      offsetX = e.clientX - panel.offsetLeft;
      offsetY = e.clientY - panel.offsetTop;
      panel.style.cursor = 'move';
      panel.style.right = 'auto';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      panel.style.left = (e.clientX - offsetX) + 'px';
      panel.style.top = (e.clientY - offsetY) + 'px';
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        panel.style.cursor = '';
      }
    });

    dcVisorDraggableInitialized = true;
    console.log('[DCVisor] Draggable initialized');
  }

  // Presentation (fullscreen) mode for DC Visor
  let dcVisorPresentationActive = false;
  let dcVisorPresentationExitBtn = null;
  let dcVisorPresentationHint = null;

  function toggleDCVisorPresentation() {
    if (dcVisorPresentationActive) {
      exitDCVisorPresentation();
    } else {
      enterDCVisorPresentation();
    }
  }

  function enterDCVisorPresentation() {
    const panel = document.getElementById('dcVisorPanel');
    if (!panel) return;

    // Exit maximized mode if active
    if (panel.classList.contains('maximized')) {
      toggleDCVisorMaximize();
    }

    // Store original position/size
    panel._presentationOriginal = {
      width: panel.style.width,
      height: panel.style.height,
      left: panel.style.left,
      top: panel.style.top
    };

    // Clear inline styles and enter presentation mode
    panel.style.width = '';
    panel.style.height = '';
    panel.style.left = '';
    panel.style.top = '';
    panel.classList.add('presentation-mode');
    dcVisorPresentationActive = true;

    // Create close button (X)
    dcVisorPresentationExitBtn = document.createElement('button');
    dcVisorPresentationExitBtn.className = 'presentation-exit-btn';
    dcVisorPresentationExitBtn.innerHTML = '&#x2715;';
    dcVisorPresentationExitBtn.title = 'Exit Presentation (ESC)';
    dcVisorPresentationExitBtn.addEventListener('click', exitDCVisorPresentation);
    document.body.appendChild(dcVisorPresentationExitBtn);

    // Show ESC hint that fades after 3 seconds
    dcVisorPresentationHint = document.createElement('div');
    dcVisorPresentationHint.className = 'presentation-esc-hint';
    dcVisorPresentationHint.textContent = 'Press ESC to exit presentation mode';
    document.body.appendChild(dcVisorPresentationHint);
    setTimeout(() => {
      if (dcVisorPresentationHint) {
        dcVisorPresentationHint.style.opacity = '0';
        setTimeout(() => {
          if (dcVisorPresentationHint && dcVisorPresentationHint.parentNode) {
            dcVisorPresentationHint.parentNode.removeChild(dcVisorPresentationHint);
            dcVisorPresentationHint = null;
          }
        }, 1000);
      }
    }, 3000);

    // Try native fullscreen
    if (panel.requestFullscreen) {
      panel.requestFullscreen().catch(() => {});
    } else if (panel.webkitRequestFullscreen) {
      panel.webkitRequestFullscreen();
    }

    // Add ESC key listener
    document.addEventListener('keydown', handleDCPresentationEsc);
    document.addEventListener('fullscreenchange', handleDCFullscreenChange);

    // Resize map after entering
    if (dcVisorState.map) {
      setTimeout(() => dcVisorState.map.resize(), 100);
    }

    console.log('[DCVisor] Entered presentation mode');
  }

  function exitDCVisorPresentation() {
    const panel = document.getElementById('dcVisorPanel');
    if (!panel) return;

    panel.classList.remove('presentation-mode');
    dcVisorPresentationActive = false;

    // Restore original position/size
    if (panel._presentationOriginal) {
      panel.style.width = panel._presentationOriginal.width;
      panel.style.height = panel._presentationOriginal.height;
      panel.style.left = panel._presentationOriginal.left;
      panel.style.top = panel._presentationOriginal.top;
    }

    // Remove close button
    if (dcVisorPresentationExitBtn && dcVisorPresentationExitBtn.parentNode) {
      dcVisorPresentationExitBtn.parentNode.removeChild(dcVisorPresentationExitBtn);
      dcVisorPresentationExitBtn = null;
    }

    // Remove hint
    if (dcVisorPresentationHint && dcVisorPresentationHint.parentNode) {
      dcVisorPresentationHint.parentNode.removeChild(dcVisorPresentationHint);
      dcVisorPresentationHint = null;
    }

    // Exit native fullscreen if active
    if (document.fullscreenElement) {
      document.exitFullscreen().catch(() => {});
    }

    // Remove listeners
    document.removeEventListener('keydown', handleDCPresentationEsc);
    document.removeEventListener('fullscreenchange', handleDCFullscreenChange);

    // Resize map after exiting
    if (dcVisorState.map) {
      setTimeout(() => dcVisorState.map.resize(), 100);
    }

    console.log('[DCVisor] Exited presentation mode');
  }

  function handleDCPresentationEsc(e) {
    if (e.key === 'Escape' && dcVisorPresentationActive) {
      e.preventDefault();
      e.stopPropagation();
      exitDCVisorPresentation();
    }
  }

  function handleDCFullscreenChange() {
    if (!document.fullscreenElement && dcVisorPresentationActive) {
      exitDCVisorPresentation();
    }
  }

  // DC Visor map resize handle
  (function() {
    let dragging = false;
    let startY = 0;
    let startHeight = 0;

    document.addEventListener('mousedown', (e) => {
      if (!e.target.closest('#dcVisorMapResizeHandle')) return;
      const mapEl = document.getElementById('dcVisorMap');
      if (!mapEl) return;
      dragging = true;
      startY = e.clientY;
      startHeight = mapEl.getBoundingClientRect().height;
      e.target.closest('#dcVisorMapResizeHandle').classList.add('dragging');
      document.body.style.cursor = 'ns-resize';
      document.body.style.userSelect = 'none';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const mapEl = document.getElementById('dcVisorMap');
      if (!mapEl) return;
      const delta = e.clientY - startY;
      const newHeight = Math.max(80, startHeight + delta);
      mapEl.style.flex = 'none';
      mapEl.style.height = newHeight + 'px';
      if (dcVisorState.map) dcVisorState.map.resize();
      e.preventDefault();
    });

    document.addEventListener('mouseup', () => {
      if (!dragging) return;
      dragging = false;
      const handle = document.getElementById('dcVisorMapResizeHandle');
      if (handle) handle.classList.remove('dragging');
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
      if (dcVisorState.map) dcVisorState.map.resize();
    });
  })();

  // DC Visor event handlers
  function initDCVisorEventHandlers() {
    document.getElementById('btnDCVisorClose')?.addEventListener('click', (e) => {
      e.stopPropagation();
      hideDCVisor();
    });
    document.getElementById('btnDCVisorPresentation')?.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleDCVisorPresentation();
    });
    document.getElementById('btnDCVisorMaximize')?.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleDCVisorMaximize();
    });
    document.getElementById('btnOpenDCVisor')?.addEventListener('click', showDCVisor);
    document.getElementById('btnDCVisorSelectAll')?.addEventListener('click', selectAllVisorDCs);
    document.getElementById('btnDCVisorClearAll')?.addEventListener('click', clearAllVisorDCs);
    document.getElementById('dcVisorSearch')?.addEventListener('input', () => renderDCVisorList());
    document.getElementById('dcVisorRegionFilter')?.addEventListener('change', () => renderDCVisorList());
    document.getElementById('dcVisorTypeFilter')?.addEventListener('change', () => renderDCVisorList());

    // DC name labels toggle
    document.getElementById('btnDCVisorShowNames')?.addEventListener('click', () => {
      dcVisorState.showNames = !dcVisorState.showNames;
      document.getElementById('btnDCVisorShowNames')?.classList.toggle('active', dcVisorState.showNames);
      updateFixedDCLabels();
    });

    console.log('[DCVisor] Event handlers initialized');
  }

  // Initialize DC Visor on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initDCVisorEventHandlers);
  } else {
    initDCVisorEventHandlers();
  }

  // ============== VISOR IMAGE ACTIONS (Copy, Save, Print) ==============

  /**
   * Capture a MapLibre map as a canvas, including all overlays.
   * Returns a Promise<HTMLCanvasElement>.
   */
  function captureVisorMap(mapObj, panelId) {
    return new Promise((resolve, reject) => {
      if (!mapObj) { reject(new Error('Map not initialized')); return; }
      try {
        // Get the map canvas
        const mapCanvas = mapObj.getCanvas();
        const panel = document.getElementById(panelId);
        if (!panel) { reject(new Error('Panel not found')); return; }

        // Create output canvas at full resolution
        const dpr = window.devicePixelRatio || 1;
        const w = mapCanvas.width;
        const h = mapCanvas.height;
        const outCanvas = document.createElement('canvas');
        outCanvas.width = w;
        outCanvas.height = h;
        const ctx = outCanvas.getContext('2d');

        // Draw map canvas
        // Force a render to make sure the map is fully painted
        mapObj.triggerRepaint();
        setTimeout(() => {
          try {
            ctx.drawImage(mapCanvas, 0, 0);

            // Draw MapLibre markers (HTML overlays) on top if any exist
            // These are DOM elements, so we approximate by including them
            resolve(outCanvas);
          } catch (e) {
            reject(e);
          }
        }, 100);
      } catch (e) {
        reject(e);
      }
    });
  }

  function visorSaveImage(mapObj, panelId, format) {
    captureVisorMap(mapObj, panelId).then(canvas => {
      const mime = format === 'jpg' ? 'image/jpeg' : 'image/png';
      const quality = format === 'jpg' ? 0.92 : undefined;
      canvas.toBlob(blob => {
        if (!blob) { showToast('Failed to create image', 'error'); return; }
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `visor_map.${format}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast(`Image saved as ${format.toUpperCase()}`);
      }, mime, quality);
    }).catch(e => {
      showToast('Failed to capture map: ' + e.message, 'error');
    });
  }

  function visorCopyImage(mapObj, panelId) {
    captureVisorMap(mapObj, panelId).then(canvas => {
      canvas.toBlob(async blob => {
        if (!blob) { showToast('Failed to create image', 'error'); return; }
        try {
          await navigator.clipboard.write([
            new ClipboardItem({ 'image/png': blob })
          ]);
          showToast('Image copied to clipboard');
        } catch (e) {
          showToast('Clipboard copy failed: ' + e.message, 'error');
        }
      }, 'image/png');
    }).catch(e => {
      showToast('Failed to capture map: ' + e.message, 'error');
    });
  }

  function visorPrint(mapObj, panelId, title) {
    captureVisorMap(mapObj, panelId).then(canvas => {
      const dataUrl = canvas.toDataURL('image/png');
      const printWin = window.open('', '_blank', 'width=900,height=700');
      if (!printWin) { showToast('Popup blocked - please allow popups', 'error'); return; }
      printWin.document.write(`<!DOCTYPE html><html><head><title>${title}</title><style>
        @media print { body { margin: 0; } img { max-width: 100%; height: auto; } }
        body { display: flex; flex-direction: column; align-items: center; padding: 20px; font-family: sans-serif; }
        h2 { margin: 0 0 12px; color: #333; }
        img { max-width: 100%; box-shadow: 0 2px 8px rgba(0,0,0,0.15); border-radius: 4px; }
      </style></head><body>
        <h2>${title}</h2>
        <img src="${dataUrl}" />
      </body></html>`);
      printWin.document.close();
      printWin.onload = () => { printWin.print(); };
    }).catch(e => {
      showToast('Failed to capture map: ' + e.message, 'error');
    });
  }

  // Toggle visor action menus
  function setupVisorActionMenu(btnId, menuId) {
    const btn = document.getElementById(btnId);
    const menu = document.getElementById(menuId);
    if (!btn || !menu) return;

    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      // Close any other open menus
      document.querySelectorAll('.visor-action-menu.show').forEach(m => {
        if (m !== menu) m.classList.remove('show');
      });
      menu.classList.toggle('show');
    });

    // Close menu on click outside
    document.addEventListener('click', () => menu.classList.remove('show'));
    menu.addEventListener('click', () => menu.classList.remove('show'));
  }

  // Cable & DC Visor image actions â€” deferred until DOM is ready
  // (Visor HTML is defined after this script block)
  function initVisorImageActions() {
    // Cable Visor image actions
    setupVisorActionMenu('btnCableVisorActions', 'cableVisorActionMenu');
    document.getElementById('btnCableVisorCopyImage')?.addEventListener('click', () => {
      visorCopyImage(cableVisorState.map, 'cableVisorPanel');
    });
    document.getElementById('btnCableVisorSavePNG')?.addEventListener('click', () => {
      visorSaveImage(cableVisorState.map, 'cableVisorPanel', 'png');
    });
    document.getElementById('btnCableVisorSaveJPG')?.addEventListener('click', () => {
      visorSaveImage(cableVisorState.map, 'cableVisorPanel', 'jpg');
    });
    document.getElementById('btnCableVisorPrint')?.addEventListener('click', () => {
      visorPrint(cableVisorState.map, 'cableVisorPanel', 'Submarine Cable Visor');
    });

    // DC Visor image actions
    setupVisorActionMenu('btnDCVisorActions', 'dcVisorActionMenu');
    document.getElementById('btnDCVisorCopyImage')?.addEventListener('click', () => {
      visorCopyImage(dcVisorState.map, 'dcVisorPanel');
    });
    document.getElementById('btnDCVisorSavePNG')?.addEventListener('click', () => {
      visorSaveImage(dcVisorState.map, 'dcVisorPanel', 'png');
    });
    document.getElementById('btnDCVisorSaveJPG')?.addEventListener('click', () => {
      visorSaveImage(dcVisorState.map, 'dcVisorPanel', 'jpg');
    });
    document.getElementById('btnDCVisorPrint')?.addEventListener('click', () => {
      visorPrint(dcVisorState.map, 'dcVisorPanel', 'Datacenter Visor');
    });
  }
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initVisorImageActions);
  } else {
    initVisorImageActions();
  }

  // Add handler for group by region checkbox
  document.getElementById('cableNavGroupByRegion')?.addEventListener('change', () => {
    updateCableNavigatorList();
  });

  function showDeleteCableSystemDialog(csId) {
    const cs = findCableSystem(csId);
    if (!cs) return;

    const links = getCableSystemLinks(csId);
    const nodes = getCableSystemNodes(csId);

    // Highlight associated items on canvas
    highlightCableSystemItems(csId);

    // Create modal dialog
    const modal = document.createElement('div');
    modal.id = 'deleteCableSystemModal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 10001;
      display: flex; justify-content: center; align-items: center;
    `;

    modal.innerHTML = `
      <div style="background: #fff; border-radius: 8px; padding: 24px; max-width: 400px; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
        <h3 style="margin: 0 0 16px;">Delete Cable System "${cs.shortName}"?</h3>
        <p style="margin: 0 0 12px; color: #666;">This cable system has:</p>
        <ul style="margin: 0 0 16px; padding-left: 20px; color: #666;">
          <li>${links.length} link(s)</li>
          <li>${nodes.length} node(s)</li>
        </ul>
        <p style="margin: 0 0 20px; font-size: 13px; color: #888;">
          These items are highlighted on the canvas.
        </p>
        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
          <button class="btn" id="btnDeleteAll" style="background: #d32f2f; color: #fff; border-color: #d32f2f;">Delete All</button>
          <button class="btn" id="btnUnmapOnly">Unmap Only</button>
          <button class="btn" id="btnCancelDelete">Cancel</button>
        </div>
        <p style="margin: 12px 0 0; font-size: 11px; color: #888;">
          <strong>Delete All:</strong> Remove cable system AND all its links/nodes<br/>
          <strong>Unmap Only:</strong> Remove cable system but keep links/nodes
        </p>
      </div>
    `;

    document.body.appendChild(modal);

    modal.querySelector('#btnDeleteAll').addEventListener('click', () => {
      deleteCableSystem(csId, 'deleteAll');
      clearHighlights();
      modal.remove();
    });

    modal.querySelector('#btnUnmapOnly').addEventListener('click', () => {
      deleteCableSystem(csId, 'unmapOnly');
      clearHighlights();
      modal.remove();
    });

    modal.querySelector('#btnCancelDelete').addEventListener('click', () => {
      clearHighlights();
      modal.remove();
    });
  }

  function highlightCableSystemItems(csId) {
    // Add temporary highlight class to associated items
    const links = getCableSystemLinks(csId);
    const nodes = getCableSystemNodes(csId);

    // Visual highlight via render - store temporarily
    state._highlightedLinks = new Set(links.map(l => l.id));
    state._highlightedNodes = new Set(nodes.map(n => n.id));
    render();
  }

  function clearHighlights() {
    state._highlightedLinks = null;
    state._highlightedNodes = null;
    render();
  }

  // ========== CABLE SYSTEM BULK IMPORT ==========
  let csBulkImportSelection = new Set();
  let csBulkImportCables = {};
  let csBulkSource = 'local'; // 'local' | 'telegeography'

  async function showCableSystemBulkImportModal() {
    const modal = document.getElementById('csBulkImportModal');
    const cableList = document.getElementById('csBulkCableList');
    const regionFilter = document.getElementById('csBulkRegionFilter');
    const searchInput = document.getElementById('csBulkSearchInput');

    if (!modal) return;

    // Reset state
    csBulkImportSelection.clear();
    csBulkImportCables = {};

    // Show modal
    modal.style.display = 'flex';

    // Setup 2-source toggle (once)
    const sourceRadios = modal.querySelectorAll('input[name="csBulkSrc"]');
    if (sourceRadios.length && !sourceRadios[0]._bound) {
      const allLabels = {
        local: document.getElementById('lblSrcLocal'),
        telegeography: document.getElementById('lblSrcTG')
      };
      sourceRadios.forEach(radio => {
        radio.addEventListener('change', function() {
          if (this.checked) {
            csBulkSource = this.value;
            // Update label styles
            Object.values(allLabels).forEach(lbl => {
              if (lbl) { lbl.style.borderColor = 'transparent'; lbl.style.background = 'white'; }
            });
            const activeLbl = allLabels[this.value];
            if (activeLbl) { activeLbl.style.borderColor = '#0369a1'; activeLbl.style.background = '#e0f2fe'; }
            loadBulkImportCables();
          }
        });
        radio._bound = true;
      });
    }

    // Refresh from API button
    const bulkRefreshBtn = document.getElementById('btnBulkRefreshAPI');
    if (bulkRefreshBtn && !bulkRefreshBtn._bound) {
      bulkRefreshBtn.addEventListener('click', async () => {
        bulkRefreshBtn.disabled = true;
        bulkRefreshBtn.textContent = 'â³ Fetching...';
        try {
          const db = await loadFromTeleGeographyAPI();
          const cables = db.cables || {};
          csBulkImportCables = cables;
          csBulkImportSelection.clear();
          updateCsBulkImportCount();
          const regions = [...new Set(Object.values(cables).map(c => c.region))].sort();
          const regionFilter = document.getElementById('csBulkRegionFilter');
          if (regionFilter) regionFilter.innerHTML = '<option value="">All Corridors</option>' + regions.map(r => '<option value="' + r + '">' + r + '</option>').join('');
          renderCsBulkCableList();
        } catch (err) {
          const cl = document.getElementById('csBulkCableList');
          if (cl) cl.innerHTML = '<div style="padding:20px; text-align:center; color:#c00;">API refresh failed: ' + err.message + '</div>';
        }
        bulkRefreshBtn.disabled = false;
        bulkRefreshBtn.textContent = 'ðŸ”„ Refresh from API';
      });
      bulkRefreshBtn._bound = true;
    }

    // Load cables
    await loadBulkImportCables();
  }

  async function loadBulkImportCables() {
    const cableList = document.getElementById('csBulkCableList');
    const regionFilter = document.getElementById('csBulkRegionFilter');
    const searchInput = document.getElementById('csBulkSearchInput');

    // Reset
    csBulkImportSelection.clear();
    csBulkImportCables = {};
    updateCsBulkImportCount();

    // Show loading
    const srcNames = { local: 'Internal database', telegeography: 'Public Cable System DB' };
    const srcIcons = { local: 'ðŸ“‚', telegeography: 'ðŸŒ' };
    const srcName = srcNames[csBulkSource] || 'database';
    const srcIcon = srcIcons[csBulkSource] || 'ðŸ“‚';
    cableList.innerHTML = '<div style="text-align:center; padding:40px; color:#666;">' +
      '<div style="font-size:24px; margin-bottom:10px;">' + srcIcon + '</div>' +
      'Loading from ' + srcName + '...</div>';

    try {
      // Load cable database based on selected source
      let db;
      if (csBulkSource === 'telegeography') {
        db = await loadFromLocalTeleGeographyData();
      } else {
        db = await loadSubmarineCableDb();
      }
      const cables = db.cables || {};
      csBulkImportCables = cables;

      // Get unique regions
      const regions = [...new Set(Object.values(cables).map(c => c.region))].sort();

      // Populate region filter
      regionFilter.innerHTML = '<option value="">All Corridors</option>' +
        regions.map(r => '<option value="' + r + '">' + r + '</option>').join('');

      // Clear search
      if (searchInput) searchInput.value = '';

      // Render cable list
      renderCsBulkImportList();

    } catch (error) {
      let errHtml = '<div style="color:#ef4444; padding:20px; text-align:center;">';
      errHtml += 'Failed to load cable database: ' + escapeHtml(error.message);
      if (error.message && error.message.includes('Failed to fetch')) {
        errHtml += '<br><span style="color:#888; font-size:11px;">This may be caused by running from a local file or network issues.</span>';
      }
      errHtml += '<br><br><button onclick="loadBulkImportCables()" class="btn">Retry</button>';
      errHtml += '</div>';
      cableList.innerHTML = errHtml;
    }
  }

  function renderCsBulkImportList() {
    const cableList = document.getElementById('csBulkCableList');
    const regionFilter = document.getElementById('csBulkRegionFilter');
    const searchInput = document.getElementById('csBulkSearchInput');

    if (!cableList) return;

    const searchTerm = (searchInput?.value || '').toLowerCase();
    const selectedRegion = regionFilter?.value || '';

    // Build set of already-imported cable names for duplicate detection
    const importedNames = new Set();
    (state.cableSystems || []).forEach(cs => {
      if (cs.name) importedNames.add(cs.name.toLowerCase());
      if (cs.shortName) importedNames.add(cs.shortName.toLowerCase());
    });

    // Filter cables
    const filteredCables = Object.entries(csBulkImportCables).filter(([key, cable]) => {
      // Region filter
      if (selectedRegion && cable.region !== selectedRegion) return false;

      // Search filter
      if (searchTerm) {
        const searchable = `${cable.name} ${cable.ownersText} ${cable.description}`.toLowerCase();
        if (!searchable.includes(searchTerm)) return false;
      }

      return true;
    });

    // Group by region
    const byRegion = {};
    filteredCables.forEach(([key, cable]) => {
      if (!byRegion[cable.region]) byRegion[cable.region] = [];
      byRegion[cable.region].push({ key, cable });
    });

    // Sort regions
    const sortedRegions = Object.keys(byRegion).sort();

    if (sortedRegions.length === 0) {
      cableList.innerHTML = '<div style="text-align:center; padding:40px; color:#666;">No cables match your search.</div>';
      return;
    }

    // Build HTML
    let html = '';
    for (const region of sortedRegions) {
      const cables = byRegion[region];
      const allSelected = cables.every(c => csBulkImportSelection.has(c.key));
      const someSelected = cables.some(c => csBulkImportSelection.has(c.key));

      html += `
        <div class="cs-bulk-region" style="margin-bottom:16px;">
          <div style="display:flex; align-items:center; gap:8px; padding:8px 12px; background:#f3f4f6; border-radius:8px 8px 0 0; border:1px solid #e0e0e0; border-bottom:none;">
            <input type="checkbox" class="cs-bulk-region-cb" data-region="${region}"
              ${allSelected ? 'checked' : ''} ${someSelected && !allSelected ? 'style="opacity:0.5"' : ''} />
            <span style="font-weight:600; flex:1;">${region}</span>
            <span style="font-size:11px; color:#666;">${cables.length} cable${cables.length > 1 ? 's' : ''}</span>
          </div>
          <div style="border:1px solid #e0e0e0; border-radius:0 0 8px 8px; background:white;">
            ${cables.map(({ key, cable }) => {
              const isSelected = csBulkImportSelection.has(key);
              const alreadyImported = importedNames.has((cable.name || '').toLowerCase());
              const statusIcon = getStatusIcon(cable.rfs, cable.status);
              // Use enriched capacityTbps if available, otherwise fallback to designCapacity
              const capacityInfo = cable.capacityTbps ? `${cable.capacityTbps} Tbps` : (cable.designCapacity !== 'Unknown' ? cable.designCapacity : '');
              const fpInfo = cable.fiberPairs > 0 ? `${cable.fiberPairs} FP` : '';
              // Use rfsYear if available, otherwise rfs string
              const rfsInfo = cable.rfsYear ? `RFS ${cable.rfsYear}` : (cable.rfs !== 'Unknown' ? cable.rfs : '');
              const metaInfo = [cable.status || '', rfsInfo, fpInfo, capacityInfo].filter(Boolean).join(' Â· ');

              return `
                <label class="cs-bulk-item" data-key="${key}" style="display:flex; align-items:flex-start; gap:10px; padding:10px 12px; cursor:pointer; border-bottom:1px solid #f0f0f0; ${isSelected ? 'background:#f0fdf4;' : ''}${alreadyImported ? 'opacity:0.6;' : ''}">
                  <input type="checkbox" class="cs-bulk-cable-cb" data-key="${key}" ${isSelected ? 'checked' : ''} style="margin-top:3px;" />
                  <div style="flex:1; min-width:0;">
                    <div style="font-weight:500; display:flex; align-items:center; gap:6px;">
                      ${statusIcon} ${cable.name}
                      ${alreadyImported ? '<span style="font-size:10px; background:#d1fae5; color:#065f46; padding:1px 4px; border-radius:3px;">Imported</span>' : ''}
                      ${cable.isMultiSegment ? '<span style="font-size:10px; background:#e0e7ff; color:#3730a3; padding:1px 4px; border-radius:3px;">Multi-segment</span>' : ''}
                    </div>
                    <div style="font-size:11px; color:#666; margin-top:2px;">${metaInfo}</div>
                    <div style="font-size:10px; color:#888; margin-top:2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${cable.ownersText}</div>
                  </div>
                  <div style="font-size:10px; color:#888; text-align:right; min-width:70px;">
                    ${cable.length_km ? cable.length_km.toLocaleString() + ' km' : ''}
                  </div>
                </label>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }

    cableList.innerHTML = html;
    updateCsBulkImportCount();

    // Attach event handlers
    cableList.querySelectorAll('.cs-bulk-cable-cb').forEach(cb => {
      cb.addEventListener('change', (e) => {
        const key = e.target.dataset.key;
        if (e.target.checked) {
          csBulkImportSelection.add(key);
        } else {
          csBulkImportSelection.delete(key);
        }
        renderCsBulkImportList();
      });
    });

    cableList.querySelectorAll('.cs-bulk-region-cb').forEach(cb => {
      cb.addEventListener('change', (e) => {
        const region = e.target.dataset.region;
        const cables = byRegion[region] || [];
        if (e.target.checked) {
          cables.forEach(c => csBulkImportSelection.add(c.key));
        } else {
          cables.forEach(c => csBulkImportSelection.delete(c.key));
        }
        renderCsBulkImportList();
      });
    });
  }

  function getStatusIcon(rfs, status) {
    // Use direct status if available from enriched database
    if (status) {
      if (status === 'Active') return 'ðŸŸ¢';           // In service
      if (status === 'Under Construction') return 'ðŸŸ¡'; // Being built
      if (status === 'Planned') return 'ðŸ”µ';          // Future
    }
    // Fallback to RFS-based inference
    if (!rfs || rfs === 'Unknown') return 'â›ª';  // Unknown status - neutral circle
    const year = parseInt(rfs);
    const currentYear = new Date().getFullYear();
    if (year > currentYear) return 'ðŸ”µ'; // Planned
    if (year === currentYear) return 'ðŸŸ¡'; // Under construction
    return 'ðŸŸ¢'; // In service
  }

  function updateCsBulkImportCount() {
    const countEl = document.getElementById('csBulkSelectedCount');
    const importBtn = document.getElementById('btnCsBulkImport');

    if (countEl) countEl.textContent = csBulkImportSelection.size;
    if (importBtn) importBtn.disabled = csBulkImportSelection.size === 0;
  }

  function closeCsBulkImportModal() {
    const modal = document.getElementById('csBulkImportModal');
    if (modal) modal.style.display = 'none';
    csBulkImportSelection.clear();
  }

  // Export cable systems to JSON file
  function exportCableSystems() {
    if (state.cableSystems.length === 0) {
      showToast('No cable systems to export.');
      return;
    }

    // Build export object matching our internal database format
    const exportData = {
      version: '1.0',
      lastUpdated: new Date().toISOString().split('T')[0],
      source: 'NexiMap Studio Export',
      exportedAt: new Date().toISOString(),
      cableCount: state.cableSystems.length,
      cables: {}
    };

    state.cableSystems.forEach(cs => {
      // Create a cable entry with all available data
      exportData.cables[cs.id] = {
        id: cs.id,
        name: cs.name,
        shortName: cs.shortName || cs.name,
        color: cs.color || '#0077b6',
        region: cs.region || 'Unknown',
        status: cs.status || 'operational',
        rfs: cs.rfs || '',
        rfsYear: cs.rfsYear || null,
        owners: cs.owners || [],
        ownersText: cs.owners ? cs.owners.join(', ') : '',
        length_km: cs.length_km || null,
        url: cs.url || null,
        geometry: cs.geometry || null,
        description: cs.description || '',
        source: cs.source || 'NexiMap',
        fiberAtlanticId: cs.fiberAtlanticId || null,
        fiberAtlanticName: cs.fiberAtlanticName || null,
        fiberAtlanticConfidence: cs.fiberAtlanticConfidence || null,
        faLiveStatus: cs.faLiveStatus || null
      };
    });

    // Create and download JSON file
    const jsonStr = JSON.stringify(exportData, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'cable_systems_export_' + new Date().toISOString().split('T')[0] + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    showToast('Exported ' + state.cableSystems.length + ' cable system(s) to JSON.');
  }

  // Export cable systems as standard GeoJSON FeatureCollection
  // If multi-select is active, exports only selected cables; otherwise exports all
  function exportCableSystemsAsGeoJSON() {
    // Determine which cables to export
    const multiSelectActive = document.getElementById('cableNavMultiSelect')?.checked || false;
    let cablesToExport;

    if (multiSelectActive && state.multiSelectedCableSystems && state.multiSelectedCableSystems.size > 0) {
      cablesToExport = state.cableSystems.filter(cs => state.multiSelectedCableSystems.has(cs.id));
    } else if (state.selectedCableSystem) {
      // Single selection - export just the selected one
      cablesToExport = state.cableSystems.filter(cs => cs.id === state.selectedCableSystem);
    } else {
      // No selection - export all
      cablesToExport = state.cableSystems;
    }

    if (cablesToExport.length === 0) {
      showToast('No cable systems to export. Select cables first or ensure Cable System List is not empty.');
      return;
    }

    // Only export cables that have geometry
    const withGeometry = cablesToExport.filter(cs => cs.geometry);
    const withoutGeometry = cablesToExport.filter(cs => !cs.geometry);

    if (withGeometry.length === 0) {
      showToast('None of the selected cable systems have geometry data to export as GeoJSON.');
      return;
    }

    // Build GeoJSON FeatureCollection
    const features = [];
    withGeometry.forEach(cs => {
      const properties = {
        id: cs.id,
        name: cs.name,
        shortName: cs.shortName || cs.name,
        color: cs.color || '#0077b6',
        region: cs.region || 'Unknown',
        status: cs.status || 'unknown',
        rfs: cs.rfs || '',
        rfsYear: cs.rfsYear || null,
        owners: cs.owners || [],
        length_km: cs.length_km || null,
        source: cs.source || 'NexiMap',
        stroke: cs.color || '#0077b6',
        'stroke-width': 2,
        'stroke-opacity': 1
      };
      if (cs.fiberAtlanticId) properties.fiberAtlanticId = cs.fiberAtlanticId;
      if (cs.fiberAtlanticName) properties.fiberAtlanticName = cs.fiberAtlanticName;
      if (cs.faLiveStatus) properties.faLiveStatus = cs.faLiveStatus;

      // Handle different geometry types
      const geom = cs.geometry;
      if (geom.type === 'MultiLineString' || geom.type === 'LineString' || geom.type === 'Point' || geom.type === 'MultiPoint' || geom.type === 'Polygon' || geom.type === 'MultiPolygon' || geom.type === 'GeometryCollection') {
        features.push({
          type: 'Feature',
          properties: properties,
          geometry: geom
        });
      } else if (geom.coordinates) {
        // Fallback: assume LineString if coordinates present but no type
        features.push({
          type: 'Feature',
          properties: properties,
          geometry: { type: 'LineString', coordinates: geom.coordinates }
        });
      }
    });

    const geojson = {
      type: 'FeatureCollection',
      name: 'NexiMap Studio Cable Export',
      exportedAt: new Date().toISOString(),
      features: features
    };

    // Download
    const jsonStr = JSON.stringify(geojson, null, 2);
    const blob = new Blob([jsonStr], { type: 'application/geo+json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const dateStr = new Date().toISOString().split('T')[0];
    const nameHint = cablesToExport.length === 1 ? '_' + (cablesToExport[0].shortName || cablesToExport[0].name).replace(/[^a-zA-Z0-9_-]/g, '_').substring(0, 40) : '';
    a.download = 'cables_geojson' + nameHint + '_' + dateStr + '.geojson';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    let msg = 'Exported ' + withGeometry.length + ' cable(s) as GeoJSON.';
    if (withoutGeometry.length > 0) {
      msg += ' (' + withoutGeometry.length + ' skipped - no geometry)';
    }
    showToast(msg);
  }

  function executeCsBulkImport() {
    if (csBulkImportSelection.size === 0) return;

    const currentYear = new Date().getFullYear();
    let importedCount = 0;

    for (const cableKey of csBulkImportSelection) {
      const cable = csBulkImportCables[cableKey];
      if (!cable) continue;

      // Use shortName from JSON database, fallback to name if not available
      const shortName = cable.shortName || cable.name;

      // Use status from enriched database metadata, with fallback to RFS-based inference
      let status = 'planned';
      if (cable.status === 'Active' || cable.status === 'operational') {
        status = 'operational';
      } else if (cable.status === 'Under Construction' || cable.status === 'under-construction') {
        status = 'under-construction';
      } else if (cable.status === 'Planned' || cable.status === 'planned') {
        status = 'planned';
      } else {
        // Fallback: infer from RFS year if status not available
        const rfsCheck = cable.rfsYear || parseInt(cable.rfs);
        if (!isNaN(rfsCheck) && rfsCheck <= currentYear) {
          status = 'operational';
        }
      }

      // Safety net: ALWAYS cross-check â€” if RFS year is in the past, cable must be operational
      // This catches cases where the DB has status='Unknown' or 'Planned' but rfs='2010'
      if (status === 'planned') {
        const rfsCheck = cable.rfsYear || parseInt(cable.rfs);
        if (!isNaN(rfsCheck) && rfsCheck <= currentYear) {
          status = (currentYear - rfsCheck) >= 20 ? 'decommissioned' : 'operational';
        } else if (!isNaN(rfsCheck) && rfsCheck <= currentYear + 2) {
          status = 'under-construction';
        }
      }

      // Determine RFS year from metadata
      // Priority: explicit rfsYear > parsed rfs string > infer from status > null
      let rfsYear = null;
      if (cable.rfsYear && typeof cable.rfsYear === 'number') {
        rfsYear = cable.rfsYear;
      } else if (cable.rfs && cable.rfs !== 'Unknown' && cable.rfs !== '') {
        const parsed = parseInt(cable.rfs);
        if (!isNaN(parsed) && parsed > 1990 && parsed < 2100) rfsYear = parsed;
      }
      // If status is Active but no RFS year, leave rfsYear as null rather than guessing
      // The getStatusClass function will use the status field as fallback

      // Use capacity from enriched metadata, with fallback to parsed designCapacity
      let capacityTbps = cable.capacityTbps || 0;
      if (!capacityTbps && cable.designCapacity && cable.designCapacity !== 'Unknown') {
        const capMatch = cable.designCapacity.match(/([\d.]+)/);
        if (capMatch) capacityTbps = parseFloat(capMatch[1]);
      }

      // Build notes from landing points (support both landingPoints and landing_points)
      const lps = cable.landingPoints || cable.landing_points || [];
      const landingPointNotes = lps.map(lp => `${lp.name}${lp.country ? ', ' + lp.country : ''}`).join(' â†’ ') || '';
      const notes = [
        cable.length_km ? `Length: ${cable.length_km.toLocaleString()} km` : '',
        cable.status ? `Status: ${cable.status}` : '',
        landingPointNotes ? `Route: ${landingPointNotes}` : '',
        cable.isMultiSegment ? `Multi-segment cable (${cable.segmentCount} segments)` : '',
        `Source: Submarine Cable Database`
      ].filter(Boolean).join('\n');

      // Build filter tags
      const filterTags = ['submarine', cable.region];
      if (cable.name) filterTags.push(cable.name.toLowerCase().replace(/[^a-z0-9]/g, '-'));

      // Create the cable system object with enriched metadata
      const id = state.nextCableSystem++;
      const cs = {
        id,
        uuid: generateUUID(),
        shortName: shortName,
        name: cable.name,
        type: 'wet',
        rfsYear: rfsYear,
        rfs: cable.rfs || '',
        fiberPairs: cable.fiberPairs || 8,
        status: status,
        capacityTbps: capacityTbps || 100,
        owners: cable.owners || [],
        region: cable.region || 'Unknown',
        color: cable.color || '#0077b6',
        length_km: cable.length_km || null,
        url: cable.url || null,
        geometry: cable.geometry || null,  // IMPORTANT: Include geometry for export
        filterTags: filterTags,
        notes: notes,
        description: cable.description || '',
        source: cable.source || 'Submarine Cable Database',
        // Store reference to original cable data for potential path import
        _sourceDbId: cableKey
      };

      state.cableSystems.push(cs);
      importedCount++;
    }

    if (importedCount > 0) {
      commit();
      updateCableNavigatorList();
      showToast(`Imported ${importedCount} cable system${importedCount > 1 ? 's' : ''} from database.`);
    }

    // Keep modal open for further imports â€” just clear selection and refresh list
    csBulkImportSelection.clear();
    updateCsBulkImportCount();
    renderCsBulkImportList();
  }

  // Set up bulk import modal event handlers
  document.getElementById('btnCloseCsBulkImport')?.addEventListener('click', closeCsBulkImportModal);
  document.getElementById('btnCsBulkCancel')?.addEventListener('click', closeCsBulkImportModal);
  document.getElementById('btnCsBulkImport')?.addEventListener('click', executeCsBulkImport);

  document.getElementById('btnCsBulkSelectAll')?.addEventListener('click', () => {
    // Select all visible cables
    const searchTerm = (document.getElementById('csBulkSearchInput')?.value || '').toLowerCase();
    const selectedRegion = document.getElementById('csBulkRegionFilter')?.value || '';

    Object.entries(csBulkImportCables).forEach(([key, cable]) => {
      if (selectedRegion && cable.region !== selectedRegion) return;
      if (searchTerm) {
        const searchable = `${cable.name} ${cable.ownersText} ${cable.description}`.toLowerCase();
        if (!searchable.includes(searchTerm)) return;
      }
      csBulkImportSelection.add(key);
    });
    renderCsBulkImportList();
  });

  document.getElementById('btnCsBulkSelectNone')?.addEventListener('click', () => {
    csBulkImportSelection.clear();
    renderCsBulkImportList();
  });

  document.getElementById('csBulkSearchInput')?.addEventListener('input', renderCsBulkImportList);
  document.getElementById('csBulkRegionFilter')?.addEventListener('change', renderCsBulkImportList);

  // Close modal on backdrop click
  document.getElementById('csBulkImportModal')?.addEventListener('click', (e) => {
    if (e.target.id === 'csBulkImportModal') closeCsBulkImportModal();
  });
  // ========== END CABLE SYSTEM BULK IMPORT ==========

  // Update inspector to show cable system details
  function updateCableSystemInspector() {
    const csNoSel = document.getElementById('csNoSelection');
    const csDetails = document.getElementById('csDetails');

    if (!csNoSel || !csDetails) return;

    if (!state.selectedCableSystem) {
      csNoSel.style.display = 'block';
      csDetails.style.display = 'none';
      return;
    }

    const cs = findCableSystem(state.selectedCableSystem);
    if (!cs) {
      csNoSel.style.display = 'block';
      csDetails.style.display = 'none';
      return;
    }

    csNoSel.style.display = 'none';
    csDetails.style.display = 'block';

    // Populate fields
    document.getElementById('csUUID').value = cs.uuid || '';
    document.getElementById('csShortName').value = cs.shortName || '';
    document.getElementById('csName').value = cs.name || '';
    document.getElementById('csType').value = cs.type || 'wet';
    document.getElementById('csStatus').value = cs.status || 'planned';
    document.getElementById('csRfsYear').value = cs.rfsYear || '';
    document.getElementById('csFiberPairs').value = cs.fiberPairs || '';
    document.getElementById('csCapacity').value = cs.capacityTbps || '';
    document.getElementById('csOwners').value = cs.owners || '';
    document.getElementById('csFilterTags').value = (cs.filterTags || []).join(', ');
    document.getElementById('csNotes').value = cs.notes || '';

    // FiberAtlantic link field
    const faIdInput = document.getElementById('csFiberAtlanticId');
    const faSearchInput = document.getElementById('csFaSearchInput');
    const faClearBtn = document.getElementById('csFaSearchClear');
    const faStatus = document.getElementById('csFaLinkStatus');
    const faMatchInfo = document.getElementById('csFaMatchInfo');
    const faDropdown = document.getElementById('csFaDropdown');
    if (faIdInput) faIdInput.value = cs.fiberAtlanticId || '';
    if (faSearchInput) {
      faSearchInput.value = cs.fiberAtlanticName || '';
      faSearchInput.style.fontWeight = cs.fiberAtlanticId ? '600' : 'normal';
    }
    if (faClearBtn) faClearBtn.style.display = cs.fiberAtlanticId ? 'block' : 'none';
    if (faDropdown) faDropdown.style.display = 'none';
    if (faStatus) {
      if (cs.fiberAtlanticId) {
        faStatus.textContent = cs.fiberAtlanticName || cs.fiberAtlanticId;
        faStatus.className = 'fa-link-badge';
      } else {
        faStatus.textContent = 'Not linked';
        faStatus.className = 'fa-link-badge unlinked';
      }
    }
    if (faMatchInfo) {
      faMatchInfo.textContent = cs.fiberAtlanticConfidence ? `Match: ${cs.fiberAtlanticConfidence}` : '';
    }

    // Update member lists
    const links = getCableSystemLinks(cs.id);
    const nodes = getCableSystemNodes(cs.id);

    document.getElementById('csMemberLinksCount').textContent = links.length;
    document.getElementById('csMemberNodesCount').textContent = nodes.length;

    const linksContainer = document.getElementById('csMemberLinks');
    if (links.length === 0) {
      linksContainer.innerHTML = '<div class="muted">No links assigned</div>';
    } else {
      linksContainer.innerHTML = links.map(l => {
        const nodeA = findNode(l.a);
        const nodeB = findNode(l.b);
        return `<div class="member-item" data-type="edge" data-id="${l.id}" style="padding:4px; cursor:pointer; border-radius:3px; display:flex; justify-content:space-between; align-items:center;">
          <span>${l.code || 'L-' + l.id}: ${nodeA?.name || '?'} â†” ${nodeB?.name || '?'}</span>
          <button class="remove-member-btn" data-type="edge" data-id="${l.id}" style="background:none; border:none; color:#d32f2f; cursor:pointer; font-size:14px;" title="Remove from cable system">Ã—</button>
        </div>`;
      }).join('');
    }

    const nodesContainer = document.getElementById('csMemberNodes');
    if (nodes.length === 0) {
      nodesContainer.innerHTML = '<div class="muted">No nodes assigned</div>';
    } else {
      nodesContainer.innerHTML = nodes.map(n => {
        return `<div class="member-item" data-type="node" data-id="${n.id}" style="padding:4px; cursor:pointer; border-radius:3px; display:flex; justify-content:space-between; align-items:center;">
          <span>${n.code || 'N-' + n.id}: ${n.name || 'Unnamed'}</span>
          <button class="remove-member-btn" data-type="node" data-id="${n.id}" style="background:none; border:none; color:#d32f2f; cursor:pointer; font-size:14px;" title="Remove from cable system">Ã—</button>
        </div>`;
      }).join('');
    }

    // Add click handlers for member items
    document.querySelectorAll('#csMemberLinks .member-item, #csMemberNodes .member-item').forEach(item => {
      let clickCount = 0;
      let clickTimer = null;

      item.addEventListener('click', (e) => {
        // Ignore if clicking remove button
        if (e.target.classList.contains('remove-member-btn')) return;

        clickCount++;
        if (clickCount === 1) {
          clickTimer = setTimeout(() => {
            // Single click - highlight on canvas
            const type = item.dataset.type;
            const id = parseInt(item.dataset.id);
            highlightItemOnCanvas(type, id);
            clickCount = 0;
          }, 300);
        } else if (clickCount === 2) {
          // Double click - show in main inspector
          clearTimeout(clickTimer);
          const type = item.dataset.type;
          const id = parseInt(item.dataset.id);
          select({ type, id });
          // Show main inspector if hidden
          if (inspector.style.display === 'none') {
            inspector.style.display = 'flex';
            btnToggleInspector.classList.add('active');
          }
          clickCount = 0;
        }
      });

      item.addEventListener('mouseenter', () => {
        item.style.background = '#e3f2fd';
      });
      item.addEventListener('mouseleave', () => {
        item.style.background = '';
      });
    });

    // Add click handlers for remove buttons
    document.querySelectorAll('.remove-member-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const type = btn.dataset.type;
        const id = parseInt(btn.dataset.id);

        if (type === 'edge') {
          const edge = findEdge(id);
          if (edge) {
            edge.cableSystemId = null;
            commit();
            updateCableSystemInspector();
            updateCableNavigatorList();
            render();
            showToast('Link removed from cable system.');
          }
        } else if (type === 'node') {
          const node = findNode(id);
          if (node && node.cableSystemIds) {
            node.cableSystemIds = node.cableSystemIds.filter(csId => csId !== state.selectedCableSystem);
            commit();
            updateCableSystemInspector();
            updateCableNavigatorList();
            render();
            showToast('Node removed from cable system.');
          }
        }
      });
    });
  }

  // Add mode functions
  function startAddMode(type) {
    if (!state.selectedCableSystem) {
      showToast('Select a cable system first.');
      return;
    }

    csAddMode = type; // 'links' or 'nodes'
    csPendingItems = new Set();

    const addModeBar = document.getElementById('csAddModeBar');
    const addModeText = document.getElementById('csAddModeText');

    if (addModeBar && addModeText) {
      addModeBar.style.display = 'block';
      addModeText.textContent = type === 'links'
        ? 'Click links on canvas to add them...'
        : 'Click nodes on canvas to add them...';
    }

    showToast(`Click ${type} on canvas to add. Click Accept when done.`);
    render(); // Re-render to show visual feedback
  }

  function cancelAddMode() {
    csAddMode = null;
    csPendingItems = new Set();

    const addModeBar = document.getElementById('csAddModeBar');
    if (addModeBar) addModeBar.style.display = 'none';

    clearHighlights();
    render();
  }

  function acceptAddMode() {
    if (!csAddMode || !state.selectedCableSystem) {
      cancelAddMode();
      return;
    }

    const cs = findCableSystem(state.selectedCableSystem);
    if (!cs) {
      cancelAddMode();
      return;
    }

    let count = 0;
    const addedLinkIds = [];

    if (csAddMode === 'links') {
      csPendingItems.forEach(linkId => {
        const edge = findEdge(linkId);
        if (edge) {
          edge.cableSystemId = state.selectedCableSystem;
          addedLinkIds.push(linkId);
          count++;
        }
      });

      // If links were added, show naming option dialog
      if (count > 0) {
        commit();
        showToast(`Added ${count} links to "${cs.shortName}".`);
        cancelAddMode();
        updateCableSystemInspector();
        updateCableNavigatorList();
        render();

        // Show optional naming dialog
        showAutoNameLinksDialog(cs, addedLinkIds);
        return;
      }
    } else if (csAddMode === 'nodes') {
      csPendingItems.forEach(nodeId => {
        const node = findNode(nodeId);
        if (node) {
          if (!node.cableSystemIds) node.cableSystemIds = [];
          if (!node.cableSystemIds.includes(state.selectedCableSystem)) {
            node.cableSystemIds.push(state.selectedCableSystem);
            count++;
          }
        }
      });
    }

    if (count > 0) {
      commit();
      showToast(`Added ${count} ${csAddMode} to "${cs.shortName}".`);
    }

    cancelAddMode();
    updateCableSystemInspector();
    updateCableNavigatorList();
    render();
  }

  // Show dialog to optionally apply cable system name to newly added links
  function showAutoNameLinksDialog(cs, linkIds) {
    const links = linkIds.map(id => findEdge(id)).filter(Boolean);
    const emptyTagLinks = links.filter(l => !l.tag || l.tag.trim() === '');

    // If all links already have tags, skip the dialog
    if (emptyTagLinks.length === 0) return;

    const modal = document.createElement('div');
    modal.id = 'autoNameLinksModal';
    modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:11000; display:flex; align-items:center; justify-content:center;';

    modal.innerHTML = `
      <div style="background:white; border-radius:12px; padding:20px; max-width:400px; width:90%; box-shadow:0 8px 32px rgba(0,0,0,0.3);">
        <h3 style="margin:0 0 12px 0; font-size:16px;">ðŸ·ï¸ Apply Cable System Name to Links?</h3>
        <div style="font-size:13px; color:#666; margin-bottom:16px;">
          ${emptyTagLinks.length} of ${links.length} link${links.length > 1 ? 's' : ''} ha${emptyTagLinks.length === 1 ? 's' : 've'} empty tag${emptyTagLinks.length > 1 ? 's' : ''}.<br>
          Would you like to set the tag to "<strong>${cs.shortName}</strong>"?
        </div>

        <div style="display:flex; gap:8px; justify-content:flex-end;">
          <button id="btnSkipAutoName" class="btn" style="padding:8px 16px;">No, Skip</button>
          <button id="btnApplyAutoName" class="btn primary" style="padding:8px 16px;">Yes, Apply</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    modal.querySelector('#btnSkipAutoName').addEventListener('click', () => modal.remove());
    modal.querySelector('#btnApplyAutoName').addEventListener('click', () => {
      let count = 0;
      emptyTagLinks.forEach(link => {
        link.tag = cs.shortName;
        count++;
      });

      if (count > 0) {
        commit();
        render();
        updateInspector();
        showToast(`Applied "${cs.shortName}" to ${count} link tag${count > 1 ? 's' : ''}.`);
      }
      modal.remove();
    });

    // Close on backdrop click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
  }

  // Handle canvas clicks during add mode
  function handleAddModeClick(type, id) {
    if (!csAddMode) return false;

    if (csAddMode === 'links' && type === 'edge') {
      if (csPendingItems.has(id)) {
        csPendingItems.delete(id);
      } else {
        csPendingItems.add(id);
      }
      // Update highlights
      state._highlightedLinks = new Set(csPendingItems);
      render();
      return true;
    } else if (csAddMode === 'nodes' && type === 'node') {
      if (csPendingItems.has(id)) {
        csPendingItems.delete(id);
      } else {
        csPendingItems.add(id);
      }
      // Update highlights
      state._highlightedNodes = new Set(csPendingItems);
      render();
      return true;
    }

    return false;
  }

  // Button handlers for add mode
  const btnAddLinksToCS = document.getElementById('btnAddLinksToCS');
  const btnAddNodesToCS = document.getElementById('btnAddNodesToCS');
  const btnAcceptAddToCS = document.getElementById('btnAcceptAddToCS');
  const btnCancelAddToCS = document.getElementById('btnCancelAddToCS');

  if (btnAddLinksToCS) {
    btnAddLinksToCS.addEventListener('click', () => startAddMode('links'));
  }
  if (btnAddNodesToCS) {
    btnAddNodesToCS.addEventListener('click', () => startAddMode('nodes'));
  }
  if (btnAcceptAddToCS) {
    btnAcceptAddToCS.addEventListener('click', acceptAddMode);
  }
  if (btnCancelAddToCS) {
    btnCancelAddToCS.addEventListener('click', cancelAddMode);
  }

  // Apply Cable System name to Link Tags button
  const btnApplyCSNameToLinks = document.getElementById('btnApplyCSNameToLinks');
  if (btnApplyCSNameToLinks) {
    btnApplyCSNameToLinks.addEventListener('click', () => {
      if (!state.selectedCableSystem) {
        showToast('No cable system selected.');
        return;
      }
      showApplyCSNameDialog();
    });
  }

  // FiberAtlantic auto-match button for individual cable system
  document.getElementById('btnAutoMatchFA')?.addEventListener('click', async () => {
    if (!state.selectedCableSystem) return;
    const cs = findCableSystem(state.selectedCableSystem);
    if (!cs) return;

    const btn = document.getElementById('btnAutoMatchFA');
    const info = document.getElementById('csFaMatchInfo');
    btn.disabled = true;
    btn.textContent = 'â³ Matching...';
    if (info) info.textContent = 'Contacting Live Status...';

    try {
      const cables = await fetchFiberAtlanticCables();
      if (!cables) {
        if (info) info.textContent = 'âš ï¸ Could not reach Live Status API';
        return;
      }

      let result = autoMatchFiberAtlantic(cs.name, cables);
      if (!result) result = autoMatchFiberAtlantic(cs.shortName, cables);

      if (result) {
        cs.fiberAtlanticId = result.match.id || result.match.slug || result.match.name;
        cs.fiberAtlanticName = result.match.name;
        cs.fiberAtlanticConfidence = result.confidence;
        cs.faLiveStatus = result.match.status || ''; // Store live status from cable list

        const faIdInput = document.getElementById('csFiberAtlanticId');
        if (faIdInput) faIdInput.value = cs.fiberAtlanticId;

        const faSearchInput = document.getElementById('csFaSearchInput');
        if (faSearchInput) { faSearchInput.value = result.match.name; faSearchInput.style.fontWeight = '600'; }
        const faClearBtn = document.getElementById('csFaSearchClear');
        if (faClearBtn) faClearBtn.style.display = 'block';
        const faDropdown = document.getElementById('csFaDropdown');
        if (faDropdown) faDropdown.style.display = 'none';

        const faStatus = document.getElementById('csFaLinkStatus');
        if (faStatus) {
          faStatus.textContent = cs.fiberAtlanticName || cs.fiberAtlanticId;
          faStatus.className = 'fa-link-badge';
        }
        if (info) info.textContent = `âœ… Matched (${result.confidence}): ${result.match.name}`;

        commit();
        updateCableNavigatorList();
        showToast(`Linked "${cs.shortName}" â†’ "${result.match.name}" (${result.confidence})`, 'success');
      } else {
        if (info) info.textContent = `âŒ No match found for "${cs.name}" or "${cs.shortName}"`;
      }
    } catch (err) {
      if (info) info.textContent = `âš ï¸ Error: ${err.message}`;
    } finally {
      btn.disabled = false;
      btn.textContent = 'ðŸ” Auto';
    }
  });

  // ======================
  // FiberAtlantic Manual Dropdown Search/Select
  // ======================
  // Preloaded FA cable list for the dropdown (lazy-loaded on first focus)
  let faDropdownCablesLoaded = false;
  let faDropdownCables = [];

  // Status indicator colors for dropdown items
  function faStatusDot(status) {
    const colors = { online: '#22c55e', outage: '#ef4444', 'in development': '#f59e0b', proposal: '#3b82f6', project: '#8b5cf6' };
    const color = colors[(status || '').toLowerCase()] || '#d1d5db';
    return `<span style="display:inline-block; width:8px; height:8px; border-radius:50%; background:${color}; margin-right:6px; flex-shrink:0;"></span>`;
  }

  // Load FA cable list into dropdown cache
  async function ensureFaDropdownLoaded() {
    if (faDropdownCablesLoaded) return faDropdownCables;
    const searchInput = document.getElementById('csFaSearchInput');
    if (searchInput) searchInput.placeholder = 'Loading Live Status cables...';

    const cables = await fetchFiberAtlanticCables();
    if (cables && Array.isArray(cables)) {
      faDropdownCables = cables.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
      faDropdownCablesLoaded = true;
    }
    if (searchInput) searchInput.placeholder = 'Search Live Status cables...';
    return faDropdownCables;
  }

  // Render filtered dropdown items
  function renderFaDropdown(filter = '') {
    const dropdown = document.getElementById('csFaDropdown');
    if (!dropdown) return;

    const term = filter.toLowerCase().trim();
    const filtered = term
      ? faDropdownCables.filter(c => (c.name || '').toLowerCase().includes(term))
      : faDropdownCables;

    if (filtered.length === 0) {
      dropdown.innerHTML = '<div style="padding:8px 12px; color:#999; font-style:italic;">No cables match your search</div>';
      dropdown.style.display = 'block';
      return;
    }

    // Limit to 50 for performance, show count if more
    const shown = filtered.slice(0, 50);
    const remaining = filtered.length - shown.length;

    dropdown.innerHTML = shown.map(c => `
      <div class="fa-dropdown-item" data-fa-id="${c.id}" data-fa-name="${escapeHtml(c.name)}" data-fa-status="${escapeHtml(c.status || '')}"
           style="padding:6px 12px; cursor:pointer; display:flex; align-items:center; border-bottom:1px solid #f0f0f0;"
           onmouseover="this.style.background='#f0f7ff'" onmouseout="this.style.background='white'">
        ${faStatusDot(c.status)}
        <span style="flex:1; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${escapeHtml(c.name)}</span>
        <span style="font-size:9px; color:#999; margin-left:8px; flex-shrink:0;">${escapeHtml(c.status || '')}</span>
      </div>
    `).join('') + (remaining > 0 ? `<div style="padding:6px 12px; color:#999; font-size:10px; text-align:center; background:#f9fafb;">+ ${remaining} more â€” keep typing to filter</div>` : '');

    dropdown.style.display = 'block';

    // Add click handlers to items
    dropdown.querySelectorAll('.fa-dropdown-item').forEach(item => {
      item.addEventListener('click', () => {
        selectFaDropdownItem(item.dataset.faId, item.dataset.faName, item.dataset.faStatus);
      });
    });
  }

  // Handle selection from dropdown
  function selectFaDropdownItem(faId, faName, faStatus) {
    const cs = findCableSystem(state.selectedCableSystem);
    if (!cs) return;

    // Update the cable system
    cs.fiberAtlanticId = faId;
    cs.fiberAtlanticName = faName;
    cs.fiberAtlanticConfidence = 'manual';
    cs.faLiveStatus = faStatus || ''; // Store live status from cable list

    // Update UI
    const searchInput = document.getElementById('csFaSearchInput');
    const hiddenInput = document.getElementById('csFiberAtlanticId');
    const clearBtn = document.getElementById('csFaSearchClear');
    const dropdown = document.getElementById('csFaDropdown');
    const faStatusEl = document.getElementById('csFaLinkStatus');
    const info = document.getElementById('csFaMatchInfo');

    if (searchInput) { searchInput.value = faName; searchInput.style.fontWeight = '600'; }
    if (hiddenInput) hiddenInput.value = faId;
    if (clearBtn) clearBtn.style.display = 'block';
    if (dropdown) dropdown.style.display = 'none';
    if (faStatusEl) { faStatusEl.textContent = faName; faStatusEl.className = 'fa-link-badge'; }
    if (info) info.textContent = `âœ… Manually linked â€” Status: ${faStatus || 'unknown'}`;

    commit();
    updateCableNavigatorList();
    showToast(`Linked "${cs.shortName}" â†’ "${faName}" (manual)`, 'success');

    // Fetch detail to get live status
    fetchFiberAtlanticDetail(faId);
  }

  // Clear FA link
  function clearFaSelection() {
    const cs = findCableSystem(state.selectedCableSystem);
    if (!cs) return;

    cs.fiberAtlanticId = null;
    cs.fiberAtlanticName = null;
    cs.fiberAtlanticConfidence = null;
    cs.faLiveStatus = null;

    const searchInput = document.getElementById('csFaSearchInput');
    const hiddenInput = document.getElementById('csFiberAtlanticId');
    const clearBtn = document.getElementById('csFaSearchClear');
    const faStatusEl = document.getElementById('csFaLinkStatus');
    const info = document.getElementById('csFaMatchInfo');

    if (searchInput) { searchInput.value = ''; searchInput.style.fontWeight = 'normal'; }
    if (hiddenInput) hiddenInput.value = '';
    if (clearBtn) clearBtn.style.display = 'none';
    if (faStatusEl) { faStatusEl.textContent = 'Not linked'; faStatusEl.className = 'fa-link-badge unlinked'; }
    if (info) info.textContent = '';

    commit();
    updateCableNavigatorList();
  }

  // Wire up search input events
  document.getElementById('csFaSearchInput')?.addEventListener('focus', async () => {
    await ensureFaDropdownLoaded();
    renderFaDropdown(document.getElementById('csFaSearchInput')?.value || '');
  });

  document.getElementById('csFaSearchInput')?.addEventListener('input', (e) => {
    renderFaDropdown(e.target.value);
    // If user clears the input text, don't auto-clear the link yet
    if (!e.target.value.trim()) {
      const dropdown = document.getElementById('csFaDropdown');
      if (dropdown) renderFaDropdown('');
    }
  });

  // Close dropdown when clicking outside
  document.addEventListener('click', (e) => {
    const dropdown = document.getElementById('csFaDropdown');
    const searchInput = document.getElementById('csFaSearchInput');
    if (dropdown && searchInput && !searchInput.contains(e.target) && !dropdown.contains(e.target)) {
      dropdown.style.display = 'none';
    }
  });

  // Clear button
  document.getElementById('csFaSearchClear')?.addEventListener('click', clearFaSelection);

  function showApplyCSNameDialog() {
    const cs = findCableSystem(state.selectedCableSystem);
    if (!cs) return;

    const links = getCableSystemLinks(cs.id);
    if (links.length === 0) {
      showToast('No links assigned to this cable system.');
      return;
    }

    // Count links with empty vs non-empty tags
    const emptyTagLinks = links.filter(l => !l.tag || l.tag.trim() === '');
    const nonEmptyTagLinks = links.filter(l => l.tag && l.tag.trim() !== '');

    // Create dialog
    const modal = document.createElement('div');
    modal.id = 'applyCSNameModal';
    modal.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:11000; display:flex; align-items:center; justify-content:center;';

    modal.innerHTML = `
      <div style="background:white; border-radius:12px; padding:20px; max-width:450px; width:90%; box-shadow:0 8px 32px rgba(0,0,0,0.3);">
        <h3 style="margin:0 0 12px 0; font-size:16px;">ðŸ·ï¸ Apply Cable System Name to Link Tags</h3>
        <div style="font-size:13px; color:#666; margin-bottom:16px;">
          Cable System: <strong>${cs.shortName}</strong> (${cs.name})<br>
          ${links.length} link${links.length > 1 ? 's' : ''} assigned
          ${emptyTagLinks.length > 0 ? `<br><span style="color:#10b981;">â€¢ ${emptyTagLinks.length} with empty tag</span>` : ''}
          ${nonEmptyTagLinks.length > 0 ? `<br><span style="color:#f59e0b;">â€¢ ${nonEmptyTagLinks.length} with existing tag</span>` : ''}
        </div>

        <div style="margin-bottom:16px;">
          <label style="font-size:12px; font-weight:500;">Name to apply:</label>
          <select id="csNameToApply" style="width:100%; padding:8px; border:1px solid #d0d0d0; border-radius:6px; margin-top:4px; font-size:13px;">
            <option value="${cs.shortName}">${cs.shortName} (Short Name)</option>
            <option value="${cs.name}">${cs.name} (Full Name)</option>
          </select>
        </div>

        <div style="margin-bottom:16px;">
          <label style="font-size:12px; font-weight:500;">Apply to:</label>
          <div style="margin-top:6px;">
            <label style="display:flex; align-items:center; gap:8px; padding:6px 0; cursor:pointer;">
              <input type="radio" name="applyMode" value="empty" checked />
              <span style="font-size:13px;">Only links with empty tags (${emptyTagLinks.length})</span>
            </label>
            <label style="display:flex; align-items:center; gap:8px; padding:6px 0; cursor:pointer;">
              <input type="radio" name="applyMode" value="append" />
              <span style="font-size:13px;">Append to existing tags (all ${links.length})</span>
            </label>
            <label style="display:flex; align-items:center; gap:8px; padding:6px 0; cursor:pointer;">
              <input type="radio" name="applyMode" value="replace" />
              <span style="font-size:13px;">Replace all tags (all ${links.length})</span>
            </label>
          </div>
        </div>

        <div style="display:flex; gap:8px; justify-content:flex-end;">
          <button id="btnCancelApplyCSName" class="btn" style="padding:8px 16px;">Cancel</button>
          <button id="btnConfirmApplyCSName" class="btn primary" style="padding:8px 16px;">Apply</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // Event handlers
    modal.querySelector('#btnCancelApplyCSName').addEventListener('click', () => modal.remove());
    modal.querySelector('#btnConfirmApplyCSName').addEventListener('click', () => {
      const nameToApply = modal.querySelector('#csNameToApply').value;
      const applyMode = modal.querySelector('input[name="applyMode"]:checked').value;

      let count = 0;
      links.forEach(link => {
        const currentTag = (link.tag || '').trim();

        if (applyMode === 'empty') {
          // Only apply to empty tags
          if (!currentTag) {
            link.tag = nameToApply;
            count++;
          }
        } else if (applyMode === 'append') {
          // Append to existing (with separator if not empty)
          if (currentTag) {
            // Check if name is already in the tag
            if (!currentTag.includes(nameToApply)) {
              link.tag = currentTag + ' | ' + nameToApply;
              count++;
            }
          } else {
            link.tag = nameToApply;
            count++;
          }
        } else if (applyMode === 'replace') {
          // Replace all
          link.tag = nameToApply;
          count++;
        }
      });

      if (count > 0) {
        commit();
        render();
        updateInspector();
        showToast(`Applied "${nameToApply}" to ${count} link${count > 1 ? 's' : ''}.`);
      } else {
        showToast('No links were modified.');
      }

      modal.remove();
    });

    // Close on backdrop click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
  }

  function highlightItemOnCanvas(type, id) {
    // Temporarily highlight an item
    if (type === 'edge') {
      state._highlightedLinks = new Set([id]);
      state._highlightedNodes = null;
    } else if (type === 'node') {
      state._highlightedNodes = new Set([id]);
      state._highlightedLinks = null;
    }
    render();

    // Clear after 2 seconds
    setTimeout(() => {
      clearHighlights();
    }, 2000);
  }

  // Add event listeners for cable system inspector fields
  const csFields = ['csShortName', 'csName', 'csType', 'csStatus', 'csRfsYear',
                    'csFiberPairs', 'csCapacity', 'csOwners', 'csFilterTags', 'csNotes', 'csFiberAtlanticId'];

  csFields.forEach(fieldId => {
    const el = document.getElementById(fieldId);
    if (!el) return;

    el.addEventListener('input', () => {
      if (!state.selectedCableSystem) return;
      const cs = findCableSystem(state.selectedCableSystem);
      if (!cs) return;

      switch(fieldId) {
        case 'csShortName': cs.shortName = el.value; break;
        case 'csName': cs.name = el.value; break;
        case 'csType': cs.type = el.value; break;
        case 'csStatus': cs.status = el.value; break;
        case 'csRfsYear': cs.rfsYear = parseInt(el.value) || null; break;
        case 'csFiberPairs': cs.fiberPairs = parseInt(el.value) || null; break;
        case 'csCapacity': cs.capacityTbps = parseFloat(el.value) || null; break;
        case 'csOwners': cs.owners = el.value; break;
        case 'csFilterTags':
          cs.filterTags = el.value.split(',').map(t => t.trim()).filter(Boolean);
          break;
        case 'csNotes': cs.notes = el.value; break;
        case 'csFiberAtlanticId':
          cs.fiberAtlanticId = el.value.trim() || null;
          if (!cs.fiberAtlanticId) { cs.fiberAtlanticName = null; cs.fiberAtlanticConfidence = null; }
          // Update status badge
          const faStatus = document.getElementById('csFaLinkStatus');
          if (faStatus) {
            if (cs.fiberAtlanticId) {
              faStatus.textContent = cs.fiberAtlanticId;
              faStatus.className = 'fa-link-badge';
            } else {
              faStatus.textContent = 'Not linked';
              faStatus.className = 'fa-link-badge unlinked';
            }
          }
          break;
          if (!cs.filterTags.some(t => t.toLowerCase() === 'default')) {
            cs.filterTags.unshift('default');
          }
          break;
        case 'csNotes': cs.notes = el.value; break;
      }

      commit();
      updateCableNavigatorList();
    });
  });

  // ============================================
  // PHYSICAL ROUTING DIVERSITY FUNCTIONS
  // ============================================

  // State for routing overlap pick mode
  let routingOverlapPickMode = false;
  let pendingOverlapLinkId = null; // Store picked link until diversity is set

  // Helper: Get diversity entry for a link pair
  function getDiversityEntry(edge, otherLinkId) {
    if (!edge.routingOverlap || !Array.isArray(edge.routingOverlap)) return null;
    return edge.routingOverlap.find(entry => {
      if (typeof entry === 'object') return entry.linkId === otherLinkId;
      return entry === otherLinkId; // Backward compatibility with old format
    });
  }

  // Helper: Get diversity percentage between two links
  function getDiversityPercent(edge, otherLinkId) {
    const entry = getDiversityEntry(edge, otherLinkId);
    if (!entry) return 100; // No entry means fully diverse (default)
    if (typeof entry === 'object') return entry.diversityPercent ?? 100;
    return 0; // Old format (just ID) means 0% diversity for backward compat
  }

  // Helper: Normalize routingOverlap to new format
  function normalizeRoutingOverlap(overlap) {
    if (!overlap || !Array.isArray(overlap)) return [];
    return overlap.map(entry => {
      if (typeof entry === 'object' && entry.linkId !== undefined) {
        return { linkId: entry.linkId, diversityPercent: entry.diversityPercent ?? 0 };
      }
      // Convert old format (just ID) to new format
      return { linkId: entry, diversityPercent: 0 };
    });
  }

  // Update the Routing Diversity UI in the inspector
  function updateRoutingOverlapUI(edge) {
    const listEl = document.getElementById('edgeRoutingOverlapList');
    const selectEl = document.getElementById('edgeRoutingOverlapSelect');
    const diversityInput = document.getElementById('edgeRoutingOverlapDiversity');

    if (!listEl || !selectEl) return;

    // Normalize to new format
    const overlapEntries = normalizeRoutingOverlap(edge.routingOverlap);

    // Render the list of diversity constraints
    if (overlapEntries.length === 0) {
      listEl.innerHTML = '<span class="muted" style="font-size:11px;">No diversity constraints defined</span>';
    } else {
      listEl.innerHTML = overlapEntries.map(entry => {
        const link = findEdge(entry.linkId);
        if (!link) return '';
        const nodeA = findNode(link.a);
        const nodeB = findNode(link.b);
        const linkName = link.code || `L-${entry.linkId}`;
        const nodePair = `${nodeA?.name || nodeA?.code || 'N'+link.a} â†” ${nodeB?.name || nodeB?.code || 'N'+link.b}`;
        const diversityPct = entry.diversityPercent ?? 0;

        // Color code: red (0-30%), orange (31-70%), green (71-100%)
        let diversityColor = '#ef4444'; // red
        if (diversityPct > 70) diversityColor = '#22c55e'; // green
        else if (diversityPct > 30) diversityColor = '#f59e0b'; // orange

        return `
          <div style="display:flex; justify-content:space-between; align-items:center; padding:6px 8px; background:white; border-radius:4px; margin-bottom:4px; border:1px solid #e5e7eb;">
            <span style="font-size:11px; flex:1;">
              <strong style="color:#0096D6;">${linkName}</strong>
              <span style="color:#6b7280; margin-left:4px; font-size:10px;">${nodePair}</span>
            </span>
            <div style="display:flex; align-items:center; gap:6px;">
              <input type="number" min="0" max="100" value="${diversityPct}"
                     class="diversity-percent-input" data-link-id="${entry.linkId}"
                     style="width:50px; padding:3px 4px; font-size:11px; text-align:center; border:1px solid #d1d5db; border-radius:3px;" />
              <span style="font-size:11px; color:${diversityColor}; font-weight:600; width:20px;">%</span>
              <button class="btn-remove-overlap" data-link-id="${entry.linkId}"
                      style="background:none; border:none; color:#ef4444; cursor:pointer; font-size:14px; padding:2px 4px;" title="Remove">âœ•</button>
            </div>
          </div>
        `;
      }).join('');

      // Add event handlers for diversity percent inputs
      listEl.querySelectorAll('.diversity-percent-input').forEach(input => {
        input.addEventListener('change', () => {
          const linkId = parseInt(input.dataset.linkId);
          const newPercent = Math.max(0, Math.min(100, parseInt(input.value) || 0));
          input.value = newPercent; // Normalize display
          updateDiversityPercent(edge.id, linkId, newPercent);
        });
      });

      // Add click handlers for remove buttons
      listEl.querySelectorAll('.btn-remove-overlap').forEach(btn => {
        btn.addEventListener('click', () => {
          const linkIdToRemove = parseInt(btn.dataset.linkId);
          removeRoutingOverlap(edge.id, linkIdToRemove);
        });
      });
    }

    // Populate the dropdown with available links (excluding current edge and already added ones)
    const existingLinkIds = overlapEntries.map(e => e.linkId);
    selectEl.innerHTML = '<option value="">-- Select link --</option>';
    state.edges.forEach(e => {
      if (e.id === edge.id) return; // Skip current edge
      if (existingLinkIds.includes(e.id)) return; // Skip already added

      const nodeA = findNode(e.a);
      const nodeB = findNode(e.b);
      const linkName = e.code || `L-${e.id}`;
      const nodePair = `${nodeA?.name || nodeA?.code || 'N'+e.a} â†” ${nodeB?.name || nodeB?.code || 'N'+e.b}`;

      const opt = document.createElement('option');
      opt.value = e.id;
      opt.textContent = `${linkName}: ${nodePair}`;
      selectEl.appendChild(opt);
    });

    // Reset diversity input to default
    if (diversityInput) diversityInput.value = 0;
  }

  // Add a routing diversity relationship (bidirectional)
  function addRoutingOverlap(edgeId, overlappingEdgeId, diversityPercent = 0) {
    const edge = findEdge(edgeId);
    const overlappingEdge = findEdge(overlappingEdgeId);

    if (!edge || !overlappingEdge) return;
    if (edgeId === overlappingEdgeId) return;

    // Initialize and normalize arrays if needed
    edge.routingOverlap = normalizeRoutingOverlap(edge.routingOverlap);
    overlappingEdge.routingOverlap = normalizeRoutingOverlap(overlappingEdge.routingOverlap);

    // Add to this edge (if not already present)
    const existingEntry = edge.routingOverlap.find(e => e.linkId === overlappingEdgeId);
    if (!existingEntry) {
      edge.routingOverlap.push({ linkId: overlappingEdgeId, diversityPercent });
    } else {
      existingEntry.diversityPercent = diversityPercent;
    }

    // Add to the other edge (bidirectional) with same diversity
    const existingReverseEntry = overlappingEdge.routingOverlap.find(e => e.linkId === edgeId);
    if (!existingReverseEntry) {
      overlappingEdge.routingOverlap.push({ linkId: edgeId, diversityPercent });
    } else {
      existingReverseEntry.diversityPercent = diversityPercent;
    }

    commit();
    updateRoutingOverlapUI(edge);
    showToast(`Added diversity constraint: ${diversityPercent}% diverse from ${overlappingEdge.code || 'L-'+overlappingEdgeId}`);
  }

  // Update diversity percentage (bidirectional)
  function updateDiversityPercent(edgeId, overlappingEdgeId, diversityPercent) {
    const edge = findEdge(edgeId);
    const overlappingEdge = findEdge(overlappingEdgeId);

    if (!edge) return;

    // Update on this edge
    edge.routingOverlap = normalizeRoutingOverlap(edge.routingOverlap);
    const entry = edge.routingOverlap.find(e => e.linkId === overlappingEdgeId);
    if (entry) {
      entry.diversityPercent = diversityPercent;
    }

    // Update on other edge (bidirectional)
    if (overlappingEdge) {
      overlappingEdge.routingOverlap = normalizeRoutingOverlap(overlappingEdge.routingOverlap);
      const reverseEntry = overlappingEdge.routingOverlap.find(e => e.linkId === edgeId);
      if (reverseEntry) {
        reverseEntry.diversityPercent = diversityPercent;
      }
    }

    commit();
    showToast(`Diversity updated to ${diversityPercent}%`);
  }

  // Remove a routing diversity relationship (bidirectional)
  function removeRoutingOverlap(edgeId, overlappingEdgeId) {
    const edge = findEdge(edgeId);
    const overlappingEdge = findEdge(overlappingEdgeId);

    if (!edge) return;

    // Remove from this edge
    if (edge.routingOverlap) {
      edge.routingOverlap = normalizeRoutingOverlap(edge.routingOverlap);
      edge.routingOverlap = edge.routingOverlap.filter(e => e.linkId !== overlappingEdgeId);
    }

    // Remove from the other edge (bidirectional)
    if (overlappingEdge && overlappingEdge.routingOverlap) {
      overlappingEdge.routingOverlap = normalizeRoutingOverlap(overlappingEdge.routingOverlap);
      overlappingEdge.routingOverlap = overlappingEdge.routingOverlap.filter(e => e.linkId !== edgeId);
    }

    commit();
    updateRoutingOverlapUI(edge);
    showToast('Diversity constraint removed');
  }

  // Handle routing overlap pick mode from canvas
  function handleRoutingOverlapPick(edgeId) {
    if (!routingOverlapPickMode) return false;

    const selectedEdge = state.selected?.type === 'edge' ? findEdge(state.selected.id) : null;
    if (!selectedEdge) {
      routingOverlapPickMode = false;
      return false;
    }

    if (edgeId === selectedEdge.id) {
      showToast('Cannot add diversity constraint with itself');
      return true;
    }

    // Get diversity percentage from input
    const diversityInput = document.getElementById('edgeRoutingOverlapDiversity');
    const diversityPercent = diversityInput ? Math.max(0, Math.min(100, parseInt(diversityInput.value) || 0)) : 0;

    addRoutingOverlap(selectedEdge.id, edgeId, diversityPercent);
    routingOverlapPickMode = false;

    // Update button state
    const pickBtn = document.getElementById('btnPickRoutingOverlap');
    if (pickBtn) {
      pickBtn.style.background = '#f59e0b';
      pickBtn.textContent = 'ðŸ–±ï¸ Pick from canvas';
    }

    return true;
  }

  // Set up routing overlap UI event handlers
  const btnAddRoutingOverlap = document.getElementById('btnAddRoutingOverlap');
  if (btnAddRoutingOverlap) {
    btnAddRoutingOverlap.addEventListener('click', () => {
      const selectEl = document.getElementById('edgeRoutingOverlapSelect');
      const diversityInput = document.getElementById('edgeRoutingOverlapDiversity');
      const selectedValue = selectEl?.value;

      if (!selectedValue) {
        showToast('Please select a link');
        return;
      }

      const currentEdge = state.selected?.type === 'edge' ? findEdge(state.selected.id) : null;
      if (!currentEdge) {
        showToast('No link selected');
        return;
      }

      const diversityPercent = diversityInput ? Math.max(0, Math.min(100, parseInt(diversityInput.value) || 0)) : 0;
      addRoutingOverlap(currentEdge.id, parseInt(selectedValue), diversityPercent);
    });
  }

  const btnPickRoutingOverlap = document.getElementById('btnPickRoutingOverlap');
  if (btnPickRoutingOverlap) {
    btnPickRoutingOverlap.addEventListener('click', () => {
      routingOverlapPickMode = !routingOverlapPickMode;

      if (routingOverlapPickMode) {
        btnPickRoutingOverlap.style.background = '#22c55e';
        btnPickRoutingOverlap.textContent = 'âœ“ Click a link on canvas...';
        showToast('Click a link on the canvas to add diversity constraint');
      } else {
        btnPickRoutingOverlap.style.background = '#f59e0b';
        btnPickRoutingOverlap.textContent = 'ðŸ–±ï¸ Pick from canvas';
      }
    });
  }

  // Expose for canvas click handling and protection path algorithm
  window.handleRoutingOverlapPick = handleRoutingOverlapPick;
  window.routingOverlapPickMode = () => routingOverlapPickMode;
  window.getDiversityPercent = getDiversityPercent;
  window.normalizeRoutingOverlap = normalizeRoutingOverlap;

  // Update edge cable system dropdown
  function updateEdgeCableSystemDropdown() {
    const dropdown = document.getElementById('edgeCableSystem');
    if (!dropdown) return;

    const currentValue = dropdown.value;
    dropdown.innerHTML = '<option value="">(None)</option>';

    state.cableSystems.forEach(cs => {
      const opt = document.createElement('option');
      opt.value = cs.id;
      opt.textContent = cs.shortName;
      dropdown.appendChild(opt);
    });

    dropdown.value = currentValue;
  }

  // Update node cable systems checkboxes
  function updateNodeCableSystemsCheckboxes(nodeId) {
    const container = document.getElementById('nodeCableSystems');
    if (!container) return;

    const node = findNode(nodeId);
    if (!node) {
      container.innerHTML = '<div class="muted" style="font-size:11px;">No node selected</div>';
      return;
    }

    // Get cable systems from connected edges (auto-detected)
    const connectedEdges = state.edges.filter(e => e.a === nodeId || e.b === nodeId);
    const edgeCableSystemIds = new Set();
    connectedEdges.forEach(e => {
      if (e.cableSystemId) edgeCableSystemIds.add(e.cableSystemId);
    });

    // Also include manually assigned cable systems
    const nodeCSIds = node.cableSystemIds || [];
    const allCSIds = new Set([...edgeCableSystemIds, ...nodeCSIds]);

    if (allCSIds.size === 0 && state.cableSystems.length === 0) {
      container.innerHTML = '<div class="muted" style="font-size:11px;">No cable systems</div>';
      return;
    }

    if (allCSIds.size === 0) {
      container.innerHTML = '<div class="muted" style="font-size:11px;">No connections</div>';
      return;
    }

    // Show cable systems connected to this node
    let html = '';

    // Show auto-detected cable systems from edges
    if (edgeCableSystemIds.size > 0) {
      html += '<div style="font-size:10px; color:#666; margin-bottom:4px; font-weight:600;">ðŸ“¡ Connected Cable Systems:</div>';
      edgeCableSystemIds.forEach(csId => {
        const cs = findCableSystem(csId);
        if (cs) {
          const edgeCount = connectedEdges.filter(e => e.cableSystemId === csId).length;
          html += `
            <div style="display:flex; align-items:center; gap:6px; padding:4px; font-size:11px; background:#f0f9ff; border-radius:4px; margin-bottom:2px;">
              <span style="width:10px; height:10px; border-radius:50%; background:${cs.color || '#666'}; flex-shrink:0;"></span>
              <span style="flex:1;"><strong>${cs.shortName}</strong></span>
              <span style="font-size:10px; color:#666;">${edgeCount} link${edgeCount > 1 ? 's' : ''}</span>
            </div>
          `;
        }
      });
    }

    // Show manually assigned cable systems (if any that aren't from edges)
    const manualOnlyCSIds = nodeCSIds.filter(id => !edgeCableSystemIds.has(id));
    if (manualOnlyCSIds.length > 0) {
      html += '<div style="font-size:10px; color:#666; margin-top:6px; margin-bottom:4px; font-weight:600;">ðŸ“Œ Additional:</div>';
      manualOnlyCSIds.forEach(csId => {
        const cs = findCableSystem(csId);
        if (cs) {
          html += `
            <div style="display:flex; align-items:center; gap:6px; padding:4px; font-size:11px; background:#fff8e6; border-radius:4px; margin-bottom:2px;">
              <span style="width:10px; height:10px; border-radius:50%; background:${cs.color || '#666'}; flex-shrink:0;"></span>
              <span style="flex:1;"><strong>${cs.shortName}</strong></span>
              <button onclick="removeManualCableSystem(${nodeId}, ${csId})" style="font-size:9px; padding:2px 6px; cursor:pointer;">âœ•</button>
            </div>
          `;
        }
      });
    }

    // Add option to manually add more cable systems
    if (state.cableSystems.length > allCSIds.size) {
      const availableCS = state.cableSystems.filter(cs => !allCSIds.has(cs.id));
      if (availableCS.length > 0) {
        html += `
          <div style="margin-top:6px; padding-top:6px; border-top:1px solid #e0e0e0;">
            <select id="addNodeCableSystem" style="width:100%; font-size:11px; padding:4px;">
              <option value="">+ Add cable system...</option>
              ${availableCS.map(cs => `<option value="${cs.id}">${cs.shortName} - ${cs.name}</option>`).join('')}
            </select>
          </div>
        `;
      }
    }

    container.innerHTML = html || '<div class="muted" style="font-size:11px;">No cable systems</div>';

    // Add handler for adding cable systems
    const addSelect = document.getElementById('addNodeCableSystem');
    if (addSelect) {
      addSelect.addEventListener('change', () => {
        const csId = parseInt(addSelect.value);
        if (csId && node) {
          if (!node.cableSystemIds) node.cableSystemIds = [];
          if (!node.cableSystemIds.includes(csId)) {
            node.cableSystemIds.push(csId);
            commit();
            updateNodeCableSystemsCheckboxes(nodeId);
            render();
          }
        }
      });
    }
  }

  // Remove manually assigned cable system from node
  window.removeManualCableSystem = function(nodeId, csId) {
    const node = findNode(nodeId);
    if (node && node.cableSystemIds) {
      node.cableSystemIds = node.cableSystemIds.filter(id => id !== csId);
      commit();
      updateNodeCableSystemsCheckboxes(nodeId);
      render();
    }
  };

  // Edge cable system change handler
  const edgeCableSystem = document.getElementById('edgeCableSystem');
  if (edgeCableSystem) {
    edgeCableSystem.addEventListener('change', () => {
      if (state.selected?.type !== 'edge') return;
      const e = findEdge(state.selected.id);
      if (!e) return;

      const val = edgeCableSystem.value;
      e.cableSystemId = val ? parseInt(val) : null;

      // Update info display
      const infoEl = document.getElementById('edgeCableSystemInfo');
      if (infoEl) {
        if (e.cableSystemId) {
          const cs = findCableSystem(e.cableSystemId);
          infoEl.textContent = cs ? cs.name : '';
        } else {
          infoEl.textContent = '';
        }
      }

      commit();
      render();
    });
  }

  // Initialize inspector button state
  if (btnToggleInspector) btnToggleInspector.classList.add('active');

  // ============== CANVAS SIZE CONTROLS ==============

  // Canvas Width handler
  if (canvasWidth) {
    canvasWidth.addEventListener('change', () => {
      const val = parseInt(canvasWidth.value, 10);
      if (val >= 400) {
        state.canvasWidth = val;
        updateViewBox();
        commit();
        render();
      }
    });
  }

  // Canvas Height handler
  if (canvasHeight) {
    canvasHeight.addEventListener('change', () => {
      const val = parseInt(canvasHeight.value, 10);
      if (val >= 300) {
        state.canvasHeight = val;
        updateViewBox();
        commit();
        render();
      }
    });
  }

  // Canvas Border toggle handler
  if (tglCanvasBorder) {
    tglCanvasBorder.addEventListener('change', () => {
      state.showCanvasBorder = !!tglCanvasBorder.checked;
      commit();
      render();
    });
  }

  // Auto-fit Canvas button
  const btnAutoFitCanvas = document.getElementById('btnAutoFitCanvas');
  if (btnAutoFitCanvas) {
    btnAutoFitCanvas.addEventListener('click', autoFitCanvas);
  }

  // Center Elements button
  const btnCenterElements = document.getElementById('btnCenterElements');
  if (btnCenterElements) {
    btnCenterElements.addEventListener('click', centerElements);
  }

  // Auto-expand canvas toggle - stored in state
  const tglAutoExpandCanvas = document.getElementById('tglAutoExpandCanvas');
  if (tglAutoExpandCanvas) {
    // Default to checked
    tglAutoExpandCanvas.checked = true;
  }

  // ============== SHAPE LIBRARY SYSTEM ==============

  const shapeLibraryPanel = document.getElementById('shapeLibraryPanel');
  const btnToggleLibrary = document.getElementById('btnToggleLibrary');
  const btnLibraryClose = document.getElementById('btnLibraryClose');
  const libraryContent = document.getElementById('libraryContent');
  const librarySearch = document.getElementById('librarySearch');
  const btnSaveNodeToLibrary = document.getElementById('btnSaveNodeToLibrary');
  const btnImportSVGToLibrary = document.getElementById('btnImportSVGToLibrary');
  const btnExportLibrary = document.getElementById('btnExportLibrary');
  const btnLibraryImport = document.getElementById('btnLibraryImport');
  const btnLibraryMenu = document.getElementById('btnLibraryMenu');
  const svgImportInput = document.getElementById('svgImportInput');
  const libraryImportInput = document.getElementById('libraryImportInput');

  // Load library from localStorage
  // Default container shapes - detailed continental silhouettes
  function _mkShape(id, name, category, viewBox, pathData) {
    return {
      id: id,
      name: name,
      category: category,
      viewBox: viewBox,
      pathData: pathData,
      svgData: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="' + viewBox + '"><path d="' + pathData + '" fill="currentColor" opacity="0.3"/></svg>'
    };
  }

  function getDefaultContainerShapes() {
    var s = {};
    // Helper
    function add(id, name, cat, vb, pd) { s[id] = _mkShape(id, name, cat, vb, pd); }

    // ===================== EUROPE (45) =====================
    add('country-al', 'Albania', 'Europe', '1075.0 299.5 10.6 21.0',
      'M1077.5 300.5l-2 3.1.5 1.9 1 1-.5 1.9-.1 4.3.7 3 3 2.1.2 1.4 1 .4 2.1-3 .1-2.1 1.6-.9V312l-2.3-1.6-.9-2.6.4-2.1-.5-2.3-1.3-.6-1.3-1.6-1.3.5-.4-1.2z');
    add('country-ad', 'Andorra', 'Europe', '983.4 300.3 2.7 2.3',
      'M985.4 301.7l.1-.2.1-.2v-.1l-.2-.1-.7-.2-.3-.1-.2.1-.2.2-.1.3.1.1v.4l.1.2h.4l.3-.1.5-.3h.1z');
    add('country-at', 'Austria', 'Europe', '1022.0 260.4 40.5 17.8',
      'M1060.2 264l-2.3-1.2-2.3.3-4-1.9-1.7.5-2.6 2.5-3.8-2-1.5 2.9-1.7.8 1 4-.4 1.1-1.7-1.3-2.4-.2-3.4 1.2-4.4-.3-.6 1.6-2.6-1.7-1.5.3.2 1.1-.7 1.6 2.3 1.1 2.6.2 3.1.9.5-1.2 4.8-1.1 1.3 2.2 7.2 1.6 4.2.4 2.4-1.4 4.3-.1.9-1.1 1.3-4-1.1-1.3h2.8l.2-2.6-.7-2.1.3-.8z');
    add('country-by', 'Belarus', 'Europe', '1085.6 216.4 48.8 32.2',
      'M1112.8 219.4l-5.2-1.5-4.6 2.3-2.6 1 .9 2.6-3.5 2-.5 3.4-4.8 2.2h-4.6l.6 2.7 1.7 2.3.3 2.4-2.7 1.2 1.9 2.9.5 2.7 2.2-.3 2.4-1.6 3.7-.2 5 .5 5.6 1.5 3.8.1 2 .9 1.6-1.1 1.5 1.5 4.3-.3 2 .6-.2-3.1 1.2-1.4 4.1-.3-2-3.9-1.5-2 .8-.6 3.9.2 1.6-1.3-1.7-1.6-3.4-1.1.1-1.1-2.2-1.1-3.7-3.9.6-1.6-1-2.9-4.8-1.4-2.3.7-1-1.4z');
    add('country-be', 'Belgium', 'Europe', '988.0 245.6 19.5 13.2',
      'M1000.7 246.2l-4.4 1.3-3.6-.5-3.8 1.2.7 2.2 2.2.1 2.4 2.4 3.4 2.9 2.5-.4 4.4 2.8.4-3.5 1.3-.2.4-4.2-2.8-1.4-3.1-2.7z');
    add('country-ba', 'Bosnia & Herzegovina', 'Europe', '1055.1 284.1 21.9 17.5',
      'M1062.2 284.9l-2.3.1-1 1.3-1.9-1.4-.9 2.5 2.7 2.9 1.3 1.9 2.5 2.3 2 1.4 2.2 2.5 4.7 2.4.4-3.4 1.5-1.4.9-.6 1.2-.3.5-2.9-2.7-2.3 1-2.7h-1.8l-2.4-1.4-3.5.1-4.4-1z');
    add('country-bg', 'Bulgaria', 'Europe', '1088.6 290.1 34.5 20.4',
      'M1121.6 294.3l-3-.7-4-2.2-5.8 1.4-2.3 1.6-7.5-.3-4-1-1.9.5-1.8-2.6-1.1 1.4.7 2.3 2.8 2.6-1.7 1.9-.7 2 .6.7-.7.9 2.8 2 .8 4.1 3.8.2 3.9-1.7 3.9 2.1 4.6-.6-.3-3 5-2 4.5.8-2.1-3.5 1.3-4.4 2.2-2.5z');
    add('country-ic', 'Canary Islands', 'Europe', '876.8 385.6 28.6 11.2',
      'M879.6 395.2l-.2-.2-.7.5h-.6l.1.2.1.2.7.4.6-1.1zm13.5-2.1v-.1h-.1l-.1.1-1.3-.1-.2.6-.5.4v.7l.5.7.3.1.5.1.7-.4.2-.4.1-.8-.1-.4v-.5zm-9.7.8l.5-.4v-.2l-.1-.3-.5-.3h-.2l-.2.2-.2.4.3.5.2.1h.2zm4.7-2.3l1.2-1v-.3l-1 .1-1.1 1-.3.1-1 .1h-.5l-.4.2.2.3.4 1 .7.9.6-.2.3-.2.4-.6.5-1.4zm11.6 1.3l1.5-.5.3-1 .3-1.1v-.7l-.2-.3h-.5l-.3.2-.1.6-.7 1.3-.5 1.2-.7.6-.7.2.1.1.7.1.8-.7zm-19.7-2l.5-.5.1-.3-.1-.5.2-.2-.1-.4-.3-.4h-.7l-.4.6.6 1.2.1.5h.1zm22.4-2.7l.9-.3.5-.3.1-.9.2-.3-.2-.3-.2.2-.2.4-.6.2-.8.4-.2.3-.2.9.4.1.3-.4z');
    add('country-hr', 'Croatia', 'Europe', '1044.0 275.8 31.7 27.3',
      'M1065 280.4l-4-2.6-1.6-.8-3.9 1.7-.3 2.5-1.7.6.2 1.7-2-.1-1.8-1-.8 1-3.5-.2-.2.1v2.2l1.7 2 1.3-2.6 3.3 1 .3 2 2.5 2.6-1 .5 4.6 4.5 4.8 1.8 3.1 2.2 5 2.3.5-1-4.7-2.4-2.2-2.5-2-1.4-2.5-2.3-1.3-1.9-2.7-2.9.9-2.5 1.9 1.4 1-1.3 2.3-.1 4.4 1 3.5-.1 2.4 1.4 1.7-2.3-1.7-1.8-1.5-2.4-1.8.9-4.2-1.2z');
    add('country-cy', 'Cyprus', 'Europe', '1147.2 344.7 12.6 8.0',
      'M1149.9 348.4l-.3-.1-.5.2-.4.4-.4.3-.5-.3.2.9.6 1.1.2.3.3.2 1.1.3H1151.1l.2.1.2.4h.4v-.4l.2-.2.3-.2h.3l.6-.1.6-.2.5-.4.9-1h1.2l.6-.1-.2-.4-.1-.1-.4-.5-.2-.4.1-.6 2.5-1.9.5-.5-.8.2-.6.4-.4.2-.7.4-2.3.8-.8.1h-.8l-1-.1-.9-.2v.7l-.2.6-.6.2-.3-.1z');
    add('country-cz', 'Czech Republic', 'Europe', '1034.7 247.6 36.0 17.4',
      'M1049.4 248.5l-2.1.6-1.4-.7-1.1 1.2-3.4 1.2-1.7 1.5-3.4 1.3 1 1.9.7 2.6 2.6 1.5 2.9 2.6 3.8 2 2.6-2.5 1.7-.5 4 1.9 2.3-.3 2.3 1.2.6-1.4 2.2.1 1.6-.6.1-.6.9-.3.2-1.4 1.1-.3.6-1.1h1.5l-2.6-3.1-3.6-.3-.7-2-3.4-.6-.6 1.5-2.7-1.2.1-1.7-3.7-.6-2.4-1.9z');
    add('country-dk', 'Denmark', 'Europe', '1013.1 207.7 23.9 19.3',
      'M1035.9 221.2l-1.7-3-6.7 2 .9 2.5 5.1 3.4 2.4-4.9zm-8.6-5.1l-2.6-.9-.7-1.6 1.3-2-.1-3-3.6 1.6-1.5 1.7-4 .4-1.2 1.7-.7 1.6.4 6.1 2.1 3.4 3.6.8 3-.9-1.5-3 3.1-4.3 1.4.7 1-2.3z');
    add('country-ee', 'Estonia', 'Europe', '1081.2 196.9 23.6 13.9',
      'M1093.2 197.5l-5.5.9-5.4 1.6.9 3.4 3.3 2.1 1.5-.8.1 3.5 3.7-1 2.1.7 4.4 2.2h3.8l1.6-1.9-2.5-5.5 2.6-3.4-.9-1-4.6.2-5.1-1z');
    add('country-fo', 'Faroe Islands', 'Europe', '943.6 181.1 5.5 6.4',
      'M947 186.9v-.3l-.1-.3v-.2h-.1l-.5-.1-.1-.2h-.1v.2l.1.4.5.4.3.2h.1l-.1-.1zm.5-2.1v-.1l-.2-.2-.5-.2-.2-.1-.2.1v.2l.1.1.4.1.4.3h.1l.1-.2zm-2.4-1.9l-.2-.1-.5.1h-.3l.1.3.6.2h.6l.2-.1-.1-.2-.4-.2zm2.5-.5l-.8-.2-.6-.3-1 .1.7 1.1.8.7.4.2V183.7l-.4-.5-.1-.1v-.1l.1-.1h.2l.3.2h.2l.2-.7zm1-.2l-.3-.2-.4-.4v.9h.1l.3.1.3-.4z');
    add('country-fi', 'Finland', 'Europe', '1058.3 135.6 58.5 63.4',
      'M1093.4 144.4l.8-3.8-5.7-2.1-5.8 1.8-1.1 3.9-3.4 2.4-4.7-1.3-5.3.3-5.1-2.9-2.1 1.4 5.9 2.7 7.2 3.7 1.7 8.4 1.9 2.2 6.4 2.6.9 2.3-2.6 1.2-8.7 6.1-3.3 3.6-1.5 3.3 2.9 5.2-.1 5.7 4.7 1.9 3.1 3.1 7.1-1.2 7.5-2.1 8-.5 7.9-7.4 3.3-3.3.9-2.9-7.3-3.9.9-3.7-4.9-4.1 1.7-4.8-6.4-6.3 2.8-4.1-7.2-3.7-.4-3.7z');
    add('country-fr', 'France', 'Europe', '950.5 245.2 78.8 66.4',
      'M1025.7 303.8l-1.1-5.2-3.2 2.3-1 2.3 1.4 4.2 2.4 1.2 1.5-4.8zm-31.5-50.9l-2.4-2.4-2.2-.1-.7-2.2-4.3 1.2-1.4 5.1-11.3 4.8-4.6-2.6 1.4 7-8.2-1.6-6.4 1.3.4 4.6 7.5 2.4 3.6 3.1 5.1 6.5-1 12.3-2.7 3.7 2 2.4 9.4 2.8 1.9-1.3 5.7 2.8 6-.8.5-3.7 7.4-2 10 1.6 4.5-3.4.5-2.7-2.7-.8-1.5-4.8 1.7-1.8-1.6-2.4.2-1.7-1.8-2.7-2.4.9v-2.8l3.5-3.5-.2-1.6 2.3.6 1.3-1 .5-4.5 2.3-4.2-7.1-1.2-2.4-1.6-1.4.1-1.1-.5-4.4-2.8-2.5.4-3.4-2.9z');
    add('country-ge', 'Georgia', 'Europe', '1178.0 294.4 40.7 16.9',
      'M1200 300.2l-7.5-2.9-7.7-1-4.5-1.1-.5.7 2.2 1.9 3 .7 3.4 2.3 2.1 4.2-.3 2.7 5.4-.3 5.6 3 6.9-1 1.1-1 4.2 1.8 2.8.4.6-.7-3.2-3.4 1.1-.9-3.5-1.4-2.1-2.5-5.1-1.3-2.9 1-1.1-1.2z');
    add('country-de', 'Germany', 'Europe', '1003.3 222.6 48.3 51.7',
      'M1043.6 232.3l-2.4-1.9-5.5-2.4-2.5 1.7-4.7 1.1-.1-2.1-4.9-1.4-.2-2.3-3 .9-3.6-.8.4 3.4 1.2 2.2-3 3-1-1.3-3.9.3-.9 1.3 1 2-1 5.6-1.1 2.3h-2.9l1.1 6.4-.4 4.2 1 1.4-.2 2.7 2.4 1.6 7.1 1.2-2.3 4.2-.5 4.5h4.2l1-1.4 5.4 1.9 1.5-.3 2.6 1.7.6-1.6 4.4.3 3.4-1.2 2.4.2 1.7 1.3.4-1.1-1-4 1.7-.8 1.5-2.9-2.9-2.6-2.6-1.5-.7-2.6-1-1.9 3.4-1.3 1.7-1.5 3.4-1.2 1.1-1.2 1.4.7 2.1-.6-2.3-3.9.1-2.1-1.4-3.3-2-2.2 1.2-1.6-1.4-3.1z');
    add('country-gr', 'Greece', 'Europe', '1079.6 303.7 37.9 48.5',
      'M1101.9 344.9l-.8 2.8 6.6 1.2v1.1l7.6-.6.5-1.9-2.8.8v-1.1l-3.9-.5-4.1.4-3.1-2.2zm11.5-37.4l-2.7-1.6.3 3-4.6.6-3.9-2.1-3.9 1.7-3.8-.2-1 .2-.7 1.1-2.8-.1-1.9 1.3-3.3.6v1.6l-1.6.9-.1 2.1-2.1 3 .5 1.9 2.9 3.6 2.3 3 1.3 4.3 2.3 5.1 4.6 2.9 3.4-.1-2.4-5.7 3.3-.7-1.9-3.3 5 1.7-.4-3.7-2.7-1.8-3.2-3 1.8-1.4-2.8-3-1.6-3.8.9-1.3 3 3.2h2.9l2.5-1-3.9-3.6 6.1-1.6 2.7.6 3.2.2 1.1-.7 1.2-3.9z');
    add('country-hu', 'Hungary', 'Europe', '1055.8 262.9 34.9 19.6',
      'M1079.1 263.8l-1.6.4-1 1.5-2.2.7-.6-.4-2.3 1-1.9.2-.3 1.2-4.1.8-1.9-.7-2.6-1.6-.2 2.6h-2.8l1.1 1.3-1.3 4 .8.1 1.2 2.1 1.6.8 4 2.6 4.2 1.2 1.8-.9 3.7-1.6 3.2.2 3.8-1.1 2.6-4.3 1.9-4.2 2.9-1.3-.6-1.6-2.9-1.7-1 .6-5.5-1.9z');
    add('country-is', 'Iceland', 'Europe', '871.2 157.4 49.7 18.6',
      'M915.7 158.6l-6.9-.4-7.3 2.9-5.1-1.5-6.9 3-5.9-3.8-6.5.8-3.6 3.7 8.7 1.3-.1 1.6-7.8 1.1 8.8 2.7-4.6 2.5 11.7 1.8 5.6.8 3.9-1 12.9-3.9 6.1-4.2-4.4-3.8 1.4-3.6z');
    add('country-ie', 'Ireland', 'Europe', '927.7 223.1 21.2 23.0',
      'M947.3 231.7l-3.5-1.3-2.9.1 1.1-3.2-.8-3.2-3.7 2.8-6.7 4.7 2.1 6.1-4.2 6.4 6.7.9 8.7-3.6 3.9-5.4-.7-4.3z');
    add('country-it', 'Italy', 'Europe', '1007.6 269.9 67.8 72.4',
      'M1057.8 328.6l-4 .5-5.2.7-6.2-.6-.6 3.4 7.5 3.3 2.7.7 4.2 2.4.9-3.3-.9-2 1.6-5.1zm-33.7-18.9l-2.5 1.9-2.8-.3 1.3 3.6.4 7.6 2.1 1.7 2-2.1 2.4.4.4-8.4-3.3-4.4zm14.3-34.3l-1.3-2.2-4.8 1.1-.5 1.2-3.1-.9-.3 2.5-2.1 1.1-3.8-.8-.9 2.5-2.4.2-.9-1-2.7 2.1-2.4.3-2.2-1.3-.2 1.7 1.6 2.4-1.7 1.8 1.5 4.8 2.7.8-.5 2.7 2.1-.5 2.8-2.8 2.3-.9 4.2 2.1 2.6.7 1.9 6 3.6 3.6 4.9 4 4.2 2.8 3.9.4 2.3 2.5 3.4 1.2 1.7 2.7 2.2.8 1.8 3.2 2.3 3.7-1.1 1.3-.8 3.5.1 2 2.1-.5 2.5-5.6 2.1-.4.4-3.3-3.9-2.3 1.9-4.1 4.5 1 3.1 3 .8-2.3-.6-1.2-4.7-3.2-3.9-1.9-4.8-2.3 1.4-1.2-1.4-1.4-4 .1-6-5-2.9-5.1-4.9-3.1-1.9-3.1.5-1.8-.4-3 3.9-2.2 4.1.9-1.4-2.7.3-3-7.2-1.6z');
    add('country-lv', 'Latvia', 'Europe', '1072.5 206.5 36.7 15.4',
      'M1102.1 210.1h-3.8l-4.4-2.2-2.1-.7-3.7 1-.2 4.6-3.6.1-4.4-4.5-4 2.1-1.7 3.7.5 4.5 5-1.9 7.9.4 4.4-.6.9 1.3 2.5.4 5 2.9 2.6-1 4.6-2.3-2.1-3.6-1-2.8-2.4-1.4z');
    add('country-li', 'Liechtenstein', 'Europe', '1023.3 271.7 1.7 2.4',
      'M1024.4 273.6v-.2l.1-.2-.1-.1-.1-.2-.1-.1v-.2l-.1-.1v-.2l-.1-.1-.2.6v.5l.1.2h.1l.4.1z');
    add('country-lt', 'Lithuania', 'Europe', '1073.4 215.9 29.3 16.3',
      'M1100.4 221.2l-5-2.9-2.5-.4-.9-1.3-4.4.6-7.9-.4-5 1.9 1.7 5 5 1.1 2.2.9-.2 1.7.6 1.5 2.5.6 1.4 1.9h4.6l4.8-2.2.5-3.4 3.5-2-.9-2.6z');
    add('country-lu', 'Luxembourg', 'Europe', '1004.0 254.0 3.7 5.2',
      'M1007 258.6l.2-2.7-1-1.4-1.3.2-.4 3.5 1.1.5 1.4-.1z');
    add('country-md', 'Moldova', 'Europe', '1107.2 263.9 20.4 20.4',
      'M1118.5 283.3l1.2-.7.5-2.1 1.1-2-.5-1.1 1-.5.6.9 3 .2 1.2-.5-1-.6.2-1-2-1.5-1.1-2.6-1.9-1.1v-2.1l-2.5-1.6-2-.3-3.9-1.9-3.2.6-1.1.9 1.6.6 1.8 1.9 1.9 2.6 3.4 3.7.6 2.7-.2 2.7 1.3 2.8z');
    add('country-me', 'Montenegro', 'Europe', '1070.5 294.9 10.4 11.1',
      'M1080 299.8l.4-.6-2-1.2-1.8-.7-.8-.8-1.5-1.1-.9.6-1.5 1.4-.4 3.4-.5 1 2.3 1.2 1.6 2.1 1.1.4-.5-1.9 2-3.1.4 1.2 1.3-.5.8-1.4z');
    add('country-nl', 'Netherlands', 'Europe', '991.8 233.0 19.6 18.1',
      'M1005.5 243.9h2.9l1.1-2.3 1-5.6-1-2-3.9-.2-6.5 2.6-3.9 8.9-2.5 1.7 3.6.5 4.4-1.3 3.1 2.7 2.8 1.4-1.1-6.4z');
    add('country-mk', 'North Macedonia', 'Europe', '1081.3 302.3 14.2 10.2',
      'M1094 304.8l-2.8-2-2.4.1-1.7.4-1.1.2-2.9 1-.1 1.2h-.7l-.4 2.1.9 2.6 2.3 1.6 3.3-.6 1.9-1.3 2.8.1.7-1.1 1-.2-.8-4.1z');
    add('country-no', 'Norway', 'Europe', '993.5 81.4 114.7 131.0',
      'M1088.8 133.1l-6.9 1.1-7.3-.3-5.1 4.4-6.7-.3-8.5 2.3-10.1 6.8-6.4 4-8.8 10.7-7.1 7.8-8.1 5.8-11.2 4.8-3.9 3.6 1.9 13.4 1.9 6.3 6.4 3 6-1.4 8.5-6.8 3.3 3.6 1.7-3.3 3.4-4 .9-6.9-3.1-2.9-1-7.6 2.3-5.3 4.3.1 1.3-2.2-1.8-1.9 5.7-7.9 3.4-6.1 2.2-3.9 4 .1.6-3.1 7.9.9v-3.5l2.5-.3 2.1-1.4 5.1 2.9 5.3-.3 4.7 1.3 3.4-2.4 1.1-3.9 5.8-1.8 5.7 2.1-.8 3.8 3.2-.5 6.4-2.2-5.4-3.3 4.8-1.4-13.6-3.9zm-22.6-33.3l-5.6-1-1.9-1.7-7.2.9 2.6 1.5-2.2 1.2 6.7 1.1 7.6-2zm-25.4-8.3l-4.8-1.6-5.1.2-1 1.5h-5l-2.2-1.5-9.3 1.6 3.2 3.5 7.6 3.8 5.7 1.4-3 1.7 8.4 2.9 4.4-.2.9-3.9 3-.9 1.2-3.4 8.5-1.8-12.5-3.3zm24.2-3.1l-9.1-1-3.2 1.2-5.3-1-10.4 1.2 4.3 2h5.1l.9 1.3 10.6.7 10.1-.5 4.3-2.4-7.3-1.5z');
    add('country-pl', 'Poland', 'Europe', '1041.1 223.9 54.7 39.2',
      'M1069.4 228.3l-4.6-.1-.5-1.4-4.8-1.1-5.7 2.1-7.1 2.8-3.1 1.7 1.4 3.1-1.2 1.6 2 2.2 1.4 3.3-.1 2.1 2.3 3.9 2.4 1.9 3.7.6-.1 1.7 2.7 1.2.6-1.5 3.4.6.7 2 3.6.3 2.6 3.1.3.4 1.9-.9 2.7 2.2 2.8-1.3 2.4.6 3.4-.8 4.9 2.3 1.1.4-1.6-2.8 3.8-5.1 2.3-.7.3-1.8-3.1-5.3-.5-2.7-1.9-2.9 2.7-1.2-.3-2.4-1.7-2.3-.6-2.7-1.4-1.9-2.5-.6-8.7.1-5.9-.7z');
    add('country-pt', 'Portugal', 'Europe', '926.2 301.3 18.5 38.1',
      'M937.6 335.9l-.4-2.1 2-2.5.8-1.7-1.8-1.9 1.6-4.3-2-3.8 2.2-.5.3-3 .9-.9.2-4.9 2.4-1.7-1.3-3.1-3-.2-.9.8h-3l-1.2-3.1-2.1.9-1.9 1.6.1 2.1.9 2.2.1 2.7-1.3 3.8-.4 2.5-2.2 2.3-.6 4.2 1.2 2.4 2.3.6.4 4-1 5.1 2.8-.7 2.7.9 2.2-1.7z');
    add('country-ro', 'Romania', 'Europe', '1075.5 264.9 52.8 30.9',
      'M1108.1 266.3h-2.1l-1 1.5-3.6.6-1.6.9-2.4-1.5h-3.2l-3.2-.7-1.9 1.3-2.9 1.3-1.9 4.2-2.6 4.3-3.8 1.1 2.9 2.5.8 1.9 3.2 1.5.7 2.5 3.1 1.8 1.4-1.3 1.4.7-1.1 1.1 1 1 1.8 2.6 1.9-.5 4 1 7.5.3 2.3-1.6 5.8-1.4 4 2.2 3 .7.4-7.4 1.6.5 2.3-1.3-.4-1.6-2.4-1.1-2.2 1-2.4-1.1-1.3-2.8.2-2.7-.6-2.7-3.4-3.7-1.9-2.6-1.8-1.9-1.6-.6z');
    add('country-ru', 'Russia', 'Europe', '1034.7 73.6 763.3 247.6',
      'M1332.3 95.1l-4.5-4-13.6-4.1-9.4-2.1-6.2.9-5.3 2.9 5.8.8 6.6 3.2 8 1.7 11.5 1.3 7.1-.6zm-178.7-7.3l.9-.6-5.7-.9-2.8.7-1.3 1-1.5-1.2-5.2.1-6.2.8 7.7.1-1.1 1.3 4.4 1 3.6-.7.1-.7 2.9-.3 4.2-.6zm200.5 9.9l-1.5-1.8-12.5-2.6-3-.3-2.2.5 1.2 6 18-1.8zm15.2 6.3l-9.2-.7 3.4-1.2-8.2-1.5-6.1 1.9-1 2 1.5 2.1-6.9-.1-5.3 2.6-4.3-1.1-9.3.5.3 1.3-9.2.7-4.9 2.4-4.2.2-1.2 3.3 5.5 2.6-7.7.7-9.5-.3-5.8 1.1 4.8 5.4 6.9 4.3-9.6-3-7.9.3-5.1 2 4.5 3.8-4.9-1-2.1-5-4.2-2.8-1.8.1 3.6 3.7-4.6 3.5 8.1 4.2.4 5.4 2.9 2.9 4.7.5.4 3.5 4.4 3.1-1.9 2.6.5 2.7-3.7 1.4-.5 2-5.3-.8 3.5-7.8-.5-3.6-6.7-3.3-3.8-7.3-3.7-3.7-3.6-1.6.8-4.2-2.9-2.9-11.3-1.4-2.1 1 .5 4.7-4.3 4.7 1.2 1.7 4.7 4.1.1 2.6 5.3.5.8 1.1 5.8 2.9-1 2.8-18.5-6.1-6.6-1.7-12.8-1.6-1.2 1.7 5.9 3.1-2.7 3.6-6.4-3.2-5 2.2-7.6.1-2.1 1.9-5.3-.6 2.5-3.3-3.2-.2-12.3 4.6-7.6 2.6.4 3.5-6 1.2-4-1.9-1.2-3 5-.7-3.6-3-12.2-1.8 4.3 3.4-.8 3.2 4.7 3.3-1.1 3.8-4.6-1.9-4-.3-8 5.4 4.2 4.1-3.2 1.4-11.4-3.5-2.1 2.1 3.3 2.4.2 2.7-3.8-1.4-6-1.7-1.9-5.8-1-2.6-8-4 2.9-.7 20.1 4.2 6.4-1.5 3.7-2.9-1.6-3.6-4-2.6-17.6-6.1-11.6-1.3-7.6-3.2-3.6 1.8-6.4 2.2-3.2.5.4 3.7 7.2 3.7-2.8 4.1 6.4 6.3-1.7 4.8 4.9 4.1-.9 3.7 7.3 3.9-.9 2.9-3.3 3.3-7.9 7.4 5.3 2.8-4.5 3.2.9 1-2.6 3.4 2.5 5.5-1.6 1.9 2.4 1.4 1 2.8 2.1 3.6 5.2 1.5 1 1.4 2.3-.7 4.8 1.4 1 2.9-.6 1.6 3.7 3.9 2.2 1.1-.1 1.1 3.4 1.1 1.7 1.6-1.6 1.3-3.9-.2-.8.6 1.5 2 2 3.9 1.8.2 1-1.4 1.5.3 4.8-.5 3.8 3.4-.9 1.3.7 1.9 4 .2 2.2 2.7.2 1.2 6.6 2.2 3.5-1 3.6 2.9 2.9-.1 7.6 2 .4 1.9-1.3 3.2 1.8 3.4-.3 2.1-4.7.5-2.2 1.7.4 2.8 4.2-1 .4 1.3-6.8 2.6 3.2 2.4-3.2 5.2-3.4 1 5 3.6 6.2 2.4 7.4 5.1.5-.7 4.5 1.1 7.7 1 7.5 2.9 1.1 1.2 2.9-1 5.1 1.3 2.1 2.5 3.5 1.4 1.5.2 4.3 3.8 2.4.4.5-1.5 2.6-2.5-7.3-7.3-.4-4.1-5.9-5.9 3.5-6.3 4.6-1.1 1.4-3.7-2.8-1-.2-3.2-4.2-4.1-3.6.2-5.3-4.3 1.7-4.7-1.7-1.2 2.1-6.8 6 3.6-.7-4.6 8.1-6.6 7.5-.2 11.9 4.3 6.6 2.4 4.3-2.5 7.6-.2 7.3 3.2.8-1.8 6.9.3.2-3-9.4-4.2 3.6-2.9-1.5-1.7 3.9-1.6-5-4.1 1.4-2.1 16.8-2.1 1.7-1.5 10.8-2.2 3.1-2.5 9 1.3 4.3 6.3 4.3-1.5 7 2.1 1.2 3.3 4.4-.4 9.1-5.7-.8 1.9 8.3 4.7 18.1 15.5 1.1-3.3 8.3 3.6 6.2-1.6 3.2 1.1 4.1 3.6 3.9 1.2 3.3 2.6 6-.9 4.3 3.8 1.7-.5 4.7-1 6.6-5.4 5.9-2.9 5.3 1.9 5.1.1 4.7 2.9 5 .2 7.9 1.6 2.4-4.3-4-3.6 1.3-6.4 6.9 2.5 4.8.8 6.6 1.5 3.7 4.6 8.4 2.6 3.9-1.1 5.7-.8 5.4.8 6.5 3 4.9 3.1h4.5l6.7 1 3.6-1.6 5.8-1 4.5-4.4 3.3.7 3.9 2.1 5.5-.5 7.3 2.3 4.4-3.9-1.9-2.7-.1-6.5 1.2-2-2.5-3.3-3.7-1.5 1.7-3 5.1-1.1 6.2-.2 8.5 1.8 5.9 2.3 7.7 6.1 3.8 2.7 4.4 3.7 6.1 6.1 9.9 1.9 8.9 4.5 6 5.8h7.5l2.6-2.5 6.9-1.8 1.3 5.6-.4 2.3 2.8 6.8.6 6-6.8-1.1-2.9 2.2 4.7 5.3 3.8 7.3-2.5.1 1.9 3.1 1.4 1.1-.4-2 4-4.5 5.1 3 3.2-.1 4.4-3.6 1-3.7 2.1-7.1 1.9-7.2-1.3-4.3 1-9-5.2-9.9-5.5-7.3-1.3-6.2-4.7-5.1-12.7-6.7-5.6-.4-.3 3-5.8-1.3-5.7-3.8-8-.7 4.9-14.1 3.5-11.5 13.1-1.8 14.9 1 2.5-2.8 7.9.8 4.3 4.3 6.4-.6 8.4-1.6-7.7-3.5v-9.8l9.1-1.9 12.1 7.1 3.6-6.4-3.2-4.7 4.7-.5 6.5 8.1-2.4 4.6-.8 6 .3 7.5-5.7 1.3 2.8 2.7-.1 3.6 6.4 8.3 16 13.4 10.5 8.8 5.7 4.3 1.6-5.7-4.5-6.2 5.7-1.5-5.4-6.9 5-3.1-4.7-2.6-3.4-5 4.1-.2-9-8.6-6.7-1.4-2.9-2.4-1.1-5.6-3.1-3.9 7 .8 1.3-2.5 4.7 2.2 6.1-4.6 11.4 4-1.7-2.6 2-3.6 1.5-4 3.1-.7 6.5-4.3 9.8 1.2-.9-1.5-3.8-2.3-4.1-1.6-9.1-4.6-8.1-3 6.1.4 2-2.5-32.9-21.9-9.4-2.3-15.7-2.6-7.9.3-15.2-1.4 1.8 2.3 8.5 3.4-2.5 1.8-14.2-4.8-6.8.6-9.2-1.1-7 .2-3.9 1.1-7.2-1.6-5.1-3.8-6.5-2.2-9.2-.9-14.7 1-16.1-4-7.8-3-40.1-3.4-2.1 2.2 9.3 4.8-7.5-.7-1 1.5-9.7-1.6-5 1.4-9.3-2.4 3 5.5-8.9-2.1-10-4.1-.4-2.2-6-3.3-9.8-2.6h-6.1l-9.3-.9 4.7 3.9-17.2-.8-3.9-2.3-13.3-.9-5.3.8-.1 1.3-5.8-3.2-2.3.9-7.2-1.2-5.6-.7 1.1-1.5 6.6-2.8 2.3-1.5-2.4-2.5-5.5-1.9-11.5-2.3-10.8-.1-1.9 1.2-4.1-2.4zm-162.2 31.6l-9.9-4.3-3.1-4.3 3.3-4.9 2.8-5 8.6-4.7 9.8-2.4 11.3-2.4 1.3-1.5-4.2-1.9-6.6.6-4.9 1.8-11.7.9-10.1 3.1-6.8 2.7 2.5 2.2-6.6 4.4 3.9.7-5.4 4.3 1.6 2.8-3.4 1.1 1.9 2.8 7.9 1.4 2.2 2.3 13.4.7 2.2-.4zm314-24.7l-17.9-2.6-10.2-.2-3.4.9 3.4 3.4 12.4 3.2 4.5-1.2 14.2.2-3-3.7zm25.2 2.3l-11.7-1.3-8.2-.7 1.7 1.6 10.3 2 6.8.4 1.1-2zm-12.5 9.5l-2.5-1.4-8.3-1.9-4.1.5-.8 2 1.1.2 8.8.6h5.8zm162.6 12.3l-6-3.6-1.4 2.2 3.5 1.6 3.9-.2zM1084 228.9l-.6-1.5.2-1.7-2.2-.9-5-1.1-6.3 2-.7 2.6 5.9.7 8.7-.1zm589.7 21.8l-7.2-6.2-5.1-6-6.8-5.8-4.9-4-1.3.8 4.4 2.8-1.9 2.8 6.8 8.3 7.8 6 6.4 8.3 2.4 4.6 5.5 6.8 3.8 6 4.6 5.2-.1-4.8 6.5 3.8-3-4.4-9.5-6.3-3.7-9 8.9 2-13.6-10.9z');
    add('country-rs', 'Serbia', 'Europe', '1069.9 277.9 25.0 26.6',
      'M1084.8 285.2l-3.2-1.5-.8-1.9-2.9-2.5-3.2-.2-3.7 1.6 1.5 2.4 1.7 1.8-1.7 2.3h1.8l-1 2.7 2.7 2.3-.5 2.9-1.2.3 1.5 1.1.8.8 1.8.7 2 1.2-.4.6 1.2-.5.5-2 .9-.4.8.9 1 .4.8 1 .8.3 1.1 1.1h.8l-.5 1.5-.5.7.2.5 1.7-.4 2.4-.1.7-.9-.6-.7.7-2 1.7-1.9-2.8-2.6-.7-2.3 1.1-1.4-1-1 1.1-1.1-1.4-.7-1.4 1.3-3.1-1.8-.7-2.5z');
    add('country-sk', 'Slovakia', 'Europe', '1058.5 257.3 30.3 12.4',
      'M1087.4 260.9l-4.9-2.3-3.4.8-2.4-.6-2.8 1.3-2.7-2.2-1.9.9-.3-.4h-1.5l-.6 1.1-1.1.3-.2 1.4-.9.3-.1.6-1.6.6-2.2-.1-.6 1.4-.3.8.7 2.1 2.6 1.6 1.9.7 4.1-.8.3-1.2 1.9-.2 2.3-1 .6.4 2.2-.7 1-1.5 1.6-.4 5.5 1.9 1-.6.7-2.5 1.1-1.7z');
    add('country-si', 'Slovenia', 'Europe', '1044.6 274.3 15.5 9.7',
      'M1059.4 277l-1.2-2.1-.8-.1-.9 1.1-4.3.1-2.4 1.4-4.2-.4-.3 3 1.4 2.7-1.1.5 3.5.2.8-1 1.8 1 2 .1-.2-1.7 1.7-.6.3-2.5 3.9-1.7z');
    add('country-es', 'Spain', 'Europe', '925.3 291.5 77.3 54.3',
      'M985 325.7v-.2h-.5l-.3-.4-.1.2-.1.2v.2h.5l.4.1.1-.1zm-.8-1.6h.3l.6-.7v-.3l-.3-.2-1.1.2-.2.3v.3l-.3.1-.1.4.1.2.8.1.2-.4zM967 296l-8.2-.2-4.2.3-5.4-1h-6.8l-6.2-1.1-7.4 4.5 2 2.6-.4 4.4 1.9-1.6 2.1-.9 1.2 3.1h3l.9-.8 3 .2 1.3 3.1-2.4 1.7-.2 4.9-.9.9-.3 3-2.2.5 2 3.8-1.6 4.3 1.8 1.9-.8 1.7-2 2.5.4 2.1 4.8 1 1.4 3.7 2 2.2 2.5.6 2.1-2.5 3.3-2.3 5 .1h6.7l3.8-5 3.9-1.3 1.2-4.2 3-2.9-2-3.7 2-5.1 3.1-3.5.5-2.1 6.6-1.3 4.8-4.2-.3-3.5-6 .8-5.7-2.8-1.9 1.3-9.4-2.8-2-2.4zm26 22.6l.1-.3.1-.2.1-.1-.2-.2v-.1l.2-.2-.2-.1-1.3.4-.7.4-2.1 1.5v.3l.1.2h.4l.2.4.4-.4.3-.1.3.1.3.2.1.6.1.2.6.1.9.4.4-.2.5-.3.2-.6.3-.5.3-.5.3-.4-.1-.4-.3-.1-.3-.1-.5.2-.5-.2zm6-.3l.1-.4v-.1l-.5-.7-.9-.3-1 .1-.1.1v.4l.1.1.6.1 1.6.7h.1z');
    add('country-se', 'Sweden', 'Europe', '1024.1 140.2 56.1 86.5',
      'M1077.7 161.1l-1.9-2.2-1.7-8.4-7.2-3.7-5.9-2.7-2.5.3v3.5l-7.9-.9-.6 3.1-4-.1-2.2 3.9-3.4 6.1-5.7 7.9 1.8 1.9-1.3 2.2-4.3-.1-2.3 5.3 1 7.6 3.1 2.9-.9 6.9-3.4 4-1.7 3.3 4.2 8.4 4.4 6.7 2 5.7 5.3-.3 2.2-4.7 5.7.5 2-5.5.6-10 4.6-1.3 3.3-6.6-4.8-3.3-3.6-4 2.1-8.1 7.7-4.9 6.1-4.5-1.2-3.5 3.4-3.9 7-1.5z');
    add('country-ch', 'Switzerland', 'Europe', '1005.7 268.1 24.1 14.1',
      'M1024.3 270.6l-5.4-1.9-1 1.4h-4.2l-1.3 1-2.3-.6.2 1.6-3.5 3.5v2.8l2.4-.9 1.8 2.7 2.2 1.3 2.4-.3 2.7-2.1.9 1 2.4-.2.9-2.5 3.8.8 2.1-1.1.3-2.5-2.6-.2-2.3-1.1.7-1.6-.2-1.1z');
    add('country-tr', 'Turkey', 'Europe', '1105.6 301.9 111.1 44.3',
      'M1166.6 308.9l-9.7-4.4-8.5.2-5.7 1.7-5.6 4-9.9-.8-1.6 4.8-7.9.2-5.1 6.1 3.6 3-2 5 4.2 3.6 3.7 6.4 5.8-.1 5.4 3.5 3.6-.8.9-2.7 5.7.2 4.6 3.5 8-.7 3.1-3.7 4.6 1.5 3.2-.6-1.7 2.4 2.3 3 1.2-1.4 1.2-1.5-.1-3.6 1.9 1.3 5.5-1.8 3 1.2h4.3l5.7-2.5 2.8.2 5.9-1.1 2.1-1 6.2.9 2.1 1.6 2.3-1.1-3.7-5.2.7-2-2.9-7.3 3.3-1.8-2.4-1.9-4.2-1.5v-3.1l-1.3-2.2-5.6-3-5.4.3-5.5 3.2-4.5-.6-5.8 1-7.8-2.4zm-49.6 4l2-1.9 6.1-.4.7-1.5-4.7-2-.9-2.4-4.5-.8-5 2 2.7 1.6-1.2 3.9-1.1.7.1 1.3 1.9 2.9 3.9-3.4z');
    add('country-ua', 'Ukraine', 'Europe', '1081.2 238.5 96.8 54.2',
      'M1138.5 241l-4.8.5-1.5-.3-1 1.4-1.8-.2-4.1.3-1.2 1.4.2 3.1-2-.6-4.3.3-1.5-1.5-1.6 1.1-2-.9-3.8-.1-5.6-1.5-5-.5-3.7.2-2.4 1.6-2.2.3 3.1 5.3-.3 1.8-2.3.7-3.8 5.1 1.6 2.8-1.1-.4-1.1 1.7-.7 2.5 2.9 1.7.6 1.6 1.9-1.3 3.2.7h3.2l2.4 1.5 1.6-.9 3.6-.6 1-1.5h2.1l1.1-.9 3.2-.6 3.9 1.9 2 .3 2.5 1.6v2.1l1.9 1.1 1.1 2.6 2 1.5-.2 1 1 .6-1.2.5-3-.2-.6-.9-1 .5.5 1.1-1.1 2-.5 2.1-1.2.7 2.4 1.1 2.2-1 2.4 1.1 3.3-4.6 1.3-3.4 4.5-.8.7 2.4 8 1.5 1.7 1.4-4.5 2.1-.7 1.2 5.8 1.8-.6 2.9 3 1.3 6.3-3.6 5.3-1.1.6-2.2-5.1.4-2.7-1.5-1-3.9 3.9-2.3 4.6-.3 3-2 3.9-.5-.4-2.8 2.2-1.7 4.7-.5.3-2.1-1.8-3.4 1.3-3.2-.4-1.9-7.6-2-2.9.1-3.6-2.9-3.5 1-6.6-2.2-.2-1.2-2.2-2.7-4-.2-.7-1.9.9-1.3-3.8-3.4z');
    add('country-gb', 'United Kingdom', 'Europe', '938.7 200.6 48.2 57.5',
      'M950 227.5l-4.9-3.7-3.9.3.8 3.2-1.1 3.2 2.9-.1 3.5 1.3 2.7-4.2zm13-24.3l-5.5.5-3.6-.4-3.7 4.8-1.9 6.1 2.2 3 .1 5.8 2.6-2.8 1.4 1.6-1.7 2.7 1 1.6 5.7 1.1h.1l3.1 3.8-.8 3.5-7.1-.6-1 4 2.6 3.3-5.1 1.9 1.3 2.4 7.5 1-4.3 1.3-7.3 6.5 2.5 1.2 3.5-2.3 4.5.7 3.3-2.9 2.2 1.2 8.3-1.7 6.5.1 4.3-3.3-1.9-3.1 2.4-1.8.5-3.9-5.8-1.2-1.3-2.3-2.9-6.9-3.2-1-4.1-7.1-.4-.6-4.8-.4 4.2-5.3 1.3-4.9h-5l-4.7.8 5-6.4z');

    // ===================== NORTH AMERICA (4) =====================
    add('country-ca', 'Canada', 'North America', '322.8 65.9 468.5 250.1',
      'M659 276.7l-.7-3-2.5 1.9.5 2.1 5.6 2.6 1.9-.4 3.3-2.5-4.7.1-3.4-.8zm14.4-15.9l.2-1.1-4.1-2.6-5.9-1.6-1.9.6 3.5 2.9 5.7 1.9 2.5-.1zm-305.3 3.7l.2-3.4-3.2-2.6-.4-2.9-.1-2.1-4.1-.7-2.4-.9-4.1-1.4-1.4 1.5-.6 3.3 4.3 1.1-.4 1.8 2.9 2.2v2.2l6.3 2.8 3-.9zM704.2 251l3.9-3.8 1.4-1.7-2.1-.3-4.9 2.2-4.2 3.5-8.1 9.8-5.3 3.7 1.6 1.7-3.8 2.2.2 1.9 9.6.1 5.4-.3 4.4 1.5-4.4 2.9 2.9.2 7.3-5.4 1.2.8-2.5 5.1 3 1.2 2.3-.2 3.5-5.5-.5-3.9.3-3.3-3.7 1.1 2.8-4.6-4.3-1.9-2.7 1.5-3.9-1.7 2.4-2.1-2.9-1.3-3.8 2 4.9-5.4zm-356.8-21.2l-1.9 2-1.4 2.6.9 1.9-.6 2.8.7 2.8h1.9l-.2-4.9 7.1-6.9-4.9.5-1.6-.8zm280.9-47l-.4-1.2-1.7-.1-2.8 1.7-.4.4.1 1.7 1.7.5 3.5-3zm-9.6-3.2l.8-1.1-6-.1-4.9 2.7v1.5l3 .2 7.1-3.2zm-3.1-16.6l-2.7-.5-5 5.2-3.6 4.4-5.7 2.8 6.3-.6-.8 3.4 8.2-3 6.2-3 .8 2.6 5.9 1.3 4.9-1.8-1.9-1.8-3.4.4 1.3-2.7-3.7-1.7-3.4-1.9-1.5-1.5-2.8.9.9-2.5zm44.6-8.2l3.7-1.7 1-.7 1.4-2.3-2.3-1.5-4.2.7-3.8 3.1-.7 2.6 4.9-.2zm-73.8-10.7l-.8-2-.3-1-1.6-1-3-1.5-4.9 2.3-5 1.7 3.5 2.4 3.8-.6 4.1 1.6 4.2-1.9zm22.4-2.1l-6.6-1 5.7-2.6-.4-6-1.9-2.3-4.5-.8-8.1 3.8-5.5 5.8 2.9 2.1 1.6 3.3-6.3 5.5-3.2-.2-6.2 4.4 4.2-5.2-4.8-1.8-4.5.9-2.4 3.4-5.9-.1-7.2.8-5.1-2.4-5 .4-1.5-2.9-2.1-1.3-3.8.5-5.2.3-4.4 1.8 2 2.3-7 2.8-1.4-3.3-4.4 1-11.8.6-6.4-1.2 8.5-2.6-2.8-2.8-4.4.4-4.7-1-7.5-1.9-3.8-2.3-4.5-.3-3.3 1.6-5.9.9 3.9-4.1-9.4 3.6-1.4-4.7-2.1-.6-3.8 2.5-4.5 1.2-.2-2.2-8.2 1.4-8.8 2.3-5.2-.6-7 1.6-6.2 2.3-3.7-.5-3.3-2.6-5.9-1.3-24.3 20.2-35.4 32.4 4.2.1 2.7 1.6.6 2.6.2 3.9 7.6-3.3 6.4-1.9-.5 3 .7 2.4 1.7 2.7-1.1 4.2-1.5 6.8 4.6 3.8-3.1 3.7-5.1 2.9-2.5 3.1 2.1 4.4-3.1 4.9 4.1 2.6-3.6 3.7-1.3 5.5 6.9 2.5 1.6 2.7 5.4 6.1h136.6l1.3-2.4h1.6l-.8 3.4 1 1 3.2.4 4.6 1 3.8 1.9 4.4-.8 5.3 1.6 3.2-2.4 3.2-1 1.8-1.5 1.5-.8 4 1.2 3.3.2.8.8.1 3.5 5.2 1-1.7 1.7 1.2 1.9-1.9 2.3 1.8.8-1.9 2.1 1.2.2 1.3-.9.5 1.4 3.4.7 3.8.1 3.8.6 4 1.2.8 2 1.4 4.7-2.4 2-3.8-.8-1-3.8-.9 3.9-3.8 3.4-.8 2.9-1.1 1.7-4.1 2-3.7 3.4-2 2.2 2.7.4 4.5-2 2.9-1.7 1.6-.3 2.6.6 1.7-.9 2.8-.8 4.7-.8.3-1.8-.3.1-1.7.3-1.8-.6 2.3-2.1 1.9-.7 3.9-.9 4.6-.9 1.8 1.2 1.9-1.4 1.9-.8.9.4.1.1 6.7-4.2 2.7-1.2h17l1-1.6 1.7-.3 2.5-.9 2.7-2.8 3.2-4.9 5.5-4.7 1.1 1.7 3.7-1.1 1.5 1.8-2.8 8.5 2.1 3.5 5.9-.8 8.1-.2-10.4 5.1-1.5 5.2 3.7.5 7.1-4.5 5.8-2.4 12.2-3.7 7.5-4.1-2.6-2.2 1-4.5-7.1 7-8.6.8-5.5-3.1-.1-4.6.6-6.8 6.1-4.1-3.3-3.1-7.6.6-12.1 5.2-10.9 8.2-4.6 1 7.8-5.7 10.1-8.3 7.2-2.7 5.7-4.4 5.2-.5 7.3.1 10 1.3 8.6-1 7.8-5.1 8.7-2.2 4.2-2.1 4.2-2.3 2-6.8-1.1-2.3-3.4-.8v-5.1l-2.3-1.9-6.9-1.6-2.8-3.4-4.8-3.4 3.4-3.7-2-7.1-2.6-7.5-1-5.2-4.3 2.7-7.4 6.5-8.1 3.2-1.6-3.4-3.7-1 2.2-7.3 2.6-4.9-7.7-.5-.1-2.2-3.6-3.3-3-2-4.5 1.5-4.2-.5-6.6-1.6-3.9 1.3-3.8 9-1 5.3-8.8 6.1 3.1 4.5.5 5-1.7 4-4.7 4.1-7.5 4.2-9 2.8 1.7 3.2-2.2 9.6-5.6 6.3-4.6 1.9-4.4-5.8-.1-6.8 1.7-6 3.6-5.2-4.8-.6-7.5-.4-3.6-2.5-4.8-1.6-1.7-2.9-3.3-2.2-7-2.6-7.1 1.2.7-4.5 1.5-5.5-6-1 4.9-6.8 4.9-4.6 9.4-6.5 8.6-4.6 5.6-.7 2.9-3.7 5.1-2.4 6.4-.4 7.7-3.8 2.9-2.4 7.4-4.7 3.2-2.8 3.2 1.7 6.5-.9L637 155l2.3-2.7-.8-2.9 5-2.9 1.7-2.7-3.5-2.6-5.4-.8-5.5-.4-4.6 5.9-6.5 4.6-7.2 4-1.3-3.7 4.2-4-2.2-3.5-8.7 4.2 4.3-5.5zm-75.5-18.9l-2.8-1-14.1 3.2-5.1 2-7.8 3.9 5.4 1.4 6.2-.1-11.5 2.1v1.9l5.6.1 9-.4 6.5 1.2-6.2 1-5.5-.3-7.1.9-3.3.6.6 4.2 4.2-.6 4.1 1.5-.3 2.5 7.8-.5 11.2-.8 9.4-1.8 5-.4 5.7 1.5 6.7.8 3.1-1.9-.7-2.1 7-.4 2.6-2.4-5-2.5-4.2-2.6 2.4-3.6 2.7-5.1-2.2-2-3-.9-4.2.8-2.8 5.3-4.3 2.1 2.2-5.1-1.7-1.7-7.3 2.7-2.6-2.6-10.4 1.5 4.7-2.4zm39.1-1.5l-1.7-1.1-5.4.2-2.1.7 2.2 3.6 7-3.4zm107.7 1.6l-4.4-2.8-8.4-.5-2.1.3-1.7 1.8 2 2.8.9.3 4.8-.7 4.1.1 4.1.1.7-1.4zm-39.4-.3l5.7-3.2-11.2 1.3-5.8 2.1-7.1 4.6-3.3 5.2 5.6.1-6.1 2.3 1.8 1.9 5.9.8 7.3 1.5 13.8 1.2 7.9-.6 3.2-1.6 2 1.8 3.3.3 2 3.3-3.5 1.4 7.1 1.8 4.6 2.6.5 1.9-.4 2.4-8.6 5.4-3.2 2.7.2 2-9.2.7-8 .1-5.4 4.2 2.4 1.9 13-.9.9-1.6 4.7 2.7 4.7 2.9-2.4 1.6 3.8 2.8 7.6 3.3 10.7 2.3.3-2-2.8-3.5-3.5-4.9 8.5 4.6 4.7 1.5 3.6-4.1v-5.6l-1-1.5-4.4-2.5-2.7-3.3 2.3-3.2 5.8-.7 3.8 5.4 4 2.4 10.7-6.5 3.3-3.9-6.4-.3-3.2-5.1-5.9-1.2-7.7-3.5 9-2.5-.8-5-2.2-2.1-8.3-2.1-1.9-3.3-8.2 1.2 1.1-2.3-3.6-2.5-6.8-2.6-5.2 2.1-9 1.5 3.3-3.4-2.3-5.3-11.6 2.1-7.1 4.1-.3-3.2zm-50-3.4l-7.1 2.4.9 3.4-7.4-.7-1.7 1.7 5.8 3.9.9 2 3.4.5 8.4-2 5.1-4.7-3.8-2.2 6-2.4.5-1.5-7.5.6-3.5-1zm22.3 5.4l5.6-1 10-4.5-6.1-1.2-7.8-.2-5.2 1.4-4.2 2.1-2.5 2.6-1.8 4.5 4.3.2 7.7-3.9zm-114.7 7.2l2.6-2.3 9.1-3.6 13.8-3.6 6.4-1.3-1.6-2.1-1.9-1.5-9.4-.2-4.1-1.1-14 .8-.3 3.1-7.6 3.3-7.4 3.8-4.3 2.2 5.9 2.7-.6 2.3 13.4-2.5zm124.1-18.3l.3-1.6-1.4-1.7-6.9 1.3-4.4 2.2 3.2 1.3 5.1.4 4.1-1.9zm-8.7-8.6l-1.1.7-4.8-.3-7.6 1.6-3.8-.1-4.3 3.8 6.6-.4-3.4 2.9 3.2.8 6.8-.5 5.8-3.7 2.8-2.5-.2-2.3zm-39.1 2.5l1.8-2.3-3.1-.5-5.7 1.7-.7 4.7-6.1-.4-2.8-2.9-8.2-1.6-5.4 1.4-11.6 4.8 4.1.8 17.8-.5-10.6 2.2-1.5 1.6 5.9-.1 12.2-2.2 13.8-.8 5.1-2.3 2.3-2.4-3.7-.2-4.3.8.7-1.8zm55.2-4.3l-7.1-.3-3.8 2 2.6 1.5 7 .6 1.4 2.1-2.2 2.4-1.5 2.8 8.5 1.6 5.5.6 8-.1 11.6-.8 4.3.6 6.7-1 3.5-1.4 1-2-2.3-1.9-5.8-.3-8 .4-7 1.1-5.1-.4-4.8-.3-1.2-1.1-3.1-1.1 2.8-1.9-1.4-1.6-7.3.1-2.3-1.6zm-75-2.6l-6 .7-5.5-.1-12.1 3.1-11.6 3.7 3.6 1 7-.7 9.8-2.1 3.8-.3 5.2-1.6 5.8-3.7zm80.5.6l1-.5-1.5-.9-7.2-.1-.6 1.3 6.4.3 1.9-.1zm-58.4-.8l3.2-1.4-4.1-.8-5.9.5-5.1 1.5 3.3 1.5 8.6-1.3zm7.8-4.2l-3.3-.9-1.6-.2-5.7 1.3-1 .7h6l5.6-.9zm46.4 2.5l3-1.7-2.3-1.6-1.7-.3-4.4-.1-2.1 1.8-.7 1.8 1.6 1.1 6.6-1zm-13.7-1.2l.1-2.2-7.4-1.7-6.1-.6-2.1 1.7 2.8 1.1-5.3 1.4 7.7.2 4 1.5 5.2.5 1.1-1.9zm53.7-6.1l.6-2.8-4.7-.8-4.7-.9-1.6-2.2-8.2.2.3.9-3.9.3-4.1 1.3-4.9 1.9-.3 1.9 2 1.5h6.5l-4.3 1.2-2.1 1.6 1.6 1.9 6.7.6 6.8-.4 10.5-3.4 6.4-1.3-2.6-1.5zm78.5-13.8l-7-.2-6.9-.3-10.2.6-1.4-.4-10.3.2-6.4.4-5.1.6-5 2-2.3-1-3.9-.2-6.7 1.4-7.4.6-4.1.1-6 .8-1.1 1.3 2.5 1.2.8 1.6 4.4 1.5 12.4-.3 7.2.5-7.2 1.5-2.2-.4-9.3-.2-1.1 2.2 3 1.7-2.8 1.6-7.5 1.1-4.9 1.7 4.8.9 1.7 3-7.5-2-2.5.3-2 3.4-8 1.1-2 2.3 6.7.3 4.9.6 11.7-.8 8.4 1.4 12.6-3 1-1.1-6.4.2.5-1.1 6.5-1.4 3.6-1.9 6.8-1.3 5-1.6-.8-2.2 3.3-.8-4.3-.6 11.1-.4 3.2-.9 7.9-.8 9.3-3.5 6.8-1.1 10.3-2.5h-7.4l3.9-.9 9-.8 9.7-1.6 1.1-1.1-5.2-1-6.7-.4-8.5-.3z');
    add('country-gl', 'Greenland', 'North America', '701.2 69.9 245.0 131.0',
      'M887.4 76.3l-26-.4-11.8.3-5 1.3-11.5-.1-12.7 2.1-1.6 1.7 6.7 2.1-6.2-1.3-4.5-.3-7-1.4-10.6 2.1-2.7-1.2h-10.4l-10.9.6-8.9 1-.2 1.8-5.3.5-14.6 2.9-4.6 1.7 8.1 1.5-2.8 1.6L730 95l-15.5 2.2-2.2 1.7 6.4 2 14.5 1.2-7.5.2-10.9 1.5 3.8 3.1 3 1.5 9.4-.3 10.1-.2 7.6.3 8 2.9-1.4 2.1 3.6 1.9 1.4 5.3 1 3.6 1.4 1.9-7 4.8 2.6 1.3 4.4-.8 2.6 1.8 5.3 3.4-7.5-1.4h-3.8l-3 2.8-1.5 3.6 4.2 1.8 4-.8 2.6-.8 5.5-1.9-2.8 4.2-2.6 2.3-7.1 2-7 6.3 2 2-3.4 4 3.7 5.2-1.5 5 .7 3.7 4.8 7.1.8 5.6 3.1 3.2h8.9l5 4.7 6.5-.3 4.1-5.7 3.5-4.8-.3-4.4 8.6-4.6 3.3-3.7 1.4-3.9 4.7-3.5 6.5-1.3 6.1-1.4 3-.2 10.2-3.9 7.4-5.7 4.8-2.1 4.6-.1 12.5-1.8 12.1-4.3 11.9-4.6-5.5-.3-10.6-.2 5.3-2.8-.5-3.6 4.2 3 2.7 2.1 7.3-1-.6-4.3-4.5-3.1-5-1.3 2.4-1.4 7.2 2.1.5-2.3-4.1-3.4h5.4l5.6-.8 1.7-1.8-4-2.1 8.6-.3-4-4.3 4.1-.5.1-4.2-6.2-2.5 6.4-1.6 5.8-.1-3.6-3.2 1.1-5.1 3.6-2.9 4.9-3.2-8-.2 11.3-.7 2.2-1 14.6-2.9-1.6-1.7-10-.8-16.9 1.5-9.2 1.5 4.5-2.3-2.3-1.4-7 1.2-9.7-1.4-12.1.5-1.4-.7 18.3-.4 12.9-.2 6.6-1.4-19.7-2.9z');
    add('country-mx', 'Mexico', 'North America', '342.8 358.2 163.2 127.3',
      'M444.4 407.8l-3.6-1.4-3.9-2-.8-3-.2-4.5-2.4-3.6-1-3.7-1.6-4.4-3.1-2.5-4.4.1-4.8 5-4-1.9-2.2-1.9-.4-3.5-.8-3.3-2.4-2.8-2.1-2-1.3-2.2h-9.3l-.8 2.6h-15l-10.7-4.4-7.1-3.1 1-1.3-7 .7-6.3.5.2 5.7.7 5.1.7 4.1.8 4 2.6 1.8 2.9 4.5-1 2.9-2.7 2.3-2.1-.3-.6.5 2.3 3.7 2.9 1.5 1 1.7.9-.9 3.1 2.9 2.1 2 .1 3.4-1.2 4.7 2.5 1.6 3.3 3.1 2.9 3.6.7 3.9h1l2.7-2.3.4-1.2-1.5-2.8-1.6-2.9-2.6-.2.4-3.4-.9-3-1-2.8-.5-5.9-2.6-3.2-.6-2.3-1.2-1.6v-4.1l-1 .1-.1-2.2-.7-.5-.4-1.4-2.7-4.4-1.1-2.6 1-4.8.1-3 1.8-2.6 2.4 1.7 1.9-.2 3.1 2.5-.9 2.4.4 4.9 1.5 4.7-.4 2 1.7 3.1 2.3 3.4 2.7.5.3 4.4 2.4 3.1 2.5 1.5-1.8 4 .7 1.5 4.1 2.6 1.9 4 4.5 4.9 3.8 6.4 1.3 3.2v2.5l1.4 2.9-.3 2.2-1.6 1.6.3 1.8-1.9.7.8 3.1 2.2 4 5.3 3.6 1.9 2.9 5.4 2 3 .4 1.2 1.7 4.2 3 5.9 3 4 .9 4.8 2.9 4 1.2 3.7 1.7 2.9-.7 4.8-2.4 3.1-.4 4.4 1.6 2.6 2.1 5.5 6.9.4-1.9.8-1.5-.7-1.2 3.3-5.2h7.1l.4-2.1-.8-.4-.5-1.4-1.9-1.5-1.8-2.1h2.6l.4-3.6h5.2l5.1.1.1-1 .7-.3.9.8 2.5-3.9h1l1.2-.1 1.2 1.6 2-5 1.2-2.7-.9-1.1 1.8-3.9 3.5-3.8.6-3.1-1.2-1.3-3.4.5-4.8-.2-6 1.5-4 1.7-1.2 1.8-1.2 5.4-1.8 3.7-3.9 2.6-3.6 1.1-4.3 1.1-4.3.6-5.1 1.8-1.9-2.6-5.6-1.7-1.8-3.2-.7-3.6-3-4.7-.4-5-1.2-3.1-.5-3.4 1.1-3.1 1.8-8.6 1.8-4.5 3.1-5.6-2.1.2z');
    add('country-us', 'United States', 'North America', '70.6 116.2 596.0 351.6',
      'M116.7 450.7l2-.9 2.5-1.4.2-.4-.9-2.2-.7-.8-.8-.6-1.9-1.1-.4-.1-.4.6v1.3l-1.2 1-.4.7.4 2.3-.6 1.8 1.2.9 1-1.1zm-.6-9.9l.6-.7-1.2-1-1.8-.6-.7.5v.4l.5.5.6 1.4 2-.5zm-3-3.4l-2.6-.2-.6.7 2.9.2.3-.7zm-4.7-.9l-1.1-2.1-.3-.4-1.7.9.1.2.4 1.5 1.8.2.4.1.4-.4zm-8.3-4.2l.3-1.5-1.3-.1-1 .6-.4.5 1.6 1.1.8-.6zm412.1-173.2h-1.6l-1.3 2.4H373.4l-1.6 5.1-2.4 5.1-2.3 1.6 1.1-5.9-5.8-2.1-1.4 1.2-.4 2.9-1.8 5.4-4.2 8.3-4 5.6-4 5.6-5.4 5.8-1.1 4.7-2.8 5.3-3.9 5.2 1 3.4-1.9 5.2 1.5 5.4 1.3 2.2-.8 1.5.4 9 2.5 6.5-.8 3.5 1 1 4.6.7 1.3 1.7 2.8.3-.1 1.9 2.2.7 2.1 3.7-.3 3.2 6.3-.5 7-.7-1 1.3 7.1 3.1 10.7 4.4h15l.8-2.6h9.3l1.3 2.2 2.1 2 2.4 2.8.8 3.3.4 3.5 2.2 1.9 4 1.9 4.8-5 4.4-.1 3.1 2.5 1.6 4.4 1 3.7 2.4 3.6.2 4.5.8 3 3.9 2 3.6 1.4 2.1-.2-.6-2.2.4-3.1 1-4.4 1.9-2.8 3.7-3.1 6-2.7 6.1-4.7 4.9-1.5 3.5-.4 3.5 1.4 4.9-.8 3.3 3.4 3.8.2 2.4-1.2 1.7.9 1.3-.8-.9-1.3.7-2.5-.5-1.7 2.4-1 4.2-.4 4.7.7 6.2-.8 3 1.5 2 3 .9.3 6.1-2.9 1.9 1 3 5.3.8 3.5-2 4.2.4 2.5 1.6 4.9 2 5.5 1.8 1.4.4 2.8 2.6.8 1.7-.8 2-3.9.7-2.5.9-4.3-1.2-7.4.5-2.7-1.5-4.5-.7-5.4.1-4.4 1.8-4.5 3.5-3.8 3.7-3 6.9-4.1 1.3-2.2 3.3-2.3 2.8-.4 4.4-3.8 6-1.9 4.6-4.8.9-6.5.1-2.2-1.4-.4 1.5-6.2-3-2.1 3.2 1v-4.1l1.9-2.7-1 5.3 2 2.5-2.9 4.4.4.2 4.4-5.1 2.4-2.5.6-2.5-.9-1.1-.1-3.5 1.2 1.6 1.1.4-.1 1.6 5.2-4.9 2.5-4.5-1.4-.3 2.1-1.8-.4.8h3.3l7.8-1.9-1.1-1.2-7.9 1.2 4.8-1.8 3.1-.3 2.4-.3 4.1-1.1 2.4.1 3.8-1 1-1.7-1.1-1.4-.2 2.2-2.1-.1-.6-3.3 1.1-3.3 1.4-1.3 3.9-3.7 5.9-1.8 6-2.1 6.3-3-.2-2-2.1-3.5 2.8-8.5-1.5-1.8-3.7 1.1-1.1-1.7-5.5 4.7-3.2 4.9-2.7 2.8-2.5.9-1.7.3-1 1.6h-17l-2.7 1.2-6.7 4.2.2.9-.6 2.4-4.6 2-3.9-.5-4-.2-2.6.7-.3 1.8-.1.6-5.8 3.7-4.5 1.8-2.9.8-3.7 1.7-4 .9-2.5-.3-2.7-1.3 2.7-2.4 2-2.2 3.7-3.4.7-2.5.5-3.5-1.6-.7-4.3 2.8-.9-.1.3-1.5 3.8-2.5 1.6-2.8.7-2.8-2.7-2.4-3.7-1.3-1.7 2.4-1.4.6-2.2 3.1.4-2.1-2.6 1.5-2.1 2-2.6 3.1-1.3 2.6.1 3.8-1.8 4-3.3 3-1.4.9-1.6.7h-1.8l-.3-.4-.1-3.3.7-1.6.7-1.5.6-3 2.5-3.5 2.9-4.3 4.6-4.7h-.7l-5.4 4-.4-.7 2.9-2.3 4.7-4 3.7-.5 4.4-1.3 3.7.7h.1l4.7-.5-1.5-2.5-1.2-.2-1.4-.3-.4-1.7-5.1.5-5 1.4-2.5-2.3-2.5-.8 3.1-3.3-5.3 2-4.9 2.1-4.6 1.5-2.1-2.1-5.5 1.3.4-.9 4.6-2.6 4.7-2.5 5.9-2.1-5.3-1.6-4.4.8-3.8-1.9-4.6-1-3.2-.4-1-1 .8-3.4zm-240.6-46.9l6.9-2.8v-1.8l-2.6-.4-3.4.9-6.4 2.1-2.2 2.7.7 1.6 7-2.3zm-38.7-16.4l2.3-2.3-2.9-.5-5.7 1 .8 1.6 1.6 1.1 3.9-.9zm1.2-22.3l-3.1 2.2.4.5 4.2-.4.3 1.1 1.7 1.2 4.9-1.2 1.2-.6-3.3-.8-1.6-1.5-3.4.6-1.3-1.1zM359 133.3l-4.4-1.1-10.2 2.8-3.2-.3-11 2.3-4.8.6-7.8 2.5-4.8 2.6-8.6 2.5-7.6.1-6.3 2.9 3.2 1.7.7 2.3-.8 2.7 2.3 2.1-1.2 3.5-9.2.2 4.3-2.8h-3.4l-13.1 2.7-9.1 2.3 1 3.3-1.2 2.2 4.5 1.4 6.9-.7 1.8 1.3 2.9-1.3 6.1-1.2h2.7l-5.9 2.1 1.1 1-2.5 2.6-5.5 1.8-2.5-.5-7 2.7-1.8-.9-4.1.4-5.3 3-7.6 3.1-5.8 3.4.3 2.4-4 3.3 1.4 1.4.5 2.7 7.2-1.1.4 2.1-3.3 2.1-3.6 3.5h2.8l7.2-2.3-1.6 2.9 3.6-2.1-.4 3 4.8-2.2.4 1.1 7.2-1.8-6.2 3.4-5.7 4.5-5.7 2.1-2.3 1.2-10.3 3.6-4.9 2.4-6.5.7-8.5 3.3-6.6 1.8-8.1 2.8-.4 1 10-1.7 6-2 6.9-2 6.1-1.7 2.8.5 8.1-2.6 4.5-2.8 10.5-3.1 3.9-2.6 6.6-1.8 7.6-2.5 8.9-4.2-.2-2.9 11.1-4.1 7.4-3.9 9.2-3.2-.4 1.4-6.7 1.8-8.3 5.7-3.2 3.5 6.4-1.3 6.1-1.9 6.5-1.3 2.9-.3 3.5-4.1 6.3-1.2 2.6 2.5 6 2.7 6.7-.5 5.7 2 3.2 1.1 3.3 6.1 3.7 1.7 7.1.2 4.1.4-2.7 5.5 1.6 4.9-3.3 5.2 2.5 1.9.6 2.2 5.1-2.9 3.1-3.7-4.6-3.8 1.5-6.8 1.1-4.2-1.7-2.7-.7-2.4.5-3-6.4 1.9-7.6 3.3-.2-3.9-.6-2.6-2.7-1.6-4.2-.1 35.4-32.4 24.3-20.2-3.5-.7-4.1-1.6-6.5.8-2.2-.7-7.1-.5-6.2-1.6-4.8.5-4.9-.9 2-1.2-6.3-.3-3.3 1 .5-2.4z');

    // ===================== CENTRAL AMERICA & CARIBBEAN (13) =====================
    add('country-bz', 'Belize', 'Central America & Caribbean', '480.4 453.7 9.1 18.3',
      'M482.5 471.1l1.4-2.2 1-.2 1.3-1.7 1-3.2-.3-.6.9-2.3-.4-1 1.3-2.7.3-1.8h-1.1l.1-.9h-1l-2.5 3.9-.9-.8-.7.3-.1 1-.7 5-1.2 7.2h1.6z');
    add('country-cr', 'Costa Rica', 'Central America & Caribbean', '495.4 499.9 20.2 20.9',
      'M509.1 502.6l-1.4 1.3-1.7-.4-.8-1.3-1.7-.5-1.4.8-3.5-1.7-.9.8-1.4 1.2 1.5.9-.9 2-.1 2 .7 1.3 1.7.6 1.2 1.8 1.2-1.6-.3-1.8 1.4 1.1.3 1.9 1.9.8 2.1 1.3 1.5 1.5.1 1.4-.7 1.1 1.1 1.3 2.9 1.4.4-1.2.5-1.3-.1-1.2.8-.7-1.1-1 .1-2.5 2.2-.6-2.4-2.7-2-2.6-1.2-3.4z');
    add('country-cu', 'Cuba', 'Central America & Caribbean', '506.3 423.5 64.0 23.3',
      'M539 427.3l-4.9-2.1-4.3-.1-4.7-.5-1.4.7-4.2.6-3 1.3-2.7 1.4-1.5 2.3-3.1 2 2.2.6 2.9-.7.9-1.6 2.3-.1 4.4-3.3 5.4.3-2.3 1.6 1.8 1.3 7 1 1.5 1.3 4.9 1.7 3.2-.2.8 3.6 1.7 1.8 3.5.4 2.1 1.7-4.1 3.5 7.9-.6 3.8.5 3.7-.3 3.8-.8.8-1.5-3.9-2.6-4-.3.6-1.7-3.1-1.3h-1.9l-3-2.8-4.2-4-1.8-1.5-5.2.8-1.9-2.4z');
    add('country-do', 'Dominican Republic', 'Central America & Caribbean', '577.6 444.9 22.1 16.1',
      'M579.6 457.4v1.8l1.4 1 2.6-4.4 2-.9.6 1.6 2.2-.4 1.1-1.2 1.8.3 2.6-.2 2.5 1.3 2.3-2.6-2.5-2.3-2.4-.2.3-1.9-3 .1-.8-2.2-1.4.1-3.1-1.6-4.4-.1-.8 1.1.2 3.5-.7 2.4-1.5 1.1 1.2 1.9-.2 1.8z');
    add('country-sv', 'El Salvador', 'Central America & Caribbean', '473.9 479.9 14.5 9.1',
      'M487.2 487l.6-2.5-.7-.7-1.1-.5-2.5.8-.1-.9-1.6-1-1.1-1.3-1.5-.5-1.4.4.2.7-1.1.7-2.1 1.6-.2 1 1.4 1.3 3.1.4 2.2 1.3 1.9.6 3.3.1.7-1.5z');
    add('country-gt', 'Guatemala', 'Central America & Caribbean', '462.0 457.5 25.4 28.6',
      'M482.8 458.9l-5.1-.1h-5.2l-.4 3.6h-2.6l1.8 2.1 1.9 1.5.5 1.4.8.4-.4 2.1H467l-3.3 5.2.7 1.2-.8 1.5-.4 1.9 2.7 2.6 2.5 1.3 3.4.1 2.8 1.1.2-1 2.1-1.6 1.1-.7-.2-.7 1.4-.4 1.3-1.6-.3-1.3.5-1.2 2.8-1.8 2.8-2.4-1.5-.8-.6.9-1.7-1.1h-1.6l1.2-7.2.7-5z');
    add('country-ht', 'Haiti', 'Central America & Caribbean', '563.7 444.9 17.9 13.1',
      'M580.6 446.7l-4.6-1-3.4-.2-1.4 1.7 3.4 1-.3 2.4 2.2 2.8-2.1 1.4-4.2-.5-5-.9-.7 2.1 2.8 1.9 2.7-1.1 3.3.4 2.7-.4 3.6 1.1.2-1.8-1.2-1.9 1.5-1.1.7-2.4-.2-3.5z');
    add('country-hn', 'Honduras', 'Central America & Caribbean', '477.5 469.3 38.4 21.2',
      'M514.1 476.8l-1.3-1.8-1.9-1-1.5-1.4-1.6-1.2-.8-.1-2.5-.9-1.1.5-1.5.2-1.3-.4-1.7-.4-.8.7-1.8.7-2.6.2-2.5-.6-.9.4-.5-.6-1.6.1-1.3 1.1-.6-.2-2.8 2.4-2.8 1.8-.5 1.2.3 1.3-1.3 1.6 1.5.5 1.1 1.3 1.6 1 .1.9 2.5-.8 1.1.5.7.7-.6 2.5 1.7.6.7 2 1.8-.3.8-1.5h.8l.2-3.1 1.3-.2h1.2l1.4-1.7 1.5 1.3.6-.8 1.1-.7 2.1-1.8.3-1.3.5.1.8-1.5.6-.2.9.9 1.1.3 1.3-.8h1.4l2-.8.9-.9 1.9.2z');
    add('country-jm', 'Jamaica', 'Central America & Caribbean', '542.4 453.8 12.8 6.2',
      'M550.7 458.5l3.9-.1-.8-1.8-2.7-1.5-3.7-.6-1.2-.2-2.4.4-.8 1.5 2.9 2.3 3 1 1.8-1z');
    add('country-ni', 'Nicaragua', 'Central America & Caribbean', '486.3 475.2 29.1 30.0',
      'M514.1 476.8l-1.9-.2-.9.9-2 .8h-1.4l-1.3.8-1.1-.3-.9-.9-.6.2-.8 1.5-.5-.1-.3 1.3-2.1 1.8-1.1.7-.6.8-1.5-1.3-1.4 1.7h-1.2l-1.3.2-.2 3.1h-.8l-.8 1.5-1.8.3-.4.4-.9-1-.7 1 2.6 2.9 2.2 2 1 2.1 2.5 2.6 1.8 2 .9-.8 3.5 1.7 1.4-.8 1.7.5.8 1.3 1.7.4 1.4-1.3-.8-1.1-.1-1.7 1.2-1.6-.2-1.7.7-2.7.9-.7.1-2.8-.2-1.7.4-2.8.9-2.5 1.4-2.2-.3-2.3.4-1.4.6-.6z');
    add('country-pa', 'Panama', 'Central America & Caribbean', '510.3 510.2 35.2 16.7',
      'M543.5 517l-2-1.8-1.7-1.9-2.5-1.1-3.1-.2.3-.6-3.1-.4-2 1.9-3.5 1.3-2.5 1.6-2.7.5-1.5-1.6-.5.5-2.3-.3.2-1.3-1.9-2.3-2.2.6-.1 2.5 1.1 1-.8.7.1 1.2-.5 1.3-.4 1.2.6 1 .3-1.4h2.4l1.4.7 2.3.5 1 2.5 1.8.4.8-1.1.8 3.8 2.6-.3.9-.9 1.5-.9-2.5-3.4.6-1.3 1.3-.3 2.3-1.6 1.2-2.2 2.5-.4 2.7 1.8 1 2.1 1.4.4-1.5 1.7 1 3.5 1.8 1.8.9-3.1 1.8.5 1.1-1.9-1.1-3.8.7-.9z');
    add('country-pr', 'Puerto Rico', 'Central America & Caribbean', '599.8 453.8 16.1 4.7',
      'M600.8 457.3v-.1h.1v-.1l.1-.1v-.1h-.5v.2l.2.1v.1h.1zm13.6-.3l.7-.2v-.1l-.4-.1h-.6l-.5.2.1.2h.7zm-3.7-2.2l-.1-.2h-.2l-3.5-.1-1.3-.2-.3.1-.3.1-.1.4-.2.2-.3.2.1.3.1.2.2.4-.1.5-.2 1 .3.2.7-.1.3.1.3.1.4-.1.4-.2.9.1.5-.1.6.3.4-.1.2.1H610.4l.9-.2.8-.5.3-.5.4-.3.6-.4v-.9l-.7-.1-.6-.3-1.1-.1h-.1l.1.2h-.1l-.2-.1z');
    add('country-tt', 'Trinidad & Tobago', 'Central America & Caribbean', '629.9 499.6 9.1 9.0',
      'M635.4 507.7l.1-.2v-.6l.2-.4-.2-.4-.1-.6.1-.5v-.7l.2-.3.5-.8h-.9l-.6.2-1.1.1-.5.2-.7.1-.4.2.1.1.5.2.2.2.1.2.1.4-.3 1.7-.1.1-.6.1-.2.3-1.4.8.8-.1.9.1 2.4-.1.9-.3zm1.8-6.7l1.2-.5.1-.4h-.2l-.8.3-.6.5v.2l.3-.1z');

    // ===================== SOUTH AMERICA (12) =====================
    add('country-ar', 'Argentina', 'South America', '593.5 700.6 95.6 230.9',
      'M669.8 920.7l.9-3-7.3-1.5-7.7-3.6-4.3-4.6-3-2.8 5.9 13.5h5l2.9.2 3.3 2.1 4.3-.3zm-50.4-208.1l-7.4-1.5-4 5.7.9 1.6-1.1 6.6-5.6 3.2 1.6 10.6-.9 2 2 2.5-3.2 4-2.6 5.9-.9 5.8 1.7 6.2-2.1 6.5 4.9 10.9 1.6 1.2 1.3 5.9-1.6 6.2 1.4 5.4-2.9 4.3 1.5 5.9 3.3 6.3-2.5 2.4.3 5.7.7 6.4 3.3 7.6-1.6 1.2 3.6 7.1 3.1 2.3-.8 2.6 2.8 1.3 1.3 2.3-1.8 1.1 1.8 3.7 1.1 8.2-.7 5.3 1.8 3.2-.1 3.9-2.7 2.7 3.1 6.6 2.6 2.2 3.1-.4 1.8 4.6 3.5 3.6 12 .8 4.8.9 2.2.4-4.7-3.6-4.1-6.3.9-2.9 3.5-2.5.5-7.2 4.7-3.5-.2-5.6-5.2-1.3-6.4-4.5-.1-4.7 2.9-3.1 4.7-.1.2-3.3-1.2-6.1 2.9-3.9 4.1-1.9-2.5-3.2-2.2 2-4-1.9-2.5-6.2 1.5-1.6 5.6 2.3 5-.9 2.5-2.2-1.8-3.1-.1-4.8-2-3.8 5.8.6 10.2-1.3 6.9-3.4 3.3-8.3-.3-3.2-3.9-2.8-.1-4.5-7.8-5.5-.3-3.3-.4-4.2.9-1.4-1.1-6.3.3-6.5.5-5.1 5.9-8.6 5.3-6.2 3.3-2.6 4.2-3.5-.5-5.1-3.1-3.7-2.6 1.2-.3 5.7-4.3 4.8-4.2 1.1-6.2-1-5.7-1.8 4.2-9.6-1.1-2.8-5.9-2.5-7.2-4.7-4.6-1-11.2-10.4-1-1.3-6.3-.3-1.6 5.1-3.7-4.6z');
    add('country-bo', 'Bolivia', 'South America', '584.5 630.1 77.3 91.7',
      'M655.7 700.5l1.6-1.3-.8-3.6 1.3-2.8.5-5-1.6-4-3.2-1.7-.8-2.6.6-3.6-10.7-.3-2.7-7.4 1.6-.1-.3-2.8-1.2-1.8-.5-3.7-3.3-1.9-3.5.1-2.5-1.9-3.8-1.2-2.4-2.4-6.3-1-6.4-5.7.3-4.3-.9-2.5.4-4.7-7.3 1.1-2.8 2.3-4.8 2.6-1.1 1.9-2.9.2-4.2-.6 5.5 10.3-1.1 2.1.1 4.5.3 5.4-1.9 3.2 1.2 2.4-1.1 2.1 2.8 5.3-2.8 6.9 3.1 4.3 1.2 4.6 3.2 2.7-1.1 6.2 3.7 7.1 3.1 8.8 3.8-.9 4-5.7 7.4 1.5 3.7 4.6 1.6-5.1 6.3.3 1 1.3 1.5-7.6-.2-3.4 2.1-5.6 9.5-1.9 5.1.1 5.4 3.3.3 1.9z');
    add('country-br', 'Brazil', 'South America', '551.0 526.4 242.0 273.0',
      'M659 560.1l-1.4.2-3.1-.5-1.8 1.7-2.6 1.1-1.7.2-.7 1.3-2.7-.3-3.5-3-.3-2.9-1.4-3.3 1-5.4 1.6-2.2-1.2-3-1.9-.9.8-2.8-1.3-1.5-2.9.3.7 1.8-2.1 2.4-6.4 2.4-4 1-1.7 1.5-4.4-1.6-4.2-.8-1 .6 2.4 1.6-.3 4.3.7 4 4.8.5.3 1.4-4.1 1.8-.7 2.7-2.3 1-4.2 1.5-1.1 1.9-4.4.5-3-3.4-1.1.8-1-3.8-1.6-2-1.9 2.2-10.9-.1v3.9l3.3.7-.2 2.4-1.1-.6-3.2 1v4.6l2.5 2.4.9 3.6-.1 2.8-2.2 17.4-5.1-.3-.7 1-4.6 1.2-6.2 4.3-.4 3-1.3 2.2.7 3.4-3.3 1.9.1 2.7-1.5 1.1 2.6 5.8 3.3 3.8-1 2.8 3.7.3 2.3 3.4 4.9.2 4.4-3.8.2 9.7 2.6.7 3-1.1 4.2.6 2.9-.2 1.1-1.9 4.8-2.6 2.8-2.3 7.3-1.1-.4 4.7.9 2.5-.3 4.3 6.4 5.7 6.3 1 2.4 2.4 3.8 1.2 2.5 1.9 3.5-.1 3.3 1.9.5 3.7 1.2 1.8.3 2.8-1.6.1 2.7 7.4 10.7.3-.6 3.6.8 2.6 3.2 1.7 1.6 4-.5 5-1.3 2.8.8 3.6-1.6 1.3 1.9 3.6.4 8.6 6 1.2 2.1-1.2 3.9 1.7 1.2 1.9 1 5.8.9 2.5 2 .3 2-1.1 2.1 1.2.3 3.5-.3 3.8-.7 3.6 2.6-1.2 3.1 3.7.5 5.1-4.2 3.5-3.3 2.6-5.3 6.2-5.9 8.6 3.4-.7 6.2 4.9 1.9-.2 6.2 4.1 4.8 3.5 3.8 4.3-1.9 3 2.1 3.7 2.9-3.7 1.5-6 3.2-3 3.9-5 4.5-11.2 3.4-3.5.8-3.1.3-6.4-1.3-3.5.3-4.8 4.1-6.3 6-5.1 6-1.8 3.6-2.9 8.5-2.4h5.9l1.1-3.8 4.2-2.8.6-6.5 5.1-8.3.5-8.5 1.6-2.6.3-4.1 1.1-9.9-1-11.9 1.4-4.7 1.4-.1 3.9-5.5 3.3-7.2 7.7-8.8 2.7-4.2 2-10.5-1-3.9-2-8.1-2.1-2-4.8-.2-4.3-1.9-7.3-7.1-8.4-5.3-8.4.3-10.9-3.4-6.5 2 .8-3.5-2.7-3.8-9.4-3.8-7.1-2.3-4.2 4.1-.3-6.3-9.9-1-1.7-2 4.2-5.2-.1-4.4-3-1-3-11.2-1.3-3.5-1.9.3-3.5 5.8-1.8 4.7-2.1 2.4-2.7.5-.8-1.8-1.2-.3-1.8 1.8-2.4-1.3-3.2-1.4-2.7.7-2.3-.6-.5 1.8.9 1.3-.5 1.3-3.1-.5z');
    add('country-cl', 'Chile', 'South America', '583.3 672.0 82.6 263.0',
      'M648.4 905.2l-3.7-.7-3.3 2.5.2 4.1-1.2 2.8-7.2-2.2-8.6-4-4.5-1.3 9.7 6.8 6.3 3.2 7.5 3.4 5.3.9 4.3 1.8 3 .5 2.3.1 3.2-1.8.5-2.4-2.9-.2h-5l-5.9-13.5zm-47.3-196.3l-3.7-7.1 1.1-6.2-3.2-2.7-1.2-4.6-3.1-4.3-1.2 3.3-2.7 1.6 2.1 9 1.5 10.4-.1 14.2v13.2l.9 12.3-1.9 7.8 2.1 7.8-.5 5.3 3.2 9.5-.1 9.5-1.2 10.2-.6 10.5-2.1.2 2.4 7.3 3.3 6.3-1.1 4.3 1.9 11.6 1.5 8.8 3.5.9-1.1-7.7 4 1.6 1.8 12.7-6.4-2.1 2 10.2-2.7 5.5 8.2 1.8-3.4 4.8.2 6 5 10.6 4.2 4.1.2 3.6 3.3 3.8 7.5 3.5 7.4 4.2 6.2 2 2-.1-1.8-5.7 3.4-2.2 1.7-1.5h4.2l-4.8-.9-12-.8-3.5-3.6-1.8-4.6-3.1.4-2.6-2.2-3.1-6.6 2.7-2.7.1-3.9-1.8-3.2.7-5.3-1.1-8.2-1.8-3.7 1.8-1.1-1.3-2.3-2.8-1.3.8-2.6-3.1-2.3-3.6-7.1 1.6-1.2-3.3-7.6-.7-6.4-.3-5.7 2.5-2.4-3.3-6.3-1.5-5.9 2.9-4.3-1.4-5.4 1.6-6.2-1.3-5.9-1.6-1.2-4.9-10.9 2.1-6.5-1.7-6.2.9-5.8 2.6-5.9 3.2-4-2-2.5.9-2-1.6-10.6 5.6-3.2 1.1-6.6-.9-1.6-3.8.9-3.1-8.8z');
    add('country-co', 'Colombia', 'South America', '529.4 487.7 74.9 117.1',
      'M578.3 497.2l1.2-2.1-1.3-1.7-2-.4-2.9 3.1-2.3 1.4-4.6 3.2-4.3-.5-.5 1.3-3.6.1-3.3 3-1.4 5.4-.1 2.1-2.4.7-4.4 4.4-2.9-.2-.7.9 1.1 3.8-1.1 1.9-1.8-.5-.9 3.1 2.2 3.4.6 5.4-1.2 1.6 1.1 5.9-1.2 3.7 2 1.5-2.2 3.3-2.5 4-2.8.4-1.4 2.3.2 3.2-2.1.5.8 2 5.6 3.6 1-.1 1.4 2.7 4.7.9 1.6-1 2.8 2.1 2.4 1.5 1.5-.6 3.7 3 1.8 3 2.7 1.7 3.4 6.7 4.2.8 3-1.7 2.1 1.1 3.3-.6 4.4 3-3.5 6.5 1.7.1 2.9 3.4 2.2-17.4.1-2.8-.9-3.6-2.5-2.4v-4.6l3.2-1 1.1.6.2-2.4-3.3-.7v-3.9l10.9.1 1.9-2.2 1.6 2 1 3.8 1.1-.8-1.7-6.4-1.4-2.2-2-1.4 2.9-3.1-.2-1.5-1.5-1.9-1-4.2.5-4.6 1.3-2.1 1.2-3.4-2-1.1-3.2.7-4-.3-2.3.7-3.8-5.5-3.2-.8-7.2.6-1.3-2.2-1.3-.6-.2-1.3.8-2.4-.4-2.5-1.1-1.4-.6-2.9-2.9-.5 1.8-3.7.9-4.5 1.8-2.4 2.2-1.8 1.6-3.2 3.7-1.1z');
    add('country-ec', 'Ecuador', 'South America', '520.2 561.4 35.3 44.3',
      'M553.1 573.1l-2.4-1.5-2.8-2.1-1.6 1-4.7-.9-1.4-2.7-1 .1-5.6-3.6-3.9 2.5-3.1 1.4.4 2.6-2.2 4.1-1 3.9-1.9 1 1 5.8-1.1 1.8 3.4 2.7 2.1-2.9 1.3 2.8-2.9 4.7.7 2.7-1.5 1.5.2 2.3 2.3-.5 2.3.7 2.5 3.2 3.1-2.6.9-4.3 3.3-5.5 6.7-2.5 6-6.7 1.7-4.1-.8-4.9z');
    add('country-gy', 'Guyana', 'South America', '630.9 516.6 29.5 49.7',
      'M656.1 534.2l-2.1-2.3-2.9-3.1-2.1-.1-.1-3.3-3.3-4.1-3.6-2.4-4.6 3.8-.6 2.3 1.9 2.3-1.5 1.2-3.4 1.1v2.9l-1.6 1.8 3.7 4.8 2.9-.3 1.3 1.5-.8 2.8 1.9.9 1.2 3-1.6 2.2-1 5.4 1.4 3.3.3 2.9 3.5 3 2.7.3.7-1.3 1.7-.2 2.6-1.1 1.8-1.7 3.1.5 1.4-.2-3.3-5.6-.7-3.5-1.8-.1-2.4-4.6 1.1-3.3-.3-1.5 3.5-1.6 1-5.7z');
    add('country-py', 'Paraguay', 'South America', '629.6 692.6 52.3 57.5',
      'M655.7 700.5l-.3-1.9-5.4-3.3-5.1-.1-9.5 1.9-2.1 5.6.2 3.4-1.5 7.6 11.2 10.4 4.6 1 7.2 4.7 5.9 2.5 1.1 2.8-4.2 9.6 5.7 1.8 6.2 1 4.2-1.1 4.3-4.8.3-5.7.7-3.6.3-3.8-.3-3.5-2.1-1.2-2 1.1-2-.3-.9-2.5-1-5.8-1.2-1.9-3.9-1.7-2.1 1.2-6-1.2-.4-8.6-1.9-3.6z');
    add('country-pe', 'Peru', 'South America', '516.0 566.7 81.5 128.0',
      'M584.3 599.5l-2.9-3.4-1.7-.1 3.5-6.5-4.4-3-3.3.6-2.1-1.1-3 1.7-4.2-.8-3.4-6.7-2.7-1.7-1.8-3-3.7-3-1.5.6.8 4.9-1.7 4.1-6 6.7-6.7 2.5-3.3 5.5-.9 4.3-3.1 2.6-2.5-3.2-2.3-.7-2.3.5-.2-2.3 1.5-1.5-.7-2.7-4.4 4-1.6 4.5 3 6.1-1.7 2.8 4.1 2.6 4.5 4.1 2 4.7 2.4 2.9 6 12.7 6.2 11.7 5.4 8.4-.8 1.8 2.8 5.3 4.6 3.9 10.7 6.9 11.6 6.4.7 2.6 5.9 3.7 2.7-1.6 1.2-3.3 2.8-6.9-2.8-5.3 1.1-2.1-1.2-2.4 1.9-3.2-.3-5.4-.1-4.5 1.1-2.1-5.5-10.3-3 1.1-2.6-.7-.2-9.7-4.4 3.8-4.9-.2-2.3-3.4-3.7-.3 1-2.8-3.3-3.8-2.6-5.8 1.5-1.1-.1-2.7 3.3-1.9-.7-3.4 1.3-2.2.4-3 6.2-4.3 4.6-1.2.7-1 5.1.3z');
    add('country-sr', 'Suriname', 'South America', '649.6 532.5 25.5 29.5',
      'M668 533.8l-4.6.5-.6 1.1-6.7-1.2-1 5.7-3.5 1.6.3 1.5-1.1 3.3 2.4 4.6 1.8.1.7 3.5 3.3 5.6 3.1.5.5-1.3-.9-1.3.5-1.8 2.3.6 2.7-.7 3.2 1.4 1.4-2.7.6-2.9 1-2.8-2.1-3.7-.4-4.4 3.1-5.5-6-1.7z');
    add('country-uy', 'Uruguay', 'South America', '663.8 762.2 30.0 33.9',
      'M692.5 787l-2.1-3.7 1.9-3-3.8-4.3-4.8-3.5-6.2-4.1-1.9.2-6.2-4.9-3.4.7-.5 5.1-.3 6.5 1.1 6.3-.9 1.4.4 4.2 3.9 3.5 3.6-.2 5.4 2.7 2.7-.6 4.2 1.2 5.3-3.5 1.6-4z');
    add('country-ve', 'Venezuela', 'South America', '562.5 491.2 83.3 80.1',
      'M642 518.9l-2.2-1.5-2.9.2-.7-5.1-4.1-3.2-4.4-.4-1.8-3 4.8-1.9-6.7.1-6.9.4-.2 1.6-3.2 1.9-4.2-.7-3.1-2.9-6 .7-5-.1-.1-2.1-3.5-3.5-3.9-.1-1.7-4.5-2.1 2 .6 3-7.1 2.6v4.8l1.6 2.2-1.5 4.6-2.4.4-1.9-5 2.7-3.7.3-3.3-1.7-2.9 3.3-.8.3-1.5-3.7 1.1-1.6 3.2-2.2 1.8-1.8 2.4-.9 4.5-1.8 3.7 2.9.5.6 2.9 1.1 1.4.4 2.5-.8 2.4.2 1.3 1.3.6 1.3 2.2 7.2-.6 3.2.8 3.8 5.5 2.3-.7 4 .3 3.2-.7 2 1.1-1.2 3.4-1.3 2.1-.5 4.6 1 4.2 1.5 1.9.2 1.5-2.9 3.1 2 1.4 1.4 2.2 1.7 6.4 3 3.4 4.4-.5 1.1-1.9 4.2-1.5 2.3-1 .7-2.7 4.1-1.8-.3-1.4-4.8-.5-.7-4 .3-4.3-2.4-1.6 1-.6 4.2.8 4.4 1.6 1.7-1.5 4-1 6.4-2.4 2.1-2.4-.7-1.8-3.7-4.8 1.6-1.8v-2.9l3.4-1.1 1.5-1.2-1.9-2.3.6-2.3 4.6-3.8z');

    // ===================== MIDDLE EAST (13) =====================
    add('country-ir', 'Iran', 'Middle East', '1200.0 314.4 127.3 102.8',
      'M1213.5 324.4l-3.2-2.9-1.2-2.4-3.3 1.8 2.9 7.3-.7 2 3.7 5.2 4.7 7.8 3.7 1.9 1 3.8-2.3 2.2-.5 5 4.6 6.1 7 3.4 3.5 4.9-.2 4.6h1.7l.5 3.3 3.4 3.4 1.7-2.5 3.7 2.1 2.8-1 5.1 8.4 4.3 6.1 5.5 1.8 6.1 4.9 6.9 2.1 5.1-3.1 4-1.1 2.8 1.1 3.2 7.8 6.3.8 6.1 1.5 10.5 1.9 1.2-7.4 7.4-3.3-.9-2.9-2.7-1-1-5.7-5.6-2.7-2.8-3.9-3.2-3.3 3.9-5.8-1.1-4-4.3-1.1-1.1-4-2.7-5.1 1.6-3.5-2.5-.9.5-4.7.5-8-1.6-5.5-3.9-.2-7.3-5.7-4.3-.7-6.5-3.3-3.8-.6-2.1 1.2-3.5-.2-3 3.7-4.4 1.2-.2 1.6-7.9 1.7-7.6-1.1-4.3-3.3-5.2-1.3-2.5-4.8-1.3.3-3.8-3.4 1.2-3.1-1.9-1.9-1.9.5-5.3 4.7-1.8.2-3.7-.9z');
    add('country-iq', 'Iraq', 'Middle East', '1180.7 331.4 60.8 58.3',
      'M1207.3 334.9l-6.2-.9-2.1 1-2.1 4.1-2.7 1.6 1.2 4.7-.9 7.8-11 6.7 3.1 7.7 6.7 1.7 8.5 4.5 16.7 12.7 10.2.5 3.2-6.1 3.7.5 3.2.4-3.4-3.4-.5-3.3h-1.7l.2-4.6-3.5-4.9-7-3.4-4.6-6.1.5-5 2.3-2.2-1-3.8-3.7-1.9-4.7-7.8-2.3 1.1-2.1-1.6z');
    add('country-il', 'Israel', 'Middle East', '1160.3 359.3 8.3 26.4',
      'M1167.8 360.5l-1.4.1-.4 1.1h-1.8l-.1.1-.6 1.6-.6 4.8-1.1 2.9.4.4-1.4 2.1 3.9 9.2.7 1.7 1.7-10.2-.4-2.4-2.4.8.1-1.7 1.2-.8-1.4-.7.7-4.3 2 .9.7-2h-.1l.6-1-.3-2.6z');
    add('country-jo', 'Jordan', 'Middle East', '1164.3 358.6 23.3 29.1',
      'M1186.6 367.6l-3.1-7.7-9.6 6.7-6.3-2.5-.7 2 .4 3.9-.6 1.9.4 2.4-1.7 10.2.3.9 6.1 1 2.1-2 1.1-2.3 4-.8.7-2.2 1.7-1-6.1-6.4 10.4-3.1.9-1z');
    add('country-kw', 'Kuwait', 'Middle East', '1228.2 380.4 11.4 10.8',
      'M1235.6 381.4l-3.7-.5-3.2 6.1 4.9.6 1.7 3.1 3.8-.2-2.4-4.8.3-1.5-1.4-2.8z');
    add('country-lb', 'Lebanon', 'Middle East', '1163.7 351.3 8.1 10.9',
      'M1167.8 360.5l.9-3.5 2.6-2.4-1.2-2.5-2.4-.3-.1.2-2.1 4.5-1.3 5.2h1.8l.4-1.1 1.4-.1z');
    add('country-om', 'Oman', 'Middle East', '1262.1 401.1 45.4 68.2',
      'M1301 437.8l2.1-2 .8-1.8 1.6-3.8-.1-1.4-2.1-.8-1.6-2.1-2.9-3.7-3.3-1.1-4.1-.9-3.3-2.3-2.9-4.3h-2.8l-.1 4.2 1.1.8-2.4 1.3.3 2.6-1.4 2.6.1 2.6 2.9 4.5-2.6 12.7-16.1 6.4 5.2 10.5 2.1 4.4 2.5-.3 3.6-2.2 3.1.6 2.5-1.8-.2-2.5 2.1-1.6h3.4l1.2-1.3.2-3.1 3.3-2.4h2.6l.4-.8-1-4.2.6-3.2 1-1.5 2.5.3 1.7-4.4zm-16.6-30.4l.2-2.6-.7-.6-1.3 2.2 1.3 2.2.5-1.2z');
    add('country-ps', 'Palestine', 'Middle East', '1163.7 364.7 4.1 8.5',
      'M1166.9 366.1l-2-.9-.7 4.3 1.4.7-1.2.8-.1 1.7 2.4-.8.6-1.9-.4-3.9z');
    add('country-qa', 'Qatar', 'Middle East', '1253.4 405.5 5.9 10.9',
      'M1258 415.5l.8-3.8-.5-3.7-1.9-2-1.4.7-1.1 3.3.8 4.7 1.8 1.2 1.5-.4z');
    add('country-sa', 'Saudi Arabia', 'Middle East', '1158.7 362.6 130.1 110.7',
      'M1228.7 387l-10.2-.5-16.7-12.7-8.5-4.5-6.7-1.7-.9 1-10.4 3.1 6.1 6.4-1.7 1-.7 2.2-4 .8-1.1 2.3-2.1 2-6.1-1-.5 2.5v2.2l-.6 3.5h2.7l3.2 4.4 3.7 5.1 2.5 4.7 1.7 1.5 1.7 3.3-.2 1.4 2.1 3.7 3 1.3 2.8 2.5 3.6 7v3.8l.9 4.4 4 6.1 2.5 1 4.1 4.4 1.9 5.2 3.2 5.3 3 2.3.6 2.5 1.8 1.9.9 2.8 2.3-2.1-.7-2.7 1.2-3.1 2.4 1.7 1.5-.6 6.4-.2 1 .7 5.4.6 2.1-.3 1.6 2.1 2.5-1 3.5-6.7 5-2.9 15.7-2.4 16.1-6.4 2.6-12.7-2.9-4.5-1 1.3-16.8-3.2-2.6-6.4-.4-1.5-1.2-2.4-1.5.4-1.8-1.2-1-1.6-.9-2.1-1.7-1.8-1-2.1.4-2.1-.6-2.7-4-2.6-1.2-2.3-2.9-1.4-2.7-5.5-3.8.2-1.7-3.1-4.9-.6z');
    add('country-sy', 'Syria', 'Middle East', '1165.0 333.4 35.6 34.8',
      'M1183.5 359.9l11-6.7.9-7.8-1.2-4.7 2.7-1.6 2.1-4.1-5.9 1.1-2.8-.2-5.7 2.5h-4.3l-3-1.2-5.5 1.8-1.9-1.3.1 3.6-1.2 1.5-1.2 1.4-1 2.6 1.1 5 2.4.3 1.2 2.5-2.6 2.4-.9 3.5.3 2.6-.6 1h.1l6.3 2.5 9.6-6.7z');
    add('country-ae', 'UAE', 'Middle East', '1257.9 405.3 28.6 24.9',
      'M1283.9 408.6l-1.3-2.2-3 3.9-3.7 4.1-3.3 4.3-3.3-.2-4.6-.2-4.2 1-.3-1.7-1 .3.4 1.5 2.6 6.4 16.8 3.2 1-1.3-.1-2.6 1.4-2.6-.3-2.6 2.4-1.3-1.1-.8.1-4.2h2.8l-1.3-5z');
    add('country-ye', 'Yemen', 'Middle East', '1210.8 449.3 63.6 44.9',
      'M1271.5 466.2l-2.1-4.4-5.2-10.5-15.7 2.4-5 2.9-3.5 6.7-2.5 1-1.6-2.1-2.1.3-5.4-.6-1-.7-6.4.2-1.5.6-2.4-1.7-1.2 3.1.7 2.7-2.3 2.1.4 2.7-.6 1.3.7 2.9-1.1.3 1.7 2.6 1.3 4.7 1 1.9v3.4l1.6 3.8 3.9.3 1.8-.9 2.7.2.8-1.7 1.5-.4 1.1-1.7 1.4-.4 4.7-.3 3.5-1.2 3.1-2.7 1.7.4 2.4-.3 4.7-4.5 8.8-3 5.3-2.7v-2.1l.9-2.9 3.9-1.7z');

    // ===================== AFRICA (54) =====================
    add('country-dz', 'Algeria', 'Africa', '923.8 330.0 124.3 126.6',
      'M1021 336.9l-3.6.4-2.2-1.5h-5.6l-4.9 2.6-2.7-1-8.7.5-8.9 1.2-5 2-3.4 2.6-5.7 1.2-5.1 3.5 2 4.1.3 3.9 1.8 6.7 1.4 1.4-1 2.5-7 1-2.5 2.4-3.1.5-.3 4.7-6.3 2.5-2.1 3.2-4.4 1.7-5.4 1-8.9 4.7-.1 7.5v.4l-.1 1.2 20.3 15.5 18.4 13.9 18.6 13.8 1.3 3 3.4 1.8 2.6 1.1.1 4 6.1-.6 7.8-2.8 15.8-12.5 18.6-12.2-2.5-4-4.3-2.9-2.6 1.2-2-3.6-.2-2.7-3.4-4.7 2.1-2.6-.5-4 .6-3.5-.5-2.9.9-5.2-.4-3-1.9-5.6-2.6-11.3-3.4-2.6v-1.5l-4.5-3.8-.6-4.8 3.2-3.6 1.1-5.3-1-6.2 1-3.3z');
    add('country-ao', 'Angola', 'Africa', '1037.8 596.1 76.8 94.4',
      'M1068.3 609.6l-16.6-.1-1.9.7-1.7-.1-2.3.9-.5 1.2 2.8 4 1.1 4.3 1.6 6.1-1.7 2.6-.3 1.3 1.3 3.8 1.5 3.9 1.6 2.2.3 3.6-.7 4.8-1.8 2.8-3.3 4.2-1.3 2.6-1.9 5.7-.3 2.7-2 5.9-.9 5.5.5 4 2.7-1.2 3.3-1 3.6.1 3.2 2.9.9-.4 22.5-.3 3.7 3 13.4.9 10.3-2.5-3.5-4-3.6-5.2.8-20.3 11.6.1-.5-2.2.9-2.4-.9-3 .7-3-.5-2-2.6-.4-3.5 1-2.4-.2-1.4.6.5-7.6-1.9-2.3-.3-4 .9-3.8-1.2-2.4v-4h-6.8l.5-2.3h-2.9l-.3 1.1-3.4.3-1.5 3.7-.9 1.6-3-.9-1.9.9-3.7.5-2.1-3.3-1.3-2.1-1.6-3.8-1.3-4.7zm-21.8-1.3l.2-2.7.9-1.7 2-1.3-2-2.2-1.8 1.1-2.2 2.7 1.4 4.8 1.5-.7z');
    add('country-bj', 'Benin', 'Africa', '980.2 492.4 18.6 42.7',
      'M996.9 498l-4.3-3.7h-2l-1.9 1.9-1.2 1.9-2.7.6-1.2 2.8-1.9.7-.7 3.3 1.7 1.9 2 2.3.2 3.1 1.1 1.3-.2 14.6 1.4 4.4 4.6-.8.3-10.2-.1-4.1 1-4 1.7-1.9 2.7-4-.6-1.7 1.1-2.5-1.2-3.8.2-2.1z');
    add('country-bw', 'Botswana', 'Africa', '1083.0 681.6 58.3 64.2',
      'M1116.7 685l-1-.5-3.2 1.5h-1.6l-3.7 2.5-2-2.6-8.6 2.2-4.1.2-.9 22.7-5.4.2-.6 18.5 1.4 1 3 6.1-.7 3.8 1.1 2.3 4-.7 2.8-2.8 2.7-1.9 1.5-3.1 2.7-1.5 2.3.8 2.5 1.8 4.4.3 3.6-1.5.6-2 1.2-3 3-.5 1.7-2.4 2-4.3 5.2-4.7 8-4.7-3.4-2.9-4.2-.9-1.5-4.1.1-2.2-2.3-.7-6-7-1.6-3.7-1.1-1.1-1.9-5.1z');
    add('country-bf', 'Burkina Faso', 'Africa', '944.0 474.3 47.0 38.5',
      'M978.8 477.2h-3.6l-1.4-1.2-3 .9-5.2 2.6-1.1 2-4.3 2.9-.8 1.6-2.3 1.3-2.7-.9-1.6 1.6-.8 4.4-4.5 5.2.2 2.2-1.6 2.7.4 3.7 2.5 1.4 1 2.1 2.5 1.3 1.9-1.6 2.7-.2 3.8 1.6-.8-4.8.2-3.6 9.7-.3 2.4.5 1.8-1 2.6.5 4.9.1 1.9-.7 1.2-2.8 2.7-.6 1.2-1.9.1-4.4-6.4-1.4-.2-3.1-3.1-4.1-.8-2.9.5-3.1z');
    add('country-bi', 'Burundi', 'Africa', '1139.2 586.4 10.7 14.8',
      'M1148.2 590l-.3-2.5-3-.4-1.7 3.6-3.5-.5 1.4 2.9.1 1.1 2 6.1-.1.3.6-.1 2.1-2.3 2.2-3.3 1.4-1.4v-2l-1.2-1.5z');
    add('country-cm', 'Cameroon', 'Africa', '1022.3 486.8 46.5 78.0',
      'M1060.1 502.9l.2-4.3-.5-4.2-2.2-4.1-1.6.4-.2 2 2.3 2.6-.6 1.1-.3 2.1-4.6 5-1.5 4-.7 3.3-1.2 1.4-1.1 4.5-3 2.6-.8 3.2-1.2 2.6-.5 2.6-3.9 2.2-3.2-2.6-2.1.1-3.3 3.7-1.6.1-2.7 6.1-1.4 4.5v1.8l1.4.9 1.1 2.8 2.6 1.1 2.2 4.2-.8 5 9.2.2 2.6-.4 3.4.8 3.4-.8.7.3 7.1.3 4.5 1.7 4.5 1.5.4-3.5-.6-1.8-.3-2.9-2.6-2.1-2.1-3.2-.5-2.3-2.6-3.3.4-1.9-.6-2.7.4-5 1.4-1.1 2.7-6.5.9-1.7-1.8-4.4-.8-2.6-2.5-1.1-3.3-3.7 1.2-3 2.5.6 1.6-.4 3.1.1-3.1-5.8z');
    add('country-cf', 'Central African Republic', 'Africa', '1054.2 498.5 79.7 62.0',
      'M1110.5 517.3l-.5-.3-2-1.8-.3-2 .8-2.6V508l-3.3-4-.7-2.7-3.5 1.1-2.8 2.5-4 7-5.2 2.9-5.4-.4-1.6.6.6 2.3-2.9 2.2-2.3 2.5-7.1 2.4-1.4-1.4-.9-.2-1 1.7-4.7.4-2.7 6.5-1.4 1.1-.4 5 .6 2.7-.4 1.9 2.6 3.3.5 2.3 2.1 3.2 2.6 2.1.3 2.9.6 1.8 2.9-5.9 3.3-3.4 3.8 1.1 3.6.4.5-4.5 2.2-3.2 3-2 4.6 2.1 3.6 2.4 4.1.6 4.2 1.2 1.6-3.8.8-.5 2.6.6 6.2-3.1 2.2 1.3 1.8-.2.9-1.5 2-.6 4.3.7 3.6.1 1.8-.6-.9-2.1-4.2-2.5-1.5-3.8-2.4-2.7-3.8-3.4-.1-2-3.1-2.6-3.8-2.5z');
    add('country-td', 'Chad', 'Africa', '1049.2 418.1 63.1 111.9',
      'M1108.4 447.6l-22.4-12.2-22.3-12.2-5.4 3.5 1.6 9.9 2 1.6.2 2.1 2.3 2.2-1.1 2.7-1.8 12.9-.2 8.3-6.9 6-2.3 8.4 2.4 2.3v4.1l3.6.2-.5 2.9 2.2 4.1.5 4.2-.2 4.3 3.1 5.8-3.1-.1-1.6.4-2.5-.6-1.2 3 3.3 3.7 2.5 1.1.8 2.6 1.8 4.4-.9 1.7 4.7-.4 1-1.7.9.2 1.4 1.4 7.1-2.4 2.3-2.5 2.9-2.2-.6-2.3 1.6-.6 5.4.4 5.2-2.9 4-7 2.8-2.5 3.5-1.1v-1.6l-2.1-1.8-.1-3.7-1.2-2.5-2 .4.5-2.4 1.4-2.6-.7-2.7 1.8-1.9-1.2-1.5 1.4-3.9 2.4-4.7 4.8.4-1.1-25.2z');
    add('country-cg', 'Congo', 'Africa', '1036.9 545.6 45.4 61.4',
      'M1080.3 549.9l-3.6-.4-3.8-1.1-3.3 3.4-2.9 5.9-.4 3.5-4.5-1.5-4.5-1.7-7.1-.3-.4 2.8 1.5 3.3 4.2-.5 1.4 1.2-2.4 7.4 2.7 3.8.6 4.9-.8 4.3-1.7 3-4.9-.3-3-3-.5 2.8-3.8.8-1.9 1.6 2.1 4.2-4.3 3.5 4.6 6.7 2.2-2.7 1.8-1.1 2 2.2 1.5.6 1.9-2.4 3.1.1.4 1.8 2 1.1 3.4-4 3.3-3.1 1.4-2-.2-5.3 2.5-6.2 2.6-3.2 3.7-3.1.6-2 .2-2.4.9-2.2-.3-3.6.7-5.6 1.1-4 1.6-3.4.3-3.8z');
    add('country-dj', 'Djibouti', 'Africa', '1208.9 490.8 10.1 12.3',
      'M1217.8 499.2l-2.5-1.7 3.1-1.5.1-2.7-1.4-1.9-1.6 1.5-2.4-.5-1.9 2.8-1.8 3 .5 1.7.2 2 3.1.1 1.3-.5 1.3 1.1 2-3.4z');
    add('country-cd', 'DR Congo', 'Africa', '1039.7 532.8 117.6 129.6',
      'M1124.9 539.4l-4.3-.7-2 .6-.9 1.5-1.8.2-2.2-1.3-6.2 3.1-2.6-.6-.8.5-1.6 3.8-4.2-1.2-4.1-.6-3.6-2.4-4.6-2.1-3 2-2.2 3.2-.5 4.5-.3 3.8-1.6 3.4-1.1 4-.7 5.6.3 3.6-.9 2.2-.2 2.4-.6 2-3.7 3.1-2.6 3.2-2.5 6.2.2 5.3-1.4 2-3.3 3.1-3.4 4-2-1.1-.4-1.8-3.1-.1-1.9 2.4-1.5-.6-2 1.3-.9 1.7-.2 2.7-1.5.7.8 2 2.3-.9 1.7.1 1.9-.7 16.6.1 1.3 4.7 1.6 3.8 1.3 2.1 2.1 3.3 3.7-.5 1.9-.9 3 .9.9-1.6 1.5-3.7 3.4-.3.3-1.1h2.9l-.5 2.3h6.8v4l1.2 2.4-.9 3.8.3 4 1.9 2.3-.5 7.6 1.4-.6 2.4.2 3.5-1 2.6.4 1.9.1.3 2 2.6-.1 3.5.6 1.8 2.8 4.5.9 3.4-2 1.2 3.4 4.3.8 2 2.8 2.1 3.5h4.3l-.3-6.9-1.5 1.2-3.9-2.5-1.4-1.1.8-6.4 1.2-7.5-1.2-2.8 1.6-4.1 1.6-.7 7.5-1.1 1 .3.2-1.1-1.5-1.7-.7-3.5-3.4-3.5-1.8-4.5 1-2.7-1.5-3.6 1.1-10.2.1.1-.1-1.1-1.4-2.9.6-3.5.8-.4.2-3.8 1.6-1.8.1-4.8 1.3-2.4.3-5.1 1.2-3 2.1-3.3 2.2-1.7 1.8-2.3-2.3-.8.3-7.5-5-4.2-1.4-2.7-3.1 1.3-2.6-.4-1.5 1.1-2.5-.8-3.5-5.2-1.8.6-3.6-.1z');
    add('country-eg', 'Egypt', 'Africa', '1106.4 368.2 76.6 67.1',
      'M1129.7 374.8l-5.5-1.9-5.3-1.7-7.1.2-1.8 3 1.1 2.7-1.2 3.9 2 5.1 1.3 22.7 1 23.4h65.3l-1-1.3-6.8-5.7-.4-4.2 1-1.1-5.3-7-2-3.6-2.3-3.5-4.8-9.9-3.9-6.4-2.8-6.7.5-.6 4.6 9.1 2.7 2.9 2 2 1.2-1.1 1.2-3.3.7-4.8 1.3-2.5-.7-1.7-3.9-9.2-2.5 1.6-4.2-.4-4.4-1.5-1.1 2.1-1.7-3.2-3.9-.8-4.7.6-2.1 1.8-3.9 2-2.6-1z');
    add('country-gq', 'Equatorial Guinea', 'Africa', '1028.4 557.1 12.2 9.1',
      'M1040.1 557.8l-9.2-.2-1.9 7.2 1 .9 1.9-.3h8.2v-7.6z');
    add('country-er', 'Eritrea', 'Africa', '1177.0 455.9 42.0 38.7',
      'M1198.1 474l-3.2-3.1-1.8-5.9-3.7-7.3-2.6 3.6-4 1-1.6 2-.4 4.2-1.9 9.4.7 2.5 6.5 1.3 1.5-4.7 3.5 2.9 3.2-1.5 1.4 1.3 3.9.1 4.9 2.5 1.6 2.2 2.5 2.1 2.5 3.7 2 2.1 2.4.5 1.6-1.5-2.8-1.9-1.9-2.2-3.2-3.7-3.2-3.6-7.9-6z');
    add('country-sz', 'Eswatini', 'Africa', '1143.3 734.9 8.6 11.4',
      'M1150.5 736.6l-2.7-1.2-1.6.5-.7 1.8-1.6 2.4-.1 2.2 3 3.5 3.3-.7 1.3-2.8-.3-2.8-.6-2.9z');
    add('country-et', 'Ethiopia', 'Africa', '1157.2 473.3 91.4 80.7',
      'M1187.6 477l-1.5 4.7-6.5-1.3-.7 5.5-2.1 6.2-3.2 3.2-2.3 4.8-.5 2.6-2.6 1.8-1.4 6.7v.7l.2 5-.8 2-3 .1-1.8 3.6 3.4.5 2.9 3.1 1 2.5 2.6 1.5 3.5 6.9 2.9 1.1v3.6l2 2.1h3.9l7.2 5.4h1.8l1.3-.1 1.2.7 3.8.5 1.6-2.7 5.1-2.6 2.3 2.1h3.8l1.5-2 3.6-.1 4.9-4.5 7.4-.3 15.4-19.1-4.8.1-18.5-7.6-2.2-2.2-2.1-3.1-2.2-3.5 1.1-2.3-1.3-1.1-1.3.5-3.1-.1-.2-2-.5-1.7 1.8-3 1.9-2.8-2-2.1-2.5-3.7-2.5-2.1-1.6-2.2-4.9-2.5-3.9-.1-1.4-1.3-3.2 1.5-3.5-2.9z');
    add('country-ga', 'Gabon', 'Africa', '1024.5 555.4 34.9 44.1',
      'M1050.2 557.7l-.7-.3-3.4.8-3.4-.8-2.6.4v7.6h-8.2l-1.9.3-1.1 4.8-1.3 4.6-1.3 2-.2 2.1 3.4 6.6 3.7 5.3 5.8 6.4 4.3-3.5-2.1-4.2 1.9-1.6 3.8-.8.5-2.8 3 3 4.9.3 1.7-3 .8-4.3-.6-4.9-2.7-3.8 2.4-7.4-1.4-1.2-4.2.5-1.5-3.3.4-2.8z');
    add('country-gm', 'Gambia', 'Africa', '882.0 483.4 18.4 5.7',
      'M882.8 488.5l5 .1 1.4-.9h1l2.1-1.5 2.4 1.4 2.4.1 2.4-1.5-1.1-1.8-1.8 1.1-1.8-.1-2.1-1.5-1.8.1-1.3 1.5-6.1.2-.7 2.8z');
    add('country-gh', 'Ghana', 'Africa', '957.3 499.6 26.5 44.7',
      'M976.8 502.1l-2.6-.5-1.8 1-2.4-.5-9.7.3-.2 3.6.8 4.8 1.4 9.1-2.3 5.3-1.5 7.2 2.4 5.5-.2 2.5 5 1.8 5-1.9 3.2-2.1 8.7-3.8-1.2-2.2-1.5-4-.4-3.2 1.2-5.7-1.4-2.3-.6-5.1.1-4.6-2.4-3.3.4-1.9z');
    add('country-gn', 'Guinea', 'Africa', '890.1 490.4 44.8 37.0',
      'M912.4 493l-.8.4-3-.5-.4.7-1.3.1-4-1.5-2.7-.1-.1 2.1-.6.7.4 2.1-.8.9h-1.3l-1.4 1-1.7-.1-2.6 3.1 1.6 1.1.8 1.4.7 2.8 1.3 1.2 1.5.9 2.1 2.5 2.4 3.7 3-2.8.7-1.7 1-1.4 1.5-.2 1.3-1.2h4.5l1.5 2.3 1.2 2.7-.2 1.8.9 1.7v2.3l1.5-.3 1.2-.2 1.5-.7 2.3 3.9-.4 2.6 1.1 1.3 1.6.1 1.1-2.6 1.6.2h.9l.3-2.8-.4-1.2.6-.9 2-.8-1.3-5.1-1.3-2.6.5-2.2 1.1-.5-1.7-1.8.3-1.9-.7-.7-1.2.6.2-2.1 1.2-1.6-2.3-2.7-.6-1.7-1.3-1.4-1.1-.2-1.3.9-1.8.8-1.6 1.4-2.4-.5-1.5-1.6-.9-.2-1.5.8h-.9l-.3-2.3z');
    add('country-gw', 'Guinea-Bissau', 'Africa', '882.8 491.3 18.3 11.1',
      'M900.2 492.1l-10.3-.3-1.5.7-1.8-.2-3 1.1.3 1.3 1.7 1.4v.9l1.2 1.8 2.4.5 2.9 2.6 2.6-3.1 1.7.1 1.4-1h1.3l.8-.9-.4-2.1.6-.7.1-2.1z');
    add('country-ci', 'Ivory Coast', 'Africa', '926.8 503.2 37.2 43.3',
      'M946.5 506.2l-2.3.9-1.3.8-.9-2.7-1.6.7-1-.1-1 1.9-4.3-.1-1.6-1-.7.6-1.1.5-.5 2.2 1.3 2.6 1.3 5.1-2 .8-.6.9.4 1.2-.3 2.8h-.9l-.3 1.8.6 3.1-1.2 2.8 1.6 1.8 1.8.4 2.3 2.7.2 2.5-.5.8-.5 5.2 1.1.2 5.6-2.4 3.9-1.8 6.6-1.1 3.6-.1 3.9 1.3 2.6-.1.2-2.5-2.4-5.5 1.5-7.2 2.3-5.3-1.4-9.1-3.8-1.6-2.7.2-1.9 1.6-2.5-1.3-1-2.1-2.5-1.4z');
    add('country-ke', 'Kenya', 'Africa', '1165.0 533.9 49.0 71.3',
      'M1211.7 547.2h-3.8l-2.3-2.1-5.1 2.6-1.6 2.7-3.8-.5-1.2-.7-1.3.1h-1.8l-7.2-5.4h-3.9l-2-2.1v-3.6l-2.9-1.1-3.8 4.2-3.4 3.8 2.7 4.4.7 3.2 2.6 7.3-2.1 4.7-2.7 4.2-1.6 2.6v.3l1.4 2.4-.4 4.7 20.2 13 .4 3.7 8 6.3 2.2-2.1 1.2-4.2 1.8-2.6.9-4.5 2.1-.4 1.4-2.7 4-2.5-3.3-5.3-.2-23.2 4.8-7.2z');
    add('country-ls', 'Lesotho', 'Africa', '1121.8 753.8 14.2 14.0',
      'M1128.1 766.5l1.1-2 3.1-1 1.1-2.1 1.9-3.1-1.7-1.9-2.3-2-2.6 1.3-3.1 2.5-3.2 4 3.7 4.9 2-.6z');
    add('country-lr', 'Liberia', 'Africa', '911.5 516.5 24.0 29.4',
      'M929.4 523.3l-1.6-.2-1.1 2.6-1.6-.1-1.1-1.3.4-2.6-2.3-3.9-1.5.7-1.2.2-2.6 3-2.6 3.4-.3 1.9-1.3 2 3.7 4.1 4.8 3.5 5.1 4.8 5.7 3.1 1.5-.1.5-5.2.5-.8-.2-2.5-2.3-2.7-1.8-.4-1.6-1.8 1.2-2.8-.6-3.1.3-1.8z');
    add('country-ly', 'Libya', 'Africa', '1023.1 357.1 95.9 94.8',
      'M1111.8 371.4l-1.5-2.1-5.4-.8-1.8-1.1h-2l-2-2.8-7.3-1.3-3.6.8-3.7 3-1.5 3.1 1.5 4.8-2.4 3-2.5 1.6-5.9-3.1-7.7-2.7-4.9-1.2-2.8-5.7-7.2-2.8-4.5-1.1-2.2.6-6.4-2.2-.1 4.9-2.6 1.8-1.5 2-3.7 2.5.7 2.6-.4 2.7-2.6 1.4 1.9 5.6.4 3-.9 5.2.5 2.9-.6 3.5.5 4-2.1 2.6 3.4 4.7.2 2.7 2 3.6 2.6-1.2 4.3 2.9 2.5 4 8.8 2.8 3.1 3.5 3.9-2.4 5.4-3.5 22.3 12.2 22.4 12.2v-2.7h6.3l-.5-12.7-1-23.4-1.3-22.7-2-5.1 1.2-3.9-1.1-2.7 1.8-3z');
    add('country-mg', 'Madagascar', 'Africa', '1212.5 644.5 47.2 94.9',
      'M1255.7 658.4l-1.1-4.2-1.4-2.7-1.8-2.7-2 2.8-.3 3.8-3.3 4.5-2.3-.8.6 2.7-1.8 3.2-4.8 3.9-3.4 3.7h-2.4l-2.2 1.2-3.1 1.3-2.8.2-1 4.1-2.2 3.5.1 5.9.8 4 1.1 3-.8 4.1-2.9 4.8-.2 2.1-2.6 1.1-1.3 4.6.2 4.6 1.6 5-.1 5.7 1.2 3.3 4.2 2.3 3 1.7 5-2.7 4.6-1.5 3.1-7.4 2.8-8.9 4.3-12 3.3-8.8 2.7-7.4.8-5.4 1.6-1.5.7-2.7-.8-4.7 1.2-1.9 1.6 3.8 1.1-1.9.8-3.1-1.3-2.9-.5-7.7z');
    add('country-mw', 'Malawi', 'Africa', '1158.1 628.5 18.3 53.0',
      'M1169.2 661.5l.1-2.3-1.2-1.9.1-2.8-1.5-4.7 1.7-3.5-.1-7.7-1.9-4.1.2-.7-1.1-1.7-5.4-1.2 2.6 2.8 1.2 5.4-1 1.8-1.2 5.1.9 5.3-1.8 2.2-1.9 5.9 2.9 1.7 3 3 1.6-.6 2.1 1.6.3 2.6-1.3 2.9.2 4.5 3.4 4 1.9-4.5 2.5-1.3-.1-8.2-2.2-4.6-1.9-2h-.3v.8l1.1.3 1 3.4-.2.8-1.9-2.5-1 1.6-.8-1.4z');
    add('country-ml', 'Mali', 'Africa', '904.3 408.6 100.6 104.1',
      'M1000.3 450.3l-6.1.6-.1-4-2.6-1.1-3.4-1.8-1.3-3-18.6-13.8-18.4-13.9-8.4.1 2.4 27.4 2.4 27.5 1 .8-1.3 4.4-22.3.1-.9 1.4-2.1-.4-3.2 1.3-3.8-1.8-1.8.2-1 3.7-1.9 1.2.2 3.9 1.1 3.7 2.1 1.8.4 2.4-.3 2 .3 2.3h.9l1.5-.8.9.2 1.5 1.6 2.4.5 1.6-1.4 1.8-.8 1.3-.9 1.1.2 1.3 1.4.6 1.7 2.3 2.7-1.2 1.6-.2 2.1 1.2-.6.7.7-.3 1.9 1.7 1.8.7-.6 1.6 1 4.3.1 1-1.9 1 .1 1.6-.7.9 2.7 1.3-.8 2.3-.9-.4-3.7 1.6-2.7-.2-2.2 4.5-5.2.8-4.4 1.6-1.6 2.7.9 2.3-1.3.8-1.6 4.3-2.9 1.1-2 5.2-2.6 3-.9 1.4 1.2h3.6l3.6-.3 2-2.2 7.6-.6 4.9-1 .5-3.9 3-4.3-.1-14.6z');
    add('country-mr', 'Mauritania', 'Africa', '879.3 393.7 73.8 89.5',
      'M949.8 413.3l-20.3-15.5-.2 9.7-17.9-.3-.2 16.3-5.2.5-1.4 3.3.9 9.2-21.6-.1-1.2 2.2 2.8 2.7 1.4 3-.7 3.2.6 3.2.5 6.3-.8 5.9-1.7 3.2.4 3.4 2-2 2.7.5 2.8-1.4h3.1l2.6 1.8 3.7 1.7 3.2 4.7 3.6 4.4 1.9-1.2 1-3.7 1.8-.2 3.8 1.8 3.2-1.3 2.1.4.9-1.4 22.3-.1 1.3-4.4-1-.8-2.4-27.5-2.4-27.4 8.4-.1z');
    add('country-mu', 'Mauritius', 'Africa', '1292.4 698.8 3.7 4.4',
      'M1294.7 702.5l.3-.3.2-.4.3-.3.1-.7-.2-.8-.4-.7-.5.1-.3.4-.2.5-.5.3-.1.3-.2.7-.1.4-.2.1v.2l.3.3.8.1.7-.2z');
    add('country-yt', 'Mayotte', 'Africa', '1227.5 652.2 2.0 3.1',
      'M1228.7 654.7v-.3l.2-.5v-.1l.1-.5-.3-.3h-.2l-.2-.3-.3.3.3.5-.1.3-.1.4.1.4.2.2.3-.1z');
    add('country-ma', 'Morocco', 'Africa', '878.6 340.0 96.5 100.4',
      'M965.2 348.4l-2.3-.1-5.5-1.4-5 .4-3.1-2.7h-3.9l-1.8 3.9-3.7 6.7-4 2.6-5.4 2.9-3.5 4.3-.9 3.4-2.1 5.4 1.1 7.9-4.7 5.3-2.7 1.7-4.4 4.4-5.1.7-2.8 2.4-.1.1-3.6 6.5-3.7 2.3-2.1 4-.2 3.3-1.6 3.8-1.9 1-3.1 4-2 4.5.3 2.2-1.9 3.3-2.2 1.7-.3 3h.1l12.4-.5.7-2.3 2.3-2.9 2-8.8 7.8-6.8 2.8-8.1 1.7-.4 1.9-5 4.6-.7 1.9.9h2.5l1.8-1.5 3.4-.2-.1-3.4h.8l.1-7.5 8.9-4.7 5.4-1 4.4-1.7 2.1-3.2 6.3-2.5.3-4.7 3.1-.5 2.5-2.4 7-1 1-2.5-1.4-1.4-1.8-6.7-.3-3.9-2-4.1z');
    add('country-mz', 'Mozambique', 'Africa', '1141.8 632.6 64.9 115.0',
      'M1203 640.7l-.8-2.9-4.6 3.7-6.2 2.5-3.3-.1-2.1 1.9-3.9.1-1.4.8-6.7-1.8-2.1.3-1.6 6 .7 7.3h.3l1.9 2 2.2 4.6.1 8.2-2.5 1.3-1.9 4.5-3.4-4-.2-4.5 1.3-2.9-.3-2.6-2.1-1.6-1.6.6-3-3-17.1 5.2.3 4.5.3 2.4 4.6-.1 2.6 1.3 1.1 1.6 2.6.5 2.8 2-.3 8.1-1.3 4.4-.5 4.7.8 1.9-.8 3.7-.9.6-1.6 4.6-6.2 7.2 2.2 9 1.1 4.5-1.4 7.1.4 2.3.6 2.9.3 2.8h4.1l.7-3.3-1.4-.5-.3-2.6 2.6-2.4 6.8-3.4 4.6-2.2 2.5-2.3.9-2.6-1.2-1.1 1.1-3 .5-6.2-1 .3v-1.9l-.8-3.7-2.4-4.8.7-4.6 2.3-1.4 4.1-4.6 2.2-1.1 6.7-6.8 6.4-3.1 5.2-2.5 3.7-3.9 2.4-4.4 1.9-4.6-.9-3.1.2-9.9-.4-5.6.4-6.3z');
    add('country-na', 'Namibia', 'Africa', '1038.1 676.1 81.3 84.7',
      'M1105.4 683.7l-10.3 2.5-13.4-.9-3.7-3-22.5.3-.9.4-3.2-2.9-3.6-.1-3.3 1-2.7 1.2.2 4.9 4.4 6.2 1.1 4 2.8 7.7 2.7 5.2 2.1 2.6.6 3.5v7.6l1.6 9.8 1.2 4.6 1 6.2 1.9 4.7 3.9 4.8 2.7-3.2 2.1 1.8.8 2.7 2.4.5 3.3 1.2 2.9-.5 5-3.2 1.1-23.6.6-18.5 5.4-.2.9-22.7 4.1-.2 8.6-2.2 2 2.6 3.7-2.5h1.6l3.2-1.5v-.5l-2.1-1.4-3.6-.4-4.6 1.5z');
    add('country-ne', 'Niger', 'Africa', '974.0 419.0 94.7 82.7',
      'M1051.3 425.6l-8.8-2.8-18.6 12.2-15.8 12.5-7.8 2.8.1 14.6-3 4.3-.5 3.9-4.9 1-7.6.6-2 2.2-3.6.3-.5 3.1.8 2.9 3.1 4.1.2 3.1 6.4 1.4-.1 4.4 1.9-1.9h2l4.3 3.7.3-5.7 1.6-2.6.8-3.6 1.4-1.4 6-.8 5.6 2.4 2.1 2.4 2.9.1 2.6-1.5 6.8 3.3 2.8-.2 3.3-2.7 3.3.2 1.6-.9 3 .4 4.3 1.8 4.3-3.5 1.3.2 3.9 7 1-.2.2-2 1.6-.4.5-2.9-3.6-.2v-4.1l-2.4-2.3 2.3-8.4 6.9-6 .2-8.3 1.8-12.9 1.1-2.7-2.3-2.2-.2-2.1-2-1.6-1.6-9.9-3.9 2.4-3.1-3.5z');
    add('country-ng', 'Nigeria', 'Africa', '988.5 480.8 72.9 67.4',
      'M1055.8 492.7l-1 .2-3.9-7-1.3-.2-4.3 3.5-4.3-1.8-3-.4-1.6.9-3.3-.2-3.3 2.7-2.8.2-6.8-3.3-2.6 1.5-2.9-.1-2.1-2.4-5.6-2.4-6 .8-1.4 1.4-.8 3.6-1.6 2.6-.3 5.7-.2 2.1 1.2 3.8-1.1 2.5.6 1.7-2.7 4-1.7 1.9-1 4 .1 4.1-.3 10.2h9.2l3.9 4.2 1.9 4.6 3 3.9 4.5.2 2.2-1.4 2.1.3 5.8-2.3 1.4-4.5 2.7-6.1 1.6-.1 3.3-3.7 2.1-.1 3.2 2.6 3.9-2.2.5-2.6 1.2-2.6.8-3.2 3-2.6 1.1-4.5 1.2-1.4.7-3.3 1.5-4 4.6-5 .3-2.1.6-1.1-2.3-2.6z');
    add('country-re', 'Reunion', 'Africa', '1280.5 704.4 4.3 4.2',
      'M1284 707.9l.2-.4.1-.8-.4-.8-.4-.7-.4-.2-.8-.1-.7.3-.4.6-.2.3.4 1.1.2.3 1.1.6h.5l.8-.2z');
    add('country-rw', 'Rwanda', 'Africa', '1139.2 578.8 11.2 12.4',
      'M1147.6 579.4l-3.3 1.9-1.4-.6-1.6 1.8-.2 3.8-.8.4-.6 3.5 3.5.5 1.7-3.6 3 .4 1.6-.8.4-3.7-2.3-3.6z');
    add('country-sn', 'Senegal', 'Africa', '876.9 465.2 37.5 29.8',
      'M908.9 479.2l-3.6-4.4-3.2-4.7-3.7-1.7-2.6-1.8h-3.1l-2.8 1.4-2.7-.5-2 2-1.3 3.3-2.8 4.4-2.5 1.2 2.7 2.3 2.2 5 6.1-.2 1.3-1.5 1.8-.1 2.1 1.5 1.8.1 1.8-1.1 1.1 1.8-2.4 1.5-2.4-.1-2.4-1.4-2.1 1.5h-1l-1.4.9-5-.1.8 4.9 3-1.1 1.8.2 1.5-.7 10.3.3 2.7.1 4 1.5 1.3-.1.4-.7 3 .5.8-.4.3-2-.4-2.4-2.1-1.8-1.1-3.7-.2-3.9z');
    add('country-sc', 'Seychelles', 'Africa', '1287.1 600.7 1.9 2.4',
      'M1288.5 602l-.5-.8-.4.3.2.3.3.2.1.4.3.2v-.6z');
    add('country-sl', 'Sierra Leone', 'Africa', '901.7 507.2 18.6 22.9',
      'M919.4 518.7l-1.5.3v-2.3l-.9-1.7.2-1.8-1.2-2.7-1.5-2.3H910l-1.3 1.2-1.5.2-1 1.4-.7 1.7-3 2.8.7 4.7.9 2.3 2.9 3.5 4.1 2.5 1.5.5 1.3-2 .3-1.9 2.6-3.4 2.6-3z');
    add('country-so', 'Somalia', 'Africa', '1204.1 491.3 60.9 95.9',
      'M1223.4 505.7l-2.6-2.7-1.2-2.6-1.8-1.2-2 3.4-1.1 2.3 2.2 3.5 2.1 3.1 2.2 2.2 18.5 7.6 4.8-.1-15.4 19.1-7.4.3-4.9 4.5-3.6.1-1.5 2-4.8 7.2.2 23.2 3.3 5.3 1.3-1.5 1.3-3.4 6.1-7.7 5.3-4.8 8.3-6.4 5.6-5.1 6.4-8.7 4.7-7.1 4.6-9.3 3.2-8.2 2.5-7.1 1.3-6.8 1.1-2.3-.2-3.4.4-3.7-.2-1.7h-2.1l-2.6 2.2-2.9.6-2.5.9-1.8.2-3.2.2-1.9 1.1-2.8.5-4.8 1.9-6.1.8-5.2 1.6h-2.8z');
    add('country-za', 'South Africa', 'Africa', '1060.8 708.6 99.2 89.1',
      'M1148.2 713.7l-2.9-.6-1.9.8-2.6-1.1-2.2-.1-8 4.7-5.2 4.7-2 4.3-1.7 2.4-3 .5-1.2 3-.6 2-3.6 1.5-4.4-.3-2.5-1.8-2.3-.8-2.7 1.5-1.5 3.1-2.7 1.9-2.8 2.8-4 .7-1.1-2.3.7-3.8-3-6.1-1.4-1-1.1 23.6-5 3.2-2.9.5-3.3-1.2-2.4-.5-.8-2.7-2.1-1.8-2.7 3.2 3.5 8.2v.1l2.5 5.3 3.2 6-.2 4.8-1.7 1.2 1.4 4.2-.2 3.8.6 1.7.3-.9 2.1 2.9 1.8.1 2.1 2.3 2.4-.2 3.5-2.4 4.6-1 5.6-2.5 2.2.3 3.3-.8 5.7 1.2 2.7-1.2 3.2 1 .8-1.8 2.7-.3 5.8-2.5 4.3-2.9 4.1-3.8 6.7-6.5 3.4-4.6 1.8-3.2 2.5-3.3 1.2-.9 3.9-3.2 1.6-2.9 1.1-5.2 1.7-4.7h-4.1l-1.3 2.8-3.3.7-3-3.5.1-2.2 1.6-2.4.7-1.8 1.6-.5 2.7 1.2-.4-2.3 1.4-7.1-1.1-4.5-2.2-9zm-20.1 52.8l-2 .6-3.7-4.9 3.2-4 3.1-2.5 2.6-1.3 2.3 2 1.7 1.9-1.9 3.1-1.1 2.1-3.1 1-1.1 2z');
    add('country-ss', 'South Sudan', 'Africa', '1107.3 491.4 70.7 61.2',
      'M1166 508.7l-.7-2.2-2.9-2.5-.8-4.6.5-4.7-2.6-.5-.3 1.5-3.4.3 1.4 1.8.6 3.9-3 3.5-2.7 4.5-2.8.7-4.8-3.7-2.1 1.3-.5 1.9-2.9 1.2-.2 1.3h-5.5l-.8-1.3-4.1-.3-2 1.1-1.5-.5-3-3.7-1-1.8-4 .9-1.5 2.9-1.3 5.7-1.9 1.2-1.7.7 3.8 2.5 3.1 2.6.1 2 3.8 3.4 2.4 2.7 1.5 3.8 4.2 2.5.9 2.1 3.5 5.2 2.5.8 1.5-1.1 2.6.4 3.1-1.3 1.4 2.7 5 4.2 2.3-1.7 3.5 1.4 4.5-1.5 4 .1 3.4-3 3.4-3.8 3.8-4.2-3.5-6.9-2.6-1.5-1-2.5-2.9-3.1-3.4-.5 1.8-3.6 3-.1.8-2-.2-5-.8-.1v-3.1z');
    add('country-sd', 'Sudan', 'Africa', '1094.6 427.9 99.3 93.6',
      'M1180.8 468.5l.4-4.2 1.6-2 4-1 2.6-3.6-3.1-2.4-2.2-1.6-2.5-7.6-1.1-6.5 1.1-1.2-2.1-6.2H1114.2l.5 12.7h-6.3v2.7l1.1 25.2-4.8-.4-2.4 4.7-1.4 3.9 1.2 1.5-1.8 1.9.7 2.7-1.4 2.6-.5 2.4 2-.4 1.2 2.5.1 3.7 2.1 1.8v1.6l.7 2.7 3.3 4v2.6l-.8 2.6.3 2 2 1.8.5.3 1.7-.7 1.9-1.2 1.3-5.7 1.5-2.9 4-.9 1 1.8 3 3.7 1.5.5 2-1.1 4.1.3.8 1.3h5.5l.2-1.3 2.9-1.2.5-1.9 2.1-1.3 4.8 3.7 2.8-.7 2.7-4.5 3-3.5-.6-3.9-1.4-1.8 3.4-.3.3-1.5 2.6.5-.5 4.7.8 4.6 2.9 2.5.7 2.2v3.1l.8.1v-.7l1.4-6.7 2.6-1.8.5-2.6 2.3-4.8 3.2-3.2 2.1-6.2.7-5.5-.7-2.5 1.9-9.4z');
    add('country-tz', 'Tanzania', 'Africa', '1139.8 575.2 65.3 74.9',
      'M1149.6 578.6l-2 .8 2.3 3.6-.4 3.7-1.6.8.3 2.5 1.2 1.5v2l-1.4 1.4-2.2 3.3-2.1 2.3-.6.1-.3 2.7 1.1.9-.2 2.7 1 2.6-1.3 2.4 4.5 4.3.3 3.9 2.7 6.5.3.2 2.2 1.1 3.5 1.1 3.2 1.9 5.4 1.2 1.1 1.7.4-1.2 2.8 3.4.3 6.7 1.8 2.4v.1l2.1-.3 6.7 1.8 1.4-.8 3.9-.1 2.1-1.9 3.3.1 6.2-2.5 4.6-3.7-2-1.4-2.2-6.3-1.8-3.9.4-3.1-.3-1.9 1.7-3.9-.2-1.6-3.5-2.3-.3-3.6 2.8-7.9-8-6.3-.4-3.7-20.2-13-2.8 2.8-1.9 2.9 2.2 2.2-3.2 1.6-.7-.8-3.2.4-2.5 1.4-1.6-2.4 1.1-4.5.2-3.8-6.2-.1z');
    add('country-tg', 'Togo', 'Africa', '975.9 500.5 11.9 35.5',
      'M981.7 502.2l-4.9-.1-.4 1.9 2.4 3.3-.1 4.6.6 5.1 1.4 2.3-1.2 5.7.4 3.2 1.5 4 1.2 2.2 4.6-1.3-1.4-4.4.2-14.6-1.1-1.3-.2-3.1-2-2.3-1.7-1.9.7-3.3z');
    add('country-tn', 'Tunisia', 'Africa', '1015.6 332.0 23.4 49.5',
      'M1038 361.4l-2-1-1.5-3-2.8-.1-1.1-3.5 3.4-3.2.5-5.6-1.9-1.6-.1-3 2.5-3.2-.4-1.3-4.4 2.4.1-3.3-3.7-.7-5.6 2.6-1 3.3 1 6.2-1.1 5.3-3.2 3.6.6 4.8 4.5 3.8v1.5l3.4 2.6 2.6 11.3 2.6-1.4.4-2.7-.7-2.6 3.7-2.5 1.5-2 2.6-1.8.1-4.9z');
    add('country-ug', 'Uganda', 'Africa', '1141.4 543.3 33.8 39.8',
      'M1167.6 545.1l-3.4 3-4-.1-4.5 1.5-3.5-1.4-2.3 1.7-.3 7.5 2.3.8-1.8 2.3-2.2 1.7-2.1 3.3-1.2 3-.3 5.1-1.3 2.4-.1 4.8 1.4.6 3.3-1.9 2-.8 6.2.1-.3-2.5 2.6-3.7 3.5-.9 2.4-1.5 2.9 1.2.3.5v-.3l1.6-2.6 2.7-4.2 2.1-4.7-2.6-7.3-.7-3.2-2.7-4.4z');
    add('country-eh', 'Western Sahara', 'Africa', '880.4 394.1 51.6 46.6',
      'M929.6 396.2h-.8l.1 3.4-3.4.2-1.8 1.5h-2.5l-1.9-.9-4.6.7-1.9 5-1.7.4-2.8 8.1-7.8 6.8-2 8.8-2.3 2.9-.7 2.3-12.4.5h-.1l-.3 2.7 1.2-2.2 21.6.1-.9-9.2 1.4-3.3 5.2-.5.2-16.3 17.9.3.2-9.7.1-1.2v-.4z');
    add('country-zm', 'Zambia', 'Africa', '1095.0 621.5 72.2 68.0',
      'M1149.2 626.7l-1.9-.5.4-1.3-1-.3-7.5 1.1-1.6.7-1.6 4.1 1.2 2.8-1.2 7.5-.8 6.4 1.4 1.1 3.9 2.5 1.5-1.2.3 6.9h-4.3l-2.1-3.5-2-2.8-4.3-.8-1.2-3.4-3.4 2-4.5-.9-1.8-2.8-3.5-.6-2.6.1-.3-2-1.9-.1.5 2-.7 3 .9 3-.9 2.4.5 2.2-11.6-.1-.8 20.3 3.6 5.2 3.5 4 4.6-1.5 3.6.4 2.1 1.4v.5l1 .5 6.2.7 1.7.7 1.9-.1 3.2-4.1 5.1-5.3 2-.5.7-2.2 3.3-2.5 4.2-.9-.3-4.5 17.1-5.2-2.9-1.7 1.9-5.9 1.8-2.2-.9-5.3 1.2-5.1 1-1.8-1.2-5.4-2.6-2.8-3.2-1.9-3.5-1.1-2.2-1.1-.3-.2.5 1.1-1 .4-1.2-1.4z');
    add('country-zw', 'Zimbabwe', 'Africa', '1114.6 668.6 46.5 47.4',
      'M1148.2 713.7l6.2-7.2 1.6-4.6.9-.6.8-3.7-.8-1.9.5-4.7 1.3-4.4.3-8.1-2.8-2-2.6-.5-1.1-1.6-2.6-1.3-4.6.1-.3-2.4-4.2.9-3.3 2.5-.7 2.2-2 .5-5.1 5.3-3.2 4.1-1.9.1-1.7-.7-6.2-.7 1.9 5.1 1.1 1.1 1.6 3.7 6 7 2.3.7-.1 2.2 1.5 4.1 4.2.9 3.4 2.9 2.2.1 2.6 1.1 1.9-.8 2.9.6z');

    // ===================== EAST ASIA (7) =====================
    add('country-cn', 'China', 'East Asia', '1344.9 223.0 315.9 244.5',
      'M1587.2 453.3l.6-3.6 2-2.8-1.6-2.5-3.2-.1-5.8 1.8-2.2 2.8 1 5.5 4.9 2 4.3-3.1zm13.2-196.5l-6.1-6.1-4.4-3.7-3.8-2.7-7.7-6.1-5.9-2.3-8.5-1.8-6.2.2-5.1 1.1-1.7 3 3.7 1.5 2.5 3.3-1.2 2 .1 6.5 1.9 2.7-4.4 3.9-7.3-2.3.6 4.6.3 6.2 2.7 2.6 2.4-.8 5.4 1 2.5-2.3 5.1 2 7.2 4.3.7 2.2-4.3-.7-6.8.8-2.4 1.8-1.4 4.1-6.3 2.4-3.1 3.3-5.9-1.3-3.2-.5-.4 4 2.9 2.3 1.9 2.1-2.5 2-1.9 3.3-4.9 2.2-7.5.2-7.2 2.2-4.4 3.3-3.2-2-6.2.1-9.3-3.8-5.5-.9-6.4.8-11.2-1.3-5.5.1-4.7-3.6-4.9-5.7-3.4-.7-7.9-3.8-7.2-.9-6.4-1-3-2.7-1.3-7.3-5.8-5-8.1-2.3-5.7-3.3-3.3-4.4-1.7.5-1.8 4.2-3.8.6 2.5 6.2-1.6 2.8-10.7-2 1 11.1-2 1.4-9 2.4 8.7 10.7-2.9 1.6 1.7 3.5-.2 1.4-6.8 3.4-1 2.4-6.4.8-.6 4-5.7-.9-3.2 1.2-4 3 1.1 1.5-1 1.5 3 5.9 1.6-.6 3.5 1.4.6 2.5 1.8 3.7 1.4 1.9 4.7 3 2.9 5 9.4 2.6 7.6 7.5.8 5.2 3 3.3.6 3.3-4.1-.9 3.2 7 6.2 4 8.5 4.4 1.9-1.5 4.7 2 6.4 4.1 3.2.9 2.5 3.1 4.5 1.2 5 2.8 6.4 1.5 6.5.6 3-1.4 1.5 5.1 2.6-4.8 2.6-1.6 4.2 1.5 2.9.1 2.7 1.8 4.2-.8 3.9-4.8 5.3-4 4.9 1.5 3.2-2.6 3.5 3.9-1.2 2.7 6.1.9 3-.4 2.7 3.7 2.7 1.5 1.3 4.9.8 5.3-4.1 5.3.7 7.5 5.6-1 2.3 5.8 3.7 1.3-.8 5.2 4.5 2.4 2.5 1.2 3.8-1.8.6 2.6.7 1.5 2.9.1-1.9-7.2 2.7-1 2.7-1.5h4.3l5.3-.7 4.1-3.4 3 2.4 5.2 1.1-.2 3.7 3 2.6 5.9 1.6 2.4-1 7.7 2-.9 2.5 2.2 4.6 3-.4.8-6.7 5.6-.9 7.2-3.2 2.5-3.2 2.3 2.1 2.8-2.9 6.1-.7 6.6-5.3 6.3-5.9 3.3-7.6 2.3-8.4 2.1-6.9 2.8-.5-.1-5.1-.8-5.1-3.8-2-2.5-3.4 2.8-1.7-1.6-4.7-5.4-4.9-5.4-5.8-4.6-6.3-7.1-3.5.9-4.6 3.8-3.2 1-3.5 6.7-1.8-2.4-3.4-3.4-.2-5.8-2.5-3.9 4.6-4.9-1.9-1.5-2.9-4.7-1-4.7-4.4 1.2-3 5-.3 1.2-4.1 3.6-4.4 3.4-2.2 4.4 3.3-1.9 4.2 2.3 2.5-1.4 3 4.8-1.8 2.4-2.9 6.3-1.9 2.1-4 3.8-3.4 1-4.4 3.6 2 4.6.2-2.7-3.3 6.3-2.6-.1-3.5 5.5 3.6-1.9-3.1 2.5-.1-3.8-7.3-4.7-5.3 2.9-2.2 6.8 1.1-.6-6-2.8-6.8.4-2.3-1.3-5.6-6.9 1.8-2.6 2.5h-7.5l-6-5.8-8.9-4.5-9.9-1.9z');
    add('country-hk', 'Hong Kong', 'East Asia', '1602.2 428.1 3.5 3.4',
      'M1604.9 430.9v-.4l-.4-.2h-.3l.1.2.4.5.2-.1zm-1.3 0l-.1-.5.2-.3-.9.3-.1.3v.1l.2.1h.7zm1.6-1.2l-.1-.3-.2-.1-.1-.3-.1-.2-.3-.1-.2-.1h-.4l-.1.1h-.2l-.2.2v.2l-.5.4v.2l.3.2.5-.1.6.2.8.3v-.5l.2-.1z');
    add('country-jp', 'Japan', 'East Asia', '1664.2 278.3 58.4 101.1',
      'M1692.5 354.9l-4.5-1.3-1.1 2.7-3.3-.8-1.3 3.8 1.2 3 4.2 1.8-.1-3.7 2.1-1.5 3.1 2.1 1.3-3.9-1.6-2.2zm24.4-19.3l-3.6-6.7 1.3-6.4-2.8-5.2-8.1-8.7-4.8 1.2.2 3.9 5.1 7.1 1 7.9-1.7 2.5-4.5 6.5-5-3.1v11.5l-6.3-1.3-9.6 1.9-1.9 4.4-3.9 3.3-1.1 4-4.3 2 4 4.3 4.1 1.9.9 5.7 3.5 2.5 2.5-2.7-.8-10.8-7.3-4.7 6.1-.1 5-3 8.6-1.4 2.4 4.8 4.6 2.4 4.4-7.3 9.1-.4 5.4-3 .6-4.6-2.5-3.2-.6-5.2zm-11.8-44.2l-5.3-2.1-10.4-6.4 1.9 4.8 4.3 8.5-5.2.4.6 4.7 4.6 6.1h5.7l-1.6-6.8 10.8 4.2.4-6.1 6.4-1.7-6-6.9-1.7 2.6-4.5-1.3z');
    add('country-mn', 'Mongolia', 'East Asia', '1398.5 239.5 183.0 71.1',
      'M1473.7 252.1l-3.7-4.6-6.6-1.5-4.8-.8-6.9-2.5-1.3 6.4 4 3.6-2.4 4.3-7.9-1.6-5-.2-4.7-2.9-5.1-.1-5.3-1.9-5.9 2.9-6.6 5.4-4.7 1 3.3 4.4 5.7 3.3 8.1 2.3 5.8 5 1.3 7.3 3 2.7 6.4 1 7.2.9 7.9 3.8 3.4.7 4.9 5.7 4.7 3.6 5.5-.1 11.2 1.3 6.4-.8 5.5.9 9.3 3.8 6.2-.1 3.2 2 4.4-3.3 7.2-2.2 7.5-.2 4.9-2.2 1.9-3.3 2.5-2-1.9-2.1-2.9-2.3.4-4 3.2.5 5.9 1.3 3.1-3.3 6.3-2.4 1.4-4.1 2.4-1.8 6.8-.8 4.3.7-.7-2.2-7.2-4.3-5.1-2-2.5 2.3-5.4-1-2.4.8-2.7-2.6-.3-6.2-.6-4.6-5.5.5-3.9-2.1-3.3-.7-4.5 4.4-5.8 1-3.6 1.6-6.7-1h-4.5l-4.9-3.1-6.5-3-5.4-.8-5.7.8-3.9 1.1-8.4-2.6z');
    add('country-kp', 'North Korea', 'East Asia', '1619.3 297.0 28.1 36.8',
      'M1644.7 302.3l-5.5-3.6.1 3.5-6.3 2.6 2.7 3.3-4.6-.2-3.6-2-1 4.4-3.8 3.4-2.1 4 3.3 1.7 3.4.7.8 1 .4 3.5 1.1 1.2-.9.7-.1 2.9 1.9 1 1.6.6.8 1.2 1.3-.5v-1.3l3.1 1.3.1-.6 2.4.2.7-2.9 3.5-.3 2.1-.4-.1-1.6-4.3-2.8-2.6-1 .2-.7-1.2-2.8 1.3-1.7 2.9-1 1-1.9.3-1.1 1.9-1.4-2.8-4.5.3-2.1.9-2 2.2.3-1.4-1.1z');
    add('country-kr', 'South Korea', 'East Asia', '1636.1 324.7 26.0 30.0',
      'M1637.3 331.7l6.2 5.5-3.4 1.1 5.2 6.8 1.1 4.8 2.1 3.5 4.5-.5 3.2-2.7 4.2-1.2.5-3.6-3.4-7.5-3.3-4.2-8.2-7.6.1 1.6-2.1.4-3.5.3-.7 2.9-2.4-.2-.1.6z');
    add('country-tw', 'Taiwan', 'East Asia', '1635.0 410.1 9.1 23.3',
      'M1642.3 427.2l1.2-10.2.1-3.9-2.9-1.9-3.3 4.8-1.9 6.3 1.5 4.7 4 5.4 1.3-5.2z');

    // ===================== SOUTH & SOUTHEAST ASIA (23) =====================
    add('country-af', 'Afghanistan', 'South & Southeast Asia', '1295.5 324.0 79.4 64.6',
      'M1369.9 333.8h-5.4l-3.8-.5-2.5 2.9-2.1.7-1.5 1.3-2.6-2.1-1-5.4-1.6-.3v-2l-3.2-1.5-1.7 2.3.2 2.6-.6.9-3.2-.1-.9 3-2.1-1.3-3.3 2.1-1.8-.8-4.3-1.4h-2.9l-1.6-.2-2.9-1.7-.3 2.3-4.1 1.2.1 5.2-2.5 2-4 .9-.4 3-3.9.8-5.9-2.4-.5 8-.5 4.7 2.5.9-1.6 3.5 2.7 5.1 1.1 4 4.3 1.1 1.1 4-3.9 5.8 9.6 3.2 5.3-.9 3.3.8.9-1.4 3.8.5 6.6-2.6-.8-5.4 2.3-3.6h4l.2-1.7 4-.9 2.1.6 1.7-1.8-1.1-3.8 1.5-3.8 3-1.6-3-4.2 5.1.2.9-2.3-.8-2.5 2-2.7-1.4-3.2-1.9-2.8 2.4-2.8 5.3-1.3 5.8-.8 2.4-1.2 2.8-.7-1.4-1.9z');
    add('country-bd', 'Bangladesh', 'South & Southeast Asia', '1456.8 402.1 31.7 40.4',
      'M1486.5 431.9l-4.5-10.1-1.5.1-.2 4-3.5-3.3 1.1-3.6 2.4-.4 1.6-5.3-3.4-1.1-5 .1-5.4-.9-1.2-4.4-2.7-.4-4.8-2.7-1.2 4.3 4.6 3.4-3.1 2.4-.8 2.3 3.7 1.7-.4 3.8 2.6 4.8 1.6 5.2 2.2.6 1.7.7.6-1.2 2.5 1.3 1.3-3.5-.9-2.6 5.1.2 2.8 3.7 1.5 3.1.8 3.2 2 3.3-1.1-5.1 2.1 1-.5-4.6z');
    add('country-bn', 'Brunei', 'South & Southeast Asia', '1617.3 537.0 7.7 10.2',
      'M1617.8 543.4l2.7 3.3 1.1-2.2 2.7.2.1-4.1.1-3.1-4.6 3.5-2.1 2.4z');
    add('country-kh', 'Cambodia', 'South & Southeast Asia', '1545.8 478.2 32.3 28.5',
      'M1574.8 481.8l-5.2-2.3-2 4.3-4.9-2.4-5.3-1-7.1 1.3-3 5.2 2.1 7.7 3.4 6.6 2.6 3.3 4.7.9 4.7-2.5 5.8-.5-2.8-3.8 8.9-4.9-.1-7.7-1.8-4.2z');
    add('country-in', 'India', 'South & Southeast Asia', '1342.7 337.5 170.5 192.7',
      'M1414.1 380.1l-8.5-4.4-6.2-4-3.2-7 4.1.9-.6-3.3-3-3.3-.8-5.2-7.6-7.5-3.7 5.4-5.7 1-8.5-1.6-1.9 2.8 3.2 5.6 2.9 4.3 5 3.1-3.7 3.7 1 4.5-3.9 6.3-2.1 6.5-4.5 6.7-6.4-.5-4.9 6.6 4 2.9 1.3 4.9 3.5 3.2 1.8 5.5h-12l-3.2 4.2 7.1 5.4 1.9 2.5-2.4 2.3 8 7.7 4 .8 7.6-3.8 1.7 5.9.8 7.8 2.5 8.1 3.6 12.3 5.8 8.8 1.3 3.9 2 8 3.4 6.1 2.2 3 2.5 6.4 3.1 8.9 5.5 6 2.2-1.8 1.7-4.4 5-1.8-1.8-2.1 2.2-4.8 2.9-.3-.7-10.8 1.9-6.1-.7-5.3-1.9-8.2 1.2-4.9 2.5-.3 4.8-2.3 2.6-1.6-.3-2.9 5-4.2 3.7-4 5.3-7.5 7.4-4.2 2.4-3.8-.9-4.8 6.6-1.3 3.7.1.5-2.4-1.6-5.2-2.6-4.8.4-3.8-3.7-1.7.8-2.3 3.1-2.4-4.6-3.4 1.2-4.3 4.8 2.7 2.7.4 1.2 4.4 5.4.9 5-.1 3.4 1.1-1.6 5.3-2.4.4-1.1 3.6 3.5 3.3.2-4 1.5-.1 4.5 10.1 2.4-1.5-.9-2.7.9-2.1-.9-6.6 4.6 1.4 1.5-5.2-.3-3.1 2.1-5.4-.9-3.6 6.1-4.4 4.1 1.1-1.3-3.9 1.6-1.2-.9-2.4-6.1-.9 1.2-2.7-3.5-3.9-3.2 2.6-4.9-1.5-5.3 4-3.9 4.8-4.2.8 2.7 2 .4 3.9-4.4.2-4.7-.4-3.2 1-5.5-2.5-.3-1.2-1.5-5.1-3 1.4.1 2.7 1.5 4.1-.1 2.5-4.6.1-6.8-1.5-4.3-.6-3.8-3.2-7.6-.9-7.7-3.5-5.8-3.1-5.7-2.5.9-5.9 2.8-2.9z');
    add('country-id', 'Indonesia', 'South & Southeast Asia', '1498.5 532.3 283.1 110.9',
      'M1651.9 637.3l.5-1.7-1.8-1.9-2.8-2-5.3 1.3 7 4.4 2.4-.1zm20.9-.6l4-4.8.1-1.9-.5-1.3-5.7 2.6-2.8 3.9-.7 2.1.6.8 5-1.4zm-35.6-13l-1.6 2.2-3.1.1-2.2 3.6 3 .1 3.9-.9 6.6-1.2-1.2-2.8-3.5.6-1.9-1.7zm28.1 0l-5.2 2.3-3.8.5-3.4-1.9-4.5 1.3-.2 2.3 7.4.8 8.6-1.8 1.1-3.5zm-79.5-8.4l-.7-2.3-2.3-.5-4.4-2.4-6.8-.4-4.1 6.1 5.1.4.8 2.8 10 2.6 2.4-.8 4.1.6 6.3 2.4 5.2 1.2 5.8.5 5.1-.2 5.9 2.5 6.6-2.4-6.6-3.8-8.3-1.1-1.8-4.1-10.3-3.1-1.3 2.6-10.7-.6zm146.6-3.6l.2-3-1.2-1.9-1.3 2.2-1.2 2.2.3 4.8 3.2-4.3zm-41-17.5l-1.4-2.1-5.7.3 1 2.7 3.9 1.2 2.2-2.1zm18.1-2.4l-6.1-1.8-6.9.3-1.5 3.5 3.9.2 3.2-.4 4.6.5 4.7 2.6-1.9-4.9zm21-12.3l-.8-2.4-9-2.6-2.9 2.1-7.6 1.5 2.3 3.2 5 1.2 2.1 3.7 8.3.1.4 1.6-4-.1-6.2 2.3 4.2 3.1-.1 2.8 1.2 2.3 2.1-.5 1.8-3.1 8.2 5.9 4.6.5 10.6 5.4 2.3 5.3 1 6.9-3.7 1.8-2.8 5.2 7.1-.2 1.6-1.8 5.5 1.3 4.6 5.2 1.5-20.8 1-20.7-6-1.2-4.1-2.3-4.7-2.2h-5l-6.6 3.8-4.9 6.8-5.7-3.8-1.3-10.3zm-50-16.4l-1-1.4-5.5 4.6-6.5.3-7.1-.9-4.4-1.9-4.7 4.8-1.2 2.6-2.9 9.6-.9 5-2.4 4.2 1.6 4.3 2.3.1.6 6.1-1.9 5.9 2.3 1.9 3.6-1 .3-9.1-.2-7.4 3.8-1.9-.7 6.2 3.9 3.7-.8 2.5 1.3 1.7 5.6-2.4-3 5.2 2.1 2.2 3.1-1.9.3-4.1-4.7-7.4 1.1-2.2-5.1-8.1 5-2.5 2.6-3.7 2.4.9.5-2.9-10.5 2.1-3.1 2.9-5-5.6.9-4.8 4.9-1 9.3-.3 5.4 1.3 4.3-1.3 4.4-6.3zm19.4 1.9l-.6-2.6-3.3-.6-.5-3.5-1.8 2.3-1 5.1 1.7 8.2 2.2 4 1.6-.8-2.3-3.3.9-3.9 2.9.6.2-5.5zm-60.9-4.5l.9-2.9-4.3-6 3-5.8-5-1h-6.4l-1.7 7.2-2 2.2-2.7 8.9-4.5 1.3-5.4-1.8-2.7.6-3.2 3.2-3.6-.4-3.6 1.2-3.9-3.5-1-4.3-3.3 4.2-.6 5.9.8 5.6 2.6 5.4 2.8 1.8.7 8.5 4.6.8 3.6-.4 2 3.1 6.7-2.3 2.8 2 4 .4 2 3.9 6.5-2.9.8 2.3 2.5-9.7.3-6.4 5.5-4.3-.2-5.8 1.8-4.3 6.7-.8-6.5-5.9zm-68.7 48.9l.7-9.8 1.7-8-2.6-4-4.1-.5-1.9-3.6-.9-4.4-2-.2-3.2-2.2 2.3-5.2-4.3-2.9-3.3-5.3-4.8-4.4-5.7-.1-5.5-6.8-3.2-2.7-4.5-4.3-5.2-6.2-8.8-1.2-3.6-.3.6 3.2 6.1 7 4.4 3.6 3.1 5.5 5.1 4 2.2 4.9 1.7 5.5 4.9 5.3 4.1 8.9 2.7 4.8 4.1 5.2 2.2 3.8 7 5.2 4.5 5.3 6.2-.1z');
    add('country-kz', 'Kazakhstan', 'South & Southeast Asia', '1195.8 218.0 219.2 99.7',
      'M1308.8 223.8l-9-1.3-3.1 2.5-10.8 2.2-1.7 1.5-16.8 2.1-1.4 2.1 5 4.1-3.9 1.6 1.5 1.7-3.6 2.9 9.4 4.2-.2 3-6.9-.3-.8 1.8-7.3-3.2-7.6.2-4.3 2.5-6.6-2.4-11.9-4.3-7.5.2-8.1 6.6.7 4.6-6-3.6-2.1 6.8 1.7 1.2-1.7 4.7 5.3 4.3 3.6-.2 4.2 4.1.2 3.2 2.8 1 4.4-1.3 5-2.7 4.7 1.5 4.9-.3 1.9 3.9.6 6-4.6-.9-4 1 .9 4.5-5-.6.6 2 3.2 1.6 3.7 5.5 6.4 2.1 1.5 2.1-.7 2.6.7 1.5 1.8-2 5.5-1.3 3.8 1.7 4.9 4.9 2.5-.3-6.2-22.8 11.9-3.6 1.1.5 9.1 4.5 4.8 2.3 6.5 5.5 5.7-.9 8.6-.5 7.5 4.5 1.5 6.2 2.5.1 2.6 5 6.6.2 2.3 3h1.9l.9-4.5 5.4-4.3 2.5-1.2.3-2.7 3.1-.8 9.1 2.1-.5-3.6 2.5-1.3 8.1 2.6 1.6-.7 8.6.2 7.8.6 3.3 2.2 3.5.9-1.7-3.5 2.9-1.6-8.7-10.7 9-2.4 2-1.4-1-11.1 10.7 2 1.6-2.8-2.5-6.2 3.8-.6 1.8-4.2-4.3-3.8-6 .9-3.3-2.6-3.9-1.2-4.1-3.6-3.2-1.1-6.2 1.6-8.3-3.6-1.1 3.3-18.1-15.5-8.3-4.7.8-1.9-9.1 5.7-4.4.4-1.2-3.3-7-2.1-4.3 1.5-4.3-6.3z');
    add('country-kg', 'Kyrgyzstan', 'South & Southeast Asia', '1334.3 295.6 55.4 27.5',
      'M1387.2 302.6l-3.5-.9-3.3-2.2-7.8-.6-8.6-.2-1.6.7-8.1-2.6-2.5 1.3.5 3.6-9.1-2.1-3.1.8-.3 2.7 1.8.6-3.1 4.1 4.6 2.3 3.2-1.6 7.1 3.3-5.2 4.5-4.1-.6-1.4 2-5.9-1.1.6 3.7 5.4-.5 7.1 2 9.5-.9 1-1.5-1.1-1.5 4-3 3.2-1.2 5.7.9.6-4 6.4-.8 1-2.4 6.8-3.4.2-1.4z');
    add('country-la', 'Laos', 'South & Southeast Asia', '1526.7 426.5 50.6 60.1',
      'M1574.8 481.8l.2-6.4-2-4.5-4.8-4.4-4.3-5.6-5.7-7.5-7.3-3.8 1.3-2.3 3.3-1.7-3-5.5-6.8-.1-3.4-5.7-4-5.1-2.7 1 1.9 7.2-2.9-.1-.7-1.5-4.1 4.1-.8 2.4 2.6 1.9.9 3.8 3.8.3-.4 6.7 1 5.7 5.3-3.8 1.8 1.2 3.2-.2.8-2.2 4.3.4 4.9 5.2 1.3 6.3 5.2 5.5.5 5.4-1.5 2.9 4.9 2.4 2-4.3 5.2 2.3z');
    add('country-my', 'Malaysia', 'South & Southeast Asia', '1532.6 526.1 118.3 43.0',
      'M1543.6 532.7l-4.7-2.8-.9 1.1 1.4 2.7-.4 4.7 2.1 3.4 1 5.3 3.4 4.3.8 3.2 6.7 5 5.4 4.8 4-.5.1-2.1-2.3-5.6-2.1-1.8-.5-3.8-.6-2.1.5-2.9-.5-4.3-2.6-4.3-3.5-3.8-1.3-.6-1.7 2.6-3.7.8-.6-3.3zm99 11l-1.2-3.1 3.8-.4.3-2.4-4.8-2-3.8-1.7-.4-2.8-3.1-3.2h-2.3l-2.5 5-4.1 4.4-.1 3.1-.1 4.1-2.7-.2-1.1 2.2-2.7-3.3-2.6 4-3.8 5-6.7 1.4-2.4 1.2-.9 5.4-4.4 1.2-4.1-2.2 1 4.3 3.9 3.5 3.6-1.2 3.6.4 3.2-3.2 2.7-.6 5.4 1.8 4.5-1.3 2.7-8.9 2-2.2 1.7-7.2h6.4l5 1 4-2.1z');
    add('country-mv', 'Maldives', 'South & Southeast Asia', '1388.4 544.6 1.6 7.5',
      'M1389.1 551.6l.1-.1v-.2l-.1-.1h-.1l-.1.2v.2h.2zm.3-5.9l.1-.2v-.4l-.1.1-.1.2v.1l-.1.1v.1h.2z');
    add('country-mm', 'Myanmar', 'South & Southeast Asia', '1482.5 386.0 53.9 128.8',
      'M1533.9 435.8l-.6-2.6-3.8 1.8-2.5-1.2-4.5-2.4.8-5.2-3.7-1.3-2.3-5.8-5.6 1-.7-7.5 4.1-5.3-.8-5.3-1.3-4.9-2.7-1.5-2.7-3.7-3 .4.9 2.4-1.6 1.2 1.3 3.9-4.1-1.1-6.1 4.4.9 3.6-2.1 5.4.3 3.1-1.5 5.2-4.6-1.4.9 6.6-.9 2.1.9 2.7-2.4 1.5.5 4.6-2.1-1 1.1 5.1 4.6 5.2 3.4.9-.4 2.2 5.4 7.4 1.9 5.9-.9 7.9 3.6 1.5 3.2.6 5.8-4.6 3.2-3.1 3.1 5.2 2 8.1 2.6 7.6 2.6 3.3.2 6.9 2.2 3.8-1.3 4.8.9 4.8 2.2-6.6 2.6-5.9-2.8-5.8-.2-3-1-3.5-4.2-5.1-1.7-3.2 1.7-1.1 1.4-5.6-2.9-4.2-4.1-4.6-3.5-5.6 2.2-1.1 1.5-6.9 3.9-.3 2.8-2.8 3-1.4.8-2.4 4.1-4.1z');
    add('country-np', 'Nepal', 'South & Southeast Asia', '1408.1 377.3 51.0 28.2',
      'M1455.2 394.8l-6.5-.6-6.4-1.5-5-2.8-4.5-1.2-2.5-3.1-3.2-.9-6.4-4.1-4.7-2-1.9 1.5-2.8 2.9-.9 5.9 5.7 2.5 5.8 3.1 7.7 3.5 7.6.9 3.8 3.2 4.3.6 6.8 1.5 4.6-.1.1-2.5-1.5-4.1-.1-2.7z');
    add('country-pk', 'Pakistan', 'South & Southeast Asia', '1301.1 331.4 91.3 94.3',
      'M1388.3 346.3l-9.4-2.6-2.9-5-4.7-3-2.8.7-2.4 1.2-5.8.8-5.3 1.3-2.4 2.8 1.9 2.8 1.4 3.2-2 2.7.8 2.5-.9 2.3-5.1-.2 3 4.2-3 1.6-1.5 3.8 1.1 3.8-1.7 1.8-2.1-.6-4 .9-.2 1.7h-4l-2.3 3.6.8 5.4-6.6 2.6-3.8-.5-.9 1.4-3.3-.8-5.3.9-9.6-3.2 3.2 3.3 2.8 3.9 5.6 2.7 1 5.7 2.7 1 .9 2.9-7.4 3.3-1.2 7.4 7.6-.9 8.9-.1 9.9-1.2 4.9 4.8 2.1 4.6 4.2 1.6 3.2-4.2h12l-1.8-5.5-3.5-3.2-1.3-4.9-4-2.9 4.9-6.6 6.4.5 4.5-6.7 2.1-6.5 3.9-6.3-1-4.5 3.7-3.7-5-3.1-2.9-4.3-3.2-5.6 1.9-2.8 8.5 1.6 5.7-1 3.7-5.4z');
    add('country-ph', 'Philippines', 'South & Southeast Asia', '1630.3 450.3 58.3 90.5',
      'M1684.6 518.6l-.6-2.3-.8-3.2-4.8-3 .8 4.9-3.9.2-.7 2.8-4.2 1.7-2.2-2.8-2.8 2.4-3.4 1.7-1.9 5.4 1.1 1.9 3.9-3.6 2.7.3 1.5-2.7 3.8 3-1.5 3.1 1.9 4.6 6.8 3.7 1.4-3-2.1-4.7 2.4-3.2 2.5 6.4 1.5-5.8-.6-3.5-.8-4.3zm-14.5-11.8v-6.1l-3.6 6.1.5-4.2-3 .3-.3 4-1.2 1.8-1 1.7 3.8 4.4 1.6-1.9 1.4-4 1.8-2.1zm-30.1 6.1l2.6-4.4 3.4-3.5-1.5-5.2-2.4 6.3-2.9 4.4-3.8 4-2.4 4.4 7-6zm17.4-16.4l1.2 3-.1 3.3.5 2.9 3.3-1.9 2.4-2.7-.2-2.6h-3.6l-3.5-2zm20-1.7l-1.8-2.4-5.4-.1 4 4.8.3 2.4-3.3-.5 1.2 3.9 1.7.3.7 4.5 2.5-1.4-1.7-4-.4-2.1 4.5 1.7-2.3-7.1zm-22.9-5.8l-2.2-2.3-4.8-.2 3.4 4.8 2.8 3.2.8-5.5zm-6.4-34.6h-3.3l-.9 5.8 1.1 9.9-2.6-2 1.2 6 1.2 2.8 3.3 3.7.4-2.3 1.8 1.4-1.5 1.7.1 2.6 2.9 1.4 5-.9 4 3.8 1.1-2.4 2.5 3.4 4.8 3.1.2-2.9-2-1.6.1-3.4-7.5-3.6-2.3.8-3.1-.7-2-5.1.1-5.1 3-2.1.6-5.3-2.7-4.6.4-2.6-.7-1.6-1.5 1.6-3.7-1.8z');
    add('country-sg', 'Singapore', 'South & Southeast Asia', '1558.7 562.5 2.9 2.1',
      'M1561 563.7l.1-.2-.2-.2-.3-.1-.5-.2-.6.1-.3.6.9.4.9-.4z');
    add('country-lk', 'Sri Lanka', 'South & Southeast Asia', '1422.6 508.5 13.1 26.9',
      'M1432.2 532.7l2.3-1.8.6-6.6-3-6.6-2.9-4.5-4.1-3.5-1.9 10.3 1.4 9.1 2.8 5.1 4.8-1.5z');
    add('country-tj', 'Tajikistan', 'South & Southeast Asia', '1325.4 309.8 46.6 29.7',
      'M1344.1 315.7l-2.1.2-1.3-1.8.2-2.9-6.4 1.5-.5 4-1.5 3.5-4.4-.3-.6 2.8 4.2 1.6 2.4 4.7-1.3 6.6 1.8.8 3.3-2.1 2.1 1.3.9-3 3.2.1.6-.9-.2-2.6 1.7-2.3 3.2 1.5v2l1.6.3 1 5.4 2.6 2.1 1.5-1.3 2.1-.7 2.5-2.9 3.8.5h5.4l-1.8-3.7-.6-2.5-3.5-1.4-1.6.6-3-5.9-9.5.9-7.1-2-5.4.5-.6-3.7 5.9 1.1 1.4-2z');
    add('country-th', 'Thailand', 'South & Southeast Asia', '1513.2 437.6 53.5 103.1',
      'M1562.7 481.4l1.5-2.9-.5-5.4-5.2-5.5-1.3-6.3-4.9-5.2-4.3-.4-.8 2.2-3.2.2-1.8-1.2-5.3 3.8-1-5.7.4-6.7-3.8-.3-.9-3.8-2.6-1.9-3 1.4-2.8 2.8-3.9.3-1.5 6.9-2.2 1.1 3.5 5.6 4.1 4.6 2.9 4.2-1.4 5.6-1.7 1.1 1.7 3.2 4.2 5.1 1 3.5.2 3 2.8 5.8-2.6 5.9-2.2 6.6-1.3 6.1-.3 3.9 1.2 3.6.7-3.8 2.9 3.1 3.2 3.5 1.1 3.2 2.4 2.4.9-1.1 4.7 2.8.6 3.3 3.7-.8 1.7-2.6-3.1-3.3-3.4-.8-3.3-3.6-1.4-5.5-2.6-5.8-3.7-.2-.7-4.6 1.4-5.6 2.2-9.3-.2-7 4.9-.1-.3 5 4.7-.1 5.3 2.9-2.1-7.7 3-5.2 7.1-1.3 5.3 1z');
    add('country-tl', 'Timor-Leste', 'South & Southeast Asia', '1675.7 624.3 14.8 8.1',
      'M1676.8 631.9l4.9-1.8 6-2.8 2.2-1.7-2-.8-1.8.8-4 .2-4.9 1.4-.8 1.5.5 1.3-.1 1.9z');
    add('country-tm', 'Turkmenistan', 'South & Southeast Asia', '1242.1 297.7 87.5 52.4',
      'M1325.6 334.2l-.8-4-7.7-2.7-6.2-3.2-4.2-3-7-4.4-4.3-6.4-2-1.2-5.5.3-2.3-1.3-1.9-4.9-7.8-3.3-3.3 3.6-3.8 2.2 1.6 3.1-5.8.1-2.5.3-4.9-4.9-3.8-1.7-5.5 1.3-1.8 2 2.5 4-.5-4.5 3.7-1.6 2.4 3.6 4.6 3.7-4 2-5.3-1.5.1 5.2 3.5.4-.4 4.4 4.5 2.1.7 6.8 1.8 4.5 4.4-1.2 3-3.7 3.5.2 2.1-1.2 3.8.6 6.5 3.3 4.3.7 7.3 5.7 3.9.2 1.6 5.5 5.9 2.4 3.9-.8.4-3 4-.9 2.5-2-.1-5.2 4.1-1.2.3-2.3 2.9 1.7 1.6.2z');
    add('country-uz', 'Uzbekistan', 'South & Southeast Asia', '1253.7 280.1 104.5 58.2',
      'M1339.8 303.1l-2.5 1.2-5.4 4.3-.9 4.5h-1.9l-2.3-3-6.6-.2-2.6-5-2.5-.1-1.5-6.2-7.5-4.5-8.6.5-5.7.9-6.5-5.5-4.8-2.3-9.1-4.5-1.1-.5-11.9 3.6 6.2 22.8 5.8-.1-1.6-3.1 3.8-2.2 3.3-3.6 7.8 3.3 1.9 4.9 2.3 1.3 5.5-.3 2 1.2 4.3 6.4 7 4.4 4.2 3 6.2 3.2 7.7 2.7.8 4h2.9l4.3 1.4 1.3-6.6-2.4-4.7-4.2-1.6.6-2.8 4.4.3 1.5-3.5.5-4 6.4-1.5-.2 2.9 1.3 1.8 2.1-.2 4.1.6 5.2-4.5-7.1-3.3-3.2 1.6-4.6-2.3 3.1-4.1-1.8-.6z');
    add('country-vn', 'Vietnam', 'South & Southeast Asia', '1535.9 418.9 53.2 103.2',
      'M1571.6 435l-5.9-1.6-3-2.6.2-3.7-5.2-1.1-3-2.4-4.1 3.4-5.3.7h-4.3l-2.7 1.5 4 5.1 3.4 5.7 6.8.1 3 5.5-3.3 1.7-1.3 2.3 7.3 3.8 5.7 7.5 4.3 5.6 4.8 4.4 2 4.5-.2 6.4 1.8 4.2.1 7.7-8.9 4.9 2.8 3.8-5.8.5-4.7 2.5 4.5 3.7-1.3 4.3 2.3 4 6.6-5.9 4.1-5.3 6.1-4.1 4.3-4.2-.4-11.2-4-11.7-4.1-5.1-5.6-4-6.4-8.3-5.3-6.7.5-4.4 3.7-6 6.5-5.5z');

    // ===================== OCEANIA (10) =====================
    add('country-au', 'Australia', 'Oceania', '1576.9 629.5 246.4 230.6',
      'M1726.7 832l-3-.5-1.9 2.9-.6 5.4-2.1 4-.5 5.3 3 .2.8.3 6.6-4.3.6 1.7 4-4.9 3.2-2.2 4.5-7.3-2.8-.5-4.8 1.2-3.4.9-3.6-2.2zm50.1-172.3l.5-2.3.1-3.6-1.6-3.2.1-2.7-1.3-.8.1-3.9-1.2-3.2-2.3 2.4-.4 1.8-1.5 3.5-1.8 3.4.6 2.1-1.2 1.3-1.5 4.8.1 3.7-.7 1.8.3 3.1-2.6 5-1.3 3.5-1.7 2.9-1.7 3.4-4.1 2.1-4.9-2.1-.5-2-2.5-1.6h-1.6l-3.3-3.8-2.5-2.2-3.9-2-3.9-3.5-.1-1.8 2.5-3.1 2.1-3.2-.3-2.6 1.9-.2 2.5-2.5 2-3.4-2.2-3.2-1.5 1.2-2-.5-3.5 1.8-3.2-2-1.7.7-4.5-1.6-2.7-2.7-3.5-1.5-3.1.9 3.9 2.1-.3 3.2-4.8 1.2-2.8-.7-3.6 2.2-2.9 3.7.6 1.5-2.7 1.7-3.4 5.1.6 3.5-3.4-.6h-3.5l-2.5-3.8-3.7-2.9-2.8.8-2.6.9-.3 1.6-2.4-.7-.3 1.8-3 1.1-1.7 2.5-3.5 3.1-1.4 4.8-2.3-1.3-2.2 3.1 1.5 3-2.6 1.2-1.4-5.5-4.8 5.4-.8 3.5-.7 2.5-3.8 3.3-2 3.4-3.5 2.8-6.1 1.9-3.1-.2-1.5.6-1.1 1.4-3.5.7-4.7 2.4-1.4-.8-2.6.5-4.6 2.3-3.2 2.7-4.8 2.1-3.1 4.4.4-4.8-3.1 4.6-.1 3.7-1.3 3.2-1.5 1.5-1.3 3.7.9 1.9.1 2 1.6 5-.7 3.3-1-2.5-2.3-1.8.4 5.9-1.7-2.8.1 2.8 1.8 5-.6 5 1.7 2.5-.4 1.9.9 4.1-1.3 3.6-.3 3.6.7 6.5-.7 3.7-2.2 4.4-.6 2.3-1.5 1.5-2.9.8-1.5 3.7 2.4 1.2 4 4.1h3.6l3.8.3 3.3-2.1 3.4-1.8 1.4.3 4.5-3.4 3.8-.3 4.1-.7 4.2 1.2 3.6-.6 4.6-.2 3-2.6 2.3-3.3 5.2-1.5 6.9-3.2 5 .4 6.9-2.1 7.8-2.3 9.8-.6 4 3.1 3.7.2 5.3 3.8-1.6 1.5 1.8 2.4 1.3 4.6-1.6 3.4 2.9 2.6 4.3-5.1 4.3-2.1 6.7-5.5-1.6 4.7-3.4 3.2-2.5 3.7-4.4 3.5 5.2-1.2 4.7-4.4-.9 4.8-3.2 3.1 4.7.8 1.3 2.6-.4 3.3-1.5 4.9 1.4 4 4 1.9 2.8.4 2.4 1 3.5 1.8 7.2-4.7 3.5-1.2-2.7 3.4 2.6 1.1 2.7 2.8 4.7-2.7 3.8-2.5 6.3-2.7 6-.2 4.2-2.3.9-2 3-4.5 3.9-4.8 3.6-3.2 4.4-5.6 3.3-3.1 4.4-5 5.4-3.1 5-5.8 3.1-4.5 1.4-3.6 3.8-5.7 2.1-2.9 2.5-5.7-.7-5.4 1.7-3.9 1.1-3.7v-5.1l-2.8-5.1-1.9-2.5-2.9-3.9.7-6.7-1.5 1-1.6-2.8-2.5 1.4-.6-6.9-2.2-4 1-1.5-3.1-2.8-3.2-3-5.3-3.3-.9-4.3 1.3-3.3-.4-5.5-1.3-.7-.2-3.2-.2-5.5 1.1-2.8-2.3-2.5-1.4-2.7-3.9 2.4-1.2-5z');
    add('country-fj', 'Fiji', 'Oceania', '1958.0 673.7 19.6 15.5',
      'M1976.7 674.4l-3.7 2-1.9.3-3.1 1.3.2 2.4 3.9-1.3 3.9-1.6.7-3.1zm-11 8.1l-1.6 1-2.3-.8-2.7 2.2-.2 2.8 2.9.8 3.6-.9 1.8-3.3-1.5-1.8z');
    add('country-pf', 'French Polynesia', 'Oceania', '131.3 624.1 95.6 84.7',
      'M213.2 704.9l-.1-.3-.2-.3-.1.1.1.1.2.3v.2l.1-.1zm9.3-14.7l-.2-.2-.4-.2-.2-.1-.2-.1-.1.1.1.1h.1l.3.2.3.1.2.1v.1l.1-.1zm-24.5-1.1l-.6-.3.1.2.4.2.2.1-.1-.2zm20.5-.2l-.4-.5h-.3l.7.6v-.1zm-21.6-1l-.4-.4-.2-.3-.3-.1.1.1.4.4.3.4.2.1-.1-.2zm-.3-2.1l-.1-.1v-.3l.2-.3.6-.4v-.1l-.2.1-.4.2-.2.2-.1.2-.1.3.1.2.1.1h.2l-.1-.1zm-47.4-1.1l-.2-.6-.3-.5-.8-.1-.5.2-.1.2.1.4.5.7.5.1.8-.1.4.6.2.1.4.1.1-.3-.2-.5-.9-.3zm-2.9-.9l.1-.4-.2-.1h-.5v.2l.1.2.1.1.3.2.1-.2zm-9.7-4.3h.2l-.4-.6-.3-.2V679.5l.3.1.2-.1zm43.9-1.6h-.6l.5.1.4.2-.3-.3zm-.7.1l-.3-.1-.3-.2h-.3l.7.3h.2zm-43.8.1l.1-.2-.1-.1-.4-.2.1.3v.2l.2.1.1-.1zm32.8-2l-.3-.4-.2-.3-.2-.4-.4-.5.1.3.1.2.2.2.2.4.1.2.3.4h.1v-.1zm16.2-1.5l.1-.5h-.2v.5h.1zm-14.4-1.6l-.6-.6h-.1l.1.2.5.5.1.2v-.3zm30.8-33.9l.1-.2v-.2l-.1-.1-.3-.1.1.7.2-.1zm-2.7-3.7l-.1-.2h-.2l-.1.1v.5l.4-.4zm.1-1.6l-.8.5.2.4.4.1.2-.2.8-.1.3-.4-.3.1-.8-.4zm-6.1-1.7l.2-.5-.2-.1-.4.2v.2l.3.4.1-.2zm2.6-3.1l.3-.1v-.1l-.2-.2-.3-.1-.1.1-.1.2.1.3.3-.1zm-2.9-.1l.1-.3v-.2l-.1-.2-.9-.2-.1.1v.4l.2.5h.3l.5-.1z');
    add('country-nr', 'Nauru', 'Oceania', '1914.2 574.8 1.3 1.4',
      'M1915 575.5v-.2h-.2l-.1.2.1.1.1.1.1-.2z');
    add('country-nc', 'New Caledonia', 'Oceania', '1858.5 692.7 46.1 24.8',
      'M1897.3 716.1v-.3l-.4-.2-.2.5v.1l.2.1h.2l.2-.2zm4.6-7.6l-.1-.1v-.3l.1-.2-.4.2-.6.2.1.8-.1.4.3.1.1.3h.2l.7-.2.3-1.1h-.4l-.2-.1zm-3-1.7l.3-.5.1-.2-.2-.7-.3-.3.3-1-.1-.2-.4-.2-.9.3-.1.2.5.1.2.2-.5.7-.5.1.1.5.2.4.7.2.3.4h.3zm-3.9-2.9l.3-.3.3-.4-.1-.1v-.3l.2-.4.3-.1-.2-.2-.2-.1v.3l-.3.7-.1.3-.5.6h.3zm-12.3-2.9l-.6-.7-.1.2-.1.4v.3l.3.2.1.2-.1.5v.4l.6.9.1.7.3.6.5.5.4.5.8 1.4.2.5.4.3 1 1.2.4.4.4.2.9.7.6.3.3.5.6.3.8.4.1.2v.3l.1.3.5.4.6.3.1.2.1.2.3-.1.3.1.9.7.4-.1h.3l.5-.2.3-.4-.1-1.1-.5-.5-.7-.4-.4-.5-.4-.5-.8-1-1.1-1-.5-.2-.3-.4-.3-.1-.2-.3-.5-.3-.3-.6-.6-.6-.1-.3.1-.3-.1-.3-.4-.3-.2-.5-.2-.3-.4-.2-.7-.4-1.6-1.9-.7-.6-.7.2-.6-.4zm-22-6l.2-.4.1-.8-.2.4-.2 1 .1-.2z');
    add('country-nz', 'New Zealand', 'Oceania', '1804.9 787.5 111.8 84.6',
      'M1868.6 832.8l.9-2.6-5.8 2.9-3.4 3.4-3.2 1.6-5.9 4.6-5.6 3.2-7 3.2-5.5 2.4-4.3 1.1-11.3 6.1-6.4 4.6-1.1 2.3 5.1.4 1.5 2.1 4.5.1 4-1.8 6.3-2.8 8.1-6.2 4.7-4.1 6.2-2.3 4-.1.6-2.9 4.6-2.5 7-4.5 4.2-2.9 2.1-2.6.5-2.6-5.6 2.5.8-2.6zm28.8-30.5l1.9-5.7-3.1-1.7-.8-3.6-2.3.5-.4 4.6.8 5.7.9 2.7-.9 1.1-.6 4.4-2.4 4.1-4.2 5-5.3 2.2-1.7 2.4 3.7 2.5-.8 3.5-6.9 5.1 1.4.9-.4 1.6 5.9-2.5 5.9-4.2 4.5-3.4 1.6-1.2 1.5-2.7 2.8-2 3.8.2 4.2-3.8 5.1-5.7-2.1-.8-4.6 2.5-3.2-.5-2.9-2.1 2.3-4.9-1.2-1.8-2.9 4.4.4-6.8z');
    add('country-pg', 'Papua New Guinea', 'Oceania', '1762.0 585.5 93.8 57.0',
      'M1850.7 615.6l.9-1.8-2.4-2.2-2.5-4-1.6-1.5-.5-1.9-.8.7.9 4.8 2.2 4 2.2 2.5 1.6-.6zm-21.2-8.6l2.1-3.9.4-3.5-1.1-1-3.4.1.4 3.7-3.3 2.3-1.7 2.2-3.2.5-.4-3.4-.8.1-1 3.1-3.1.5-5-.9-.6 1.9 3.1 1.8 4.5 1.9h2.9l3-1.5 3.2-1.6 1-1.8 3-.5zm-27.8 12.2l-.9-4.3 5.2-.7-1.1-3.3-9.1-4-.6-3.7-2.9-3.2-3.7-3.3-10.2-3.6-9.6-4.4-1 20.7-1.5 20.8 5.7.2 3.1 1.1 4.6-2.2-.3-4.7 3.6-2.1 4.9-1.8 7 2.8 2.4 5.6 2.9 3.5 3.9 4 5.5 1 4.8.7 1.1 1.6 3.8-.4.8-1.8-5.6-2.7 1.8-1.2-4.2-1.1.5-2.8-3.2.2-3-6.8-4.7-4.1zm34.7-18.4l-.5-3.3-2-2.1-2.1-2.6-2.3-1.5-1.9-1.4-2.9-1.8-1.6 1.5 3.9 1.9 3.1 2.7 2.4 2.1 1.2 2.4.8 3.8 1.9-1.7z');
    add('country-sb', 'Solomon Islands', 'Oceania', '1846.4 612.5 65.7 36.5',
      'M1909.1 646.4l-.2-.2-.1-.4h-.3l-.3.1.2.6h.2l.5-.1zm-35.6.8l-.1-.2-.5-.4-1.9-1.3-.4-.1-.1.1-.1.3.1.2.5.1v.1l.3.2.7.2.4.3.1.5.3.1.3.1.4-.2zm32-6.6v-.1l.2-.3-.2-.1-.5-.1-.7.1-.3.2-.2.3h-.2v.2l.1.4.2-.1.2.1.5-.5h.4l.5-.1zm-24.4-2.3l-.1-.2-.2-.1-.9-.7-.5-.2h-.5l-.1.5v.3h.6l.4.2v.6l.2.2v.5l1.2.9.7.4.7.1.4.2.5-.1.5.2.4-.1-.4-.3v-.4l-.5-1.3-.3-.3-.5.1-.5-.2h-.4l-.7-.3zm-.4-4.9l-.6-1.6-.2-.1.1.6.1.4-.1.5-.1.6.2.2.2-.2.4.5V633.4zm-9.8-2.2l-.3-.1-.4.3-.1.3-.1.7v.4l.3.7.3.5.3.3.2.2.9.1 1.7.1.9.4.9.2.4-.1.5-.2.1-.1-.1-.6-.2-.3-.4-.2-.2-.6-.5-.4-.9-.7h-1.6l-.6.1-1.1-1zm2.6-1.8l-.5.2v.3l.4.1.4.2.1.3.2-.1.4.2.2-.3-.4-.5-.4-.3h-.1l-.3-.1zm-5.6.8l.3-.2v-.4h-.3l-.1-.2h-.2l-.3.2-.2.3.1.2h.4l.2.1h.1zm-8.4-2.3l-.1-.2-.3-.2h-.2l-.5.1.1.1.6.3.3.1.1-.2zm3.1.4l.3-.2-.1-.2-.1-.5-.4.7.1.2h.2zm-.5-.9v-.4l-.2-.1.4-.3-.1-.1-.6-.2-.2.2-.2.1-.1.1-.1.1-.1.5.2.4.4.2.6-.5zm-4 .2l-.3-.4.1-.5.2-.1.2-.5-.1-.4-.2.1-.7.6-.1.3.6.8.3.2v-.1zm13-1.3l-.2-.4v-.2l-.3-.2-.2.1-.1.3.1.2.4.3.3-.1zm6-1.2h-.2l-.1.1h-.5l-.1.2.6 1.1-.3.5.4 2.2.4 1.2.8.8v.2l.8.5.6 1.3.2.1.1-.2v-.6l-.5-1.1.1-.8-.2-.3v-.3l-.2-.8-.6-.7-.3-.1-.2-.3.2-.6.2-.2.1-.3-1.3-1.9zm-16.6-.5l-.6-.2-.2-.3v-1l-.6-.3-.3.2-.6.7-.2.4-.5.3-.1.3v.4l.4.1.3-.4.9-.1.3.1v.4l.1.7.3.3.5.2.4.6.1-.3h.2l.2-.4-.3-1.2-.3-.5zm-6.5-.4l.1-.5-.1-.9-.2.1v.2l-.1.4.2.8.1-.1zm3.2-.4l.2-.2v-.9l-.2-.4-.2-.2-.5.1-.4.5v.5l.4.6h.7zm-2.6-1.2l.2-.3.5-.7.1-.3-.5-.2-.4-.5-.4-.2-.3.4v.4l.5.6-.1.4.2.1.1.4.1-.1zm17.5 3.9l-.1-.5-.3-.4.4-.5-2.2-1.9-.3-.2-.4-.1-.5-.4-.5-.1-.5-.4-.2-.3-.6-.4-.6-.8-1.5-.3.1.2.4.4.1.7.5.4.5.6.2.1.2.2.4.5.8.4.8.6.3.1.3.3 1.5.7.5.7.7.5v-.1zm-21.8-9.2l.2-.3-.7-.5-.2.3-.2.5.4.2.5-.2zm9.1 1.5l-.1-.1h-.3l-.4-.2-.7-.8-.2-.3-.2-1-.4-.4-1.4-.8-.8-.8-.7-.2-.2.2v.5l.2.3 1 .9 1.1 1.7 1 1 .8.1h.4v.1l.1.2.5.2.5-.4-.2-.2z');
    add('country-to', 'Tonga', 'Oceania', '10.0 689.4 4.8 20.1',
      'M13.3 707.7l-.2.3v.2l.4.4-.2-.9zm-1.6-.9h-.2l.2-.1-.4-.2h-.4l-.2-.1v-.2l-.2.3.2.3.9.4.3.2.2-.6v-.2l-.3.1v.1h-.1zm2.5-16l.1-.2v-.2l-.3-.1h-.1l-.3.5.1.1.3.2h.1l.1-.3z');
    add('country-vu', 'Vanuatu', 'Oceania', '1902.9 664.6 6.2 13.9',
      'M1908.6 676.9l-2.7-3.6-.6 1.7 1.3 2.8 2-.9zm-2-9.7l-2.3-2-.9 4.9.5 1.8 1.2-.4 1.3.8.2-5.1z');

    return s;
  }

  function loadShapeLibrary() {
    try {
      const saved = localStorage.getItem('netmap-shape-library');
      if (saved) {
        const parsed = JSON.parse(saved);
        state.shapeLibrary.shapes = parsed.shapes || {};
        state.shapeLibrary.categories = parsed.categories || ['Network Devices', 'Cloud Services', 'Custom'];

        // Always start with built-in shapes, then merge user-saved custom shapes on top
        const builtIn = getDefaultContainerShapes();
        const userShapes = parsed.containerShapes || {};
        // Filter out old-format country shapes (country-<fullname>) that duplicate built-in ISO-2 shapes
        const filteredUserShapes = {};
        Object.entries(userShapes).forEach(([id, shape]) => {
          if (id.startsWith('country-') && id.replace('country-', '').length > 2) return;
          if (builtIn[id]) return;
          filteredUserShapes[id] = shape;
        });
        state.shapeLibrary.containerShapes = Object.assign({}, builtIn, filteredUserShapes);
      } else {
        // First time: load defaults
        state.shapeLibrary.containerShapes = getDefaultContainerShapes();
      }

      // Always use the full category list
      const defaultCats = ['Europe', 'North America', 'Central America & Caribbean', 'South America', 'Middle East', 'Africa', 'East Asia', 'South & Southeast Asia', 'Oceania', 'Custom'];
      state.shapeLibrary.containerCategories = defaultCats;
      saveShapeLibrary();
    } catch (e) {
      console.warn('Failed to load shape library:', e);
    }
    renderLibraryPanel();
  }

  // Save library to localStorage
  function saveShapeLibrary() {
    try {
      localStorage.setItem('netmap-shape-library', JSON.stringify(state.shapeLibrary));
    } catch (e) {
      console.warn('Failed to save shape library:', e);
    }
  }

  // Generate a thumbnail SVG for a library shape
  function generateShapeThumbnail(shape) {
    if (shape.type === 'svg' && shape.svgData) {
      return shape.svgData;
    }

    // Generate built-in shape thumbnail
    const shapeType = shape.shape || 'circle';
    const fill = shape.fill || '#667eea';
    const stroke = shape.stroke || '#4a5568';
    const sw = shape.strokeW || 2;

    let shapeEl = '';
    switch (shapeType) {
      case 'square':
        shapeEl = `<rect x="6" y="6" width="20" height="20" rx="2" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/>`;
        break;
      case 'rectangle':
        shapeEl = `<rect x="3" y="8" width="26" height="16" rx="2" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/>`;
        break;
      case 'ellipse':
        shapeEl = `<ellipse cx="16" cy="16" rx="13" ry="9" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/>`;
        break;
      case 'triangle':
        shapeEl = `<polygon points="16,4 28,28 4,28" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/>`;
        break;
      case 'hexagon':
        shapeEl = `<polygon points="16,3 27,9 27,21 16,27 5,21 5,9" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/>`;
        break;
      default: // circle
        shapeEl = `<circle cx="16" cy="16" r="12" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/>`;
    }

    return `<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">${shapeEl}</svg>`;
  }

  // ============== MULTILINK GROUP MANAGER ==============

  // Multilink Group Manager state
  const mlgManagerState = {
    editingGroup: null,  // ID of group being edited, or 'new' for creating
    editingSegment: null,  // ID of segment being edited
    pickingPath: null,  // { segmentId, pathId } when picking links for a path
    tempGroup: null,  // Temporary group data during editing
    nextTempSegmentId: 1,
    nextTempPathId: 1
  };

  // DOM elements
  const multilinkManager = document.getElementById('multilinkManager');
  const multilinkEditor = document.getElementById('multilinkEditor');
  const multilinkManagerHeader = document.getElementById('multilinkManagerHeader');
  const multilinkEditorHeader = document.getElementById('multilinkEditorHeader');
  const btnToggleMultilinkManager = document.getElementById('btnToggleMultilinkManager');

  // Helper: Find multilink group by ID
  function findMultilinkGroup(id) {
    return state.multilinkGroups.find(mlg => mlg.id === id);
  }

  // Helper: Get node display name
  function getNodeDisplayName(nodeId) {
    const node = findNode(nodeId);
    if (!node) return `Node ${nodeId}`;
    return node.name || node.code || `N-${nodeId}`;
  }

  // Helper: Get link display name
  function getLinkDisplayName(linkId) {
    const link = findEdge(linkId);
    if (!link) return `Link ${linkId}`;
    return link.code || `L-${linkId}`;
  }

  // Helper: Calculate path latency (sum of link latencies)
  function calculatePathLatency(links) {
    let total = 0;
    links.forEach(linkId => {
      const link = findEdge(linkId);
      if (link && typeof link.latencyMs === 'number') {
        total += link.latencyMs;
      }
    });
    return total;
  }

  // Helper: Calculate segment latency (min of path latencies)
  function calculateSegmentLatency(segment) {
    if (!segment.paths || segment.paths.length === 0) return 0;
    const latencies = segment.paths.map(p => calculatePathLatency(p.links)).filter(l => l > 0);
    return latencies.length > 0 ? Math.min(...latencies) : 0;
  }

  // Helper: Calculate total multilink group latency
  function calculateMLGLatency(segments) {
    return segments.reduce((total, seg) => total + calculateSegmentLatency(seg), 0);
  }

  // ============== MLG CAPACITY CALCULATION (Phase 1) ==============
  // Capacity uses MIN cascade: MLG.cap = MIN(segments) where segment.cap = MIN(paths) where path.cap = MIN(links)
  // This ensures "guaranteed survivable capacity" - what remains if any single path fails

  /**
   * Calculate capacity for a single path (MIN of all link capacities)
   * @param {Array} links - Array of link IDs in the path
   * @returns {Object} Capacity object with cap1G, cap10G, cap100G, cap400G, capTbps
   */
  function calculatePathCapacity(links) {
    if (!links || links.length === 0) {
      return { cap1G: 0, cap10G: 0, cap100G: 0, cap400G: 0, capTbps: 0 };
    }

    // Start with infinity (will be reduced by MIN)
    let min1G = Infinity, min10G = Infinity, min100G = Infinity, min400G = Infinity, minTbps = Infinity;
    let hasValidLink = false;

    for (const linkId of links) {
      const link = findEdge(linkId);
      if (!link) continue;

      hasValidLink = true;
      // Get link capacity (default to 0 if undefined)
      const l1G = link.cap1G || 0;
      const l10G = link.cap10G || 0;
      const l100G = link.cap100G || 0;
      const l400G = link.cap400G || 0;
      const lTbps = link.capTbps || 0;

      // MIN across all links
      min1G = Math.min(min1G, l1G);
      min10G = Math.min(min10G, l10G);
      min100G = Math.min(min100G, l100G);
      min400G = Math.min(min400G, l400G);
      minTbps = Math.min(minTbps, lTbps);
    }

    // If no valid links found, return zeros
    if (!hasValidLink) {
      return { cap1G: 0, cap10G: 0, cap100G: 0, cap400G: 0, capTbps: 0 };
    }

    return {
      cap1G: min1G === Infinity ? 0 : min1G,
      cap10G: min10G === Infinity ? 0 : min10G,
      cap100G: min100G === Infinity ? 0 : min100G,
      cap400G: min400G === Infinity ? 0 : min400G,
      capTbps: minTbps === Infinity ? 0 : minTbps
    };
  }

  /**
   * Calculate capacity for a segment (MIN of all path capacities)
   * @param {Object} segment - Segment object with paths array
   * @returns {Object} Capacity object
   */
  function calculateSegmentCapacity(segment) {
    if (!segment || !segment.paths || segment.paths.length === 0) {
      return { cap1G: 0, cap10G: 0, cap100G: 0, cap400G: 0, capTbps: 0 };
    }

    let min1G = Infinity, min10G = Infinity, min100G = Infinity, min400G = Infinity, minTbps = Infinity;

    for (const path of segment.paths) {
      const pathCap = calculatePathCapacity(path.links);
      min1G = Math.min(min1G, pathCap.cap1G);
      min10G = Math.min(min10G, pathCap.cap10G);
      min100G = Math.min(min100G, pathCap.cap100G);
      min400G = Math.min(min400G, pathCap.cap400G);
      minTbps = Math.min(minTbps, pathCap.capTbps);
    }

    return {
      cap1G: min1G === Infinity ? 0 : min1G,
      cap10G: min10G === Infinity ? 0 : min10G,
      cap100G: min100G === Infinity ? 0 : min100G,
      cap400G: min400G === Infinity ? 0 : min400G,
      capTbps: minTbps === Infinity ? 0 : minTbps
    };
  }

  /**
   * Calculate capacity for entire MLG (MIN of all segment capacities)
   * @param {Array} segments - Array of segment objects
   * @returns {Object} Capacity object
   */
  function calculateMLGCapacity(segments) {
    if (!segments || segments.length === 0) {
      return { cap1G: 0, cap10G: 0, cap100G: 0, cap400G: 0, capTbps: 0 };
    }

    let min1G = Infinity, min10G = Infinity, min100G = Infinity, min400G = Infinity, minTbps = Infinity;

    for (const segment of segments) {
      const segCap = calculateSegmentCapacity(segment);
      min1G = Math.min(min1G, segCap.cap1G);
      min10G = Math.min(min10G, segCap.cap10G);
      min100G = Math.min(min100G, segCap.cap100G);
      min400G = Math.min(min400G, segCap.cap400G);
      minTbps = Math.min(minTbps, segCap.capTbps);
    }

    return {
      cap1G: min1G === Infinity ? 0 : min1G,
      cap10G: min10G === Infinity ? 0 : min10G,
      cap100G: min100G === Infinity ? 0 : min100G,
      cap400G: min400G === Infinity ? 0 : min400G,
      capTbps: minTbps === Infinity ? 0 : minTbps
    };
  }

  /**
   * Get effective capacity for an MLG (override values take precedence over calculated)
   * @param {Object} mlg - Multilink group object
   * @returns {Object} Effective capacity object
   */
  function getMLGEffectiveCapacity(mlg) {
    return {
      cap1G: mlg.overrideCap1G !== null ? mlg.overrideCap1G : (mlg.calcCap1G || 0),
      cap10G: mlg.overrideCap10G !== null ? mlg.overrideCap10G : (mlg.calcCap10G || 0),
      cap100G: mlg.overrideCap100G !== null ? mlg.overrideCap100G : (mlg.calcCap100G || 0),
      cap400G: mlg.overrideCap400G !== null ? mlg.overrideCap400G : (mlg.calcCap400G || 0),
      capTbps: mlg.overrideCapTbps !== null ? mlg.overrideCapTbps : (mlg.calcCapTbps || 0)
    };
  }

  /**
   * Calculate total capacity in Gbps for an MLG
   * @param {Object} mlg - Multilink group object
   * @returns {number} Total capacity in Gbps
   */
  function getMLGTotalCapacityGbps(mlg) {
    const cap = getMLGEffectiveCapacity(mlg);
    return cap.cap1G + (10 * cap.cap10G) + (100 * cap.cap100G) + (400 * cap.cap400G) + (1000 * cap.capTbps);
  }

  /**
   * Recalculate capacity for a specific MLG and update its stored values
   * Call this when underlying links change
   * @param {number} mlgId - ID of the MLG to recalculate
   */
  function recalculateMLGCapacity(mlgId) {
    const mlg = findMultilinkGroup(mlgId);
    if (!mlg) return;

    const capacity = calculateMLGCapacity(mlg.segments);
    mlg.calcCap1G = capacity.cap1G;
    mlg.calcCap10G = capacity.cap10G;
    mlg.calcCap100G = capacity.cap100G;
    mlg.calcCap400G = capacity.cap400G;
    mlg.calcCapTbps = capacity.capTbps;
  }

  /**
   * Recalculate capacity for all MLGs
   * Call this after bulk link changes or on file load
   */
  function recalculateAllMLGCapacities() {
    state.multilinkGroups.forEach(mlg => {
      const capacity = calculateMLGCapacity(mlg.segments);
      mlg.calcCap1G = capacity.cap1G;
      mlg.calcCap10G = capacity.cap10G;
      mlg.calcCap100G = capacity.cap100G;
      mlg.calcCap400G = capacity.cap400G;
      mlg.calcCapTbps = capacity.capTbps;
    });
  }

  /**
   * Find all MLGs that contain a specific link
   * @param {number} linkId - The link ID to search for
   * @returns {Array} Array of MLG objects containing the link
   */
  function findMLGsContainingLink(linkId) {
    return state.multilinkGroups.filter(mlg => {
      if (!mlg.segments) return false;
      return mlg.segments.some(seg => {
        if (!seg.paths) return false;
        return seg.paths.some(path => {
          if (!path.links) return false;
          return path.links.includes(linkId);
        });
      });
    });
  }

  /**
   * Recalculate latency and capacity for all MLGs containing a specific link
   * Call this whenever a link's latency or capacity changes
   * @param {number} linkId - The link that was modified
   */
  function updateMLGsForLinkChange(linkId) {
    const affectedMLGs = findMLGsContainingLink(linkId);

    if (affectedMLGs.length === 0) return;

    affectedMLGs.forEach(mlg => {
      // Recalculate path latencies
      mlg.segments.forEach(seg => {
        seg.paths.forEach(path => {
          path.latency = calculatePathLatency(path.links);
        });
        seg.latency = calculateSegmentLatency(seg);
      });

      // Recalculate total MLG latency
      mlg.totalLatency = calculateMLGLatency(mlg.segments);

      // Recalculate capacity
      const capacity = calculateMLGCapacity(mlg.segments);
      mlg.calcCap1G = capacity.cap1G;
      mlg.calcCap10G = capacity.cap10G;
      mlg.calcCap100G = capacity.cap100G;
      mlg.calcCap400G = capacity.cap400G;
      mlg.calcCapTbps = capacity.capTbps;
    });

    // Update MLG manager display if open
    if (typeof updateMultilinkGroupList === 'function') {
      updateMultilinkGroupList();
    }

    console.log(`[MLG] Updated ${affectedMLGs.length} MLG(s) for link ${linkId} change`);
  }

  // ============== END MLG CAPACITY CALCULATION ==============

  // Helper: Classify multilink group type
  function classifyMLGType(segments) {
    if (!segments || segments.length === 0) return 'linear';
    const hasRing = segments.some(s => s.paths && s.paths.length >= 2);
    const hasLinear = segments.some(s => !s.paths || s.paths.length < 2);
    if (hasRing && hasLinear) return 'ring_linear';
    if (hasRing) return 'ring';
    return 'linear';
  }

  // Helper: Check path diversity (no shared links between paths in a segment)
  function checkPathDiversity(paths) {
    if (!paths || paths.length < 2) return { isDiverse: true, warning: null };

    const linkSets = paths.map(p => new Set(p.links));
    for (let i = 0; i < linkSets.length; i++) {
      for (let j = i + 1; j < linkSets.length; j++) {
        const shared = [...linkSets[i]].filter(l => linkSets[j].has(l));
        if (shared.length > 0) {
          const sharedNames = shared.map(l => getLinkDisplayName(l)).join(', ');
          return {
            isDiverse: false,
            warning: `${paths[i].type} and ${paths[j].type} share: ${sharedNames}`
          };
        }
      }
    }
    return { isDiverse: true, warning: null };
  }

  // Helper: Check segment diversity (no shared links between segments)
  function checkSegmentDiversity(segments) {
    if (!segments || segments.length < 2) return { isDiverse: true, warning: null };

    // Collect all links from each segment
    const segmentLinkSets = segments.map(seg => {
      const links = new Set();
      (seg.paths || []).forEach(p => p.links.forEach(l => links.add(l)));
      return links;
    });

    for (let i = 0; i < segmentLinkSets.length; i++) {
      for (let j = i + 1; j < segmentLinkSets.length; j++) {
        const shared = [...segmentLinkSets[i]].filter(l => segmentLinkSets[j].has(l));
        if (shared.length > 0) {
          const sharedNames = shared.map(l => getLinkDisplayName(l)).join(', ');
          return {
            isDiverse: false,
            warning: `Segments ${i + 1} and ${j + 1} share: ${sharedNames}`
          };
        }
      }
    }
    return { isDiverse: true, warning: null };
  }

  // Helper: Check if link is used in other multilink groups
  function checkLinkReuse(linkId, currentMLGId) {
    const reusedIn = [];
    state.multilinkGroups.forEach(mlg => {
      if (mlg.id === currentMLGId) return;
      mlg.segments.forEach(seg => {
        seg.paths.forEach(path => {
          if (path.links.includes(linkId)) {
            reusedIn.push(mlg.name);
          }
        });
      });
    });
    return reusedIn.length > 0 ? reusedIn : null;
  }

  // Helper: Validate path continuity (links form connected chain from A to B)
  function validatePathContinuity(links, fromNode, toNode) {
    if (links.length === 0) return { valid: false, error: 'Path has no links' };
    if (links.length === 1) {
      const link = findEdge(links[0]);
      if (!link) return { valid: false, error: 'Link not found' };
      const endpoints = [link.a, link.b];
      if (!endpoints.includes(fromNode) || !endpoints.includes(toNode)) {
        return { valid: false, error: 'Single link must connect segment endpoints' };
      }
      return { valid: true };
    }

    // For multiple links, check they form a connected path
    const linkObjs = links.map(id => findEdge(id)).filter(l => l);
    if (linkObjs.length !== links.length) return { valid: false, error: 'Some links not found' };

    // Build adjacency from links
    const nodeConnections = new Map();
    linkObjs.forEach(link => {
      if (!nodeConnections.has(link.a)) nodeConnections.set(link.a, []);
      if (!nodeConnections.has(link.b)) nodeConnections.set(link.b, []);
      nodeConnections.get(link.a).push(link.b);
      nodeConnections.get(link.b).push(link.a);
    });

    // Check fromNode and toNode are in the path
    if (!nodeConnections.has(fromNode)) return { valid: false, error: 'Path does not start at segment origin' };
    if (!nodeConnections.has(toNode)) return { valid: false, error: 'Path does not end at segment destination' };

    // BFS to check connectivity from fromNode to toNode
    const visited = new Set();
    const queue = [fromNode];
    visited.add(fromNode);

    while (queue.length > 0) {
      const current = queue.shift();
      if (current === toNode) return { valid: true };

      const neighbors = nodeConnections.get(current) || [];
      neighbors.forEach(n => {
        if (!visited.has(n)) {
          visited.add(n);
          queue.push(n);
        }
      });
    }

    return { valid: false, error: 'Links do not form a continuous path' };
  }

  // Generate all warnings for a multilink group
  function generateMLGWarnings(mlg, currentMLGId) {
    const warnings = [];

    // Check each segment
    mlg.segments.forEach((seg, segIdx) => {
      // Check path diversity within segment
      const pathDiv = checkPathDiversity(seg.paths);
      if (!pathDiv.isDiverse) {
        warnings.push(`Segment ${segIdx + 1}: ${pathDiv.warning}`);
      }

      // Check path continuity
      seg.paths.forEach(path => {
        const validity = validatePathContinuity(path.links, seg.fromNode, seg.toNode);
        if (!validity.valid) {
          warnings.push(`Segment ${segIdx + 1} ${path.type}: ${validity.error}`);
        }
      });

      // Check link reuse across MLGs
      seg.paths.forEach(path => {
        path.links.forEach(linkId => {
          const reusedIn = checkLinkReuse(linkId, currentMLGId);
          if (reusedIn) {
            warnings.push(`${getLinkDisplayName(linkId)} also used in: ${reusedIn.join(', ')}`);
          }
        });
      });
    });

    // Check segment diversity
    const segDiv = checkSegmentDiversity(mlg.segments);
    if (!segDiv.isDiverse) {
      warnings.push(segDiv.warning);
    }

    // Check segment chaining
    for (let i = 1; i < mlg.segments.length; i++) {
      if (mlg.segments[i].fromNode !== mlg.segments[i - 1].toNode) {
        warnings.push(`Segment ${i + 1} does not chain from Segment ${i}`);
      }
    }

    return [...new Set(warnings)]; // Remove duplicates
  }

  // Update multilink group list
  function updateMultilinkGroupList() {
    const list = document.getElementById('multilinkGroupList');
    if (!list) return;

    const searchTerm = (document.getElementById('mlgSearch')?.value || '').toLowerCase();

    const filtered = state.multilinkGroups.filter(mlg => {
      if (!searchTerm) return true;
      return (mlg.name || '').toLowerCase().includes(searchTerm) ||
             (mlg.description || '').toLowerCase().includes(searchTerm);
    });

    if (filtered.length === 0) {
      list.innerHTML = '<div class="muted" style="padding:12px; text-align:center;">No multilink groups found.<br/>Click "+ New" to create one.</div>';
      return;
    }

    list.innerHTML = filtered.map(mlg => {
      const isSelected = state.selectedMultilinkGroup === mlg.id;
      const typeLabel = mlg.type === 'ring' ? 'Ring' : mlg.type === 'ring_linear' ? 'Ring+Linear' : 'Linear';
      const origin = mlg.segments.length > 0 ? getNodeDisplayName(mlg.segments[0].fromNode) : 'â€”';
      const dest = mlg.segments.length > 0 ? getNodeDisplayName(mlg.segments[mlg.segments.length - 1].toNode) : 'â€”';
      const warnings = generateMLGWarnings(mlg, mlg.id);

      return `
        <div class="mlg-item ${isSelected ? 'selected' : ''}" data-id="${mlg.id}">
          <div class="mlg-header">
            <span class="mlg-name">${mlg.name || 'Unnamed'}</span>
            <span class="mlg-type ${mlg.type}">${typeLabel}</span>
          </div>
          <div class="mlg-info">
            ${mlg.segments.length} segment${mlg.segments.length !== 1 ? 's' : ''} Â· ${mlg.totalLatency || 0} ms
          </div>
          <div class="mlg-route">${origin} â†’ ${dest}</div>
          ${warnings.length > 0 ? `<div class="mlg-warnings">âš ï¸ ${warnings.length} warning${warnings.length !== 1 ? 's' : ''}</div>` : ''}
        </div>
      `;
    }).join('');

    // Add click handlers
    list.querySelectorAll('.mlg-item').forEach(item => {
      item.addEventListener('click', () => {
        // Don't parseInt - MLG IDs can be strings like "mlg_1234567890"
        const id = item.dataset.id;
        // Try to parse as int if it looks like a number, otherwise keep as string
        const parsedId = /^\d+$/.test(id) ? parseInt(id) : id;
        selectMultilinkGroup(parsedId);
      });
      item.addEventListener('dblclick', () => {
        const id = item.dataset.id;
        const parsedId = /^\d+$/.test(id) ? parseInt(id) : id;
        editMultilinkGroup(parsedId);
      });
    });
  }

  // Select a multilink group
  function selectMultilinkGroup(id) {
    state.selectedMultilinkGroup = id;
    updateMultilinkGroupList();
    highlightMultilinkGroup(id);
  }

  // Highlight multilink group on canvas
  function highlightMultilinkGroup(id) {
    const mlg = findMultilinkGroup(id);
    if (!mlg) {
      clearHighlights();
      return;
    }

    // Collect all links and nodes
    const linkIds = new Set();
    const nodeIds = new Set();

    mlg.segments.forEach(seg => {
      nodeIds.add(seg.fromNode);
      nodeIds.add(seg.toNode);
      seg.paths.forEach(path => {
        path.links.forEach(l => linkIds.add(l));
      });
    });

    state._highlightedLinks = linkIds;
    state._highlightedNodes = nodeIds;
    render();
  }

  // Clear multilink group highlights
  function clearMLGHighlights() {
    state._highlightedLinks = null;
    state._highlightedNodes = null;
    render();
  }

  // Create new multilink group
  function createNewMultilinkGroup() {
    mlgManagerState.editingGroup = 'new';
    mlgManagerState.nextTempSegmentId = 1;
    mlgManagerState.nextTempPathId = 1;
    mlgManagerState.tempGroup = {
      id: null,
      name: '',
      color: '#f59e0b',
      description: '',
      segments: [],
      type: 'linear',
      totalLatency: 0,
      isDiverse: true,
      warnings: [],
      // Phase 1: New fields for MLG Path Finder integration
      source: 'manual',  // 'manual' | 'pathfinder' | 'byop' - how the MLG was created
      tags: [],          // MLG-level tags (structure ready for future use)
      // Auto-calculated capacity (MIN cascade through segmentsâ†’pathsâ†’links)
      calcCap1G: 0,
      calcCap10G: 0,
      calcCap100G: 0,
      calcCap400G: 0,
      calcCapTbps: 0,
      // User override capacity (when not null, prevails over calculated values)
      overrideCap1G: null,
      overrideCap10G: null,
      overrideCap100G: null,
      overrideCap400G: null,
      overrideCapTbps: null
    };

    showMultilinkEditor();
    renderMultilinkEditor();
  }

  // Edit existing multilink group
  function editMultilinkGroup(id) {
    const mlg = findMultilinkGroup(id);
    if (!mlg) return;

    mlgManagerState.editingGroup = id;
    mlgManagerState.nextTempSegmentId = Math.max(0, ...mlg.segments.map(s => s.id)) + 1;
    mlgManagerState.nextTempPathId = 1;
    mlg.segments.forEach(seg => {
      const maxPathId = Math.max(0, ...seg.paths.map(p => p.id));
      if (maxPathId >= mlgManagerState.nextTempPathId) {
        mlgManagerState.nextTempPathId = maxPathId + 1;
      }
    });

    // Deep copy for editing
    mlgManagerState.tempGroup = JSON.parse(JSON.stringify(mlg));

    showMultilinkEditor();
    renderMultilinkEditor();
  }

  // Delete multilink group
  function deleteMultilinkGroup() {
    if (!state.selectedMultilinkGroup) {
      showToast('Select a multilink group first');
      return;
    }

    const mlg = findMultilinkGroup(state.selectedMultilinkGroup);
    if (!mlg) return;

    if (!confirm(`Delete multilink group "${mlg.name}"?`)) return;

    state.multilinkGroups = state.multilinkGroups.filter(m => m.id !== state.selectedMultilinkGroup);
    state.selectedMultilinkGroup = null;

    updateMultilinkGroupList();
    clearMLGHighlights();
    commit();
    showToast('Multilink group deleted');
  }

  // Save multilink group
  function saveMultilinkGroup() {
    const temp = mlgManagerState.tempGroup;
    if (!temp) return;

    // Validate
    if (!temp.name || !temp.name.trim()) {
      showToast('Please enter a name');
      return;
    }

    if (temp.segments.length === 0) {
      showToast('Please add at least one segment');
      return;
    }

    // Check each segment has at least primary path with links
    for (let i = 0; i < temp.segments.length; i++) {
      const seg = temp.segments[i];
      if (!seg.fromNode || !seg.toNode) {
        showToast(`Segment ${i + 1}: Select origin and destination nodes`);
        return;
      }
      const primary = seg.paths.find(p => p.type === 'primary');
      if (!primary || primary.links.length === 0) {
        showToast(`Segment ${i + 1}: Primary path needs at least one link`);
        return;
      }
    }

    // Calculate computed properties
    temp.segments.forEach(seg => {
      seg.paths.forEach(path => {
        path.latency = calculatePathLatency(path.links);
      });
      seg.latency = calculateSegmentLatency(seg);
      const pathDiv = checkPathDiversity(seg.paths);
      seg.isDiverse = pathDiv.isDiverse;
      seg.diversityWarning = pathDiv.warning;
    });

    temp.type = classifyMLGType(temp.segments);
    temp.totalLatency = calculateMLGLatency(temp.segments);
    temp.originNode = temp.segments[0].fromNode;
    temp.destinationNode = temp.segments[temp.segments.length - 1].toNode;

    // Calculate capacity (MIN cascade through segmentsâ†’pathsâ†’links)
    const capacity = calculateMLGCapacity(temp.segments);
    temp.calcCap1G = capacity.cap1G;
    temp.calcCap10G = capacity.cap10G;
    temp.calcCap100G = capacity.cap100G;
    temp.calcCap400G = capacity.cap400G;
    temp.calcCapTbps = capacity.capTbps;

    // Preserve source field if already set, default to 'manual'
    if (!temp.source) temp.source = 'manual';

    // Ensure tags array exists
    if (!temp.tags) temp.tags = [];

    const segDiv = checkSegmentDiversity(temp.segments);
    temp.isDiverse = segDiv.isDiverse && temp.segments.every(s => s.isDiverse);
    temp.diversityWarning = segDiv.warning;
    temp.warnings = generateMLGWarnings(temp, temp.id);
    temp.modified = new Date().toISOString();

    if (mlgManagerState.editingGroup === 'new') {
      // Create new
      temp.id = state.nextMultilinkGroup++;
      temp.created = new Date().toISOString();
      state.multilinkGroups.push(temp);
      state.selectedMultilinkGroup = temp.id;
      showToast(`Created multilink group: ${temp.name}`);
    } else {
      // Update existing
      const idx = state.multilinkGroups.findIndex(m => m.id === mlgManagerState.editingGroup);
      if (idx >= 0) {
        state.multilinkGroups[idx] = temp;
        showToast(`Updated multilink group: ${temp.name}`);
      }
    }

    hideMultilinkEditor();
    // Clear editing state to prevent interference with canvas selection
    mlgManagerState.editingGroup = null;
    mlgManagerState.tempGroup = null;
    mlgManagerState.pickingPath = null;

    updateMultilinkGroupList();
    highlightMultilinkGroup(temp.id);
    commit();
  }

  // Cancel editing
  function cancelMultilinkEditor() {
    mlgManagerState.editingGroup = null;
    mlgManagerState.tempGroup = null;
    mlgManagerState.pickingPath = null;
    hideMultilinkEditor();

    if (state.selectedMultilinkGroup) {
      highlightMultilinkGroup(state.selectedMultilinkGroup);
    } else {
      clearMLGHighlights();
    }
  }

  // Show/hide editor
  function showMultilinkEditor() {
    if (multilinkEditor) {
      multilinkEditor.style.display = 'flex';
      // Ensure it's positioned within the viewport
      const rect = multilinkEditor.getBoundingClientRect();
      if (rect.left < 0 || rect.left > window.innerWidth - 200) {
        multilinkEditor.style.left = '360px';
      }
      if (rect.top < 50 || rect.top > window.innerHeight - 200) {
        multilinkEditor.style.top = '80px';
      }
      // Remove minimized state
      multilinkEditor.classList.remove('minimized');
      const btnMinimize = document.getElementById('btnMinimizeMLEditor');
      if (btnMinimize) btnMinimize.textContent = 'âˆ’';
    }
  }

  function hideMultilinkEditor() {
    if (multilinkEditor) multilinkEditor.style.display = 'none';
  }

  // Add segment to temp group
  function addSegment() {
    const temp = mlgManagerState.tempGroup;
    if (!temp) return;

    const segId = mlgManagerState.nextTempSegmentId++;
    const pathId = mlgManagerState.nextTempPathId++;

    // If there are existing segments, auto-set fromNode from previous segment's toNode
    const prevSeg = temp.segments.length > 0 ? temp.segments[temp.segments.length - 1] : null;

    temp.segments.push({
      id: segId,
      fromNode: prevSeg ? prevSeg.toNode : null,
      toNode: null,
      paths: [
        { id: pathId, type: 'primary', links: [], latency: 0 }
      ],
      latency: 0,
      isDiverse: true,
      diversityWarning: null
    });

    renderMultilinkEditor();
  }

  // Remove segment
  function removeSegment(segId) {
    const temp = mlgManagerState.tempGroup;
    if (!temp) return;

    temp.segments = temp.segments.filter(s => s.id !== segId);
    renderMultilinkEditor();
  }

  // Add path to segment
  function addPath(segId) {
    const temp = mlgManagerState.tempGroup;
    if (!temp) return;

    const seg = temp.segments.find(s => s.id === segId);
    if (!seg) return;

    const pathTypes = ['primary', 'secondary', 'tertiary', 'quaternary'];
    const existingTypes = seg.paths.map(p => p.type);
    const nextType = pathTypes.find(t => !existingTypes.includes(t)) || `path${seg.paths.length + 1}`;

    const pathId = mlgManagerState.nextTempPathId++;
    seg.paths.push({
      id: pathId,
      type: nextType,
      links: [],
      latency: 0
    });

    renderMultilinkEditor();
  }

  // Remove path from segment
  function removePath(segId, pathId) {
    const temp = mlgManagerState.tempGroup;
    if (!temp) return;

    const seg = temp.segments.find(s => s.id === segId);
    if (!seg) return;

    // Don't remove primary path
    const path = seg.paths.find(p => p.id === pathId);
    if (path && path.type === 'primary') {
      showToast('Cannot remove primary path');
      return;
    }

    seg.paths = seg.paths.filter(p => p.id !== pathId);
    renderMultilinkEditor();
  }

  // Start picking links for a path
  function startPickingLinks(segId, pathId) {
    const temp = mlgManagerState.tempGroup;
    if (!temp) return;

    const seg = temp.segments.find(s => s.id === segId);
    if (!seg || !seg.fromNode || !seg.toNode) {
      showToast('Select segment origin and destination first');
      return;
    }

    mlgManagerState.pickingPath = { segmentId: segId, pathId };
    showToast('Click links on canvas to add to path. Click "Done" when finished.');
    renderMultilinkEditor();
  }

  // Stop picking links
  function stopPickingLinks() {
    mlgManagerState.pickingPath = null;
    renderMultilinkEditor();
  }

  // Add link to current picking path
  function addLinkToPath(linkId) {
    if (!mlgManagerState.pickingPath) return false;

    const temp = mlgManagerState.tempGroup;
    if (!temp) return false;

    const seg = temp.segments.find(s => s.id === mlgManagerState.pickingPath.segmentId);
    if (!seg) return false;

    const path = seg.paths.find(p => p.id === mlgManagerState.pickingPath.pathId);
    if (!path) return false;

    // Toggle link
    const idx = path.links.indexOf(linkId);
    if (idx >= 0) {
      path.links.splice(idx, 1);
    } else {
      path.links.push(linkId);
    }

    // Update latency
    path.latency = calculatePathLatency(path.links);
    seg.latency = calculateSegmentLatency(seg);

    renderMultilinkEditor();
    return true;
  }

  // Remove link from path
  function removeLinkFromPath(segId, pathId, linkId) {
    const temp = mlgManagerState.tempGroup;
    if (!temp) return;

    const seg = temp.segments.find(s => s.id === segId);
    if (!seg) return;

    const path = seg.paths.find(p => p.id === pathId);
    if (!path) return;

    path.links = path.links.filter(l => l !== linkId);
    path.latency = calculatePathLatency(path.links);
    seg.latency = calculateSegmentLatency(seg);

    renderMultilinkEditor();
  }

  // Render the multilink editor
  function renderMultilinkEditor() {
    const temp = mlgManagerState.tempGroup;
    if (!temp) return;

    // Update title
    const titleEl = document.getElementById('mlEditorTitle');
    if (titleEl) {
      titleEl.textContent = mlgManagerState.editingGroup === 'new' ? 'New Multilink Group' : `Edit: ${temp.name || 'Unnamed'}`;
    }

    // Update basic fields
    const nameInput = document.getElementById('mlgName');
    const colorInput = document.getElementById('mlgColor');
    const descInput = document.getElementById('mlgDescription');

    if (nameInput) nameInput.value = temp.name || '';
    if (colorInput) colorInput.value = temp.color || '#f59e0b';
    if (descInput) descInput.value = temp.description || '';

    // Render segments
    const container = document.getElementById('mlgSegmentsContainer');
    if (!container) return;

    if (temp.segments.length === 0) {
      container.innerHTML = '<div class="muted" style="padding:12px; text-align:center; font-size:11px; color:#94a3b8;">No segments yet. Click "+ Add Segment" to start building the multilink group.</div>';
    } else {
      container.innerHTML = temp.segments.map((seg, idx) => {
        const pathDiv = checkPathDiversity(seg.paths);
        const hasWarning = !pathDiv.isDiverse;
        const isFirst = idx === 0;

        return `
          <div class="segment-card ${hasWarning ? 'has-warning' : ''}" data-seg-id="${seg.id}">
            <div class="segment-header">
              <div class="segment-title">
                <span>Segment ${idx + 1}</span>
                ${seg.latency > 0 ? `<span class="segment-latency">${seg.latency} ms</span>` : ''}
              </div>
              <div class="segment-actions">
                <button onclick="removeSegment(${seg.id})" title="Remove segment">ðŸ—‘ï¸</button>
              </div>
            </div>
            <div class="segment-content">
              <div class="segment-nodes">
                <select onchange="updateSegmentNode(${seg.id}, 'from', this.value)" ${!isFirst ? 'disabled' : ''} style="${!isFirst ? 'background:#f0f0f0;' : ''}">
                  <option value="">Origin...</option>
                  ${state.nodes.map(n => `<option value="${n.id}" ${seg.fromNode === n.id ? 'selected' : ''}>${getNodeDisplayName(n.id)}</option>`).join('')}
                </select>
                <span class="arrow">â†’</span>
                <select onchange="updateSegmentNode(${seg.id}, 'to', this.value)">
                  <option value="">Destination...</option>
                  ${state.nodes.map(n => `<option value="${n.id}" ${seg.toNode === n.id ? 'selected' : ''}>${getNodeDisplayName(n.id)}</option>`).join('')}
                </select>
              </div>

              ${seg.paths.map(path => {
                const isPicking = mlgManagerState.pickingPath?.segmentId === seg.id && mlgManagerState.pickingPath?.pathId === path.id;
                return `
                  <div class="path-card ${path.type}">
                    <div class="path-header">
                      <span class="path-type ${path.type}">${path.type}</span>
                      <span class="path-latency">${path.latency || 0} ms</span>
                      ${path.type !== 'primary' ? `<button onclick="removePath(${seg.id}, ${path.id})" style="background:none; border:none; cursor:pointer; color:#dc2626; font-size:10px;">âœ•</button>` : ''}
                    </div>
                    <div class="path-links ${path.links.length === 0 ? 'empty' : ''}">
                      ${path.links.length === 0 ? 'No links added' : path.links.map(l => `
                        <span class="path-link-chip">
                          ${getLinkDisplayName(l)}
                          <span class="remove-link" onclick="removeLinkFromPath(${seg.id}, ${path.id}, ${l})">Ã—</span>
                        </span>
                      `).join('')}
                    </div>
                    <div class="path-actions">
                      ${isPicking ? `
                        <button class="picking" onclick="stopPickingLinks()">âœ“ Done</button>
                      ` : `
                        <button onclick="startPickingLinks(${seg.id}, ${path.id})">+ Pick Links</button>
                      `}
                    </div>
                  </div>
                `;
              }).join('')}

              <button class="btn" style="width:100%; margin-top:8px; font-size:10px; padding:4px;" onclick="addPath(${seg.id})">+ Add Path</button>

              ${hasWarning ? `<div style="margin-top:8px; padding:6px; background:#fef2f2; border-radius:4px; font-size:10px; color:#dc2626;">âš ï¸ ${pathDiv.warning}</div>` : ''}
            </div>
          </div>
        `;
      }).join('');
    }

    // Update computed properties
    const computedEl = document.getElementById('mlgComputedProps');
    const typeEl = document.getElementById('mlgComputedType');
    const routeEl = document.getElementById('mlgComputedRoute');
    const latencyEl = document.getElementById('mlgComputedLatency');
    const diversityEl = document.getElementById('mlgComputedDiversity');

    if (temp.segments.length > 0 && computedEl) {
      computedEl.style.display = 'block';

      const type = classifyMLGType(temp.segments);
      const typeLabel = type === 'ring' ? 'ðŸ¡ï¸ Ring' : type === 'ring_linear' ? 'ðŸ”€ Ring+Linear' : 'âž¡ï¸ Linear';
      if (typeEl) typeEl.textContent = typeLabel;

      const origin = temp.segments[0].fromNode ? getNodeDisplayName(temp.segments[0].fromNode) : 'â€”';
      const dest = temp.segments[temp.segments.length - 1].toNode ? getNodeDisplayName(temp.segments[temp.segments.length - 1].toNode) : 'â€”';
      if (routeEl) routeEl.textContent = `${origin} â†’ ${dest}`;

      const totalLatency = calculateMLGLatency(temp.segments);
      if (latencyEl) latencyEl.textContent = `${totalLatency} ms`;

      const segDiv = checkSegmentDiversity(temp.segments);
      const allPathsDiverse = temp.segments.every(s => checkPathDiversity(s.paths).isDiverse);
      const isDiverse = segDiv.isDiverse && allPathsDiverse;
      if (diversityEl) diversityEl.textContent = isDiverse ? 'âœ… Diverse' : 'âš ï¸ Not fully diverse';
    } else if (computedEl) {
      computedEl.style.display = 'none';
    }

    // Update warnings
    const warningsBox = document.getElementById('mlgWarningsBox');
    const warningsList = document.getElementById('mlgWarningsList');

    const warnings = generateMLGWarnings(temp, temp.id);
    if (warnings.length > 0 && warningsBox && warningsList) {
      warningsBox.style.display = 'block';
      warningsList.innerHTML = warnings.map(w => `<div class="warning-item">â€¢ ${w}</div>`).join('');
    } else if (warningsBox) {
      warningsBox.style.display = 'none';
    }

    // Update commercial cost display
    if (temp.segments.length > 0 && typeof updateMLGCostDisplayForTemp === 'function') {
      updateMLGCostDisplayForTemp(temp);
    } else {
      const mlgCostSection = document.getElementById('mlgCostSection');
      if (mlgCostSection) mlgCostSection.style.display = 'none';
    }
  }

  // Update segment node
  window.updateSegmentNode = function(segId, type, value) {
    const temp = mlgManagerState.tempGroup;
    if (!temp) return;

    const seg = temp.segments.find(s => s.id === segId);
    if (!seg) return;

    const nodeId = value ? parseInt(value) : null;

    if (type === 'from') {
      seg.fromNode = nodeId;
    } else {
      seg.toNode = nodeId;
      // Update next segment's fromNode if it exists
      const segIdx = temp.segments.findIndex(s => s.id === segId);
      if (segIdx >= 0 && segIdx < temp.segments.length - 1) {
        temp.segments[segIdx + 1].fromNode = nodeId;
      }
    }

    renderMultilinkEditor();
  };

  // Expose functions globally for onclick handlers
  window.removeSegment = removeSegment;
  window.addPath = addPath;
  window.removePath = removePath;
  window.startPickingLinks = startPickingLinks;
  window.stopPickingLinks = stopPickingLinks;
  window.removeLinkFromPath = removeLinkFromPath;

  // Handle link click when picking for multilink group
  function handleMLGLinkClick(linkId) {
    if (!mlgManagerState.pickingPath) return false;
    return addLinkToPath(linkId);
  }

  // Make it accessible globally
  window.handleMLGLinkClick = handleMLGLinkClick;

  // Panel dragging
  if (multilinkManagerHeader && multilinkManager) {
    let isDragging = false;
    let offsetX, offsetY;

    multilinkManagerHeader.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'BUTTON') return;
      isDragging = true;
      offsetX = e.clientX - multilinkManager.offsetLeft;
      offsetY = e.clientY - multilinkManager.offsetTop;
      multilinkManager.style.cursor = 'move';
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      multilinkManager.style.left = (e.clientX - offsetX) + 'px';
      multilinkManager.style.top = (e.clientY - offsetY) + 'px';
      multilinkManager.style.right = 'auto';
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
      multilinkManager.style.cursor = '';
    });
  }

  if (multilinkEditorHeader && multilinkEditor) {
    let isDragging = false;
    let offsetX, offsetY;

    multilinkEditorHeader.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'BUTTON') return;
      isDragging = true;
      offsetX = e.clientX - multilinkEditor.offsetLeft;
      offsetY = e.clientY - multilinkEditor.offsetTop;
      multilinkEditor.style.cursor = 'move';
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      multilinkEditor.style.left = (e.clientX - offsetX) + 'px';
      multilinkEditor.style.top = (e.clientY - offsetY) + 'px';
      multilinkEditor.style.right = 'auto';
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
      multilinkEditor.style.cursor = '';
    });
  }

  // Toggle manager visibility
  if (btnToggleMultilinkManager) {
    btnToggleMultilinkManager.addEventListener('click', () => {
      if (multilinkManager.style.display === 'none' || !multilinkManager.style.display) {
        multilinkManager.style.display = 'flex';
        btnToggleMultilinkManager.classList.add('active');
        updateMultilinkGroupList();
      } else {
        multilinkManager.style.display = 'none';
        btnToggleMultilinkManager.classList.remove('active');
        state.selectedMultilinkGroup = null;
        hideMultilinkEditor();
        clearMLGHighlights();
      }
    });
  }

  // Minimize/close buttons
  const btnMinimizeMLManager = document.getElementById('btnMinimizeMLManager');
  const btnCloseMLManager = document.getElementById('btnCloseMLManager');
  const btnMinimizeMLEditor = document.getElementById('btnMinimizeMLEditor');
  const btnCloseMLEditor = document.getElementById('btnCloseMLEditor');

  if (btnMinimizeMLManager) {
    btnMinimizeMLManager.addEventListener('click', () => {
      multilinkManager.classList.toggle('minimized');
      btnMinimizeMLManager.textContent = multilinkManager.classList.contains('minimized') ? '+' : 'âˆ’';
    });
  }

  if (btnCloseMLManager) {
    btnCloseMLManager.addEventListener('click', () => {
      multilinkManager.style.display = 'none';
      btnToggleMultilinkManager?.classList.remove('active');
      state.selectedMultilinkGroup = null;
      hideMultilinkEditor();
      clearMLGHighlights();
    });
  }

  if (btnMinimizeMLEditor) {
    btnMinimizeMLEditor.addEventListener('click', () => {
      multilinkEditor.classList.toggle('minimized');
      btnMinimizeMLEditor.textContent = multilinkEditor.classList.contains('minimized') ? '+' : 'âˆ’';
    });
  }

  if (btnCloseMLEditor) {
    btnCloseMLEditor.addEventListener('click', cancelMultilinkEditor);
  }

  // New/Delete buttons
  const btnNewMLG = document.getElementById('btnNewMultilinkGroup');
  const btnDeleteMLG = document.getElementById('btnDeleteMultilinkGroup');

  if (btnNewMLG) {
    btnNewMLG.addEventListener('click', createNewMultilinkGroup);
  }

  if (btnDeleteMLG) {
    btnDeleteMLG.addEventListener('click', deleteMultilinkGroup);
  }

  // Save/Cancel buttons
  const btnSaveMLG = document.getElementById('btnSaveMultilinkGroup');
  const btnCancelMLG = document.getElementById('btnCancelMLEditor');

  if (btnSaveMLG) {
    btnSaveMLG.addEventListener('click', saveMultilinkGroup);
  }

  if (btnCancelMLG) {
    btnCancelMLG.addEventListener('click', cancelMultilinkEditor);
  }

  // Add segment button
  const btnAddSeg = document.getElementById('btnAddSegment');
  if (btnAddSeg) {
    btnAddSeg.addEventListener('click', addSegment);
  }

  // Search
  const mlgSearchInput = document.getElementById('mlgSearch');
  if (mlgSearchInput) {
    mlgSearchInput.addEventListener('input', updateMultilinkGroupList);
  }

  // Editor field change handlers
  const mlgNameInput = document.getElementById('mlgName');
  const mlgColorInput = document.getElementById('mlgColor');
  const mlgDescInput = document.getElementById('mlgDescription');

  if (mlgNameInput) {
    mlgNameInput.addEventListener('input', () => {
      if (mlgManagerState.tempGroup) {
        mlgManagerState.tempGroup.name = mlgNameInput.value;
      }
    });
  }

  if (mlgColorInput) {
    mlgColorInput.addEventListener('input', () => {
      if (mlgManagerState.tempGroup) {
        mlgManagerState.tempGroup.color = mlgColorInput.value;
      }
    });
  }

  if (mlgDescInput) {
    mlgDescInput.addEventListener('input', () => {
      if (mlgManagerState.tempGroup) {
        mlgManagerState.tempGroup.description = mlgDescInput.value;
      }
    });
  }

  // ============== END MULTILINK GROUP MANAGER ==============

  // Render the library panel
  function renderLibraryPanel() {
    if (!libraryContent) return;

    const searchTerm = (librarySearch?.value || '').toLowerCase();
    const isContainerTab = state.libraryTab === 'containers';

    // Update tab buttons
    document.querySelectorAll('.library-tab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.tab === state.libraryTab);
    });

    // Update action buttons visibility
    const nodesActions = document.getElementById('libraryActionsNodes');
    const containerActions = document.getElementById('libraryActionsContainers');
    if (nodesActions) nodesActions.style.display = isContainerTab ? 'none' : 'block';
    if (containerActions) containerActions.style.display = isContainerTab ? 'block' : 'none';

    if (isContainerTab) {
      renderContainerShapesLibrary(searchTerm);
    } else {
      renderNodeShapesLibrary(searchTerm);
    }

    // Update selection bar after render
    if (typeof updateLibrarySelectionActions === 'function') {
      updateLibrarySelectionActions();
    }
  }

  // Render node shapes library
  function renderNodeShapesLibrary(searchTerm) {
    const shapes = state.shapeLibrary.shapes;
    const categories = state.shapeLibrary.categories;

    // Group shapes by category
    const byCategory = {};
    categories.forEach(cat => byCategory[cat] = []);

    Object.entries(shapes).forEach(([id, shape]) => {
      if (searchTerm && !shape.name.toLowerCase().includes(searchTerm)) return;
      const cat = shape.category || 'Custom';
      if (!byCategory[cat]) byCategory[cat] = [];
      byCategory[cat].push({ id, ...shape });
    });

    // Check if library is empty
    const totalShapes = Object.keys(shapes).length;

    if (totalShapes === 0) {
      libraryContent.innerHTML = `
        <div class="library-empty">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="3" y="3" width="18" height="18" rx="2"/>
            <circle cx="12" cy="10" r="3"/>
            <path d="M6 21v-2a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v2"/>
          </svg>
          <div>No node shapes in library</div>
          <div style="font-size:10px; margin-top:4px;">Import SVGs or save nodes to build your library</div>
        </div>
      `;
      return;
    }

    let html = '';
    categories.forEach(cat => {
      const items = byCategory[cat];
      if (items.length === 0 && !searchTerm) return; // Hide empty categories unless searching

      html += `
        <div class="library-category" data-category="${cat}">
          <div class="library-category-header" onclick="this.parentElement.classList.toggle('collapsed')">
            <span class="arrow">â–¼</span>
            <span>${cat}</span>
            <span style="margin-left:auto; opacity:0.6; font-size:10px;">${items.length}</span>
          </div>
          <div class="library-items">
      `;

      items.forEach(item => {
        const thumb = generateShapeThumbnail(item);
        const selClass = state.selectedLibraryItems.has(item.id) ? ' selected' : '';
        html += `
          <div class="library-item${selClass}" draggable="true" data-library-id="${item.id}" data-library-type="node" title="${item.name}">
            <div class="library-item-preview">${thumb}</div>
            <div class="library-item-name">${item.name}</div>
            <div class="library-item-menu" onclick="event.stopPropagation(); showLibraryItemMenu('${item.id}', event)">â‹®</div>
          </div>
        `;
      });

      html += '</div></div>';
    });

    libraryContent.innerHTML = html;

    // Add drag, click, and dblclick handlers
    libraryContent.querySelectorAll('.library-item[data-library-id]').forEach(item => {
      item.addEventListener('dragstart', handleLibraryDragStart);
      item.addEventListener('dblclick', handleLibraryDoubleClick);
      item.addEventListener('click', handleLibraryItemClick);
    });
  }

  // Render container shapes library
  function renderContainerShapesLibrary(searchTerm) {
    const shapes = state.shapeLibrary.containerShapes || {};
    const categories = state.shapeLibrary.containerCategories || ['Countries', 'Custom'];

    // Group shapes by category
    const byCategory = {};
    categories.forEach(cat => byCategory[cat] = []);

    Object.entries(shapes).forEach(([id, shape]) => {
      if (searchTerm && !shape.name.toLowerCase().includes(searchTerm)) return;
      const cat = shape.category || 'Custom';
      if (!byCategory[cat]) byCategory[cat] = [];
      byCategory[cat].push({ id, ...shape });
    });

    // Check if library is empty
    const totalShapes = Object.keys(shapes).length;

    if (totalShapes === 0) {
      libraryContent.innerHTML = `
        <div class="library-empty">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="2" y="4" width="20" height="16" rx="2"/>
            <path d="M2 8h20"/>
            <path d="M8 4v4"/>
          </svg>
          <div>No container shapes</div>
          <div style="font-size:10px; margin-top:4px;">Import country or region SVGs to create shaped containers</div>
        </div>
      `;
      return;
    }

    let html = '';
    categories.forEach(cat => {
      const items = byCategory[cat];
      if (items.length === 0 && !searchTerm) return;

      // Collapse all categories by default (expand when user is searching)
      const collapsed = searchTerm ? '' : ' collapsed';

      html += `
        <div class="library-category${collapsed}" data-category="${cat}">
          <div class="library-category-header" onclick="this.parentElement.classList.toggle('collapsed')">
            <span class="arrow">â–¼</span>
            <span>${cat}</span>
            <span style="margin-left:auto; opacity:0.6; font-size:10px;">${items.length}</span>
          </div>
          <div class="library-items">
      `;

      items.forEach(item => {
        // Generate thumbnail - for container shapes, show the SVG
        const thumb = item.svgData || '<svg viewBox="0 0 24 24"><rect x="2" y="2" width="20" height="20" fill="none" stroke="currentColor"/></svg>';
        const selClass = state.selectedLibraryItems.has(item.id) ? ' selected' : '';
        html += `
          <div class="library-item${selClass}" draggable="true" data-container-shape-id="${item.id}" data-library-type="container" title="${item.name} - Drag to canvas to create container">
            <div class="library-item-preview" style="opacity:0.7;">${thumb}</div>
            <div class="library-item-name">${item.name}</div>
            <div class="library-item-menu" onclick="event.stopPropagation(); showContainerShapeMenu('${item.id}', event)">â‹®</div>
          </div>
        `;
      });

      html += '</div></div>';
    });

    libraryContent.innerHTML = html;

    // Add drag, click, and dblclick handlers for container shapes
    libraryContent.querySelectorAll('.library-item[data-container-shape-id]').forEach(item => {
      // Enable dragging
      item.addEventListener('dragstart', (e) => {
        const shapeId = item.dataset.containerShapeId;
        e.dataTransfer.setData('application/x-container-shape', shapeId);
        e.dataTransfer.effectAllowed = 'copy';
      });

      // Double-click to apply to selected container
      item.addEventListener('dblclick', (e) => {
        const shapeId = item.dataset.containerShapeId;
        // If a container is selected, apply shape to it
        if (state.selected?.type === 'group' || state.selection.groups.size > 0) {
          applyContainerShapeToSelected(shapeId);
        } else {
          showToast('Drag to canvas to create container, or select a container first');
        }
      });

      // Click for selection
      item.addEventListener('click', handleLibraryItemClick);
    });
  }

  // Handle drag start from library
  function handleLibraryDragStart(e) {
    const libraryId = e.currentTarget.dataset.libraryId;
    e.dataTransfer.setData('application/x-library-shape', libraryId);
    e.dataTransfer.effectAllowed = 'copy';
  }

  // Handle double-click on library item (create at center of visible view)
  function handleLibraryDoubleClick(e) {
    const libraryId = e.currentTarget.dataset.libraryId;
    const wrap = document.getElementById('wrap');
    if (wrap) {
      // Calculate center of visible area in canvas coordinates
      const centerScreenX = wrap.scrollLeft + wrap.clientWidth / 2;
      const centerScreenY = wrap.scrollTop + wrap.clientHeight / 2;
      const centerX = centerScreenX / state.zoom;
      const centerY = centerScreenY / state.zoom;
      createNodeFromLibrary(libraryId, centerX, centerY);
    } else {
      // Fallback: center of canvas
      createNodeFromLibrary(libraryId, state.canvasWidth / 2, state.canvasHeight / 2);
    }
  }

  // Handle click on library item for selection (single-click = select, Shift+click = toggle multi-select)
  function handleLibraryItemClick(e) {
    // Don't interfere with the â‹® menu button
    if (e.target.closest('.library-item-menu')) return;

    const el = e.currentTarget;
    const itemId = el.dataset.libraryId || el.dataset.containerShapeId;
    if (!itemId) return;

    if (e.shiftKey) {
      // Shift+click: toggle this item in multi-selection
      if (state.selectedLibraryItems.has(itemId)) {
        state.selectedLibraryItems.delete(itemId);
        el.classList.remove('selected');
      } else {
        state.selectedLibraryItems.add(itemId);
        el.classList.add('selected');
      }
    } else {
      // Normal click: select only this item (clear others)
      state.selectedLibraryItems.clear();
      libraryContent.querySelectorAll('.library-item.selected').forEach(s => s.classList.remove('selected'));
      state.selectedLibraryItems.add(itemId);
      el.classList.add('selected');
    }

    updateLibrarySelectionActions();
  }

  // Update the library selection action bar (show/hide Delete Selected button)
  function updateLibrarySelectionActions() {
    const count = state.selectedLibraryItems.size;
    let bar = document.getElementById('librarySelectionBar');

    if (count === 0) {
      if (bar) bar.style.display = 'none';
      return;
    }

    if (!bar) {
      bar = document.createElement('div');
      bar.id = 'librarySelectionBar';
      bar.style.cssText = 'display:flex; gap:4px; padding:4px 8px; background:#f0f0ff; border-top:1px solid #ddd; align-items:center; font-size:11px;';
      // Insert before the action buttons at the bottom
      const actionsNodes = document.getElementById('libraryActionsNodes');
      const actionsContainers = document.getElementById('libraryActionsContainers');
      const insertBefore = (state.libraryTab === 'containers' ? actionsContainers : actionsNodes) || actionsNodes;
      if (insertBefore) {
        insertBefore.parentElement.insertBefore(bar, insertBefore);
      }
    }

    bar.style.display = 'flex';
    bar.innerHTML = `
      <span style="flex:1; color:#444;">${count} selected</span>
      <button id="btnDeleteSelectedLibrary" style="padding:2px 8px; font-size:11px; background:#fee2e2; border:1px solid #fca5a5; border-radius:4px; cursor:pointer; color:#b91c1c;">Delete</button>
      <button id="btnClearLibrarySelection" style="padding:2px 8px; font-size:11px; background:#f3f4f6; border:1px solid #d1d5db; border-radius:4px; cursor:pointer; color:#374151;">Clear</button>
    `;

    document.getElementById('btnDeleteSelectedLibrary').addEventListener('click', deleteSelectedLibraryItems);
    document.getElementById('btnClearLibrarySelection').addEventListener('click', () => {
      state.selectedLibraryItems.clear();
      libraryContent.querySelectorAll('.library-item.selected').forEach(s => s.classList.remove('selected'));
      updateLibrarySelectionActions();
    });
  }

  // Delete all selected library items
  function deleteSelectedLibraryItems() {
    const count = state.selectedLibraryItems.size;
    if (count === 0) return;

    if (!confirm(`Delete ${count} selected shape(s) from library?`)) return;

    state.selectedLibraryItems.forEach(id => {
      if (state.shapeLibrary.shapes[id]) {
        delete state.shapeLibrary.shapes[id];
      }
      if (state.shapeLibrary.containerShapes && state.shapeLibrary.containerShapes[id]) {
        delete state.shapeLibrary.containerShapes[id];
      }
    });

    state.selectedLibraryItems.clear();
    saveShapeLibrary();
    renderLibraryPanel();
    showToast(`Deleted ${count} shape(s)`);
  }

  // Create node from library shape
  function createNodeFromLibrary(libraryId, x, y) {
    const libShape = state.shapeLibrary.shapes[libraryId];
    if (!libShape) {
      showToast('Library shape not found');
      return;
    }

    const node = {
      id: state.nextNode++,
      x: Math.round(x),
      y: Math.round(y),
      name: libShape.defaultName || libShape.name || 'Node',
      tag: libShape.defaultCode || '',
      r: libShape.r || 24,
      fill: libShape.fill || '#1b2030',
      stroke: libShape.stroke || '#9fb3ff',
      strokeW: libShape.strokeW || 2,
      shape: libShape.shape || 'circle',
      nameColor: libShape.nameColor,
      nameFont: libShape.nameFont,
      tagColor: libShape.tagColor,
      tagFont: libShape.tagFont,
      // For custom SVG shapes
      libraryShapeId: libShape.type === 'svg' ? libraryId : null,
      customSvg: libShape.type === 'svg' ? libShape.svgData : null
    };

    state.nodes.push(node);
    state.selected = { type: 'node', id: node.id };
    commit();
    render();
    showToast(`Created: ${node.name}`);
  }

  // Save current node to library
  function saveNodeToLibrary(node) {
    if (!node) {
      showToast('No node selected');
      return;
    }

    const name = prompt('Enter a name for this library shape:', node.name || 'My Shape');
    if (!name) return;

    const category = prompt('Enter category:', 'Custom') || 'Custom';

    // Add category if new
    if (!state.shapeLibrary.categories.includes(category)) {
      state.shapeLibrary.categories.push(category);
    }

    const libShape = {
      id: 'lib-' + Date.now(),
      name: name,
      category: category,
      type: node.customSvg ? 'svg' : 'builtin',
      shape: node.shape || 'circle',
      r: node.r || 24,
      fill: node.fill,
      stroke: node.stroke,
      strokeW: node.strokeW,
      nameColor: node.nameColor,
      nameFont: node.nameFont,
      tagColor: node.tagColor,
      tagFont: node.tagFont,
      defaultName: node.name,
      defaultCode: node.tag,
      svgData: node.customSvg || null
    };

    state.shapeLibrary.shapes[libShape.id] = libShape;
    saveShapeLibrary();
    renderLibraryPanel();
    showToast(`Saved "${name}" to library`);
  }

  // Import SVG file to library
  function importSVGToLibrary(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      let svgContent = e.target.result;

      // Parse and clean SVG
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgContent, 'image/svg+xml');
      const svgEl = doc.querySelector('svg');

      if (!svgEl) {
        showToast('Invalid SVG file');
        return;
      }

      // Ensure viewBox exists
      if (!svgEl.getAttribute('viewBox')) {
        const w = svgEl.getAttribute('width') || 64;
        const h = svgEl.getAttribute('height') || 64;
        svgEl.setAttribute('viewBox', `0 0 ${parseFloat(w)} ${parseFloat(h)}`);
      }

      // Remove width/height to make scalable
      svgEl.removeAttribute('width');
      svgEl.removeAttribute('height');

      const cleanSvg = svgEl.outerHTML;

      const name = prompt('Enter a name for this shape:', file.name.replace('.svg', ''));
      if (!name) return;

      const category = prompt('Enter category:', 'Custom') || 'Custom';

      // Add category if new
      if (!state.shapeLibrary.categories.includes(category)) {
        state.shapeLibrary.categories.push(category);
      }

      const libShape = {
        id: 'lib-' + Date.now(),
        name: name,
        category: category,
        type: 'svg',
        svgData: cleanSvg,
        r: 24,
        fill: '#667eea',
        stroke: '#4a5568',
        strokeW: 2
      };

      state.shapeLibrary.shapes[libShape.id] = libShape;
      saveShapeLibrary();
      renderLibraryPanel();
      showToast(`Imported "${name}" to library`);
    };
    reader.readAsText(file);
  }

  // Import SVG as container shape (decorative)
  function importContainerShapeSVG(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      let svgContent = e.target.result;

      // Parse SVG
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgContent, 'image/svg+xml');
      const svgEl = doc.querySelector('svg');

      if (!svgEl) {
        showToast('Invalid SVG file');
        return;
      }

      // Get or compute viewBox
      let viewBox = svgEl.getAttribute('viewBox');
      if (!viewBox) {
        const w = parseFloat(svgEl.getAttribute('width')) || 100;
        const h = parseFloat(svgEl.getAttribute('height')) || 100;
        viewBox = `0 0 ${w} ${h}`;
      }

      // Simplify complex SVGs by combining all paths
      const allPaths = svgEl.querySelectorAll('path');
      let combinedPathD = '';

      if (allPaths.length > 0) {
        // Combine all path d attributes
        allPaths.forEach(path => {
          const d = path.getAttribute('d');
          if (d) combinedPathD += d + ' ';
        });
      }

      // Create a simplified SVG with just the outline
      const [vbX, vbY, vbW, vbH] = viewBox.split(/\s+/).map(parseFloat);
      const simplifiedSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}" preserveAspectRatio="xMidYMid meet">
        <path d="${combinedPathD.trim()}" fill="currentColor" stroke="none" opacity="0.15"/>
      </svg>`;

      const name = prompt('Enter a name for this container shape:', file.name.replace('.svg', ''));
      if (!name) return;

      const category = prompt('Enter category:', 'Countries') || 'Countries';

      // Add category if new
      if (!state.shapeLibrary.containerCategories) {
        state.shapeLibrary.containerCategories = ['Countries', 'Custom'];
      }
      if (!state.shapeLibrary.containerCategories.includes(category)) {
        state.shapeLibrary.containerCategories.push(category);
      }

      const shapeId = 'container-' + Date.now();
      if (!state.shapeLibrary.containerShapes) {
        state.shapeLibrary.containerShapes = {};
      }

      state.shapeLibrary.containerShapes[shapeId] = {
        id: shapeId,
        name: name,
        category: category,
        svgData: simplifiedSvg,
        viewBox: viewBox,
        pathData: combinedPathD.trim()
      };

      saveShapeLibrary();
      renderLibraryPanel();
      showToast(`Imported "${name}" as container shape`);
    };
    reader.readAsText(file);
  }

  // Apply container shape to selected container
  function applyContainerShapeToSelected(shapeId) {
    const shape = state.shapeLibrary.containerShapes?.[shapeId];
    if (!shape) {
      showToast('Shape not found');
      return;
    }

    // Find selected container(s)
    const selectedGroups = [];
    if (state.selected?.type === 'group') {
      selectedGroups.push(state.selected.id);
    }
    state.selection.groups.forEach(id => selectedGroups.push(id));

    if (selectedGroups.length === 0) {
      showToast('Select a container first');
      return;
    }

    selectedGroups.forEach(groupId => {
      const group = findGroup(groupId);
      if (group) {
        group.decorativeShape = {
          id: shapeId,
          svgData: shape.svgData,
          pathData: shape.pathData,
          viewBox: shape.viewBox,
          name: shape.name
        };
      }
    });

    commit();
    render();
    showToast(`Applied "${shape.name}" to ${selectedGroups.length} container(s)`);
  }

  // Remove decorative shape from selected container(s)
  function removeContainerShapeFromSelected() {
    const selectedGroups = [];
    if (state.selected?.type === 'group') {
      selectedGroups.push(state.selected.id);
    }
    state.selection.groups.forEach(id => selectedGroups.push(id));

    if (selectedGroups.length === 0) {
      showToast('Select a container first');
      return;
    }

    let removed = 0;
    selectedGroups.forEach(groupId => {
      const group = findGroup(groupId);
      if (group && group.decorativeShape) {
        delete group.decorativeShape;
        removed++;
      }
    });

    if (removed > 0) {
      commit();
      render();
      showToast(`Removed shape from ${removed} container(s)`);
    } else {
      showToast('Selected containers have no decorative shape');
    }
  }

  // Show context menu for container shape library item
  window.showContainerShapeMenu = function(shapeId, event) {
    // Remove any existing menu
    const existingMenu = document.querySelector('.library-context-menu');
    if (existingMenu) existingMenu.remove();

    const menu = document.createElement('div');
    menu.className = 'library-context-menu';
    menu.style.cssText = `
      position: fixed;
      left: ${event.clientX}px;
      top: ${event.clientY}px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10000;
      min-width: 140px;
      padding: 4px 0;
    `;

    const items = [
      { label: 'âœï¸ Rename', action: () => renameContainerShape(shapeId) },
      { label: 'ðŸ—‘ï¸ Delete', action: () => deleteContainerShape(shapeId) }
    ];

    items.forEach(item => {
      const btn = document.createElement('button');
      btn.textContent = item.label;
      btn.style.cssText = `
        display: block;
        width: 100%;
        padding: 8px 12px;
        border: none;
        background: none;
        text-align: left;
        cursor: pointer;
        font-size: 12px;
      `;
      btn.onmouseenter = () => btn.style.background = '#f0f0f0';
      btn.onmouseleave = () => btn.style.background = 'none';
      btn.onclick = () => {
        menu.remove();
        item.action();
      };
      menu.appendChild(btn);
    });

    document.body.appendChild(menu);

    // Close on click outside
    setTimeout(() => {
      document.addEventListener('click', () => menu.remove(), { once: true });
    }, 0);
  };

  // Rename container shape
  function renameContainerShape(shapeId) {
    const shape = state.shapeLibrary.containerShapes?.[shapeId];
    if (!shape) return;

    const newName = prompt('Enter new name:', shape.name);
    if (newName && newName !== shape.name) {
      shape.name = newName;
      saveShapeLibrary();
      renderLibraryPanel();
      showToast(`Renamed to "${newName}"`);
    }
  }

  // Delete container shape from library
  function deleteContainerShape(shapeId) {
    const shape = state.shapeLibrary.containerShapes?.[shapeId];
    if (!shape) return;

    if (confirm(`Delete "${shape.name}" from library?`)) {
      delete state.shapeLibrary.containerShapes[shapeId];
      saveShapeLibrary();
      renderLibraryPanel();
      showToast(`Deleted "${shape.name}"`);
    }
  }

  // Export library to file
  function exportShapeLibrary() {
    // Prompt for custom filename
    const defaultName = 'netmap-library';
    const fileName = prompt('Enter library filename:', defaultName);
    if (!fileName) return; // User cancelled

    const data = JSON.stringify(state.shapeLibrary, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    // Ensure .ndl extension
    const finalName = fileName.endsWith('.ndl') ? fileName : fileName + '.ndl';
    a.download = finalName;
    a.click();
    URL.revokeObjectURL(url);
    showToast(`Library exported as "${finalName}"`);
  }

  // Import library from file
  function importLibraryFromFile(file) {
    console.log('[Library Import] Starting import of file:', file.name);
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        console.log('[Library Import] File read successfully, parsing JSON...');
        const imported = JSON.parse(e.target.result);
        console.log('[Library Import] Parsed data:', Object.keys(imported));

        // Validate the imported data has expected structure
        if (!imported.shapes && !imported.containerShapes && !imported.categories) {
          showToast('âš ï¸ Invalid library format - missing shapes data');
          console.error('[Library Import] Invalid format - no shapes, containerShapes, or categories found');
          return;
        }

        // Merge with existing library
        const mergeMode = confirm('Merge with existing library?\n\nOK = Merge (add imported shapes to current library)\nCancel = Replace (clear current library and use imported)');

        if (mergeMode) {
          // Merge node shapes
          const importedShapeCount = Object.keys(imported.shapes || {}).length;
          Object.assign(state.shapeLibrary.shapes, imported.shapes || {});
          // Merge node categories
          (imported.categories || []).forEach(cat => {
            if (!state.shapeLibrary.categories.includes(cat)) {
              state.shapeLibrary.categories.push(cat);
            }
          });
          // Merge container shapes
          if (imported.containerShapes) {
            if (!state.shapeLibrary.containerShapes) state.shapeLibrary.containerShapes = {};
            const importedContainerCount = Object.keys(imported.containerShapes).length;
            Object.assign(state.shapeLibrary.containerShapes, imported.containerShapes);
          }
          // Merge container categories
          (imported.containerCategories || []).forEach(cat => {
            if (!state.shapeLibrary.containerCategories) {
              state.shapeLibrary.containerCategories = ['Countries', 'Custom'];
            }
            if (!state.shapeLibrary.containerCategories.includes(cat)) {
              state.shapeLibrary.containerCategories.push(cat);
            }
          });
          console.log('[Library Import] Merged successfully');
        } else {
          state.shapeLibrary = imported;
          // Ensure container arrays exist
          if (!state.shapeLibrary.containerShapes) state.shapeLibrary.containerShapes = {};
          if (!state.shapeLibrary.containerCategories) {
            state.shapeLibrary.containerCategories = ['Countries', 'Custom'];
          }
          if (!state.shapeLibrary.shapes) state.shapeLibrary.shapes = {};
          if (!state.shapeLibrary.categories) state.shapeLibrary.categories = ['Network Devices', 'Cloud Services', 'Custom'];
          console.log('[Library Import] Replaced library');
        }

        saveShapeLibrary();
        renderLibraryPanel();

        const shapeCount = Object.keys(state.shapeLibrary.shapes || {}).length;
        const containerCount = Object.keys(state.shapeLibrary.containerShapes || {}).length;
        showToast(`âœ… Library imported: ${shapeCount} node shapes, ${containerCount} container shapes`);
      } catch (err) {
        console.error('[Library Import] Error:', err);
        showToast('âŒ Invalid library file: ' + err.message);
      }
    };
    reader.onerror = (err) => {
      console.error('[Library Import] File read error:', err);
      showToast('âŒ Failed to read file');
    };
    reader.readAsText(file);
  }

  // Show context menu for library item
  window.showLibraryItemMenu = function(libraryId, event) {
    // Remove existing menu
    document.querySelectorAll('.context-menu').forEach(m => m.remove());

    const menu = document.createElement('div');
    menu.className = 'context-menu';
    menu.innerHTML = `
      <div class="context-menu-item" data-action="rename">âœï¸ Rename</div>
      <div class="context-menu-item" data-action="duplicate">ðŸ“‹ Duplicate</div>
      <div class="context-menu-item" data-action="category">ðŸ“ Change Category</div>
      <div class="context-menu-sep"></div>
      <div class="context-menu-item danger" data-action="delete">ðŸ—‘ï¸ Delete</div>
    `;

    menu.style.left = event.clientX + 'px';
    menu.style.top = event.clientY + 'px';
    document.body.appendChild(menu);

    menu.addEventListener('click', (e) => {
      const action = e.target.dataset.action;
      if (!action) return;

      const shape = state.shapeLibrary.shapes[libraryId];
      if (!shape) return;

      switch (action) {
        case 'rename':
          const newName = prompt('New name:', shape.name);
          if (newName) {
            shape.name = newName;
            saveShapeLibrary();
            renderLibraryPanel();
          }
          break;
        case 'duplicate':
          const dupShape = { ...shape, id: 'lib-' + Date.now(), name: shape.name + ' Copy' };
          state.shapeLibrary.shapes[dupShape.id] = dupShape;
          saveShapeLibrary();
          renderLibraryPanel();
          showToast('Shape duplicated');
          break;
        case 'category':
          const newCat = prompt('New category:', shape.category);
          if (newCat) {
            shape.category = newCat;
            if (!state.shapeLibrary.categories.includes(newCat)) {
              state.shapeLibrary.categories.push(newCat);
            }
            saveShapeLibrary();
            renderLibraryPanel();
          }
          break;
        case 'delete':
          if (confirm(`Delete "${shape.name}" from library?`)) {
            delete state.shapeLibrary.shapes[libraryId];
            saveShapeLibrary();
            renderLibraryPanel();
            showToast('Shape deleted');
          }
          break;
      }

      menu.remove();
    });

    // Close on click outside
    setTimeout(() => {
      document.addEventListener('click', function closeMenu() {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }, { once: true });
    }, 0);
  };

  // Toggle library panel from toolbar button
  if (btnToggleLibrary && shapeLibraryPanel) {
    btnToggleLibrary.addEventListener('click', () => {
      const isVisible = shapeLibraryPanel.classList.contains('visible');
      shapeLibraryPanel.classList.toggle('visible');
      btnToggleLibrary.classList.toggle('active', !isVisible);
      localStorage.setItem('netmap-library-visible', !isVisible);
    });

    // Restore visibility state (default: hidden)
    if (localStorage.getItem('netmap-library-visible') === 'true') {
      shapeLibraryPanel.classList.add('visible');
      btnToggleLibrary.classList.add('active');
    }
  }

  // Close button in library header
  if (btnLibraryClose && shapeLibraryPanel) {
    btnLibraryClose.addEventListener('click', () => {
      shapeLibraryPanel.classList.remove('visible');
      if (btnToggleLibrary) btnToggleLibrary.classList.remove('active');
      localStorage.setItem('netmap-library-visible', 'false');
    });
  }

  // Tab switching for library
  document.querySelectorAll('.library-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      state.libraryTab = tab.dataset.tab;
      renderLibraryPanel();
    });
  });

  // Container shape action buttons
  const btnApplyContainerShape = document.getElementById('btnApplyContainerShape');
  const btnImportContainerShape = document.getElementById('btnImportContainerShape');
  const btnRemoveContainerShape = document.getElementById('btnRemoveContainerShape');

  if (btnApplyContainerShape) {
    btnApplyContainerShape.addEventListener('click', () => {
      const selected = libraryContent?.querySelector('.library-item.selected[data-container-shape-id]');
      if (selected) {
        applyContainerShapeToSelected(selected.dataset.containerShapeId);
      } else {
        showToast('Select a shape first, then select a container');
      }
    });
  }

  if (btnImportContainerShape) {
    btnImportContainerShape.addEventListener('click', () => {
      // Trigger file input for container shape import
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.svg,image/svg+xml';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (file) importContainerShapeSVG(file);
      };
      input.click();
    });
  }

  if (btnRemoveContainerShape) {
    btnRemoveContainerShape.addEventListener('click', () => {
      removeContainerShapeFromSelected();
    });
  }

  // Draggable library panel
  if (shapeLibraryPanel) {
    const libraryHeader = shapeLibraryPanel.querySelector('.library-header');
    let isDragging = false;
    let dragStartX, dragStartY, panelStartX, panelStartY;

    // Restore saved position
    const savedPos = localStorage.getItem('netmap-library-position');
    if (savedPos) {
      try {
        const pos = JSON.parse(savedPos);
        shapeLibraryPanel.style.left = pos.x + 'px';
        shapeLibraryPanel.style.top = pos.y + 'px';
        // Remove default positioning if custom position exists
        shapeLibraryPanel.style.right = 'auto';
      } catch (e) {}
    }

    if (libraryHeader) {
      libraryHeader.addEventListener('mousedown', (e) => {
        // Don't start drag if clicking on buttons
        if (e.target.closest('.library-header-btn')) return;

        // Don't allow dragging when docked
        if (shapeLibraryPanel.classList.contains('docked')) return;

        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;

        const rect = shapeLibraryPanel.getBoundingClientRect();
        panelStartX = rect.left;
        panelStartY = rect.top;

        shapeLibraryPanel.style.transition = 'none';
        shapeLibraryPanel.style.cursor = 'grabbing';
        document.body.style.userSelect = 'none';

        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;

        let newX = panelStartX + dx;
        let newY = panelStartY + dy;

        // Keep panel within viewport bounds
        const panelRect = shapeLibraryPanel.getBoundingClientRect();
        const maxX = window.innerWidth - 50; // Leave some visible
        const maxY = window.innerHeight - 50;

        newX = Math.max(-panelRect.width + 50, Math.min(newX, maxX));
        newY = Math.max(0, Math.min(newY, maxY));

        shapeLibraryPanel.style.left = newX + 'px';
        shapeLibraryPanel.style.top = newY + 'px';
        shapeLibraryPanel.style.right = 'auto';
      });

      document.addEventListener('mouseup', () => {
        if (!isDragging) return;

        isDragging = false;
        shapeLibraryPanel.style.transition = '';
        shapeLibraryPanel.style.cursor = '';
        document.body.style.userSelect = '';

        // Save position
        const rect = shapeLibraryPanel.getBoundingClientRect();
        localStorage.setItem('netmap-library-position', JSON.stringify({
          x: rect.left,
          y: rect.top
        }));
      });
    }

    // Reset position button (double-click on header)
    if (libraryHeader) {
      libraryHeader.addEventListener('dblclick', (e) => {
        if (e.target.closest('.library-header-btn')) return;

        // Reset to default position
        shapeLibraryPanel.style.left = '0px';
        shapeLibraryPanel.style.top = '120px';
        shapeLibraryPanel.style.right = 'auto';
        localStorage.removeItem('netmap-library-position');
        showToast('Library position reset');
      });
    }
  }

  // Library search
  if (librarySearch) {
    librarySearch.addEventListener('input', () => {
      renderLibraryPanel();
    });
  }

  // Save node to library button
  if (btnSaveNodeToLibrary) {
    btnSaveNodeToLibrary.addEventListener('click', () => {
      if (state.selected?.type === 'node') {
        const node = findNode(state.selected.id);
        saveNodeToLibrary(node);
      } else {
        showToast('Select a node first');
      }
    });
  }

  // Import SVG button
  if (btnImportSVGToLibrary) {
    btnImportSVGToLibrary.addEventListener('click', () => {
      svgImportInput?.click();
    });
  }

  if (btnLibraryImport) {
    btnLibraryImport.addEventListener('click', () => {
      svgImportInput?.click();
    });
  }

  // SVG file input handler
  if (svgImportInput) {
    svgImportInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        importSVGToLibrary(file);
        svgImportInput.value = '';
      }
    });
  }

  // Export library button
  if (btnExportLibrary) {
    btnExportLibrary.addEventListener('click', exportShapeLibrary);
  }

  // Import library button (new dedicated button)
  const btnImportLibraryFile = document.getElementById('btnImportLibraryFile');
  if (btnImportLibraryFile) {
    btnImportLibraryFile.addEventListener('click', () => {
      libraryImportInput?.click();
    });
  }

  // Dock/Undock button handler
  const btnLibraryDock = document.getElementById('btnLibraryDock');
  const wrapElement = document.getElementById('wrap');
  const headerElement = document.querySelector('header');

  // Function to get header height
  function getHeaderHeight() {
    return headerElement ? headerElement.offsetHeight : 115;
  }

  // Function to apply docked position
  function applyDockedPosition() {
    if (!shapeLibraryPanel) return;
    const headerH = getHeaderHeight();
    shapeLibraryPanel.style.top = headerH + 'px';
    shapeLibraryPanel.style.height = `calc(100vh - ${headerH}px)`;
    shapeLibraryPanel.style.maxHeight = `calc(100vh - ${headerH}px)`;
  }

  // Load docked state from localStorage
  const savedDockedState = localStorage.getItem('netmap-library-docked') === 'true';
  if (savedDockedState && shapeLibraryPanel) {
    shapeLibraryPanel.classList.add('docked');
    wrapElement?.classList.add('library-docked');
    if (btnLibraryDock) btnLibraryDock.classList.add('active');
    // Apply position after a small delay to ensure header is rendered
    setTimeout(applyDockedPosition, 50);
  }

  if (btnLibraryDock) {
    btnLibraryDock.addEventListener('click', (e) => {
      e.stopPropagation();

      const isDocked = shapeLibraryPanel.classList.toggle('docked');
      wrapElement?.classList.toggle('library-docked', isDocked);
      btnLibraryDock.classList.toggle('active', isDocked);

      // Save docked state
      localStorage.setItem('netmap-library-docked', isDocked);

      if (isDocked) {
        // Position below header when docking
        shapeLibraryPanel.style.left = '0px';
        applyDockedPosition();
        showToast('ðŸ“Œ Library docked to left side');
      } else {
        // Restore floating position
        shapeLibraryPanel.style.left = '0px';
        shapeLibraryPanel.style.top = '120px';
        shapeLibraryPanel.style.height = '';
        shapeLibraryPanel.style.maxHeight = 'calc(100vh - 140px)';
        showToast('ðŸ“Œ Library undocked');
      }
    });
  }

  // Update docked position on window resize
  window.addEventListener('resize', () => {
    if (shapeLibraryPanel?.classList.contains('docked')) {
      applyDockedPosition();
    }
  });

  // Library menu button
  if (btnLibraryMenu) {
    btnLibraryMenu.addEventListener('click', (e) => {
      e.stopPropagation();

      // Remove existing menu
      document.querySelectorAll('.context-menu').forEach(m => m.remove());

      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.innerHTML = `
        <div class="context-menu-item" data-action="import-lib">ðŸ“¥ Import Library File</div>
        <div class="context-menu-item" data-action="export-lib">ðŸ“¤ Export Library</div>
        <div class="context-menu-sep"></div>
        <div class="context-menu-item" data-action="add-category">ðŸ“ Add Category</div>
        <div class="context-menu-sep"></div>
        <div class="context-menu-item danger" data-action="clear-lib">ðŸ—‘ï¸ Clear Library</div>
      `;

      const rect = btnLibraryMenu.getBoundingClientRect();
      menu.style.left = rect.left + 'px';
      menu.style.top = rect.bottom + 4 + 'px';
      document.body.appendChild(menu);

      menu.addEventListener('click', (ev) => {
        const action = ev.target.dataset.action;

        switch (action) {
          case 'import-lib':
            libraryImportInput?.click();
            break;
          case 'export-lib':
            exportShapeLibrary();
            break;
          case 'add-category':
            const newCat = prompt('New category name:');
            if (newCat && !state.shapeLibrary.categories.includes(newCat)) {
              state.shapeLibrary.categories.push(newCat);
              saveShapeLibrary();
              renderLibraryPanel();
              showToast(`Added category: ${newCat}`);
            }
            break;
          case 'clear-lib':
            if (confirm('Clear entire library? This cannot be undone.')) {
              state.shapeLibrary.shapes = {};
              saveShapeLibrary();
              renderLibraryPanel();
              showToast('Library cleared');
            }
            break;
        }

        menu.remove();
      });

      setTimeout(() => {
        document.addEventListener('click', function closeMenu() {
          menu.remove();
          document.removeEventListener('click', closeMenu);
        }, { once: true });
      }, 0);
    });
  }

  // Library import file handler
  if (libraryImportInput) {
    libraryImportInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        importLibraryFromFile(file);
        libraryImportInput.value = '';
      }
    });
  }

  // Handle drop on canvas from library
  const svgContainer = document.getElementById('svgContainer');
  if (svgContainer) {
    svgContainer.addEventListener('dragover', (e) => {
      if (e.dataTransfer.types.includes('application/x-library-shape') ||
          e.dataTransfer.types.includes('application/x-container-shape')) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
      }
    });

    svgContainer.addEventListener('drop', (e) => {
      // Handle node shape drop
      const libraryId = e.dataTransfer.getData('application/x-library-shape');
      if (libraryId) {
        e.preventDefault();
        // Use SVG coordinate transform (same as getMouse)
        const pt = svg.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
        createNodeFromLibrary(libraryId, svgPt.x, svgPt.y);
        return;
      }

      // Handle container shape drop
      const containerShapeId = e.dataTransfer.getData('application/x-container-shape');
      if (containerShapeId) {
        e.preventDefault();
        const pt = svg.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgPt = pt.matrixTransform(svg.getScreenCTM().inverse());
        createContainerFromShape(containerShapeId, svgPt.x, svgPt.y);
      }
    });
  }

  // Create container from library shape
  function createContainerFromShape(shapeId, x, y) {
    const shape = state.shapeLibrary.containerShapes?.[shapeId];
    if (!shape) {
      showToast('Shape not found in library');
      return;
    }

    // Parse viewBox to get aspect ratio
    const vbParts = (shape.viewBox || '0 0 100 100').split(/\s+/).map(parseFloat);
    const origW = vbParts[2] || 100;
    const origH = vbParts[3] || 100;
    const aspectRatio = origW / origH;

    // Default container size, respecting aspect ratio
    let containerW = 300;
    let containerH = containerW / aspectRatio;

    // Ensure minimum size
    if (containerH < 150) {
      containerH = 150;
      containerW = containerH * aspectRatio;
    }
    if (containerW < 200) {
      containerW = 200;
      containerH = containerW / aspectRatio;
    }

    // Center on drop point
    const groupX = x - containerW / 2;
    const groupY = y - containerH / 2;

    // Create the container
    const newGroup = {
      id: Date.now(),
      uuid: generateUUID(),
      type: 'country',
      title: shape.name,
      x: groupX,
      y: groupY,
      w: Math.round(containerW),
      h: Math.round(containerH),
      fill: 'rgba(54, 76, 140, 0.08)',
      stroke: '#6073b8',
      strokeW: 2,
      titleColor: '#eaeaea',
      titleFont: 14,
      filterTags: ['default'],
      // Shape as the visual container
      shapeContainer: true,
      decorativeShape: {
        id: shapeId,
        svgData: shape.svgData,
        pathData: shape.pathData,
        viewBox: shape.viewBox,
        name: shape.name,
        aspectRatio: aspectRatio
      }
    };

    state.groups.push(newGroup);
    select({ type: 'group', id: newGroup.id });
    commit();
    render();
    showToast(`Created "${shape.name}" container`);
  }

  // ============== CONTEXT MENU SYSTEM ==============

  // Shared clipboard for copy/paste style
  let _ctxStyleClipboard = null;

  function showContextMenu(e, items) {
    e.preventDefault();
    e.stopPropagation();
    document.querySelectorAll('.context-menu').forEach(m => m.remove());

    const menu = document.createElement('div');
    menu.className = 'context-menu';
    menu.innerHTML = items.map(item => {
      if (item === '---') return '<div class="context-menu-sep"></div>';
      if (item.header) return `<div class="context-menu-header">${item.header}</div>`;
      const cls = ['context-menu-item'];
      if (item.danger) cls.push('danger');
      if (item.disabled) cls.push('disabled');
      return `<div class="${cls.join(' ')}" data-action="${item.action}">${item.icon || ''} ${item.label}</div>`;
    }).join('');

    // Position with viewport bounds check
    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
    document.body.appendChild(menu);

    // Adjust if overflowing viewport
    const rect = menu.getBoundingClientRect();
    if (rect.right > window.innerWidth) menu.style.left = (e.clientX - rect.width) + 'px';
    if (rect.bottom > window.innerHeight) menu.style.top = (e.clientY - rect.height) + 'px';

    return menu;
  }

  function bindContextMenu(menu, handler) {
    menu.addEventListener('click', (ev) => {
      const item = ev.target.closest('.context-menu-item');
      if (!item || item.classList.contains('disabled')) return;
      const action = item.dataset.action;
      if (action) handler(action);
      menu.remove();
    });
    setTimeout(() => {
      document.addEventListener('click', function closeMenu() {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }, { once: true });
    }, 0);
  }

  // ---- NODE CONTEXT MENU ----
  function showNodeContextMenu(e, node) {
    const connectedEdges = state.edges.filter(ed => ed.a === node.id || ed.b === node.id);
    const hasPasteStyle = _ctxStyleClipboard && _ctxStyleClipboard.type === 'node';

    const items = [
      { header: node.name || 'Node' },
      { action: 'connect', icon: '\u{1F517}', label: 'Start Link from Here' },
      { action: 'select-links', icon: '\u{21C4}', label: `Select Connected Links (${connectedEdges.length})`, disabled: connectedEdges.length === 0 },
      '---',
      { action: 'duplicate', icon: '\u{1F4CB}', label: 'Duplicate' },
      { action: 'add-to-library', icon: '\u{1F4DA}', label: 'Add to Library' },
      '---',
      { action: 'copy-style', icon: '\u{1F3A8}', label: 'Copy Style' },
      { action: 'paste-style', icon: '\u{1F58C}\u{FE0F}', label: 'Paste Style', disabled: !hasPasteStyle },
      '---',
      { action: 'geocode', icon: '\u{1F30D}', label: 'Geocode Address' },
      '---',
      { action: 'delete', icon: '\u{1F5D1}\u{FE0F}', label: 'Delete', danger: true }
    ];

    const menu = showContextMenu(e, items);
    bindContextMenu(menu, (action) => {
      switch (action) {
        case 'connect':
          linkMode = true;
          window.linkMode = true;
          linkSourceNode = node.id;
          window.linkSourceNode = node.id;
          state.connectFrom = node.id;
          const btn = document.getElementById('btnCreateLink');
          if (btn) btn.classList.add('primary');
          select({ type: 'node', id: node.id });
          showToast(`Link source: ${node.name || 'N' + node.id} \u{2192} Click target node`);
          render();
          break;
        case 'select-links':
          connectedEdges.forEach(ed => state.selection.edges.add(ed.id));
          state.selected = null;
          render();
          showToast(`Selected ${connectedEdges.length} connected link(s)`);
          break;
        case 'duplicate': {
          const dn = { ...node, id: state.nextNode++, uuid: generateUUID(), x: node.x + 30, y: node.y + 30, name: node.name + ' (copy)' };
          state.nodes.push(dn);
          select({ type: 'node', id: dn.id });
          commit(); render();
          showToast('Node duplicated');
          break;
        }
        case 'add-to-library':
          saveNodeToLibrary(node);
          break;
        case 'copy-style':
          _ctxStyleClipboard = { type: 'node', style: pickStyle('node', node) };
          showToast('Node style copied');
          break;
        case 'paste-style':
          if (_ctxStyleClipboard && _ctxStyleClipboard.type === 'node') {
            applyStyle('node', node, _ctxStyleClipboard.style);
            commit(); render();
            showToast('Style pasted');
          }
          break;
        case 'geocode':
          select({ type: 'node', id: node.id });
          render();
          setTimeout(() => useAddressForGps(), 100);
          break;
        case 'delete':
          select({ type: 'node', id: node.id });
          deleteSelected();
          break;
      }
    });
  }

  // ---- EDGE CONTEXT MENU ----
  function showEdgeContextMenu(e, edge) {
    const nodeA = findNode(edge.a);
    const nodeB = findNode(edge.b);
    const hasPath = !!(edge.cableGeometry && edge.cableGeometry.coordinates);
    const hasPasteStyle = _ctxStyleClipboard && _ctxStyleClipboard.type === 'edge';

    const items = [
      { header: edge.label || edge.name || ('Link ' + edge.id) },
      { action: 'select-endpoints', icon: '\u{1F4CD}', label: 'Select Both Endpoints' },
      { action: 'edit-path', icon: '\u{1F5FA}\u{FE0F}', label: hasPath ? 'Edit Path Geometry' : 'Add Path Geometry' },
      { action: 'duplicate', icon: '\u{1F4CB}', label: 'Duplicate' },
      '---',
      { action: 'copy-style', icon: '\u{1F3A8}', label: 'Copy Style' },
      { action: 'paste-style', icon: '\u{1F58C}\u{FE0F}', label: 'Paste Style', disabled: !hasPasteStyle },
      '---',
      { action: 'exclude-route', icon: '\u{1F6AB}', label: 'Add to Route Exclusions' },
      { action: 'must-use-route', icon: '\u{2705}', label: 'Add to Must-Use Links' },
      '---',
      { action: 'delete', icon: '\u{1F5D1}\u{FE0F}', label: 'Delete', danger: true }
    ];

    const menu = showContextMenu(e, items);
    bindContextMenu(menu, (action) => {
      switch (action) {
        case 'select-endpoints':
          if (nodeA) state.selection.nodes.add(nodeA.id);
          if (nodeB) state.selection.nodes.add(nodeB.id);
          state.selected = null;
          render();
          showToast('Selected both endpoints');
          break;
        case 'edit-path':
          select({ type: 'edge', id: edge.id });
          render();
          setTimeout(() => enterPathEditMode(edge.id), 100);
          break;
        case 'duplicate': {
          const de = { ...edge, id: state.nextEdge++, label: (edge.label || '') + ' (copy)', name: (edge.name || '') + ' (copy)' };
          if (de.cableGeometry) de.cableGeometry = JSON.parse(JSON.stringify(de.cableGeometry));
          state.edges.push(de);
          select({ type: 'edge', id: de.id });
          commit(); render();
          showToast('Link duplicated');
          break;
        }
        case 'copy-style':
          _ctxStyleClipboard = { type: 'edge', style: pickStyle('edge', edge) };
          showToast('Link style copied');
          break;
        case 'paste-style':
          if (_ctxStyleClipboard && _ctxStyleClipboard.type === 'edge') {
            applyStyle('edge', edge, _ctxStyleClipboard.style);
            commit(); render();
            showToast('Style pasted');
          }
          break;
        case 'exclude-route':
          addExcludedLink(edge.id);
          break;
        case 'must-use-route':
          addMustUseLink(edge.id);
          break;
        case 'delete':
          select({ type: 'edge', id: edge.id });
          deleteSelected();
          break;
      }
    });
  }

  // ---- GROUP CONTEXT MENU ----
  function showGroupContextMenu(e, group) {
    const nodesInside = state.nodes.filter(n => n.groupId === group.id);
    const hasPasteStyle = _ctxStyleClipboard && _ctxStyleClipboard.type === 'group';

    const items = [
      { header: group.label || group.name || 'Container' },
      { action: 'rename', icon: '\u{270F}\u{FE0F}', label: 'Rename' },
      { action: 'select-nodes', icon: '\u{1F4E6}', label: `Select All Nodes Inside (${nodesInside.length})`, disabled: nodesInside.length === 0 },
      { action: 'fit-contents', icon: '\u{1F4D0}', label: 'Fit to Contents', disabled: nodesInside.length === 0 },
      '---',
      { action: 'duplicate', icon: '\u{1F4CB}', label: 'Duplicate' },
      { action: 'change-type', icon: '\u{1F3F7}\u{FE0F}', label: group.type === 'country' ? 'Change to Region' : 'Change to Country' },
      '---',
      { action: 'copy-style', icon: '\u{1F3A8}', label: 'Copy Style' },
      { action: 'paste-style', icon: '\u{1F58C}\u{FE0F}', label: 'Paste Style', disabled: !hasPasteStyle },
      '---',
      { action: 'delete', icon: '\u{1F5D1}\u{FE0F}', label: 'Delete', danger: true }
    ];

    const menu = showContextMenu(e, items);
    bindContextMenu(menu, (action) => {
      switch (action) {
        case 'rename': {
          select({ type: 'group', id: group.id });
          render();
          // Focus the label input in inspector
          setTimeout(() => {
            const inp = document.getElementById('grpLabel');
            if (inp) { inp.focus(); inp.select(); }
          }, 150);
          break;
        }
        case 'select-nodes':
          nodesInside.forEach(n => state.selection.nodes.add(n.id));
          state.selected = null;
          render();
          showToast(`Selected ${nodesInside.length} node(s) inside container`);
          break;
        case 'fit-contents': {
          if (nodesInside.length === 0) break;
          const pad = 40;
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          nodesInside.forEach(n => {
            const r = n.r || 24;
            minX = Math.min(minX, n.x - r);
            minY = Math.min(minY, n.y - r - 20);
            maxX = Math.max(maxX, n.x + r);
            maxY = Math.max(maxY, n.y + r);
          });
          group.x = minX - pad;
          group.y = minY - pad;
          group.w = (maxX - minX) + pad * 2;
          group.h = (maxY - minY) + pad * 2;
          commit(); render();
          showToast('Container fitted to contents');
          break;
        }
        case 'duplicate': {
          const dg = { ...group, id: state.nextGroup++, x: group.x + 30, y: group.y + 30, label: (group.label || '') + ' (copy)', name: (group.name || '') + ' (copy)' };
          state.groups.push(dg);
          select({ type: 'group', id: dg.id });
          commit(); render();
          showToast('Container duplicated');
          break;
        }
        case 'change-type':
          group.type = group.type === 'country' ? 'region' : 'country';
          commit(); render();
          showToast(`Changed to ${group.type}`);
          break;
        case 'copy-style':
          _ctxStyleClipboard = { type: 'group', style: pickStyle('group', group) };
          showToast('Container style copied');
          break;
        case 'paste-style':
          if (_ctxStyleClipboard && _ctxStyleClipboard.type === 'group') {
            applyStyle('group', group, _ctxStyleClipboard.style);
            commit(); render();
            showToast('Style pasted');
          }
          break;
        case 'delete':
          select({ type: 'group', id: group.id });
          deleteSelected();
          break;
      }
    });
  }

  // ---- UNIFIED SVG CONTEXTMENU HANDLER ----
  svg.addEventListener('contextmenu', (e) => {
    // 1. Check for direct node element hit
    const nodeTarget = e.target.closest('.node-circle') || e.target.closest('polygon.node-circle');
    if (nodeTarget) {
      const nodeId = parseInt(nodeTarget.closest('g')?.dataset?.nodeId);
      const node = findNode(nodeId);
      if (node) { showNodeContextMenu(e, node); return; }
    }

    // 2. Check for group (container) â€“ checked BEFORE edges so that edge lines
    //    overlapping a container don't steal the right-click.
    //    a) Direct hit on .group-rect element
    const groupRect = e.target.closest('.group-rect');
    if (groupRect) {
      const grpEl = groupRect.closest('g');
      if (grpEl) {
        const rx = parseFloat(groupRect.getAttribute('x'));
        const ry = parseFloat(groupRect.getAttribute('y'));
        const grp = state.groups.find(g => Math.abs(g.x - rx) < 1 && Math.abs(g.y - ry) < 1);
        if (grp) { showGroupContextMenu(e, grp); return; }
      }
    }
    //    b) Direct hit on group title text
    const groupTitle = e.target.closest('.group-title');
    if (groupTitle) {
      const grpEl = groupTitle.closest('g');
      if (grpEl) {
        const rect = grpEl.querySelector('.group-rect');
        if (rect) {
          const rx = parseFloat(rect.getAttribute('x'));
          const ry = parseFloat(rect.getAttribute('y'));
          const grp = state.groups.find(g => Math.abs(g.x - rx) < 1 && Math.abs(g.y - ry) < 1);
          if (grp) { showGroupContextMenu(e, grp); return; }
        }
      }
    }
    //    c) Fallback: right-click anywhere inside a SELECTED container's bounds
    const ctxMouse = getMouse(e);
    const selGroupIds = new Set(state.selection.groups);
    if (state.selected?.type === 'group') selGroupIds.add(state.selected.id);
    for (const gId of selGroupIds) {
      const g = findGroup(gId);
      if (g && ctxMouse.x >= g.x && ctxMouse.x <= g.x + g.w &&
              ctxMouse.y >= g.y && ctxMouse.y <= g.y + g.h) {
        showGroupContextMenu(e, g); return;
      }
    }

    // 3. Fallback: right-click anywhere within a SELECTED node's area
    const selNodeIds = new Set(state.selection.nodes);
    if (state.selected?.type === 'node') selNodeIds.add(state.selected.id);
    for (const nId of selNodeIds) {
      const n = findNode(nId);
      if (n) {
        const nr = n.r ?? 24;
        const ndx = ctxMouse.x - n.x, ndy = ctxMouse.y - n.y;
        if (ndx * ndx + ndy * ndy <= (nr * 1.5) * (nr * 1.5)) {
          showNodeContextMenu(e, n); return;
        }
      }
    }

    // 4. Check for edge (hit area or visible path/line)
    const edgeTarget = e.target.closest('[data-edge-id]');
    if (edgeTarget) {
      const edgeId = parseInt(edgeTarget.getAttribute('data-edge-id'));
      const edge = findEdge(edgeId);
      if (edge) { showEdgeContextMenu(e, edge); return; }
    }
    // Also check transparent hit areas (no data-edge-id but near an edge)
    if (e.target.tagName === 'path' || e.target.tagName === 'line') {
      const sibling = e.target.previousElementSibling || e.target.nextElementSibling;
      if (sibling && sibling.getAttribute('data-edge-id')) {
        const edgeId = parseInt(sibling.getAttribute('data-edge-id'));
        const edge = findEdge(edgeId);
        if (edge) { showEdgeContextMenu(e, edge); return; }
      }
    }
  });

  // ============== CABLE SYSTEM DRAG-DROP ASSIGNMENT ==============

  // Drag start on cable system items
  document.addEventListener('dragstart', (e) => {
    const csItem = e.target.closest('.cable-system-item[draggable="true"]');
    if (!csItem) return;
    const csId = csItem.dataset.csId;
    if (!csId) return;
    e.dataTransfer.setData('text/plain', 'cable-system:' + csId);
    e.dataTransfer.effectAllowed = 'link';
    csItem.style.opacity = '0.5';
    // Store for cleanup
    window._draggedCSItem = csItem;
    window._dragCSId = parseInt(csId);
  });

  document.addEventListener('dragend', (e) => {
    if (window._draggedCSItem) {
      window._draggedCSItem.style.opacity = '';
      window._draggedCSItem = null;
    }
    // Remove all highlights
    document.querySelectorAll('.edge-drop-highlight').forEach(el => el.classList.remove('edge-drop-highlight'));
    window._dragCSId = null;
  });

  // Allow drop on SVG edges
  svg.addEventListener('dragover', (e) => {
    if (!window._dragCSId) return;
    e.preventDefault();
    e.dataTransfer.dropEffect = 'link';
  });

  svg.addEventListener('drop', (e) => {
    e.preventDefault();
    const transferData = e.dataTransfer.getData('text/plain');
    if (!transferData || !transferData.startsWith('cable-system:')) return;

    const csId = parseInt(transferData.split(':')[1]);
    const cs = findCableSystem(csId);
    if (!cs) { showToast('Cable system not found', 'error'); return; }

    // Find which edge was dropped on (check hit areas and visible paths)
    const dropX = e.clientX;
    const dropY = e.clientY;
    const elements = document.elementsFromPoint(dropX, dropY);
    let targetEdge = null;

    for (const el of elements) {
      // Check for edge data attribute
      const edgeEl = el.closest('[data-edge-id]');
      if (edgeEl) {
        const edgeId = parseInt(edgeEl.getAttribute('data-edge-id'));
        targetEdge = findEdge(edgeId);
        if (targetEdge) break;
      }
      // Check hit areas (siblings of edges)
      if ((el.tagName === 'path' || el.tagName === 'line') && el.style.cursor === 'pointer') {
        const sibling = el.previousElementSibling || el.nextElementSibling;
        if (sibling && sibling.getAttribute('data-edge-id')) {
          targetEdge = findEdge(parseInt(sibling.getAttribute('data-edge-id')));
          if (targetEdge) break;
        }
      }
    }

    if (!targetEdge) {
      showToast('Drop on a link to assign cable system', 'warning');
      return;
    }

    // Show the assignment dialog
    showCableAssignmentDialog(cs, targetEdge);
  });

  // Find nearest landing station name for a coordinate [lng, lat]
  function findNearestLandingStation(coord, landingPoints, maxDistKm) {
    if (!coord || !landingPoints || landingPoints.length === 0) return null;
    const [lng, lat] = coord;
    const toRad = d => d * Math.PI / 180;
    let best = null;
    let bestDist = Infinity;
    for (const lp of landingPoints) {
      let lpLat, lpLng;
      if (lp.coordinates && Array.isArray(lp.coordinates)) {
        lpLng = lp.coordinates[0]; lpLat = lp.coordinates[1];
      } else if (typeof lp.lat === 'number') {
        lpLat = lp.lat; lpLng = lp.lon || lp.lng;
      } else continue;
      // Haversine distance (km)
      const dLat = toRad(lpLat - lat);
      const dLon = toRad(lpLng - lng);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat)) * Math.cos(toRad(lpLat)) * Math.sin(dLon/2)**2;
      const dist = 6371 * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      if (dist < bestDist) { bestDist = dist; best = lp; }
    }
    if (best && bestDist <= (maxDistKm || 150)) {
      return best.name || null;
    }
    return null;
  }

  // Cable assignment dialog with optional geometry import
  function showCableAssignmentDialog(cs, edge) {
    // Remove any existing dialog
    document.getElementById('cableGeoOverlay')?.remove();
    document.getElementById('cableGeometryAssignDialog')?.remove();

    const nodeA = findNode(edge.a);
    const nodeB = findNode(edge.b);
    const linkLabel = edge.tag || edge.code || `Link ${edge.id}`;
    const linkEndpoints = `${nodeA?.name || '?'} \u{2194} ${nodeB?.name || '?'}`;
    const cableName = cs.shortName || cs.name;

    // Check if cable system has geometry available (from visor DB or loaded data)
    let hasGeometry = false;
    let geometryData = null;
    let landingPoints = [];

    // Check visor database for this cable
    if (cableVisorState.cableDatabase) {
      const db = cableVisorState.cableDatabase;
      // Try to find by name match
      for (const [key, cable] of Object.entries(db.cables || {})) {
        if (cable.name === cs.name || cable.shortName === cs.shortName ||
            cable.name === cs.shortName || cable.shortName === cs.name) {
          if (cable.geometry && cable.geometry.coordinates) {
            hasGeometry = true;
            geometryData = cable;
          }
          if (cable.landingPoints) landingPoints = cable.landingPoints;
          if (hasGeometry) break;
        }
      }
    }

    // Fallback: check the cable system's own geometry property (set during bulk import)
    if (!hasGeometry && cs.geometry && cs.geometry.coordinates) {
      hasGeometry = true;
      geometryData = { geometry: cs.geometry, segments: cs.segments || null };
    }

    // Build link tag action section
    const currentTag = edge.tag || '';
    const tagActionSection = `
      <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e5e7eb;">
        <div style="font-size: 12px; font-weight: 600; margin-bottom: 8px;">\u{1F3F7}\u{FE0F} Link Tag</div>
        <div style="display: flex; flex-direction: column; gap: 6px;">
          <label style="display:flex;align-items:center;gap:8px;padding:6px 10px;border:2px solid #0096D6;border-radius:5px;cursor:pointer;background:#f0f9ff;font-size:12px;">
            <input type="radio" name="csTagAction" value="replace" checked style="margin:0;accent-color:#0096D6;">
            <div><strong>Replace</strong> \u{2014} set to "${escapeHtml(cableName)}"</div>
          </label>
          ${currentTag ? `<label style="display:flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid #e0e0e0;border-radius:5px;cursor:pointer;font-size:12px;">
            <input type="radio" name="csTagAction" value="append" style="margin:0;accent-color:#0096D6;">
            <div><strong>Append</strong> \u{2014} "${escapeHtml(currentTag)} - ${escapeHtml(cableName)}"</div>
          </label>` : ''}
          <label style="display:flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid #e0e0e0;border-radius:5px;cursor:pointer;font-size:12px;">
            <input type="radio" name="csTagAction" value="keep" style="margin:0;accent-color:#0096D6;">
            <div><strong>Keep as is</strong>${currentTag ? ` \u{2014} "${escapeHtml(currentTag)}"` : ' \u{2014} (empty)'}</div>
          </label>
        </div>
      </div>`;

    // Build dialog HTML
    const overlay = document.createElement('div');
    overlay.id = 'cableGeoOverlay';
    document.body.appendChild(overlay);

    const dialog = document.createElement('div');
    dialog.id = 'cableGeometryAssignDialog';

    let geometrySection = '';
    if (hasGeometry && geometryData) {
      const isMultiLine = geometryData.geometry.type === 'MultiLineString';
      const segCount = isMultiLine ? geometryData.geometry.coordinates.length : 1;

      if (isMultiLine && segCount > 1) {
        let segListHtml = '';
        for (let i = 0; i < segCount; i++) {
          const coords = geometryData.geometry.coordinates[i];
          const ptCount = coords.length;
          const segName = geometryData.segments?.[i]?.name || '';

          // Try to resolve start/end landing station names
          const startPt = coords[0];
          const endPt = coords[coords.length - 1];
          let startLabel = startPt ? `${startPt[1].toFixed(2)}, ${startPt[0].toFixed(2)}` : '?';
          let endLabel = endPt ? `${endPt[1].toFixed(2)}, ${endPt[0].toFixed(2)}` : '?';

          // Match coordinates to landing station names if available
          if (landingPoints.length > 0) {
            const startStation = findNearestLandingStation(startPt, landingPoints, 150);
            const endStation = findNearestLandingStation(endPt, landingPoints, 150);
            if (startStation) startLabel = startStation;
            if (endStation) endLabel = endStation;
          }

          const endpointText = segName || `${startLabel} \u{2192} ${endLabel}`;
          const approxKm = geometryData.segments?.[i]?.approxLength_km;
          const metaText = approxKm ? `~${approxKm} km \u{2022} ${ptCount} pts` : `${ptCount} pts`;

          segListHtml += `
            <label class="geo-segment-item">
              <input type="checkbox" class="geo-seg-cb" data-seg-index="${i}" checked>
              <div class="seg-info">
                <div class="seg-name">${endpointText}</div>
                <div class="seg-detail">${metaText}</div>
              </div>
            </label>`;
        }

        geometrySection = `
          <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e5e7eb;">
            <label style="display: flex; align-items: center; gap: 8px; font-size: 12px; cursor: pointer; margin-bottom: 8px;">
              <input type="checkbox" id="geoAssignGeometry" checked>
              <strong>\u{1F5FA}\u{FE0F} Also assign path geometry to link</strong>
            </label>
            <div id="geoSegmentSection">
              <div style="font-size: 11px; color: #374151; margin-bottom: 6px; display: flex; align-items: center; gap: 6px;">
                ${segCount} segments \u{2014} select which to import:
                <button id="btnGeoSegAll" style="font-size: 9px; padding: 1px 6px; border: 1px solid #ccc; border-radius: 3px; background: #fff; cursor: pointer;">All</button>
                <button id="btnGeoSegNone" style="font-size: 9px; padding: 1px 6px; border: 1px solid #ccc; border-radius: 3px; background: #fff; cursor: pointer;">None</button>
              </div>
              <div class="geo-segment-list">${segListHtml}</div>
            </div>
          </div>`;
      } else {
        // Single LineString
        const singleCoords = isMultiLine ? geometryData.geometry.coordinates[0] : geometryData.geometry.coordinates;
        const ptCount = singleCoords.length;
        let routeLabel = '';
        if (landingPoints.length > 0 && singleCoords.length >= 2) {
          const startStation = findNearestLandingStation(singleCoords[0], landingPoints, 150);
          const endStation = findNearestLandingStation(singleCoords[singleCoords.length - 1], landingPoints, 150);
          if (startStation && endStation) routeLabel = ` (${startStation} \u{2192} ${endStation})`;
        }
        geometrySection = `
          <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #e5e7eb;">
            <label style="display: flex; align-items: center; gap: 8px; font-size: 12px; cursor: pointer;">
              <input type="checkbox" id="geoAssignGeometry" checked>
              <strong>\u{1F5FA}\u{FE0F} Also assign path geometry to link</strong>
              <span style="font-size: 10px; color: #888;">${ptCount} waypoints${routeLabel}</span>
            </label>
          </div>`;
      }
    }

    dialog.innerHTML = `
      <div class="dialog-header">
        <div>
          <div style="font-weight: 600; font-size: 14px;">\u{1F4E6} Assign Cable System to Link</div>
          <div style="font-size: 11px; color: #666; margin-top: 2px;">Drag & drop assignment</div>
        </div>
        <button id="btnGeoAssignClose" style="background:none; border:none; font-size:18px; cursor:pointer; color:#999; padding:4px;">\u{2715}</button>
      </div>
      <div class="dialog-body">
        <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 12px;">
          <div style="flex: 1;">
            <div style="font-size: 11px; color: #888;">Cable System</div>
            <div style="font-weight: 600; font-size: 13px;">${escapeHtml(cableName)}</div>
            <div style="font-size: 10px; color: #666;">${escapeHtml(cs.name)}</div>
          </div>
          <div style="font-size: 20px;">\u{27A1}</div>
          <div style="flex: 1;">
            <div style="font-size: 11px; color: #888;">Link</div>
            <div style="font-weight: 600; font-size: 13px;">${escapeHtml(linkLabel)}</div>
            <div style="font-size: 10px; color: #666;">${escapeHtml(linkEndpoints)}</div>
          </div>
        </div>
        ${edge.cableSystemId ? '<div style="padding: 8px; background: #fef3c7; border-radius: 6px; font-size: 11px; color: #92400e; margin-bottom: 8px;">\u{26A0} This link already has a cable system assigned. It will be replaced.</div>' : ''}
        ${tagActionSection}
        ${!hasGeometry ? '<div style="font-size: 11px; color: #888; margin-top: 8px;">\u{2139}\u{FE0F} No geometry available for this cable. Load cable data in the Cable Visor to enable geometry assignment.</div>' : ''}
        ${geometrySection}
      </div>
      <div class="dialog-footer">
        <button id="btnGeoAssignCancel" style="padding: 8px 16px; border: 1px solid #d1d5db; border-radius: 6px; background: white; cursor: pointer; font-size: 12px;">Cancel</button>
        <button id="btnGeoAssignConfirm" style="padding: 8px 16px; border: none; border-radius: 6px; background: #0096D6; color: white; cursor: pointer; font-size: 12px; font-weight: 500;">Assign</button>
      </div>
    `;
    document.body.appendChild(dialog);

    // Wire up events
    const closeDialog = () => { overlay.remove(); dialog.remove(); };
    overlay.addEventListener('click', closeDialog);
    document.getElementById('btnGeoAssignClose').addEventListener('click', closeDialog);
    document.getElementById('btnGeoAssignCancel').addEventListener('click', closeDialog);

    // Toggle geometry section visibility
    const geoCheckbox = document.getElementById('geoAssignGeometry');
    const segSection = document.getElementById('geoSegmentSection');
    if (geoCheckbox && segSection) {
      geoCheckbox.addEventListener('change', () => {
        segSection.style.display = geoCheckbox.checked ? 'block' : 'none';
      });
    }

    // Segment All/None buttons
    document.getElementById('btnGeoSegAll')?.addEventListener('click', () => {
      dialog.querySelectorAll('.geo-seg-cb').forEach(cb => cb.checked = true);
    });
    document.getElementById('btnGeoSegNone')?.addEventListener('click', () => {
      dialog.querySelectorAll('.geo-seg-cb').forEach(cb => cb.checked = false);
    });

    // Confirm button
    document.getElementById('btnGeoAssignConfirm').addEventListener('click', () => {
      // 1. Assign cable system
      edge.cableSystemId = cs.id;

      // 2. Apply Link Tag action
      const tagAction = dialog.querySelector('input[name="csTagAction"]:checked')?.value || 'replace';
      if (tagAction === 'replace') {
        edge.tag = cableName;
      } else if (tagAction === 'append') {
        edge.tag = (edge.tag || '') + ' - ' + cableName;
      }
      // 'keep' = do nothing to tag

      // 3. Optionally assign geometry
      if (geoCheckbox && geoCheckbox.checked && hasGeometry && geometryData) {
        // Get selected segments
        const segCheckboxes = dialog.querySelectorAll('.geo-seg-cb');
        let selectedSegs = null;
        if (segCheckboxes.length > 0) {
          selectedSegs = [];
          segCheckboxes.forEach(cb => {
            if (cb.checked) selectedSegs.push(parseInt(cb.dataset.segIndex));
          });
        }

        // Extract coordinates
        const coords = extractCoordinatesFromGeometry(geometryData.geometry, selectedSegs);
        if (coords.length > 0) {
          // Store GeoJSON geometry for map rendering (unified cableGeometry field)
          // If specific segments were selected, build a filtered geometry; otherwise use as-is
          if (selectedSegs && geometryData.geometry.type === 'MultiLineString') {
            const filteredCoords = selectedSegs
              .filter(i => i >= 0 && i < geometryData.geometry.coordinates.length)
              .map(i => geometryData.geometry.coordinates[i]);
            edge.cableGeometry = filteredCoords.length === 1
              ? { type: 'LineString', coordinates: filteredCoords[0] }
              : { type: 'MultiLineString', coordinates: filteredCoords };
          } else {
            edge.cableGeometry = JSON.parse(JSON.stringify(geometryData.geometry));
          }

          showToast(`Assigned "${cableName}" + geometry (${coords.length} waypoints) to ${linkLabel}`);
        } else {
          showToast(`Assigned "${cableName}" to ${linkLabel} (no geometry segments selected)`);
        }
      } else {
        showToast(`Assigned "${cableName}" to ${linkLabel}`);
      }

      // Update inspector if this edge is selected
      if (state.selected?.type === 'edge' && state.selected.id === edge.id) {
        const edgeCableSystemEl = document.getElementById('edgeCableSystem');
        if (edgeCableSystemEl) edgeCableSystemEl.value = cs.id;
      }

      // Add 'Imported Cable System' to filter tags
      if (!edge.filterTags) edge.filterTags = ['default'];
      if (!edge.filterTags.includes('Imported Cable System')) {
        edge.filterTags.push('Imported Cable System');
      }

      // Clear selection so the link renders with cable-system colour only, no glow
      clearSelection();
      if (window.mapLibreState) {
        mapLibreState.selectedEdge = null;
        mapLibreState.selectedNode = null;
        mapLibreState.selectedNodes.clear();
        mapLibreState.selectedEdges.clear();
      }
      commit(); render();
      updateInspector();
      if (window.mapLibreState && mapLibreState.active && typeof renderMapLibreContent === 'function') {
        mapLibreState.skipFitBounds = true;
        renderMapLibreContent();
      }
      closeDialog();
    });
  }

  // ============== END CABLE SYSTEM DRAG-DROP ==============

  // ============== DC DRAG-DROP TO CONTAINER / NODE ==============

  // Drag start on DC items
  document.addEventListener('dragstart', (e) => {
    const dcItem = e.target.closest('.dc-item[draggable="true"]');
    if (!dcItem) return;
    const dcId = dcItem.dataset.dcId;
    if (!dcId) return;
    e.dataTransfer.setData('text/plain', 'datacenter:' + dcId);
    e.dataTransfer.effectAllowed = 'copy';
    dcItem.style.opacity = '0.5';
    window._draggedDCItem = dcItem;
    window._dragDCId = parseInt(dcId);
  });

  document.addEventListener('dragend', (e) => {
    if (window._draggedDCItem) {
      window._draggedDCItem.style.opacity = '';
      window._draggedDCItem = null;
    }
    document.querySelectorAll('.dc-drop-highlight, .node-dc-drop-highlight').forEach(el => {
      el.classList.remove('dc-drop-highlight', 'node-dc-drop-highlight');
    });
    window._dragDCId = null;
  });

  // Extend SVG dragover to also handle DC items
  svg.addEventListener('dragover', (e) => {
    if (!window._dragDCId) return;
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
  });

  // SVG drop handler for DC items â€” drop on container (DC type) or node
  svg.addEventListener('drop', (e) => {
    const transferData = e.dataTransfer.getData('text/plain');
    if (!transferData || !transferData.startsWith('datacenter:')) return;
    e.preventDefault();
    e.stopPropagation();

    const dcId = parseInt(transferData.split(':')[1]);
    if (!window._dcDatabase) { showToast('Datacenter database not loaded'); return; }
    const fac = window._dcDatabase.facilities.find(f => f.id === dcId);
    if (!fac) { showToast('Datacenter not found'); return; }

    const dropX = e.clientX;
    const dropY = e.clientY;
    const elements = document.elementsFromPoint(dropX, dropY);

    // Check if dropped on a node
    let targetNode = null;
    for (const el of elements) {
      const nodeEl = el.closest('.node');
      if (nodeEl) {
        const nId = parseInt(nodeEl.getAttribute('data-node-id'));
        if (!isNaN(nId)) { targetNode = findNode(nId); if (targetNode) break; }
      }
    }

    if (targetNode) {
      // Show name action dialog
      const modal = document.createElement('div');
      modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:10001;display:flex;justify-content:center;align-items:center;';
      modal.innerHTML = `
        <div style="background:#fff;border-radius:10px;padding:24px;max-width:420px;width:90%;box-shadow:0 8px 32px rgba(0,0,0,0.3);">
          <h3 style="margin:0 0 8px;font-size:16px;">\u{1F3E2} Import Datacenter to Node</h3>
          <div style="font-size:12px;color:#666;margin-bottom:16px;">
            Dropping <strong>${escapeHtml(fac.name)}</strong> onto node <strong>"${escapeHtml(targetNode.name)}"</strong>
          </div>
          <div style="font-size:13px;font-weight:600;margin-bottom:10px;">What should happen to the node name?</div>
          <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:20px;">
            <label style="display:flex;align-items:center;gap:8px;padding:8px 12px;border:2px solid #ec4899;border-radius:6px;cursor:pointer;background:#fdf2f8;">
              <input type="radio" name="dcNameAction" value="replace" checked style="margin:0;accent-color:#ec4899;" />
              <div><strong>Replace</strong> \u{2014} set name to "${escapeHtml(fac.name)}"</div>
            </label>
            <label style="display:flex;align-items:center;gap:8px;padding:8px 12px;border:1px solid #e0e0e0;border-radius:6px;cursor:pointer;">
              <input type="radio" name="dcNameAction" value="append" style="margin:0;accent-color:#ec4899;" />
              <div><strong>Append</strong> \u{2014} "${escapeHtml(targetNode.name)} - ${escapeHtml(fac.name)}"</div>
            </label>
            <label style="display:flex;align-items:center;gap:8px;padding:8px 12px;border:1px solid #e0e0e0;border-radius:6px;cursor:pointer;">
              <input type="radio" name="dcNameAction" value="keep" style="margin:0;accent-color:#ec4899;" />
              <div><strong>Keep as is</strong> \u{2014} leave "${escapeHtml(targetNode.name)}"</div>
            </label>
          </div>
          <div style="display:flex;gap:8px;justify-content:flex-end;">
            <button id="dcNameCancel" style="padding:8px 16px;border:1px solid #d0d0d0;border-radius:6px;background:#f8f8f8;cursor:pointer;font-size:13px;">Cancel</button>
            <button id="dcNameApply" style="padding:8px 16px;border:none;border-radius:6px;background:#ec4899;color:white;cursor:pointer;font-size:13px;font-weight:600;">Apply</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);

      modal.querySelector('#dcNameCancel').addEventListener('click', () => modal.remove());
      modal.querySelector('#dcNameApply').addEventListener('click', () => {
        const action = modal.querySelector('input[name="dcNameAction"]:checked').value;
        if (action === 'replace') targetNode.name = fac.name;
        else if (action === 'append') targetNode.name = targetNode.name + ' - ' + fac.name;
        // 'keep' = do nothing to name

        // Fill address fields
        targetNode.address = [fac.address1, fac.address2].filter(Boolean).join(', ');
        targetNode.city = fac.city || '';
        targetNode.postalCode = fac.zipcode || '';
        targetNode.county = '';
        targetNode.state = fac.state || '';
        targetNode.country = fac.country || '';
        if (fac.latitude != null) targetNode.gpsLat = fac.latitude;
        if (fac.longitude != null) targetNode.gpsLon = fac.longitude;

        // Add 'Imported Datacenter' to filter tags
        if (!targetNode.tags) targetNode.tags = ['default'];
        if (!targetNode.tags.includes('Imported Datacenter')) {
          targetNode.tags.push('Imported Datacenter');
        }

        commit(); render(); updateInspector();
        showToast(`Node "${targetNode.name}" updated with DC: ${fac.name}`);
        modal.remove();
      });
      return;
    }

    // Check if dropped on a container (group)
    let targetGroup = null;
    for (const el of elements) {
      const grpEl = el.closest('.group-rect, [class*="group"]');
      if (grpEl) {
        // Find group by hit-testing mouse position
        const m = getMouse(e);
        for (const g of state.groups) {
          if (m.x >= g.x && m.x <= g.x + g.w && m.y >= g.y && m.y <= g.y + g.h) {
            targetGroup = g;
            break;
          }
        }
        if (targetGroup) break;
      }
    }

    if (targetGroup) {
      // Drop on existing container -> populate DC fields
      applyDCDataToGroup(targetGroup, fac);
      // Add 'Imported Datacenter' to filter tags
      if (!targetGroup.filterTags) targetGroup.filterTags = ['default'];
      if (!targetGroup.filterTags.includes('Imported Datacenter')) {
        targetGroup.filterTags.push('Imported Datacenter');
      }
      commit(); render(); updateInspector();
      showToast(`Container "${targetGroup.title}" populated with DC data: ${fac.name}`);
      return;
    }

    // Drop on empty canvas -> create new DC container at drop position
    const m = getMouse(e);
    const id = state.nextGroup++;
    const g = makeGroup(id, m.x - 140, m.y - 100, 'dc');
    applyDCDataToGroup(g, fac);
    // Add 'Imported Datacenter' to filter tags
    if (!g.filterTags) g.filterTags = ['default'];
    if (!g.filterTags.includes('Imported Datacenter')) {
      g.filterTags.push('Imported Datacenter');
    }
    state.groups.push(g);
    if (g.type === 'dc') updateCountryRegionMembership(g);
    refreshAllMemberships();
    select({type:'group', id});
    commit(); render();
    showToast(`Created DC container: ${fac.name}`);
  });

  // Apply PeeringDB facility data to a group/container
  function applyDCDataToGroup(g, fac) {
    g.type = 'dc';
    g.title = fac.name;
    g.dcPeeringDbId = fac.id;
    g.dcOrgName = fac.org_name || '';
    g.dcAddress = [fac.address1, fac.address2].filter(Boolean).join(', ');
    g.dcCity = fac.city || '';
    g.dcCountry = fac.country || '';
    g.dcState = fac.state || '';
    g.dcZipcode = fac.zipcode || '';
    g.dcLatitude = fac.latitude;
    g.dcLongitude = fac.longitude;
    g.dcWebsite = fac.website || '';
    g.dcRegion = fac.region_continent || '';
    g.dcNetCount = (fac.networks || []).length;
    g.dcIxCount = fac.ix_count || 0;
    g.dcCarrierCount = fac.carrier_count || 0;
    g.dcNetworks = (fac.networks || []).map(n => ({ asn: n.asn, name: n.name, type: n.type }));
    g.dcFacilityType = fac.facility_type || 'datacenter';
    g.dcCableSystems = Array.isArray(fac.cable_systems) ? [...fac.cable_systems] : [];
    // Set DC visual style â€” cable stations get a distinct blue tint
    const isCableStation = g.dcFacilityType === 'cable_station';
    if (!g.fill || g.fill === 'rgba(255, 255, 255, 0.95)' || g.fill === 'rgba(245, 245, 245, 0.9)') {
      g.fill = isCableStation ? 'rgba(239, 246, 255, 0.95)' : 'rgba(253, 242, 248, 0.95)';
    }
    if (!g.stroke || g.stroke === '#666666' || g.stroke === '#999999') {
      g.stroke = isCableStation ? '#2563eb' : '#ec4899';
    }
    if (!g.titleColor || g.titleColor === '#333333') {
      g.titleColor = isCableStation ? '#1e3a5f' : '#831843';
    }
    g.strokeW = 2;
  }

  // ============== END DC DRAG-DROP ==============

  // ============== END CONTEXT MENU SYSTEM ==============

  // Load library on startup
  loadShapeLibrary();

  // ============== END SHAPE LIBRARY SYSTEM ==============

  // ============== ROUTE FINDER / PATHFINDING SYSTEM ==============

  // Route finder state - includes calculation mode
  const routeFinderState = {
    active: false,            // Whether route finder (calculation mode) is active
    originNodeId: null,
    destNodeId: null,
    routes: [],               // Array of route objects
    activeRouteIndex: 0,      // Which route is currently highlighted

    // Default latencies for implicit connections (ms)
    containerLatency: 1,      // Nodes in same container
    regionLatency: 10,        // Containers in same region
    minLatency: 0.000001,     // Floor for zero/undefined latency

    // Transit options
    enableContainerTransit: true,  // Allow implicit connections within containers
    enableRegionTransit: true,     // Allow implicit connections between sibling containers

    // Filtering options
    visibleOnly: false,       // Only use visible elements
    excludedNodes: new Set(), // Node IDs to exclude from pathfinding
    excludedLinks: new Set(), // Link IDs to exclude from pathfinding

    // Must-use constraints
    mustUseNodes: new Set(),  // Node IDs that route must pass through
    mustUseLinks: new Set(),  // Link IDs that route must use

    // Physical routing diversity constraints
    diverseFromLinks: new Set(),  // Link IDs that route must be diverse from

    // Tag filters for path calculation
    nodeTagMode: 'any',       // 'any', 'include', 'exclude'
    nodeTagFilter: new Set(), // Tags to include/exclude for nodes
    linkTagMode: 'any',       // 'any', 'include', 'exclude'
    linkTagFilter: new Set(), // Tags to include/exclude for links

    // Capacity filters for path calculation
    capacityMode: 'none',     // 'none', 'total', 'units'
    capacityMinTotal: 0,      // Minimum total Gbps required (when mode='total')
    capacityMin1G: 0,         // Minimum 1G units required (when mode='units')
    capacityMin10G: 0,        // Minimum 10G units required
    capacityMin100G: 0,       // Minimum 100G units required
    capacityMin400G: 0,       // Minimum 400G units required
    capacityMinTbps: 0,       // Minimum Tbps units required
    capacityIncludeUndefined: true,  // Include links with all capacity fields = 0

    // Implicit transit option (at top of panel)
    skipImplicitTransit: false,      // Skip implicit container/region transit connections

    // Pick mode for exclusions/must-use
    pickMode: null,            // null, 'excludeNode', 'excludeLink', 'mustUseNode', 'mustUseLink', 'mustUseMLG', 'excludeMLG', 'diverseFromLink'

    // ============== COST OPTIMIZATION SETTINGS (Phase 4) ==============
    // Optimization balance: 0 = pure latency, 1 = pure cost
    optimizationBalance: 0,           // 0-1 slider value (default: latency only)
    costMetric: 'lease',              // 'lease' (ACV) or 'iru' (NPV)
    costScale: 'logarithmic',         // 'linear' or 'logarithmic' for cost normalization
    capacityTier: '10G',              // Capacity tier for cost calculation: '1G', '10G', '100G', '400G'
    // ============== END COST OPTIMIZATION SETTINGS ==============

    // ============== MLG PREFERENCE SETTINGS (Phase 1) ==============
    // When preferMLGs is true, the algorithm will:
    // 1. First try to find a pure MLG-only path
    // 2. If no pure MLG path exists, find hybrid path (MLG + links) with MLG priority

    preferMLGs: false,                    // Master toggle for MLG preference
    mlgTopologyFilter: new Set(['linear', 'ring', 'ring_linear']),  // Which MLG types to include
    mustUseMLGs: new Set(),               // MLG IDs that route MUST use
    excludedMLGs: new Set(),              // MLG IDs to avoid

    // MLG Capacity filters (same structure as link capacity filters)
    mlgCapacityMode: 'none',              // 'none', 'total', 'units'
    mlgCapacityMinTotal: 0,               // Minimum total Gbps required
    mlgCapacityMin1G: 0,
    mlgCapacityMin10G: 0,
    mlgCapacityMin100G: 0,
    mlgCapacityMin400G: 0,
    mlgCapacityMinTbps: 0,
    mlgCapacityIncludeUndefined: true,     // Include MLGs with all capacity = 0
    // ============== END MLG PREFERENCE SETTINGS ==============

    // ============== PROTECTION PATH SETTINGS ==============
    protectionPath: null,                 // Calculated protection path result
    protectionClosureNodes: new Set(),    // Selected ring closure node IDs
    primaryPathForProtection: null,       // Stores the primary path when calculating protection
    storedRoutesForProtection: null,      // Stores all routes when protection is set up (preserves across filter changes)
    storedActiveRouteIndex: 0,            // Stores the active route index for restoration

    // Protection Mode: when true, all restriction tools configure the protection path
    protectionMode: false,                // Whether protection mode is active
    savedPrimaryState: null,              // Stores primary filter state when entering protection mode
    protectionFilters: {                  // Persistent protection-specific filter state
      excludedNodes: new Set(),
      excludedLinks: new Set(),
      mustUseNodes: new Set(),
      mustUseLinks: new Set(),
      visibleOnly: false,
      nodeTagMode: 'any',
      nodeTagFilter: new Set(),
      linkTagMode: 'any',
      linkTagFilter: new Set(),
      capacityMode: 'none',
      capacityMinTotal: 0,
      capacityMin1G: 0,
      capacityMin10G: 0,
      capacityMin100G: 0,
      capacityMin400G: 0,
      capacityMinTbps: 0,
      capacityIncludeUndefined: true,
      skipImplicitTransit: false,
      diverseFromLinks: new Set()
    }
    // ============== END PROTECTION PATH SETTINGS ==============
  };

  // Expose globally for checking in event handlers
  window.routeFinderState = routeFinderState;

  // ============== BLENDED COST CALCULATION ==============
  // The edge cost for pathfinding is a blend of latency and commercial cost
  // Balance: 0 = pure latency, 1 = pure cost, 0.5 = equal weight

  // Normalize commercial cost to comparable scale with latency
  // Using logarithmic scale helps when costs vary dramatically
  function normalizeCommercialCost(commercialCost) {
    if (!commercialCost || commercialCost <= 0) return 0;

    if (routeFinderState.costScale === 'logarithmic') {
      // Log scale: 1K â†’ ~7, 10K â†’ ~9, 100K â†’ ~12, 1M â†’ ~14
      return Math.log10(commercialCost + 1) * 2;
    } else {
      // Linear scale: divide by 10000 to bring into similar range as latency (ms)
      return commercialCost / 10000;
    }
  }

  // Get commercial cost for an edge based on selected metric and capacity tier
  function getEdgeCostForPathfinding(edge) {
    if (!edge) return 0;

    const metric = routeFinderState.costMetric || state.pathfinderSettings?.costMetric || 'lease';
    const tier = routeFinderState.capacityTier || '10G';
    const discountRate = state.financialSettings?.npvDiscountRate || 12.5;

    if (metric === 'iru') {
      const iruFee = getValueForTier(edge.iruFee, tier, 1);
      return calculateIRUNPV(
        iruFee,
        edge.iruTerm || 15,
        edge.iruOamPercent ?? 3,
        edge.iruOamAnnualIncrement ?? 2,
        discountRate
      );
    } else {
      const nrc = getValueForTier(edge.leaseNRC, tier, 0);
      const mrc = getValueForTier(edge.leaseMRC, tier, 1);
      return calculateLeaseACV(nrc, mrc);
    }
  }

  // Cost calculation with blended latency/cost optimization
  // Priority ranges from -100 to +100
  // At priority 0: cost = latency (neutral)
  // At priority +100: cost = latency Ã— 0.5 (half cost, preferred)
  // At priority -100: cost = latency Ã— 1.5 (50% more cost, avoided)
  function calculateEdgeCost(latency, priority, edge = null) {
    const lat = (latency && latency > 0) ? latency : routeFinderState.minLatency;
    const pri = (typeof priority === 'number') ? Math.max(-100, Math.min(100, priority)) : 0;
    const priorityFactor = (1 - pri / 200);

    // Base latency cost
    const latencyCost = lat * priorityFactor;

    // If no cost optimization or no edge, return pure latency cost
    const balance = routeFinderState.optimizationBalance || 0;
    if (balance === 0 || !edge) {
      return latencyCost;
    }

    // Get commercial cost for blending
    const commercialCost = getEdgeCostForPathfinding(edge);
    const normalizedCost = normalizeCommercialCost(commercialCost);

    // Blend: (1 - balance) Ã— latency + balance Ã— normalizedCost
    // balance = 0: pure latency
    // balance = 1: pure cost
    // balance = 0.5: equal weight
    const blendedCost = (1 - balance) * latencyCost + balance * normalizedCost * priorityFactor;

    return Math.max(blendedCost, routeFinderState.minLatency);
  }

  // Calculate total commercial cost for a route using selected tier
  function calculateRouteCost(segments, tierOverride = null) {
    const metric = routeFinderState.costMetric || state.pathfinderSettings?.costMetric || 'lease';
    const tier = tierOverride || routeFinderState.capacityTier || '10G';
    const discountRate = state.financialSettings?.npvDiscountRate || 12.5;
    let totalCost = 0;

    segments.forEach(seg => {
      if (seg.edgeId) {
        // Regular link
        const edge = findEdge(seg.edgeId);
        if (edge) {
          if (metric === 'iru') {
            const iruFee = getValueForTier(edge.iruFee, tier, 1);
            totalCost += calculateIRUNPV(
              iruFee,
              edge.iruTerm || 15,
              edge.iruOamPercent ?? 3,
              edge.iruOamAnnualIncrement ?? 2,
              discountRate
            );
          } else {
            const nrc = getValueForTier(edge.leaseNRC, tier, 0);
            const mrc = getValueForTier(edge.leaseMRC, tier, 1);
            totalCost += calculateLeaseACV(nrc, mrc);
          }
        }
      } else if (seg.implicit && (seg.containerId || seg.regionId)) {
        // Implicit container/region transit - add container commercial cost
        const groupId = seg.containerId || seg.regionId;
        const group = findGroup(groupId);
        if (group) {
          if (metric === 'iru') {
            const iruFee = getValueForTier(group.iruFee, tier, 1);
            totalCost += calculateIRUNPV(
              iruFee,
              group.iruTerm || 15,
              group.iruOamPercent ?? 3,
              group.iruOamAnnualIncrement ?? 2,
              discountRate
            );
          } else {
            const nrc = getValueForTier(group.leaseNRC, tier, 0);
            const mrc = getValueForTier(group.leaseMRC, tier, 1);
            totalCost += calculateLeaseACV(nrc, mrc);
          }
        }
      }
    });

    return totalCost;
  }

  // ============== END BLENDED COST CALCULATION ==============

  // Build pathfinding graph from current state
  function buildPathfindingGraph() {
    const adjacency = new Map();

    // Helper to check if node passes tag filter
    function nodePassesTagFilter(n) {
      if (routeFinderState.nodeTagMode === 'any') return true;

      // Get node tags using the proper function
      let nodeTags;
      if (typeof getNodeTags === 'function') {
        nodeTags = getNodeTags(n);
      } else {
        // Fallback
        nodeTags = new Set(['default']);
        if (n.tags && Array.isArray(n.tags)) {
          n.tags.forEach(t => {
            const trimmed = t.trim().toLowerCase();
            if (trimmed) nodeTags.add(trimmed);
          });
        }
      }

      if (nodeTags.size === 0 && routeFinderState.nodeTagFilter.size > 0) {
        return routeFinderState.nodeTagMode === 'exclude';
      }

      // Check if any node tag matches the filter
      let hasMatchingTag = false;
      for (const t of nodeTags) {
        if (routeFinderState.nodeTagFilter.has(t)) {
          hasMatchingTag = true;
          break;
        }
      }

      if (routeFinderState.nodeTagMode === 'include') {
        return hasMatchingTag;
      } else if (routeFinderState.nodeTagMode === 'exclude') {
        return !hasMatchingTag;
      }
      return true;
    }

    // Helper to check if edge passes tag filter
    function edgePassesTagFilter(edge) {
      if (routeFinderState.linkTagMode === 'any') return true;

      // Get edge tags using the proper function
      let edgeTags;
      if (typeof getEdgeTags === 'function') {
        edgeTags = getEdgeTags(edge);
      } else {
        // Fallback
        edgeTags = new Set(['default']);
        if (edge.filterTags && Array.isArray(edge.filterTags)) {
          edge.filterTags.forEach(t => {
            const trimmed = t.trim().toLowerCase();
            if (trimmed) edgeTags.add(trimmed);
          });
        }
      }

      if (edgeTags.size === 0 && routeFinderState.linkTagFilter.size > 0) {
        return routeFinderState.linkTagMode === 'exclude';
      }

      // Check if any edge tag matches the filter
      let hasMatchingTag = false;
      for (const t of edgeTags) {
        if (routeFinderState.linkTagFilter.has(t)) {
          hasMatchingTag = true;
          break;
        }
      }

      if (routeFinderState.linkTagMode === 'include') {
        return hasMatchingTag;
      } else if (routeFinderState.linkTagMode === 'exclude') {
        return !hasMatchingTag;
      }
      return true;
    }

    // Helper to check if edge passes capacity filter
    function edgePassesCapacityFilter(edge) {
      if (routeFinderState.capacityMode === 'none') return true;

      // Get edge capacity values
      const cap1G = edge.cap1G || 0;
      const cap10G = edge.cap10G || 0;
      const cap100G = edge.cap100G || 0;
      const cap400G = edge.cap400G || 0;
      const capTbps = edge.capTbps || 0;

      // Check if all capacity fields are zero (undefined capacity)
      const isUndefined = (cap1G === 0 && cap10G === 0 && cap100G === 0 && cap400G === 0 && capTbps === 0);

      // If capacity is undefined and we allow undefined, pass the filter
      if (isUndefined && routeFinderState.capacityIncludeUndefined) {
        return true;
      }

      // If capacity is undefined and we don't allow undefined, fail the filter
      if (isUndefined && !routeFinderState.capacityIncludeUndefined) {
        return false;
      }

      // Check based on mode
      if (routeFinderState.capacityMode === 'total') {
        // Calculate total available capacity in Gbps
        const totalGbps = cap1G + (10 * cap10G) + (100 * cap100G) + (400 * cap400G) + (1000 * capTbps);
        return totalGbps >= routeFinderState.capacityMinTotal;
      }

      if (routeFinderState.capacityMode === 'units') {
        // Check each unit type meets minimum requirement
        // Only check units where a minimum is specified (> 0)
        if (routeFinderState.capacityMin1G > 0 && cap1G < routeFinderState.capacityMin1G) return false;
        if (routeFinderState.capacityMin10G > 0 && cap10G < routeFinderState.capacityMin10G) return false;
        if (routeFinderState.capacityMin100G > 0 && cap100G < routeFinderState.capacityMin100G) return false;
        if (routeFinderState.capacityMin400G > 0 && cap400G < routeFinderState.capacityMin400G) return false;
        if (routeFinderState.capacityMinTbps > 0 && capTbps < routeFinderState.capacityMinTbps) return false;
        return true;
      }

      return true;
    }

    // Helper to check if edge passes physical diversity filter
    function edgePassesDiversityFilter(edge) {
      // Check if diversity filtering is enabled
      const chkLinearPhysicalDiversity = document.getElementById('chkLinearPhysicalDiversity');
      const inputLinearRequiredDiversity = document.getElementById('inputLinearRequiredDiversity');

      console.log(`[Diversity Filter DEBUG] Checkbox element:`, chkLinearPhysicalDiversity);
      console.log(`[Diversity Filter DEBUG] Checkbox checked:`, chkLinearPhysicalDiversity?.checked);
      console.log(`[Diversity Filter DEBUG] diverseFromLinks size:`, routeFinderState.diverseFromLinks.size);
      console.log(`[Diversity Filter DEBUG] diverseFromLinks contents:`, [...routeFinderState.diverseFromLinks]);

      const usePhysicalDiversity = chkLinearPhysicalDiversity ? chkLinearPhysicalDiversity.checked : false;
      if (!usePhysicalDiversity) {
        console.log(`[Diversity Filter DEBUG] DISABLED - checkbox not checked, returning true`);
        return true; // Disabled, allow all
      }

      const requiredDiversity = inputLinearRequiredDiversity ?
        Math.max(0, Math.min(100, parseInt(inputLinearRequiredDiversity.value) || 100)) : 100;

      if (routeFinderState.diverseFromLinks.size === 0) {
        console.log(`[Diversity Filter DEBUG] No constraints - diverseFromLinks is empty, returning true`);
        return true; // No constraints defined
      }

      // Debug: Log what we're checking
      console.log(`[Diversity Filter] Checking edge ${edge.id} (${edge.code || 'L-'+edge.id}), diverseFromLinks:`, [...routeFinderState.diverseFromLinks], 'required:', requiredDiversity + '%');
      console.log(`[Diversity Filter] Edge ${edge.id} routingOverlap:`, edge.routingOverlap);

      // Check if this edge has low diversity with any of the "diverse from" links
      // Need to check BOTH directions since diversity relationships are bidirectional
      for (const diverseFromLinkId of routeFinderState.diverseFromLinks) {
        // The "diverse from" link itself should be excluded (we want routes diverse FROM it)
        if (edge.id === diverseFromLinkId) {
          console.log(`[Diversity Filter] *** EXCLUDING link ${edge.id} - it IS the diverse-from reference link`);
          return false;
        }

        // Direction 1: Check if the "diverse from" link has an entry pointing to this edge
        const diverseFromEdge = findEdge(diverseFromLinkId);
        console.log(`[Diversity Filter] diverseFromEdge (id=${diverseFromLinkId}):`, diverseFromEdge ? 'found' : 'NOT FOUND', diverseFromEdge?.routingOverlap);

        if (diverseFromEdge && diverseFromEdge.routingOverlap) {
          const overlapEntries = window.normalizeRoutingOverlap ?
            window.normalizeRoutingOverlap(diverseFromEdge.routingOverlap) :
            diverseFromEdge.routingOverlap;

          console.log(`[Diversity Filter] Checking Direction 1 - diverseFromEdge ${diverseFromLinkId} overlap entries:`, overlapEntries);

          for (const entry of overlapEntries) {
            const linkId = typeof entry === 'object' ? entry.linkId : entry;
            const diversityPct = typeof entry === 'object' ? (entry.diversityPercent ?? 0) : 0;

            console.log(`[Diversity Filter] Entry: linkId=${linkId}, diversityPct=${diversityPct}, comparing to edge.id=${edge.id}`);

            if (linkId === edge.id && diversityPct < requiredDiversity) {
              console.log(`[Diversity Filter] *** EXCLUDING link ${edge.id} - ${diversityPct}% diverse from link ${diverseFromLinkId} (required: ${requiredDiversity}%) [checked on diverseFrom link]`);
              return false;
            }
          }
        }

        // Direction 2: Check if THIS edge has an entry pointing to the "diverse from" link
        if (edge.routingOverlap) {
          const edgeOverlapEntries = window.normalizeRoutingOverlap ?
            window.normalizeRoutingOverlap(edge.routingOverlap) :
            edge.routingOverlap;

          console.log(`[Diversity Filter] Checking Direction 2 - edge ${edge.id} overlap entries:`, edgeOverlapEntries);

          for (const entry of edgeOverlapEntries) {
            const linkId = typeof entry === 'object' ? entry.linkId : entry;
            const diversityPct = typeof entry === 'object' ? (entry.diversityPercent ?? 0) : 0;

            console.log(`[Diversity Filter] Entry: linkId=${linkId}, diversityPct=${diversityPct}, comparing to diverseFromLinkId=${diverseFromLinkId}`);

            if (linkId === diverseFromLinkId && diversityPct < requiredDiversity) {
              console.log(`[Diversity Filter] *** EXCLUDING link ${edge.id} - ${diversityPct}% diverse from link ${diverseFromLinkId} (required: ${requiredDiversity}%) [checked on candidate edge]`);
              return false;
            }
          }
        }
      }

      console.log(`[Diversity Filter] Edge ${edge.id} PASSED diversity check`);
      return true;
    }

    // Determine which nodes to include
    const validNodes = state.nodes.filter(n => {
      // Check if excluded
      if (routeFinderState.excludedNodes.has(n.id)) return false;
      // Check visibility if enabled
      if (routeFinderState.visibleOnly && !isNodeVisible(n)) return false;
      // Check tag filter
      if (!nodePassesTagFilter(n)) return false;
      return true;
    });

    const nodeIds = new Set(validNodes.map(n => n.id));

    // Initialize adjacency lists
    nodeIds.forEach(id => adjacency.set(id, []));

    // 1. Add explicit edges (bidirectional)
    state.edges.forEach(edge => {
      // Check if edge is excluded
      if (routeFinderState.excludedLinks.has(edge.id)) return;

      // Check if both nodes are valid
      if (!nodeIds.has(edge.a) || !nodeIds.has(edge.b)) return;

      // Check edge visibility if enabled
      if (routeFinderState.visibleOnly && !isEdgeVisible(edge)) return;

      // Check tag filter
      if (!edgePassesTagFilter(edge)) return;

      // Check capacity filter
      if (!edgePassesCapacityFilter(edge)) return;

      // Check physical diversity filter
      if (!edgePassesDiversityFilter(edge)) return;

      const nodeA = findNode(edge.a);
      const nodeB = findNode(edge.b);
      if (!nodeA || !nodeB) return;

      // Pass edge to calculateEdgeCost for blended latency/cost optimization
      const cost = calculateEdgeCost(edge.latencyMs, edge.priority, edge);
      const latencyDisplay = edge.latencyMs || routeFinderState.minLatency;
      // Store commercial cost for display in results
      const commercialCost = getEdgeCostForPathfinding(edge);

      adjacency.get(edge.a).push({
        to: edge.b,
        cost,
        edgeId: edge.id,
        implicit: false,
        latency: latencyDisplay,
        commercialCost,
        description: `${nodeA.name || 'N'+nodeA.id} â†’ ${nodeB.name || 'N'+nodeB.id}`
      });
      adjacency.get(edge.b).push({
        to: edge.a,
        cost,
        edgeId: edge.id,
        implicit: false,
        latency: latencyDisplay,
        commercialCost,
        description: `${nodeB.name || 'N'+nodeB.id} â†’ ${nodeA.name || 'N'+nodeA.id}`
      });
    });

    // 2. Build containerNodes map (needed for both container and region transit)
    const containerNodes = new Map();
    validNodes.forEach(n => {
      if (n.groupId) {
        if (!containerNodes.has(n.groupId)) containerNodes.set(n.groupId, []);
        containerNodes.get(n.groupId).push(n.id);
      }
    });

    // 2a. Add implicit edges within same container (if enabled and not skipped)
    if (routeFinderState.enableContainerTransit && !routeFinderState.skipImplicitTransit) {
      containerNodes.forEach((nodeIdsInContainer, groupId) => {
        const group = findGroup(groupId);
        const containerName = group?.title || 'Container';
        // Use per-container transit latency if defined, otherwise use global default
        const latency = (group?.transitLatency !== undefined && group?.transitLatency !== null)
          ? group.transitLatency
          : routeFinderState.containerLatency;

        // Get commercial cost for cost optimization (if balance > 0)
        const balance = routeFinderState.optimizationBalance || 0;
        let cost;
        if (balance > 0 && group) {
          // Blend latency and commercial cost
          const commercialCost = getContainerCostForPathfinding(group);
          const normalizedCost = normalizeCommercialCost(commercialCost);
          const latencyCost = latency || routeFinderState.minLatency;
          cost = (1 - balance) * latencyCost + balance * normalizedCost;
        } else {
          cost = calculateEdgeCost(latency, 0);
        }

        for (let i = 0; i < nodeIdsInContainer.length; i++) {
          for (let j = i + 1; j < nodeIdsInContainer.length; j++) {
            const a = nodeIdsInContainer[i];
            const b = nodeIdsInContainer[j];

            // Check if explicit edge exists (and is not excluded)
            const hasExplicit = state.edges.some(e =>
              ((e.a === a && e.b === b) || (e.a === b && e.b === a)) &&
              !routeFinderState.excludedLinks.has(e.id) &&
              (!routeFinderState.visibleOnly || isEdgeVisible(e))
            );

            if (!hasExplicit) {
              adjacency.get(a).push({
                to: b, cost, edgeId: null, implicit: true, containerId: groupId,
                latency, commercialCost: group ? getContainerCostForPathfinding(group) : 0, description: `via ${containerName}`
              });
              adjacency.get(b).push({
                to: a, cost, edgeId: null, implicit: true, containerId: groupId,
                latency, commercialCost: group ? getContainerCostForPathfinding(group) : 0, description: `via ${containerName}`
              });
            }
          }
        }
      });
    }

    // 3. Add implicit edges between sibling containers (same parent region) - if enabled and not skipped
    if (routeFinderState.enableRegionTransit && !routeFinderState.skipImplicitTransit) {
      const regionContainers = new Map();
      state.groups.forEach(g => {
        if (g.type === 'country' && g.parentId) {
          if (!regionContainers.has(g.parentId)) regionContainers.set(g.parentId, []);
          regionContainers.get(g.parentId).push(g.id);
        }
      });

      regionContainers.forEach((containerIds, regionId) => {
        const region = findGroup(regionId);
        const regionName = region?.title || 'Region';
        // Use per-region transit latency if defined, otherwise use global default
        const latency = (region?.transitLatency !== undefined && region?.transitLatency !== null)
          ? region.transitLatency
          : routeFinderState.regionLatency;

        // Get commercial cost for cost optimization (if balance > 0)
        const balance = routeFinderState.optimizationBalance || 0;
        let cost;
        if (balance > 0 && region) {
          // Blend latency and commercial cost
          const commercialCost = getContainerCostForPathfinding(region);
          const normalizedCost = normalizeCommercialCost(commercialCost);
          const latencyCost = latency || routeFinderState.minLatency;
          cost = (1 - balance) * latencyCost + balance * normalizedCost;
        } else {
          cost = calculateEdgeCost(latency, 0);
        }

        for (let i = 0; i < containerIds.length; i++) {
          for (let j = i + 1; j < containerIds.length; j++) {
            const containerA = containerIds[i];
            const containerB = containerIds[j];
            const nodesA = containerNodes.get(containerA) || [];
            const nodesB = containerNodes.get(containerB) || [];

            nodesA.forEach(a => {
              nodesB.forEach(b => {
                // Check if explicit edge exists (and is not excluded)
                const hasExplicit = state.edges.some(e =>
                  ((e.a === a && e.b === b) || (e.a === b && e.b === a)) &&
                  !routeFinderState.excludedLinks.has(e.id) &&
                  (!routeFinderState.visibleOnly || isEdgeVisible(e))
                );

                if (!hasExplicit) {
                  adjacency.get(a).push({
                    to: b, cost, edgeId: null, implicit: true, regionId,
                    latency, commercialCost: region ? getContainerCostForPathfinding(region) : 0, description: `via ${regionName}`
                  });
                  adjacency.get(b).push({
                    to: a, cost, edgeId: null, implicit: true, regionId,
                    latency, commercialCost: region ? getContainerCostForPathfinding(region) : 0, description: `via ${regionName}`
                  });
                }
              });
            });
          }
        }
      });
    }

    return { adjacency, nodeIds };
  }

  // ============== MLG-AUGMENTED PATHFINDING (Phase 1) ==============

  /**
   * Check if an MLG passes the current filter settings
   * @param {Object} mlg - Multilink group object
   * @returns {boolean} True if MLG passes all filters
   */
  function mlgPassesFilters(mlg) {
    // Check if MLG is excluded
    if (routeFinderState.excludedMLGs.has(mlg.id)) return false;

    // Check topology type filter
    if (!routeFinderState.mlgTopologyFilter.has(mlg.type)) return false;

    // Check capacity filters
    if (routeFinderState.mlgCapacityMode !== 'none') {
      const cap = getMLGEffectiveCapacity(mlg);

      // Check if capacity is undefined (all zeros)
      const isUndefined = cap.cap1G === 0 && cap.cap10G === 0 &&
                          cap.cap100G === 0 && cap.cap400G === 0 && cap.capTbps === 0;

      if (isUndefined && routeFinderState.mlgCapacityIncludeUndefined) {
        // Allow undefined capacity through
      } else if (isUndefined && !routeFinderState.mlgCapacityIncludeUndefined) {
        return false;
      } else {
        // Check actual capacity
        if (routeFinderState.mlgCapacityMode === 'total') {
          const totalGbps = cap.cap1G + (10 * cap.cap10G) + (100 * cap.cap100G) +
                           (400 * cap.cap400G) + (1000 * cap.capTbps);
          if (totalGbps < routeFinderState.mlgCapacityMinTotal) return false;
        } else if (routeFinderState.mlgCapacityMode === 'units') {
          if (routeFinderState.mlgCapacityMin1G > 0 && cap.cap1G < routeFinderState.mlgCapacityMin1G) return false;
          if (routeFinderState.mlgCapacityMin10G > 0 && cap.cap10G < routeFinderState.mlgCapacityMin10G) return false;
          if (routeFinderState.mlgCapacityMin100G > 0 && cap.cap100G < routeFinderState.mlgCapacityMin100G) return false;
          if (routeFinderState.mlgCapacityMin400G > 0 && cap.cap400G < routeFinderState.mlgCapacityMin400G) return false;
          if (routeFinderState.mlgCapacityMinTbps > 0 && cap.capTbps < routeFinderState.mlgCapacityMinTbps) return false;
        }
      }
    }

    return true;
  }

  /**
   * Build a graph using only MLGs as edges (no individual links)
   * Used for Phase 1 of MLG-preferred search
   * @returns {Object} { adjacency, nodeIds, mlgEdges } - Graph structure with MLG info
   */
  function buildMLGOnlyGraph() {
    const adjacency = new Map();
    const mlgEdges = new Map(); // Track which MLG creates which edge

    // Get all valid nodes (for endpoints)
    const validNodes = new Set();

    // Process each MLG
    state.multilinkGroups.forEach(mlg => {
      // Check if MLG passes filters
      if (!mlgPassesFilters(mlg)) return;

      // Get MLG endpoints
      const origin = mlg.originNode || (mlg.segments[0]?.fromNode);
      const dest = mlg.destinationNode || (mlg.segments[mlg.segments.length - 1]?.toNode);

      if (!origin || !dest) return;

      // Check endpoint nodes are not excluded
      if (routeFinderState.excludedNodes.has(origin)) return;
      if (routeFinderState.excludedNodes.has(dest)) return;

      // Add endpoints to valid nodes
      validNodes.add(origin);
      validNodes.add(dest);

      // Initialize adjacency lists if needed
      if (!adjacency.has(origin)) adjacency.set(origin, []);
      if (!adjacency.has(dest)) adjacency.set(dest, []);

      // Calculate edge cost from MLG latency
      const latency = mlg.totalLatency || 0.001;
      const cost = calculateEdgeCost(latency, 0);

      // Create unique edge key for this MLG
      const edgeKey = `mlg-${mlg.id}`;

      // Add bidirectional edges
      const edgeData = {
        to: dest,
        cost,
        mlgId: mlg.id,
        edgeId: null,  // No individual link
        implicit: false,
        isMLG: true,
        latency,
        description: `MLG: ${mlg.name || 'Unnamed'}`,
        mlgType: mlg.type
      };

      adjacency.get(origin).push(edgeData);
      adjacency.get(dest).push({
        ...edgeData,
        to: origin
      });

      // Track MLG edges
      mlgEdges.set(edgeKey, mlg.id);
    });

    return { adjacency, nodeIds: validNodes, mlgEdges };
  }

  /**
   * Build a hybrid graph with MLGs (highly preferred) and individual links
   * MLGs get a significant cost bonus to ensure they're always preferred when available
   * Used for Phase 2 of MLG-preferred search
   * @returns {Object} { adjacency, nodeIds, mlgEdges }
   */
  function buildMLGAugmentedGraph() {
    // Start with regular pathfinding graph
    const { adjacency, nodeIds } = buildPathfindingGraph();
    const mlgEdges = new Map();

    // Process each MLG and add as super-edges with very low cost multiplier
    // Using 0.001 multiplier ensures MLGs are always preferred over links
    const MLG_PREFERENCE_FACTOR = 0.001;

    state.multilinkGroups.forEach(mlg => {
      // Check if MLG passes filters
      if (!mlgPassesFilters(mlg)) return;

      // Get MLG endpoints
      const origin = mlg.originNode || (mlg.segments[0]?.fromNode);
      const dest = mlg.destinationNode || (mlg.segments[mlg.segments.length - 1]?.toNode);

      if (!origin || !dest) return;

      // Check endpoint nodes exist in graph
      if (!adjacency.has(origin) || !adjacency.has(dest)) {
        // Add nodes if they exist but weren't in graph
        const originNode = findNode(origin);
        const destNode = findNode(dest);
        if (!originNode || !destNode) return;

        if (!adjacency.has(origin)) {
          adjacency.set(origin, []);
          nodeIds.add(origin);
        }
        if (!adjacency.has(dest)) {
          adjacency.set(dest, []);
          nodeIds.add(dest);
        }
      }

      // Check endpoint nodes are not excluded
      if (routeFinderState.excludedNodes.has(origin)) return;
      if (routeFinderState.excludedNodes.has(dest)) return;

      // Calculate edge cost with strong preference factor
      const latency = mlg.totalLatency || 0.001;
      const cost = calculateEdgeCost(latency, 0) * MLG_PREFERENCE_FACTOR;

      const edgeKey = `mlg-${mlg.id}`;

      const edgeData = {
        to: dest,
        cost,
        mlgId: mlg.id,
        edgeId: null,
        implicit: false,
        isMLG: true,
        latency,
        description: `MLG: ${mlg.name || 'Unnamed'}`,
        mlgType: mlg.type
      };

      // Add bidirectional MLG edges
      adjacency.get(origin).push(edgeData);
      adjacency.get(dest).push({
        ...edgeData,
        to: origin
      });

      mlgEdges.set(edgeKey, mlg.id);
    });

    return { adjacency, nodeIds, mlgEdges };
  }

  /**
   * Find K shortest paths using MLG preference
   * Phase 1: Try pure MLG-only paths
   * Phase 2: If Phase 1 fails, try hybrid graph with MLG preference
   * @param {number} source - Origin node ID
   * @param {number} target - Destination node ID
   * @param {number} k - Number of paths to find
   * @returns {Array} Array of route objects with MLG flags
   */
  function findKShortestPathsWithMLGPreference(source, target, k = 3) {
    // Phase 1: Try pure MLG-only path
    console.log('[MLG PathFinder] Phase 1: Attempting pure MLG path...');

    const mlgGraph = buildMLGOnlyGraph();

    if (mlgGraph.adjacency.has(source) && mlgGraph.adjacency.has(target)) {
      // Run Dijkstra on MLG-only graph
      const { dist, prev } = dijkstra(mlgGraph.adjacency, source);

      if (dist.get(target) !== Infinity) {
        // Found pure MLG path!
        const pathResult = reconstructPath(prev, source, target);
        if (pathResult) {
          console.log('[MLG PathFinder] Phase 1 SUCCESS: Found pure MLG path');

          // Convert to route format
          const route = {
            path: pathResult.path,
            segments: pathResult.segments.map(seg => ({
              ...seg,
              isMLG: true,
              mlgId: seg.mlgId
            })),
            totalCost: dist.get(target),
            isPureMLG: true
          };

          // Check must-use MLG constraints
          if (routeFinderState.mustUseMLGs.size > 0) {
            const usedMLGs = new Set(pathResult.segments.filter(s => s.mlgId).map(s => s.mlgId));
            for (const requiredMLG of routeFinderState.mustUseMLGs) {
              if (!usedMLGs.has(requiredMLG)) {
                console.log('[MLG PathFinder] Phase 1 path does not include must-use MLG:', requiredMLG);
                // Continue to Phase 2 to try including required MLG
                break;
              }
            }
            // All must-use MLGs included
            return [route];
          }

          return [route];
        }
      }
    }

    console.log('[MLG PathFinder] Phase 1 FAILED: No pure MLG path found');

    // Phase 2: Try hybrid graph (MLG + links with MLG preference)
    console.log('[MLG PathFinder] Phase 2: Attempting hybrid path with MLG preference...');

    const hybridGraph = buildMLGAugmentedGraph();

    if (!hybridGraph.adjacency.has(source) || !hybridGraph.adjacency.has(target)) {
      console.log('[MLG PathFinder] Phase 2 FAILED: Source or target not in graph');
      return [];
    }

    // Use modified findKShortestPaths with the hybrid graph
    // For now, use simple Dijkstra for the best path
    const { dist, prev } = dijkstra(hybridGraph.adjacency, source);

    if (dist.get(target) === Infinity) {
      console.log('[MLG PathFinder] Phase 2 FAILED: No path found');
      return [];
    }

    const pathResult = reconstructPath(prev, source, target);
    if (!pathResult) {
      return [];
    }

    console.log('[MLG PathFinder] Phase 2 SUCCESS: Found hybrid path');

    // Mark segments that are MLGs vs links
    const route = {
      path: pathResult.path,
      segments: pathResult.segments.map(seg => ({
        ...seg,
        isMLG: !!seg.isMLG,
        mlgId: seg.mlgId || null
      })),
      totalCost: dist.get(target),
      isPureMLG: false,
      hasMLGs: pathResult.segments.some(s => s.isMLG)
    };

    return [route];
  }

  // ============== END MLG-AUGMENTED PATHFINDING ==============

  // Dijkstra's algorithm
  function dijkstra(adjacency, source, excludeEdges = new Set()) {
    const dist = new Map();
    const prev = new Map();
    const visited = new Set();
    const pq = [];

    adjacency.forEach((_, node) => {
      dist.set(node, Infinity);
      prev.set(node, null);
    });
    dist.set(source, 0);
    pq.push({ node: source, cost: 0 });

    while (pq.length > 0) {
      pq.sort((a, b) => a.cost - b.cost);
      const { node: u } = pq.shift();

      if (visited.has(u)) continue;
      visited.add(u);

      const neighbors = adjacency.get(u) || [];
      for (const edge of neighbors) {
        const edgeKey = `${Math.min(u, edge.to)}-${Math.max(u, edge.to)}-${edge.edgeId || 'implicit'}`;
        if (excludeEdges.has(edgeKey)) continue;

        const v = edge.to;
        const alt = dist.get(u) + edge.cost;

        if (alt < dist.get(v)) {
          dist.set(v, alt);
          prev.set(v, { from: u, edge });
          pq.push({ node: v, cost: alt });
        }
      }
    }

    return { dist, prev };
  }

  // Reconstruct path
  function reconstructPath(prev, source, target) {
    if (prev.get(target) === null && target !== source) return null;

    const path = [];
    const segments = [];
    let current = target;

    while (current !== null && current !== source) {
      const prevInfo = prev.get(current);
      if (!prevInfo) break;
      path.unshift(current);
      segments.unshift(prevInfo.edge);
      current = prevInfo.from;
    }

    if (current === source) {
      path.unshift(source);
      return { path, segments };
    }
    return null;
  }

  // Yen's K-Shortest Paths Algorithm
  function findKShortestPaths(source, target, k = 3) {
    const graph = buildPathfindingGraph();
    const { adjacency } = graph;

    if (!adjacency.has(source) || !adjacency.has(target)) return [];

    // Helper to check if a route satisfies must-use constraints
    function satisfiesMustUseConstraints(path, segments) {
      // Check must-use nodes
      for (const nodeId of routeFinderState.mustUseNodes) {
        if (!path.includes(nodeId)) return false;
      }

      // Check must-use links
      for (const edgeId of routeFinderState.mustUseLinks) {
        const hasLink = segments.some(seg => seg.edgeId === edgeId);
        if (!hasLink) return false;
      }

      return true;
    }

    const hasMustUseConstraints = routeFinderState.mustUseNodes.size > 0 || routeFinderState.mustUseLinks.size > 0;

    // Special handling for must-use constraints: route through waypoints
    if (hasMustUseConstraints) {
      const mustUseRoutes = findRoutesWithMustUseConstraints(adjacency, source, target, k);
      if (mustUseRoutes.length > 0) {
        return mustUseRoutes;
      }
      // If no routes found through must-use constraints, fall through to regular algorithm
    }

    const A = [];
    const B = [];

    // Find more paths if we have must-use constraints (we'll filter later)
    const maxPaths = hasMustUseConstraints ? k * 10 : k;

    const { dist, prev } = dijkstra(adjacency, source);
    const firstPath = reconstructPath(prev, source, target);

    if (!firstPath) return [];

    // Only add if satisfies constraints (or no constraints)
    if (!hasMustUseConstraints || satisfiesMustUseConstraints(firstPath.path, firstPath.segments)) {
      A.push({ path: firstPath.path, segments: firstPath.segments, totalCost: dist.get(target) });
    }

    // Find more candidate paths
    let candidatePaths = [{ path: firstPath.path, segments: firstPath.segments, totalCost: dist.get(target) }];

    for (let i = 1; i < maxPaths && A.length < k; i++) {
      const prevPath = candidatePaths[i - 1];
      if (!prevPath) break;

      for (let j = 0; j < prevPath.path.length - 1; j++) {
        const spurNode = prevPath.path[j];
        const rootPath = prevPath.path.slice(0, j + 1);
        const rootSegments = prevPath.segments.slice(0, j);

        let rootCost = 0;
        rootSegments.forEach(seg => rootCost += seg.cost);

        const excludeEdges = new Set();

        candidatePaths.forEach(path => {
          if (arraysEqual(path.path.slice(0, j + 1), rootPath)) {
            if (j < path.segments.length) {
              const seg = path.segments[j];
              const edgeKey = `${Math.min(spurNode, seg.to)}-${Math.max(spurNode, seg.to)}-${seg.edgeId || 'implicit'}`;
              excludeEdges.add(edgeKey);
            }
          }
        });

        rootPath.slice(0, -1).forEach(nodeInRoot => {
          adjacency.get(spurNode)?.forEach(edge => {
            if (edge.to === nodeInRoot) {
              const edgeKey = `${Math.min(spurNode, edge.to)}-${Math.max(spurNode, edge.to)}-${edge.edgeId || 'implicit'}`;
              excludeEdges.add(edgeKey);
            }
          });
        });

        const spurResult = dijkstra(adjacency, spurNode, excludeEdges);
        const spurPath = reconstructPath(spurResult.prev, spurNode, target);

        if (spurPath && spurPath.path.length > 1) {
          const totalPath = [...rootPath.slice(0, -1), ...spurPath.path];
          const totalSegments = [...rootSegments, ...spurPath.segments];
          const totalCost = rootCost + spurResult.dist.get(target);

          const pathStr = totalPath.join('-');
          const isDuplicate = B.some(p => p.path.join('-') === pathStr);

          if (!isDuplicate) {
            B.push({ path: totalPath, segments: totalSegments, totalCost });
          }
        }
      }

      if (B.length === 0) break;

      B.sort((a, b) => a.totalCost - b.totalCost);
      const best = B.shift();

      const bestPathStr = best.path.join('-');
      if (!candidatePaths.some(p => p.path.join('-') === bestPathStr)) {
        candidatePaths.push(best);

        // Check if this path satisfies must-use constraints
        if (!hasMustUseConstraints || satisfiesMustUseConstraints(best.path, best.segments)) {
          if (!A.some(p => p.path.join('-') === bestPathStr)) {
            A.push(best);
          }
        }
      }

      // Stop early if we have enough valid routes
      if (A.length >= k) break;
    }

    return A.slice(0, k);
  }

  // Find routes that pass through must-use nodes and links
  function findRoutesWithMustUseConstraints(adjacency, source, target, k) {
    const results = [];

    // Get must-use links with their edge info
    const mustUseLinks = [];
    for (const edgeId of routeFinderState.mustUseLinks) {
      const edge = state.edges.find(e => e.id === edgeId);
      if (edge) {
        // Find the adjacency entry for this edge to get cost/latency info
        const adjEntries = adjacency.get(edge.a) || [];
        const edgeInfo = adjEntries.find(e => e.edgeId === edgeId);
        mustUseLinks.push({
          a: edge.a,
          b: edge.b,
          edgeId,
          cost: edgeInfo?.cost || edge.latency || 1,
          latency: edgeInfo?.latency || edge.latency || 1
        });
      }
    }

    // Get must-use nodes (excluding source/target)
    const mustUseNodes = [...routeFinderState.mustUseNodes].filter(n => n !== source && n !== target);

    // If we have must-use links, we need to route through them explicitly
    if (mustUseLinks.length > 0) {
      // For each must-use link, try both directions and find paths
      // that go: source -> linkNodeA -> (via link) -> linkNodeB -> target

      // Generate all possible orderings of link traversals
      const linkOrderings = permuteLinkDirections(mustUseLinks);

      for (const linkOrdering of linkOrderings) {
        if (results.length >= k * 2) break; // Find more candidates, will filter to k

        // Build the route by forcing each must-use link
        // Route: source -> first link start -> (link) -> first link end -> ... -> target

        // Collect all stops including forced link traversals
        const segments = [];
        let stops = [source];

        // Add must-use nodes as intermediate stops
        for (const nodeId of mustUseNodes) {
          if (!stops.includes(nodeId)) {
            stops.push(nodeId);
          }
        }

        // For each must-use link, add both endpoints
        for (const link of linkOrdering) {
          if (!stops.includes(link.from)) stops.push(link.from);
          // Note: link.to will be added naturally in the path
        }

        stops.push(target);

        // Remove source and target from middle, ensure source is first and target is last
        stops = [source, ...stops.filter(s => s !== source && s !== target), target];

        // Now build the actual path, forcing must-use links
        const fullPath = [];
        const fullSegments = [];
        let totalCost = 0;
        let valid = true;
        let linksUsed = new Set();

        for (let i = 0; i < stops.length - 1; i++) {
          let from = stops[i];
          let to = stops[i + 1];

          // Check if there's a must-use link that should be used between these stops
          // or between 'from' and some intermediate point
          let forcedLink = null;
          for (const link of linkOrdering) {
            if (!linksUsed.has(link.edgeId)) {
              // Check if we should use this link now
              if (link.from === from || link.to === from) {
                forcedLink = link;
                break;
              }
            }
          }

          if (forcedLink && !linksUsed.has(forcedLink.edgeId)) {
            // Need to route to the start of this link first (if not already there)
            const linkStart = forcedLink.from === from ? forcedLink.from : forcedLink.to;
            const linkEnd = forcedLink.from === from ? forcedLink.to : forcedLink.from;

            if (from !== linkStart) {
              // Route from current position to link start
              const { dist, prev } = dijkstra(adjacency, from);
              const subPath = reconstructPath(prev, from, linkStart);
              if (!subPath) { valid = false; break; }

              if (fullPath.length === 0) {
                fullPath.push(...subPath.path);
              } else {
                fullPath.push(...subPath.path.slice(1));
              }
              fullSegments.push(...subPath.segments);
              totalCost += dist.get(linkStart);
              from = linkStart;
            }

            // Now use the forced link
            if (fullPath.length === 0) {
              fullPath.push(linkStart);
            }
            fullPath.push(linkEnd);

            // Create segment for the forced link
            const forcedSegment = {
              to: linkEnd,
              cost: forcedLink.cost,
              edgeId: forcedLink.edgeId,
              latency: forcedLink.latency
            };
            fullSegments.push(forcedSegment);
            totalCost += forcedLink.cost;
            linksUsed.add(forcedLink.edgeId);

            // Update 'from' for next iteration - continue from linkEnd to original 'to'
            from = linkEnd;
          }

          // Route from current position to next stop
          if (from !== to) {
            const { dist, prev } = dijkstra(adjacency, from);
            const subPath = reconstructPath(prev, from, to);
            if (!subPath) { valid = false; break; }

            if (fullPath.length === 0) {
              fullPath.push(...subPath.path);
            } else {
              fullPath.push(...subPath.path.slice(1));
            }
            fullSegments.push(...subPath.segments);
            totalCost += dist.get(to);
          }
        }

        if (!valid) continue;

        // Verify all must-use links were used
        let hasAllLinks = true;
        for (const edgeId of routeFinderState.mustUseLinks) {
          if (!linksUsed.has(edgeId)) {
            hasAllLinks = false;
            break;
          }
        }
        if (!hasAllLinks) continue;

        // Verify all must-use nodes are in path
        let hasAllNodes = true;
        for (const nodeId of routeFinderState.mustUseNodes) {
          if (!fullPath.includes(nodeId)) {
            hasAllNodes = false;
            break;
          }
        }
        if (!hasAllNodes) continue;

        // Check for duplicates
        const pathStr = fullPath.join('-');
        if (results.some(r => r.path.join('-') === pathStr)) continue;

        results.push({ path: fullPath, segments: fullSegments, totalCost });
      }
    } else if (mustUseNodes.length > 0) {
      // Only must-use nodes, no links - use waypoint routing
      const permutations = permute(mustUseNodes.slice(0, 6));

      for (const ordering of permutations) {
        if (results.length >= k) break;

        const stops = [source, ...ordering, target];
        const fullPath = [];
        const fullSegments = [];
        let totalCost = 0;
        let valid = true;

        for (let i = 0; i < stops.length - 1; i++) {
          const from = stops[i];
          const to = stops[i + 1];

          const { dist, prev } = dijkstra(adjacency, from);
          const subPath = reconstructPath(prev, from, to);

          if (!subPath) { valid = false; break; }

          if (i === 0) {
            fullPath.push(...subPath.path);
          } else {
            fullPath.push(...subPath.path.slice(1));
          }
          fullSegments.push(...subPath.segments);
          totalCost += dist.get(to);
        }

        if (!valid) continue;

        const pathStr = fullPath.join('-');
        if (results.some(r => r.path.join('-') === pathStr)) continue;

        results.push({ path: fullPath, segments: fullSegments, totalCost });
      }
    }

    // Sort by cost and return top k
    results.sort((a, b) => a.totalCost - b.totalCost);
    return results.slice(0, k);
  }

  // Generate permutations of link directions (each link can be traversed A->B or B->A)
  function permuteLinkDirections(links) {
    if (links.length === 0) return [[]];
    if (links.length === 1) {
      return [
        [{ ...links[0], from: links[0].a, to: links[0].b }],
        [{ ...links[0], from: links[0].b, to: links[0].a }]
      ];
    }

    const results = [];
    const [first, ...rest] = links;
    const restPerms = permuteLinkDirections(rest);

    // Try both directions for the first link
    for (const dir of [
      { ...first, from: first.a, to: first.b },
      { ...first, from: first.b, to: first.a }
    ]) {
      for (const restPerm of restPerms) {
        // Try this link at different positions
        for (let pos = 0; pos <= restPerm.length; pos++) {
          const combined = [...restPerm.slice(0, pos), dir, ...restPerm.slice(pos)];
          results.push(combined);
        }
      }
    }

    // Limit to avoid explosion
    return results.slice(0, 48);
  }

  // Generate permutations of an array (for must-use nodes)
  function permute(arr) {
    if (arr.length <= 1) return [arr];
    if (arr.length > 6) {
      // Limit permutations for large arrays
      arr = arr.slice(0, 6);
    }

    const result = [];
    for (let i = 0; i < arr.length; i++) {
      const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
      const restPerms = permute(rest);
      for (const perm of restPerms) {
        result.push([arr[i], ...perm]);
      }
    }
    return result;
  }

  function arraysEqual(a, b) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }

  // ============== ROUTE FINDER UI ==============

  const routeFinderPanel = document.getElementById('routeFinderPanel');
  const routeOriginSelect = document.getElementById('routeOriginSelect');
  const routeDestSelect = document.getElementById('routeDestSelect');
  const btnCalculateRoutes = document.getElementById('btnCalculateRoutes');
  const btnSwapEndpoints = document.getElementById('btnSwapEndpoints');
  const btnCloseRouteFinder = document.getElementById('btnCloseRouteFinder');
  const btnExitRouteFinder = document.getElementById('btnExitRouteFinder');
  const routeResultsSection = document.getElementById('routeResultsSection');
  const routeResultsContent = document.getElementById('routeResultsContent');
  const routeDetailsSection = document.getElementById('routeDetailsSection');
  const routeDetailsContent = document.getElementById('routeDetailsContent');
  const routeContainerLatency = document.getElementById('routeContainerLatency');
  const routeRegionLatency = document.getElementById('routeRegionLatency');
  const routeEnableContainerTransit = document.getElementById('routeEnableContainerTransit');
  const routeEnableRegionTransit = document.getElementById('routeEnableRegionTransit');
  const containerLatencyRow = document.getElementById('containerLatencyRow');
  const regionLatencyRow = document.getElementById('regionLatencyRow');

  // Must-use elements
  const routeMustUseNodeSelect = document.getElementById('routeMustUseNodeSelect');
  const routeMustUseLinkSelect = document.getElementById('routeMustUseLinkSelect');
  const btnAddMustUseNode = document.getElementById('btnAddMustUseNode');
  const btnPickMustUseNode = document.getElementById('btnPickMustUseNode');
  const btnAddMustUseLink = document.getElementById('btnAddMustUseLink');
  const btnPickMustUseLink = document.getElementById('btnPickMustUseLink');
  const btnClearAllMustUse = document.getElementById('btnClearAllMustUse');
  const mustUseNodesList = document.getElementById('mustUseNodesList');
  const mustUseLinksList = document.getElementById('mustUseLinksList');

  // Enter calculation mode (Route Finder)
  function enterCalculationMode() {
    console.log('[ROUTE FINDER] === ENTERING CALCULATION MODE ===');
    routeFinderState.active = true;
    routeFinderState.originNodeId = null;
    routeFinderState.destNodeId = null;
    routeFinderState.routes = [];
    routeFinderState.activeRouteIndex = 0;
    routeFinderState.pickMode = null;

    // Preserve exclusions between calculations (don't reset here)
    // routeFinderState.excludedNodes = new Set();
    // routeFinderState.excludedLinks = new Set();

    // Show panel
    const panel = document.getElementById('routeFinderPanel');
    console.log('[ROUTE FINDER] Panel element found:', !!panel);
    if (panel) {
      panel.classList.add('visible');
      console.log('[ROUTE FINDER] Panel should now be visible');
    } else {
      console.error('[ROUTE FINDER] ERROR: Panel element not found!');
      showToast('Error: Route Finder panel not found');
      return;
    }

    // Update button state
    const btn = document.getElementById('btnRouteFinder');
    if (btn) btn.classList.add('primary');

    // Clear any current selection
    clearSelection();
    render();

    // Populate node dropdowns
    populateNodeDropdowns();

    // Populate exclusion dropdowns
    populateExclusionDropdowns();

    // Populate must-use dropdowns
    populateMustUseDropdowns();

    // Render exclusion lists
    renderExcludedNodesList();
    renderExcludedLinksList();

    // Render must-use lists
    renderMustUseNodesList();
    renderMustUseLinksList();

    // Sync visibility checkbox
    const visibleOnlyCheckbox = document.getElementById('routeVisibleOnly');
    if (visibleOnlyCheckbox) {
      visibleOnlyCheckbox.checked = routeFinderState.visibleOnly;
    }

    // Sync transit checkboxes
    if (routeEnableContainerTransit) {
      routeEnableContainerTransit.checked = routeFinderState.enableContainerTransit;
    }
    if (routeEnableRegionTransit) {
      routeEnableRegionTransit.checked = routeFinderState.enableRegionTransit;
    }

    // Update latency row visibility based on transit settings
    updateTransitLatencyVisibility();

    // Initialize diversity constraints UI
    if (typeof initializeDiversityConstraints === 'function') {
      initializeDiversityConstraints();
    }

    // Update UI
    updateRouteFinderUI();

    console.log('[ROUTE FINDER] Calculation mode active, showing toast');
    showToast('ðŸ§­ CALCULATION MODE - Select Origin and Destination nodes');
  }

  // Exit calculation mode
  function exitCalculationMode() {
    console.log('[ROUTE FINDER] Exiting calculation mode');

    // Auto-exit protection mode if active (restores primary filter state)
    if (routeFinderState.protectionMode) {
      exitProtectionMode();
    }

    routeFinderState.active = false;
    routeFinderState.pickMode = null;

    // Clear routes data
    routeFinderState.routes = [];
    routeFinderState.activeRouteIndex = 0;
    routeFinderState.originNodeId = null;
    routeFinderState.destNodeId = null;

    // Clear protection state
    routeFinderState.protectionPath = null;
    routeFinderState.protectionClosureNodes.clear();
    routeFinderState.primaryPathForProtection = null;
    routeFinderState.storedRoutesForProtection = null;
    routeFinderState.storedActiveRouteIndex = 0;

    // Hide panel
    const panel = document.getElementById('routeFinderPanel');
    if (panel) {
      panel.classList.remove('visible');
    }

    // Update button state
    const btn = document.getElementById('btnRouteFinder');
    if (btn) btn.classList.remove('primary');

    // Clear highlights in all views
    clearRouteHighlights();

    // Also clear MapLibre route path
    if (typeof clearMapLibreRoutePath === 'function') {
      clearMapLibreRoutePath();
    }

    // Re-render to remove any lingering highlights
    render();

    showToast('âœï¸ Edit Mode: Normal editing restored');
  }

  // Toggle Route Finder (calculation mode)
  function toggleRouteFinder() {
    console.log('[ROUTE FINDER] Toggle called');
    console.log('[ROUTE FINDER] Current state.active =', routeFinderState.active);
    console.log('[ROUTE FINDER] Panel element:', routeFinderPanel);
    console.log('[ROUTE FINDER] Panel has visible class:', routeFinderPanel?.classList.contains('visible'));

    if (routeFinderState.active) {
      console.log('[ROUTE FINDER] -> Calling exitCalculationMode');
      exitCalculationMode();
    } else {
      console.log('[ROUTE FINDER] -> Calling enterCalculationMode');
      enterCalculationMode();
    }
  }

  // Expose globally
  window.toggleRouteFinder = toggleRouteFinder;

  // Populate node dropdowns with all nodes
  function populateNodeDropdowns() {
    if (!routeOriginSelect || !routeDestSelect) return;

    // Sort nodes by name
    const sortedNodes = [...state.nodes].sort((a, b) => {
      const nameA = (a.name || '').toLowerCase();
      const nameB = (b.name || '').toLowerCase();
      return nameA.localeCompare(nameB);
    });

    // Build options HTML
    let optionsHtml = '<option value="">-- Click a node or select --</option>';
    sortedNodes.forEach(node => {
      const displayName = node.name || `Node ${node.id}`;
      const code = node.code ? ` [${node.code}]` : '';
      optionsHtml += `<option value="${node.id}">${displayName}${code}</option>`;
    });

    routeOriginSelect.innerHTML = optionsHtml;
    routeDestSelect.innerHTML = optionsHtml;
  }

  // Handle node click in calculation mode
  function handleCalculationModeNodeClick(nodeId) {
    if (!routeFinderState.active) return false;

    const node = findNode(nodeId);
    if (!node) return false;

    // Check if in node exclusion pick mode
    if (routeFinderState.pickMode === 'excludeNode') {
      addExcludedNode(nodeId);
      routeFinderState.pickMode = null;
      updatePickModeButtons();
      return true;
    }

    // Check if in must-use node pick mode
    if (routeFinderState.pickMode === 'mustUseNode') {
      addMustUseNode(nodeId);
      routeFinderState.pickMode = null;
      updatePickModeButtons();
      return true;
    }

    // If no origin set, set this as origin
    if (!routeFinderState.originNodeId) {
      routeFinderState.originNodeId = nodeId;
      showToast(`ðŸŸ¢ Origin: ${node.name || 'Node ' + nodeId}`);
    }
    // If origin set but no destination, set this as destination
    else if (!routeFinderState.destNodeId) {
      if (nodeId === routeFinderState.originNodeId) {
        showToast('âš ï¸ Destination cannot be same as origin');
        return true;
      }
      routeFinderState.destNodeId = nodeId;
      showToast(`ðŸ”´ Destination: ${node.name || 'Node ' + nodeId}`);
    }
    // If both set, replace destination
    else {
      if (nodeId === routeFinderState.originNodeId) {
        showToast('âš ï¸ Cannot select origin as destination');
        return true;
      }
      routeFinderState.destNodeId = nodeId;
      showToast(`ðŸ”´ New Destination: ${node.name || 'Node ' + nodeId}`);
    }

    // Clear previous routes and protection state (endpoints changed)
    routeFinderState.routes = [];
    routeFinderState.activeRouteIndex = 0;
    routeFinderState.protectionPath = null;
    routeFinderState.protectionClosureNodes.clear();
    routeFinderState.primaryPathForProtection = null;

    updateRouteFinderUI();
    highlightEndpoints();

    return true; // Handled
  }

  // Update Route Finder UI
  function updateRouteFinderUI() {
    // Update dropdowns
    if (routeOriginSelect) {
      routeOriginSelect.value = routeFinderState.originNodeId || '';
    }
    if (routeDestSelect) {
      routeDestSelect.value = routeFinderState.destNodeId || '';
    }

    // Update calculate button
    const canCalculate = routeFinderState.originNodeId && routeFinderState.destNodeId;
    if (btnCalculateRoutes) btnCalculateRoutes.disabled = !canCalculate;

    // If routes were cleared by a filter/constraint change but we have stored routes for protection,
    // restore them so the primary path stays visible on screen and the user can calculate protection
    let routesRestoredFromStorage = false;
    if (routeFinderState.routes.length === 0 && routeFinderState.storedRoutesForProtection && routeFinderState.storedRoutesForProtection.length > 0) {
      routeFinderState.routes = [...routeFinderState.storedRoutesForProtection];
      routeFinderState.activeRouteIndex = routeFinderState.storedActiveRouteIndex || 0;
      routesRestoredFromStorage = true;
      // Clear stale protection result since filters changed
      routeFinderState.protectionPath = null;
    }

    // Update routes section
    if (routeFinderState.routes.length > 0) {
      if (routeResultsSection) routeResultsSection.style.display = 'block';
      displayRouteResults();
      // Show the save as MLG button container
      const saveAsMLGContainer = document.getElementById('saveAsMLGContainer');
      if (saveAsMLGContainer) saveAsMLGContainer.style.display = 'block';
      // Update compatible MLGs dropdown for add-to-existing feature
      if (typeof updateCompatibleMLGDropdown === 'function') {
        updateCompatibleMLGDropdown();
      }

      // Show protection path section and populate closure nodes
      // Get element fresh to avoid stale reference
      const protSection = document.getElementById('routeProtectionSection');
      console.log('[Protection UI] Routes found, protection section element:', protSection);
      if (protSection) {
        protSection.style.display = 'block';
        protSection.classList.remove('collapsed');
        // Only re-populate closure nodes on fresh calculations, not filter-change restorations
        // This preserves the user's intermediate closure node selections when changing filters
        if (!routesRestoredFromStorage) {
          populateProtectionClosureNodes();
        }
      }
    } else {
      if (routeResultsSection) routeResultsSection.style.display = 'none';
      if (routeDetailsSection) routeDetailsSection.style.display = 'none';
      // Hide the save as MLG button container
      const saveAsMLGContainer = document.getElementById('saveAsMLGContainer');
      if (saveAsMLGContainer) saveAsMLGContainer.style.display = 'none';

      // Preserve protection section if a primary path was stored for protection calculation
      // This allows users to modify filters/constraints and still calculate protection paths
      if (routeFinderState.primaryPathForProtection) {
        // Keep protection section visible - user can still calculate protection with new filters
        // Only clear the previous protection result since filters changed
        routeFinderState.protectionPath = null;
        const protResultDiv = document.getElementById('protectionPathResult');
        const protErrorDiv = document.getElementById('protectionPathError');
        const saveProtMLGContainer = document.getElementById('saveProtectedMLGContainer');
        if (protResultDiv) protResultDiv.style.display = 'none';
        if (protErrorDiv) protErrorDiv.style.display = 'none';
        if (saveProtMLGContainer) saveProtMLGContainer.style.display = 'none';
      } else {
        // No primary path stored - fully hide protection section and clear state
        const protSection = document.getElementById('routeProtectionSection');
        const protResultDiv = document.getElementById('protectionPathResult');
        const protErrorDiv = document.getElementById('protectionPathError');
        const saveProtMLGContainer = document.getElementById('saveProtectedMLGContainer');
        if (protSection) protSection.style.display = 'none';
        if (protResultDiv) protResultDiv.style.display = 'none';
        if (protErrorDiv) protErrorDiv.style.display = 'none';
        if (saveProtMLGContainer) saveProtMLGContainer.style.display = 'none';
        routeFinderState.protectionPath = null;
        routeFinderState.protectionClosureNodes.clear();
        routeFinderState.primaryPathForProtection = null;
      }
    }

    // Update protection path display if calculated
    if (routeFinderState.protectionPath) {
      const protResultDiv = document.getElementById('protectionPathResult');
      const protErrorDiv = document.getElementById('protectionPathError');
      const saveProtMLGContainer = document.getElementById('saveProtectedMLGContainer');
      if (protResultDiv) protResultDiv.style.display = 'block';
      if (protErrorDiv) protErrorDiv.style.display = 'none';
      if (saveProtMLGContainer) saveProtMLGContainer.style.display = 'block';
      displayProtectionPathResult();
    }
  }

  // Populate protection closure nodes based on current active route
  function populateProtectionClosureNodes() {
    const container = document.getElementById('protectionClosureNodesList');
    if (!container) return;

    const route = routeFinderState.routes[routeFinderState.activeRouteIndex];
    if (!route || !route.path || route.path.length < 2) {
      container.innerHTML = '<div style="padding:8px; color:#94a3b8; font-style:italic; font-size:11px;">Calculate a route first</div>';
      return;
    }

    // Store the primary path for protection calculation
    routeFinderState.primaryPathForProtection = route;
    // Store all routes so they can be restored when filter changes clear them
    routeFinderState.storedRoutesForProtection = [...routeFinderState.routes];
    routeFinderState.storedActiveRouteIndex = routeFinderState.activeRouteIndex;

    // Get origin and destination
    const originId = route.path[0];
    const destId = route.path[route.path.length - 1];

    // Pre-select origin and destination as closure nodes
    routeFinderState.protectionClosureNodes.clear();
    routeFinderState.protectionClosureNodes.add(originId);
    routeFinderState.protectionClosureNodes.add(destId);

    // Build the checkbox list
    let html = '';
    route.path.forEach((nodeId, idx) => {
      const node = findNode(nodeId);
      const nodeName = node?.name || node?.code || `Node ${nodeId}`;
      const isOrigin = idx === 0;
      const isDest = idx === route.path.length - 1;
      const isEndpoint = isOrigin || isDest;
      const isSelected = routeFinderState.protectionClosureNodes.has(nodeId);

      html += `
        <div class="protection-closure-item ${isSelected ? 'selected' : ''} ${isEndpoint ? 'endpoint' : ''}" data-node-id="${nodeId}">
          <input type="checkbox" ${isSelected ? 'checked' : ''} ${isEndpoint ? 'disabled' : ''} data-node-id="${nodeId}">
          <span class="node-name">${nodeName}</span>
          ${isOrigin ? '<span class="node-badge origin">Origin</span>' : ''}
          ${isDest ? '<span class="node-badge dest">Dest</span>' : ''}
        </div>
      `;
    });

    container.innerHTML = html;

    // Add event listeners for checkboxes
    container.querySelectorAll('.protection-closure-item').forEach(item => {
      const checkbox = item.querySelector('input[type="checkbox"]');
      const nodeId = parseInt(item.dataset.nodeId);

      // Click on item (but not checkbox) toggles checkbox
      item.addEventListener('click', (e) => {
        if (e.target === checkbox || checkbox.disabled) return;
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event('change'));
      });

      // Checkbox change handler
      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          routeFinderState.protectionClosureNodes.add(nodeId);
          item.classList.add('selected');
        } else {
          routeFinderState.protectionClosureNodes.delete(nodeId);
          item.classList.remove('selected');
        }
        // Clear protection path when closure nodes change
        routeFinderState.protectionPath = null;
        const protectionResultDiv = document.getElementById('protectionPathResult');
        const protectionErrorDiv = document.getElementById('protectionPathError');
        const saveProtectedMLGContainer = document.getElementById('saveProtectedMLGContainer');
        if (protectionResultDiv) protectionResultDiv.style.display = 'none';
        if (protectionErrorDiv) protectionErrorDiv.style.display = 'none';
        if (saveProtectedMLGContainer) saveProtectedMLGContainer.style.display = 'none';
        // Re-render canvas to update closure node highlights
        render();
      });
    });
  }

  // Calculate protection path
  function calculateProtectionPath() {
    const primaryRoute = routeFinderState.primaryPathForProtection;
    if (!primaryRoute || !primaryRoute.path || primaryRoute.path.length < 2) {
      showToast('âŒ No primary path available');
      return;
    }

    // Get closure nodes in path order
    const closureNodes = primaryRoute.path.filter(nodeId =>
      routeFinderState.protectionClosureNodes.has(nodeId)
    );

    if (closureNodes.length < 2) {
      showToast('âŒ At least 2 closure nodes required (origin and destination)');
      return;
    }

    // Get physical diversity settings
    const chkPhysicalDiversity = document.getElementById('chkPhysicalDiversity');
    const inputRequiredDiversity = document.getElementById('inputRequiredDiversity');
    const usePhysicalDiversity = chkPhysicalDiversity ? chkPhysicalDiversity.checked : true;
    const requiredDiversity = inputRequiredDiversity ? Math.max(0, Math.min(100, parseInt(inputRequiredDiversity.value) || 100)) : 100;

    console.log('[Protection] Physical Diversity Check:', usePhysicalDiversity, '| Required:', requiredDiversity + '%');

    // Get primary path link IDs to exclude
    const primaryLinkIds = new Set();
    if (primaryRoute.segments) {
      primaryRoute.segments.forEach(seg => {
        if (seg.edgeId) primaryLinkIds.add(seg.edgeId);
      });
    }

    // Build set of links to exclude due to physical diversity constraints
    const physicalDiversityExcluded = new Set();
    if (usePhysicalDiversity && requiredDiversity > 0) {
      primaryLinkIds.forEach(primaryLinkId => {
        const primaryEdge = findEdge(primaryLinkId);
        if (!primaryEdge || !primaryEdge.routingOverlap) return;

        // Normalize and check each overlap entry
        const overlapEntries = window.normalizeRoutingOverlap ?
          window.normalizeRoutingOverlap(primaryEdge.routingOverlap) :
          primaryEdge.routingOverlap;

        overlapEntries.forEach(entry => {
          const diversityPct = typeof entry === 'object' ? (entry.diversityPercent ?? 0) : 0;
          const linkId = typeof entry === 'object' ? entry.linkId : entry;

          // If diversity is below required threshold, exclude this link
          if (diversityPct < requiredDiversity) {
            physicalDiversityExcluded.add(linkId);
            console.log('[Protection] Excluding link', linkId, 'due to low diversity (' + diversityPct + '%) with primary link', primaryLinkId);
          }
        });
      });
    }

    console.log('[Protection] === STARTING PROTECTION PATH CALCULATION ===');
    console.log('[Protection] Primary path:', primaryRoute.path);
    console.log('[Protection] Primary path links to exclude:', [...primaryLinkIds]);
    console.log('[Protection] Physical diversity excluded links:', [...physicalDiversityExcluded]);
    console.log('[Protection] Closure nodes:', closureNodes);

    // Build adjacency list excluding primary path links and low-diversity links
    // Also apply all current filter state (tag filters, capacity filters, etc.)
    const adj = new Map();

    // --- Node filtering (mirrors buildPathfindingGraph logic) ---
    // Helper: check if node passes tag filter
    function protNodePassesTagFilter(n) {
      if (routeFinderState.nodeTagMode === 'any') return true;
      let nodeTags;
      if (typeof getNodeTags === 'function') {
        nodeTags = getNodeTags(n);
      } else {
        nodeTags = new Set(['default']);
        if (n.tags && Array.isArray(n.tags)) {
          n.tags.forEach(t => { const trimmed = t.trim().toLowerCase(); if (trimmed) nodeTags.add(trimmed); });
        }
      }
      if (nodeTags.size === 0 && routeFinderState.nodeTagFilter.size > 0) {
        return routeFinderState.nodeTagMode === 'exclude';
      }
      let hasMatchingTag = false;
      for (const t of nodeTags) { if (routeFinderState.nodeTagFilter.has(t)) { hasMatchingTag = true; break; } }
      if (routeFinderState.nodeTagMode === 'include') return hasMatchingTag;
      if (routeFinderState.nodeTagMode === 'exclude') return !hasMatchingTag;
      return true;
    }

    // Helper: check if edge passes tag filter
    function protEdgePassesTagFilter(edge) {
      if (routeFinderState.linkTagMode === 'any') return true;
      let edgeTags;
      if (typeof getEdgeTags === 'function') {
        edgeTags = getEdgeTags(edge);
      } else {
        edgeTags = new Set(['default']);
        if (edge.filterTags && Array.isArray(edge.filterTags)) {
          edge.filterTags.forEach(t => { const trimmed = t.trim().toLowerCase(); if (trimmed) edgeTags.add(trimmed); });
        }
      }
      if (edgeTags.size === 0 && routeFinderState.linkTagFilter.size > 0) {
        return routeFinderState.linkTagMode === 'exclude';
      }
      let hasMatchingTag = false;
      for (const t of edgeTags) { if (routeFinderState.linkTagFilter.has(t)) { hasMatchingTag = true; break; } }
      if (routeFinderState.linkTagMode === 'include') return hasMatchingTag;
      if (routeFinderState.linkTagMode === 'exclude') return !hasMatchingTag;
      return true;
    }

    // Helper: check if edge passes capacity filter
    function protEdgePassesCapacityFilter(edge) {
      if (routeFinderState.capacityMode === 'none') return true;
      const cap1G = edge.cap1G || 0;
      const cap10G = edge.cap10G || 0;
      const cap100G = edge.cap100G || 0;
      const cap400G = edge.cap400G || 0;
      const capTbps = edge.capTbps || 0;
      const isUndefined = (cap1G === 0 && cap10G === 0 && cap100G === 0 && cap400G === 0 && capTbps === 0);
      if (isUndefined && routeFinderState.capacityIncludeUndefined) return true;
      if (isUndefined && !routeFinderState.capacityIncludeUndefined) return false;
      if (routeFinderState.capacityMode === 'total') {
        const totalGbps = cap1G + (10 * cap10G) + (100 * cap100G) + (400 * cap400G) + (1000 * capTbps);
        return totalGbps >= routeFinderState.capacityMinTotal;
      }
      if (routeFinderState.capacityMode === 'units') {
        if (routeFinderState.capacityMin1G > 0 && cap1G < routeFinderState.capacityMin1G) return false;
        if (routeFinderState.capacityMin10G > 0 && cap10G < routeFinderState.capacityMin10G) return false;
        if (routeFinderState.capacityMin100G > 0 && cap100G < routeFinderState.capacityMin100G) return false;
        if (routeFinderState.capacityMin400G > 0 && cap400G < routeFinderState.capacityMin400G) return false;
        if (routeFinderState.capacityMinTbps > 0 && capTbps < routeFinderState.capacityMinTbps) return false;
        return true;
      }
      return true;
    }

    // Filter valid nodes (exclude by exclusion set, visibility, and tag filter)
    const validNodeIds = new Set();
    state.nodes.forEach(n => {
      if (routeFinderState.excludedNodes.has(n.id)) return;
      if (routeFinderState.visibleOnly && typeof isNodeVisible === 'function' && !isNodeVisible(n)) return;
      if (!protNodePassesTagFilter(n)) return;
      validNodeIds.add(n.id);
    });
    validNodeIds.forEach(id => adj.set(id, []));

    let availableEdgeCount = 0;
    let excludedCount = 0;
    let diversityExcludedCount = 0;
    let tagExcludedCount = 0;
    let capacityExcludedCount = 0;

    state.edges.forEach(e => {
      // Skip only the specific links used by primary path (allow parallel links)
      if (primaryLinkIds.has(e.id)) {
        console.log('[Protection] Excluding primary link:', e.id, '(', findNode(e.a)?.name, 'â†”', findNode(e.b)?.name, ')');
        excludedCount++;
        return;
      }

      // Skip links excluded due to physical diversity constraints
      if (physicalDiversityExcluded.has(e.id)) {
        console.log('[Protection] Excluding low-diversity link:', e.id, '(', findNode(e.a)?.name, 'â†”', findNode(e.b)?.name, ')');
        diversityExcludedCount++;
        return;
      }

      // Skip hidden edges if visibility filter is on
      if (routeFinderState.visibleOnly && e.hidden) return;
      // Skip excluded edges from route finder
      if (routeFinderState.excludedLinks.has(e.id)) return;
      // Skip edges with invalid/excluded endpoint nodes
      if (!validNodeIds.has(e.a) || !validNodeIds.has(e.b)) return;

      // Apply tag filter
      if (!protEdgePassesTagFilter(e)) {
        tagExcludedCount++;
        return;
      }

      // Apply capacity filter
      if (!protEdgePassesCapacityFilter(e)) {
        capacityExcludedCount++;
        return;
      }

      // Use latencyMs (same as main pathfinder), fallback to latency for compatibility
      const latency = parseFloat(e.latencyMs) || parseFloat(e.latency) || routeFinderState.minLatency || 0.001;

      const edgeDataAB = {
        to: e.b,
        cost: latency,
        edgeId: e.id,
        implicit: false,
        latency: latency
      };

      const edgeDataBA = {
        to: e.a,
        cost: latency,
        edgeId: e.id,
        implicit: false,
        latency: latency
      };

      adj.get(e.a)?.push(edgeDataAB);
      adj.get(e.b)?.push(edgeDataBA);
      availableEdgeCount++;
    });

    console.log('[Protection] Total edges:', state.edges.length);
    console.log('[Protection] Valid nodes:', validNodeIds.size, '/', state.nodes.length);
    console.log('[Protection] Excluded (primary):', excludedCount);
    console.log('[Protection] Excluded (diversity):', diversityExcludedCount);
    console.log('[Protection] Excluded (tag filter):', tagExcludedCount);
    console.log('[Protection] Excluded (capacity filter):', capacityExcludedCount);
    console.log('[Protection] Available edges for protection:', availableEdgeCount);
    if (routeFinderState.protectionMode) console.log('[Protection] Protection Mode: ACTIVE - using protection-specific filters');

    // Dijkstra implementation
    function runDijkstra(adjacency, start, end) {
      console.log('[Protection] Running dijkstra from', start, '(', findNode(start)?.name, ') to', end, '(', findNode(end)?.name, ')');

      const dist = new Map();
      const prev = new Map();
      const visited = new Set();

      state.nodes.forEach(n => dist.set(n.id, Infinity));
      dist.set(start, 0);
      prev.set(start, null);

      const pq = [{ id: start, d: 0 }];

      while (pq.length > 0) {
        pq.sort((a, b) => a.d - b.d);
        const { id: u } = pq.shift();

        if (visited.has(u)) continue;
        visited.add(u);

        if (u === end) {
          console.log('[Protection] Reached destination!');
          break;
        }

        const neighbors = adjacency.get(u) || [];
        neighbors.forEach(edge => {
          const v = edge.to;
          if (visited.has(v)) return;

          const newDist = dist.get(u) + edge.cost;
          if (newDist < dist.get(v)) {
            dist.set(v, newDist);
            prev.set(v, { from: u, edge: edge });
            pq.push({ id: v, d: newDist });
          }
        });
      }

      if (dist.get(end) === Infinity) {
        console.log('[Protection] âŒ No path found from', findNode(start)?.name, 'to', findNode(end)?.name);
        return null;
      }

      // Reconstruct path
      const path = [];
      const segments = [];
      let totalLatency = 0;
      let cur = end;

      while (cur !== null) {
        path.unshift(cur);
        const prevInfo = prev.get(cur);
        if (prevInfo && prevInfo.edge) {
          segments.unshift({
            edgeId: prevInfo.edge.edgeId,
            latency: prevInfo.edge.latency,
            cost: prevInfo.edge.cost,
            implicit: prevInfo.edge.implicit || false
          });
          totalLatency += prevInfo.edge.latency;
        }
        cur = prevInfo ? prevInfo.from : null;
      }

      console.log('[Protection] âœ“ Found path:', path.map(id => findNode(id)?.name || id).join(' â†’ '));
      console.log('[Protection] âœ“ Segments:', segments.length, 'links:', segments.map(s => s.edgeId).join(', '));
      console.log('[Protection] âœ“ Total latency:', totalLatency, 'ms');

      return { path, segments, totalCost: dist.get(end), totalLatency };
    }

    // Calculate protection path through closure nodes (+ must-use nodes if any)
    const origin = closureNodes[0];
    const dest = closureNodes[closureNodes.length - 1];
    let intermediateNodes = closureNodes.slice(1, -1);

    // Merge must-use nodes into the intermediate waypoints (if any are set)
    if (routeFinderState.mustUseNodes.size > 0) {
      const mustUseArr = [...routeFinderState.mustUseNodes].filter(id =>
        id !== origin && id !== dest && !intermediateNodes.includes(id)
      );
      if (mustUseArr.length > 0) {
        intermediateNodes = [...new Set([...intermediateNodes, ...mustUseArr])];
        console.log('[Protection] Added must-use nodes to waypoints:', mustUseArr.map(id => findNode(id)?.name || id));
      }
    }

    console.log('[Protection] Origin:', findNode(origin)?.name, '| Dest:', findNode(dest)?.name);
    console.log('[Protection] Intermediate waypoints (closure + must-use):', intermediateNodes.map(id => findNode(id)?.name || id));

    let protectionResult = null;

    if (intermediateNodes.length > 0) {
      // Route through waypoints
      const waypoints = [origin, ...intermediateNodes, dest];
      let fullPath = [];
      let fullSegments = [];
      let totalCost = 0;
      let totalLatency = 0;
      let failed = false;

      for (let i = 0; i < waypoints.length - 1; i++) {
        const segResult = runDijkstra(adj, waypoints[i], waypoints[i + 1]);
        if (!segResult || segResult.segments.length === 0) {
          console.log('[Protection] âŒ Failed to find path segment from', findNode(waypoints[i])?.name, 'to', findNode(waypoints[i+1])?.name);
          failed = true;
          break;
        }

        console.log('[Protection] Waypoint segment', i, ':',
                    findNode(waypoints[i])?.name, 'â†’', findNode(waypoints[i+1])?.name,
                    '| Path:', segResult.path.map(id => findNode(id)?.name || id).join('â†’'),
                    '| Segments:', segResult.segments.length);

        if (i === 0) {
          fullPath = segResult.path;
        } else {
          fullPath = fullPath.concat(segResult.path.slice(1));
        }
        fullSegments = fullSegments.concat(segResult.segments);
        totalCost += segResult.totalCost;
        totalLatency += segResult.totalLatency;

        console.log('[Protection] After merge - fullPath:', fullPath.map(id => findNode(id)?.name || id).join('â†’'));
      }

      if (!failed && fullPath.length > 0 && fullSegments.length > 0) {
        protectionResult = { path: fullPath, segments: fullSegments, totalCost, totalLatency };
      }
    } else {
      // Direct path from origin to destination
      const result = runDijkstra(adj, origin, dest);
      if (result && result.segments.length > 0) {
        protectionResult = result;
      }
    }

    // Validate result - MUST have segments with actual edgeIds
    const hasValidSegments = protectionResult &&
                            protectionResult.segments &&
                            protectionResult.segments.length > 0 &&
                            protectionResult.segments.some(s => s.edgeId);

    if (!hasValidSegments) {
      // Show error
      console.log('[Protection] âŒ FAILED - No valid protection path found');

      const errorDiv = document.getElementById('protectionPathError');
      const errorText = document.getElementById('protectionErrorText');
      const resultDiv = document.getElementById('protectionPathResult');
      const saveContainer = document.getElementById('saveProtectedMLGContainer');

      if (errorDiv) errorDiv.style.display = 'block';
      if (errorText) errorText.textContent = 'No diverse path exists that avoids the primary route links. The network may not have alternative routing between these endpoints.';
      if (resultDiv) resultDiv.style.display = 'none';
      if (saveContainer) saveContainer.style.display = 'none';

      routeFinderState.protectionPath = null;
      showToast('âŒ This protection configuration is not viable');
    } else {
      // Success - store protection path
      routeFinderState.protectionPath = protectionResult;

      console.log('[Protection] âœ“âœ“âœ“ SUCCESS âœ“âœ“âœ“');
      console.log('[Protection] Final path:', protectionResult.path.map(id => findNode(id)?.name || id).join(' â†’ '));
      console.log('[Protection] Final segments:', protectionResult.segments.length);
      console.log('[Protection] Final latency:', protectionResult.totalLatency, 'ms');
      console.log('[Protection] Edge IDs:', protectionResult.segments.map(s => s.edgeId).join(', '));

      const errorDiv = document.getElementById('protectionPathError');
      const resultDiv = document.getElementById('protectionPathResult');
      const saveContainer = document.getElementById('saveProtectedMLGContainer');

      if (errorDiv) errorDiv.style.display = 'none';
      if (resultDiv) resultDiv.style.display = 'block';
      if (saveContainer) saveContainer.style.display = 'block';

      displayProtectionPathResult();
      showToast('âœ“ Protection path calculated!');
      highlightActiveRoute();
    }
  }

  // Helper to get commercial cost from edge (unused for protection, keeping latency-only)
  function getCommercialCost(edge) {
    return 0; // Protection path uses latency only
  }

  // Display protection path result
  function displayProtectionPathResult() {
    const protection = routeFinderState.protectionPath;
    if (!protection) return;

    const latencySpan = document.getElementById('protectionLatency');
    const hopsSpan = document.getElementById('protectionHops');
    const nodesDiv = document.getElementById('protectionPathNodes');

    // Use totalLatency if available, otherwise totalCost
    const latency = protection.totalLatency || protection.totalCost || 0;

    if (latencySpan) latencySpan.textContent = `ðŸ• ${latency.toFixed(3)} ms`;
    if (hopsSpan) hopsSpan.textContent = `ðŸ“ ${protection.segments?.length || 0} links`;

    // Show path with links: Node1 â†’ [L-24] â†’ Node2 â†’ [L-23] â†’ Node13
    if (nodesDiv && protection.path && protection.segments) {
      let pathStr = '';
      for (let i = 0; i < protection.path.length; i++) {
        const nodeId = protection.path[i];
        const node = findNode(nodeId);
        const nodeName = node?.name || node?.code || `N${nodeId}`;

        if (i > 0) {
          // Add the link before this node
          const segment = protection.segments[i - 1];
          if (segment && segment.edgeId !== null && segment.edgeId !== undefined) {
            const edge = state.edges.find(e => e.id === segment.edgeId);
            const linkCode = edge?.code || `L-${segment.edgeId}`;
            pathStr += ` â†’ [${linkCode}] â†’ `;
          } else {
            pathStr += ' â†’ ';
          }
        }
        pathStr += nodeName;
      }
      nodesDiv.innerHTML = `<span style="font-family: monospace; font-size: 11px;">${pathStr}</span>`;
    }
  }

  // Save as protected MLG with segments
  function saveProtectedMLG() {
    const primaryRoute = routeFinderState.primaryPathForProtection;
    const protectionPath = routeFinderState.protectionPath;

    if (!primaryRoute || !protectionPath) {
      showToast('âŒ Both primary and protection paths required');
      return;
    }

    // Get closure nodes in order
    const closureNodes = primaryRoute.path.filter(nodeId =>
      routeFinderState.protectionClosureNodes.has(nodeId)
    );

    if (closureNodes.length < 2) {
      showToast('âŒ At least 2 closure nodes required');
      return;
    }

    const originNode = findNode(closureNodes[0]);
    const destNode = findNode(closureNodes[closureNodes.length - 1]);
    const originName = originNode?.name || originNode?.code || `N${closureNodes[0]}`;
    const destName = destNode?.name || destNode?.code || `N${closureNodes[closureNodes.length - 1]}`;

    // Prompt for MLG name
    const defaultName = `Protected: ${originName} â†’ ${destName}`;
    const mlgName = prompt('Enter a name for the Protected MLG:', defaultName);

    if (!mlgName) {
      showToast('âš ï¸ MLG save cancelled');
      return;
    }

    // Build segments between consecutive closure nodes in proper MLG structure
    const segments = [];
    let segmentId = 1;
    let pathId = 1;

    for (let i = 0; i < closureNodes.length - 1; i++) {
      const fromNode = closureNodes[i];
      const toNode = closureNodes[i + 1];

      // Get primary path links for this segment
      const primarySegmentLinks = getPathLinksBetweenNodes(primaryRoute, fromNode, toNode);
      const primaryLatency = calculateLinksLatency(primarySegmentLinks);

      // Get protection path links for this segment
      const protectionSegmentLinks = getPathLinksBetweenNodes(protectionPath, fromNode, toNode);
      const protectionLatency = calculateLinksLatency(protectionSegmentLinks);

      // Create segment with proper MLG structure
      segments.push({
        id: segmentId++,
        fromNode: fromNode,
        toNode: toNode,
        paths: [
          {
            id: pathId++,
            type: 'primary',
            role: 'primary',
            links: primarySegmentLinks,
            latency: primaryLatency
          },
          {
            id: pathId++,
            type: 'protection',
            role: 'protection',
            links: protectionSegmentLinks,
            latency: protectionLatency
          }
        ],
        latency: Math.min(primaryLatency, protectionLatency),
        isDiverse: protectionSegmentLinks.length > 0,
        diversityWarning: protectionSegmentLinks.length === 0 ? 'No protection path for this segment' : null
      });
    }

    // Calculate total latencies
    const primaryLatency = primaryRoute.totalLatency || primaryRoute.totalCost || 0;
    const protectionLatency = protectionPath.totalLatency || protectionPath.totalCost || 0;

    const mlgId = 'mlg_' + Date.now();
    const now = new Date().toISOString();
    const mlg = {
      id: mlgId,
      name: mlgName.trim(),
      color: '#f59e0b',
      description: `Ring-protected route\nPrimary: ${primaryLatency.toFixed(3)} ms\nProtection: ${protectionLatency.toFixed(3)} ms`,
      type: 'ring',
      topology: 'ring',
      segments: segments,
      totalLatency: primaryLatency,
      protectionLatency: protectionLatency,
      originNode: closureNodes[0],
      destinationNode: closureNodes[closureNodes.length - 1],
      endpointA: closureNodes[0],
      endpointB: closureNodes[closureNodes.length - 1],
      source: 'pathfinder-protection',
      closureNodes: closureNodes,
      isDiverse: true,
      diversityWarning: null,
      warnings: [],
      tags: [],
      // Timestamps
      created: now,
      modified: now,
      // Capacity fields
      calcCap1G: 0,
      calcCap10G: 0,
      calcCap100G: 0,
      calcCap400G: 0,
      calcCapTbps: 0,
      overrideCap1G: null,
      overrideCap10G: null,
      overrideCap100G: null,
      overrideCap400G: null,
      overrideCapTbps: null,
      // Commercial cost fields
      calcLeaseNRC: 0,
      calcLeaseMRC: 0,
      calcIRUFee: 0,
      calcIRUOAM: 0,
      overrideLeaseNRC: null,
      overrideLeaseMRC: null,
      overrideIRUFee: null,
      overrideIRUOAM: null,
      // IRU term fields
      iruTerm: state.financialSettings?.defaultIRUTerm || 15,
      iruOamAnnualIncrement: state.financialSettings?.defaultOAMIncrement || 0,
      commercialCostMode: state.financialSettings?.defaultCommercialMode || 'lease'
    };

    console.log('[Protection] Saving MLG:', mlg);

    // Add to MLGs
    if (!state.multilinkGroups) state.multilinkGroups = [];
    state.multilinkGroups.push(mlg);

    // Clear protection state
    routeFinderState.protectionPath = null;
    routeFinderState.primaryPathForProtection = null;
    routeFinderState.protectionClosureNodes.clear();
    routeFinderState.storedRoutesForProtection = null;
    routeFinderState.storedActiveRouteIndex = 0;

    // Hide protection UI
    const protectionResultDiv = document.getElementById('protectionPathResult');
    const protectionErrorDiv = document.getElementById('protectionPathError');
    const saveProtectedMLGContainer = document.getElementById('saveProtectedMLGContainer');
    if (protectionResultDiv) protectionResultDiv.style.display = 'none';
    if (protectionErrorDiv) protectionErrorDiv.style.display = 'none';
    if (saveProtectedMLGContainer) saveProtectedMLGContainer.style.display = 'none';

    commit();
    render();
    showToast(`âœ“ Protected MLG "${mlg.name}" created!`);

    // Open MLG Manager to show the new MLG
    const multilinkManager = document.getElementById('multilinkManager');
    if (multilinkManager) {
      multilinkManager.style.display = 'flex';
    }

    // Refresh MLG manager
    if (typeof window.refreshMultilinkManager === 'function') {
      window.refreshMultilinkManager();
    }
  }

  // Helper: Calculate total latency of a list of link IDs
  function calculateLinksLatency(linkIds) {
    let total = 0;
    linkIds.forEach(linkId => {
      const edge = state.edges.find(e => e.id === linkId);
      if (edge) {
        total += parseFloat(edge.latencyMs) || parseFloat(edge.latency) || 0;
      }
    });
    return total;
  }

  // Helper: Get link IDs between two nodes in a path
  function getPathLinksBetweenNodes(route, fromNode, toNode) {
    if (!route || !route.path || !route.segments) return [];

    const links = [];
    const fromIdx = route.path.indexOf(fromNode);
    const toIdx = route.path.indexOf(toNode);

    if (fromIdx === -1 || toIdx === -1 || fromIdx >= toIdx) return [];

    // Collect links between these nodes
    for (let i = fromIdx; i < toIdx; i++) {
      const segment = route.segments[i];
      if (segment && segment.edgeId) {
        links.push(segment.edgeId);
      }
    }

    return links;
  }

  // ============== PROTECTION MODE ==============
  // When protection mode is active, all restriction tools (excluded nodes/links,
  // must-use, tag filters, capacity filters, diversity) configure the protection
  // path instead of the primary path. The primary path remains locked in place.

  function enterProtectionMode() {
    if (routeFinderState.protectionMode) return; // Already in protection mode
    if (!routeFinderState.primaryPathForProtection && routeFinderState.routes.length === 0) {
      showToast('Calculate a primary path first before entering Protection Mode');
      return;
    }

    console.log('[Protection Mode] Entering protection mode');

    // Save current primary filter state
    routeFinderState.savedPrimaryState = {
      excludedNodes: new Set(routeFinderState.excludedNodes),
      excludedLinks: new Set(routeFinderState.excludedLinks),
      mustUseNodes: new Set(routeFinderState.mustUseNodes),
      mustUseLinks: new Set(routeFinderState.mustUseLinks),
      visibleOnly: routeFinderState.visibleOnly,
      nodeTagMode: routeFinderState.nodeTagMode,
      nodeTagFilter: new Set(routeFinderState.nodeTagFilter),
      linkTagMode: routeFinderState.linkTagMode,
      linkTagFilter: new Set(routeFinderState.linkTagFilter),
      capacityMode: routeFinderState.capacityMode,
      capacityMinTotal: routeFinderState.capacityMinTotal,
      capacityMin1G: routeFinderState.capacityMin1G,
      capacityMin10G: routeFinderState.capacityMin10G,
      capacityMin100G: routeFinderState.capacityMin100G,
      capacityMin400G: routeFinderState.capacityMin400G,
      capacityMinTbps: routeFinderState.capacityMinTbps,
      capacityIncludeUndefined: routeFinderState.capacityIncludeUndefined,
      skipImplicitTransit: routeFinderState.skipImplicitTransit,
      diverseFromLinks: new Set(routeFinderState.diverseFromLinks)
    };

    // Swap in protection filters
    const pf = routeFinderState.protectionFilters;
    routeFinderState.excludedNodes = pf.excludedNodes;
    routeFinderState.excludedLinks = pf.excludedLinks;
    routeFinderState.mustUseNodes = pf.mustUseNodes;
    routeFinderState.mustUseLinks = pf.mustUseLinks;
    routeFinderState.visibleOnly = pf.visibleOnly;
    routeFinderState.nodeTagMode = pf.nodeTagMode;
    routeFinderState.nodeTagFilter = pf.nodeTagFilter;
    routeFinderState.linkTagMode = pf.linkTagMode;
    routeFinderState.linkTagFilter = pf.linkTagFilter;
    routeFinderState.capacityMode = pf.capacityMode;
    routeFinderState.capacityMinTotal = pf.capacityMinTotal;
    routeFinderState.capacityMin1G = pf.capacityMin1G;
    routeFinderState.capacityMin10G = pf.capacityMin10G;
    routeFinderState.capacityMin100G = pf.capacityMin100G;
    routeFinderState.capacityMin400G = pf.capacityMin400G;
    routeFinderState.capacityMinTbps = pf.capacityMinTbps;
    routeFinderState.capacityIncludeUndefined = pf.capacityIncludeUndefined;
    routeFinderState.skipImplicitTransit = pf.skipImplicitTransit;
    routeFinderState.diverseFromLinks = pf.diverseFromLinks;

    routeFinderState.protectionMode = true;

    // Sync UI controls with protection state
    syncFilterUIFromState();

    // Update visual indicators
    updateProtectionModeVisuals();

    showToast('Protection Mode: Restrictions now apply to protection path');
  }

  function exitProtectionMode() {
    if (!routeFinderState.protectionMode) return; // Not in protection mode

    console.log('[Protection Mode] Exiting protection mode');

    // Save current state back to protectionFilters
    routeFinderState.protectionFilters = {
      excludedNodes: routeFinderState.excludedNodes,
      excludedLinks: routeFinderState.excludedLinks,
      mustUseNodes: routeFinderState.mustUseNodes,
      mustUseLinks: routeFinderState.mustUseLinks,
      visibleOnly: routeFinderState.visibleOnly,
      nodeTagMode: routeFinderState.nodeTagMode,
      nodeTagFilter: routeFinderState.nodeTagFilter,
      linkTagMode: routeFinderState.linkTagMode,
      linkTagFilter: routeFinderState.linkTagFilter,
      capacityMode: routeFinderState.capacityMode,
      capacityMinTotal: routeFinderState.capacityMinTotal,
      capacityMin1G: routeFinderState.capacityMin1G,
      capacityMin10G: routeFinderState.capacityMin10G,
      capacityMin100G: routeFinderState.capacityMin100G,
      capacityMin400G: routeFinderState.capacityMin400G,
      capacityMinTbps: routeFinderState.capacityMinTbps,
      capacityIncludeUndefined: routeFinderState.capacityIncludeUndefined,
      skipImplicitTransit: routeFinderState.skipImplicitTransit,
      diverseFromLinks: routeFinderState.diverseFromLinks
    };

    // Restore primary state
    const ps = routeFinderState.savedPrimaryState;
    routeFinderState.excludedNodes = ps.excludedNodes;
    routeFinderState.excludedLinks = ps.excludedLinks;
    routeFinderState.mustUseNodes = ps.mustUseNodes;
    routeFinderState.mustUseLinks = ps.mustUseLinks;
    routeFinderState.visibleOnly = ps.visibleOnly;
    routeFinderState.nodeTagMode = ps.nodeTagMode;
    routeFinderState.nodeTagFilter = ps.nodeTagFilter;
    routeFinderState.linkTagMode = ps.linkTagMode;
    routeFinderState.linkTagFilter = ps.linkTagFilter;
    routeFinderState.capacityMode = ps.capacityMode;
    routeFinderState.capacityMinTotal = ps.capacityMinTotal;
    routeFinderState.capacityMin1G = ps.capacityMin1G;
    routeFinderState.capacityMin10G = ps.capacityMin10G;
    routeFinderState.capacityMin100G = ps.capacityMin100G;
    routeFinderState.capacityMin400G = ps.capacityMin400G;
    routeFinderState.capacityMinTbps = ps.capacityMinTbps;
    routeFinderState.capacityIncludeUndefined = ps.capacityIncludeUndefined;
    routeFinderState.skipImplicitTransit = ps.skipImplicitTransit;
    routeFinderState.diverseFromLinks = ps.diverseFromLinks;

    routeFinderState.protectionMode = false;
    routeFinderState.savedPrimaryState = null;

    // Sync UI controls with restored primary state
    syncFilterUIFromState();

    // Update visual indicators
    updateProtectionModeVisuals();

    showToast('Primary Mode: Restrictions now apply to primary path');
  }

  // Sync all filter UI controls from the current routeFinderState values
  function syncFilterUIFromState() {
    // Visible only checkbox
    const visibleOnlyCheckbox = document.getElementById('routeVisibleOnly');
    if (visibleOnlyCheckbox) visibleOnlyCheckbox.checked = routeFinderState.visibleOnly;

    // Skip implicit transit checkbox
    const skipImplicitCheckbox = document.getElementById('routeSkipImplicitTransit');
    if (skipImplicitCheckbox) skipImplicitCheckbox.checked = routeFinderState.skipImplicitTransit;

    // Re-render exclusion and must-use lists
    if (typeof renderExcludedNodesList === 'function') renderExcludedNodesList();
    if (typeof renderExcludedLinksList === 'function') renderExcludedLinksList();
    if (typeof renderMustUseNodesList === 'function') renderMustUseNodesList();
    if (typeof renderMustUseLinksList === 'function') renderMustUseLinksList();

    // Tag filter UI
    const routeNodeTagMode = document.getElementById('routeNodeTagMode');
    const routeLinkTagMode = document.getElementById('routeLinkTagMode');
    if (routeNodeTagMode) routeNodeTagMode.value = routeFinderState.nodeTagMode;
    if (routeLinkTagMode) routeLinkTagMode.value = routeFinderState.linkTagMode;
    if (typeof updateRouteTagModeHint === 'function') {
      updateRouteTagModeHint('node');
      updateRouteTagModeHint('link');
    }
    if (typeof updateRouteTagSelectedChips === 'function') {
      updateRouteTagSelectedChips('node');
      updateRouteTagSelectedChips('link');
    }
    if (typeof populateRouteTagFilters === 'function') populateRouteTagFilters();

    // Capacity filter UI
    const capacityModeRadio = document.querySelector(`input[name="routeCapacityMode"][value="${routeFinderState.capacityMode}"]`);
    if (capacityModeRadio) capacityModeRadio.checked = true;

    const capFields = [
      ['routeCapacityMinTotal', 'capacityMinTotal'],
      ['routeCapacityMin1G', 'capacityMin1G'],
      ['routeCapacityMin10G', 'capacityMin10G'],
      ['routeCapacityMin100G', 'capacityMin100G'],
      ['routeCapacityMin400G', 'capacityMin400G'],
      ['routeCapacityMinTbps', 'capacityMinTbps']
    ];
    capFields.forEach(([elId, stateKey]) => {
      const el = document.getElementById(elId);
      if (el) el.value = routeFinderState[stateKey];
    });
    const capUndefinedCheckbox = document.getElementById('routeCapacityIncludeUndefined');
    if (capUndefinedCheckbox) capUndefinedCheckbox.checked = routeFinderState.capacityIncludeUndefined;
    if (typeof updateCapacityFilterSections === 'function') updateCapacityFilterSections();

    // Diverse-from links
    if (typeof updateDiverseFromLinksList === 'function') updateDiverseFromLinksList();
    if (typeof populateDiverseFromLinkDropdown === 'function') populateDiverseFromLinkDropdown();
  }

  // Update visual indicators for protection mode
  function updateProtectionModeVisuals() {
    const panel = document.getElementById('routeFinderPanel');
    const toggleBtn = document.getElementById('btnProtectionModeToggle');
    const modeBanner = document.getElementById('protectionModeBanner');

    if (routeFinderState.protectionMode) {
      // Add protection mode styling to panel
      if (panel) panel.classList.add('protection-mode-active');

      // Update toggle button
      if (toggleBtn) {
        toggleBtn.textContent = 'Exit Protection Mode';
        toggleBtn.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
        toggleBtn.style.color = 'white';
      }

      // Show banner
      if (modeBanner) modeBanner.style.display = 'block';

      // Add protection badge to collapsible section headers
      document.querySelectorAll('#routeFinderPanel .inspector-section-header').forEach(header => {
        // Remove existing badges first
        const existingBadge = header.querySelector('.protection-mode-badge');
        if (existingBadge) existingBadge.remove();

        const section = header.parentElement;
        const sectionType = section?.getAttribute('data-section');
        // Add badge to restriction-related sections
        if (['route-restrictions', 'route-must-use', 'route-physical-diversity', 'route-tag-filters', 'route-capacity'].includes(sectionType)) {
          const badge = document.createElement('span');
          badge.className = 'protection-mode-badge';
          badge.style.cssText = 'margin-left:6px; padding:1px 6px; background:#f59e0b; color:white; border-radius:8px; font-size:9px; font-weight:600;';
          badge.textContent = 'PROTECTION';
          header.querySelector('span:first-child')?.appendChild(badge);
        }
      });

    } else {
      // Remove protection mode styling
      if (panel) panel.classList.remove('protection-mode-active');

      // Update toggle button
      if (toggleBtn) {
        toggleBtn.textContent = 'Enter Protection Mode';
        toggleBtn.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
        toggleBtn.style.color = 'white';
      }

      // Hide banner
      if (modeBanner) modeBanner.style.display = 'none';

      // Remove all protection badges
      document.querySelectorAll('.protection-mode-badge').forEach(badge => badge.remove());
    }
  }

  // Expose globally
  window.enterProtectionMode = enterProtectionMode;
  window.exitProtectionMode = exitProtectionMode;
  // ============== END PROTECTION MODE ==============

  // Populate exclusion dropdowns
  function populateExclusionDropdowns() {
    const nodeSelect = document.getElementById('routeExcludeNodeSelect');
    const linkSelect = document.getElementById('routeExcludeLinkSelect');

    if (nodeSelect) {
      nodeSelect.innerHTML = '<option value="">-- Select node to exclude --</option>';
      const sortedNodes = [...state.nodes].sort((a, b) => {
        const nameA = (a.name || a.code || '').toLowerCase();
        const nameB = (b.name || b.code || '').toLowerCase();
        return nameA.localeCompare(nameB);
      });
      sortedNodes.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n.id;
        const name = n.name || n.code || `Node ${n.id}`;
        opt.textContent = name;
        nodeSelect.appendChild(opt);
      });
    }

    if (linkSelect) {
      linkSelect.innerHTML = '<option value="">-- Select link to exclude --</option>';
      state.edges.forEach(e => {
        const nodeA = findNode(e.a);
        const nodeB = findNode(e.b);
        const opt = document.createElement('option');
        opt.value = e.id;
        const nameA = nodeA?.name || nodeA?.code || `N${e.a}`;
        const nameB = nodeB?.name || nodeB?.code || `N${e.b}`;
        opt.textContent = `${nameA} â†” ${nameB}`;
        linkSelect.appendChild(opt);
      });
    }
  }

  // Render excluded nodes list
  function renderExcludedNodesList() {
    const container = document.getElementById('excludedNodesList');
    if (!container) return;

    container.innerHTML = '';

    if (routeFinderState.excludedNodes.size === 0) {
      container.innerHTML = '<span style="font-size:10px; color:#94a3b8; font-style:italic;">No nodes excluded</span>';
      return;
    }

    routeFinderState.excludedNodes.forEach(nodeId => {
      const node = findNode(nodeId);
      if (!node) return;

      const tag = document.createElement('span');
      tag.style.cssText = 'display:inline-flex; align-items:center; gap:4px; padding:3px 6px 3px 8px; background:#ede9fe; color:#6d28d9; border-radius:12px; font-size:10px; font-weight:500;';
      tag.innerHTML = `
        ${node.name || node.code || 'Node ' + nodeId}
        <button style="background:none; border:none; color:#8b5cf6; cursor:pointer; font-size:12px; line-height:1; padding:0;"
                title="Remove from exclusions" data-node-id="${nodeId}">âœ•</button>
      `;
      tag.querySelector('button').addEventListener('click', (ev) => {
        ev.stopPropagation();
        removeExcludedNode(nodeId);
      });
      container.appendChild(tag);
    });
  }

  // Render excluded links list
  function renderExcludedLinksList() {
    const container = document.getElementById('excludedLinksList');
    if (!container) return;

    container.innerHTML = '';

    if (routeFinderState.excludedLinks.size === 0) {
      container.innerHTML = '<span style="font-size:10px; color:#94a3b8; font-style:italic;">No links excluded</span>';
      return;
    }

    routeFinderState.excludedLinks.forEach(edgeId => {
      const edge = state.edges.find(e => e.id === edgeId);
      if (!edge) return;

      const nodeA = findNode(edge.a);
      const nodeB = findNode(edge.b);
      const nameA = nodeA?.name || nodeA?.code || `N${edge.a}`;
      const nameB = nodeB?.name || nodeB?.code || `N${edge.b}`;

      const tag = document.createElement('span');
      tag.style.cssText = 'display:inline-flex; align-items:center; gap:4px; padding:3px 6px 3px 8px; background:#fee2e2; color:#dc2626; border-radius:12px; font-size:10px; font-weight:500;';
      tag.innerHTML = `
        ${nameA} â†” ${nameB}
        <button style="background:none; border:none; color:#ef4444; cursor:pointer; font-size:12px; line-height:1; padding:0;"
                title="Remove from exclusions" data-edge-id="${edgeId}">âœ•</button>
      `;
      tag.querySelector('button').addEventListener('click', (ev) => {
        ev.stopPropagation();
        removeExcludedLink(edgeId);
      });
      container.appendChild(tag);
    });
  }

  // Add excluded node
  function addExcludedNode(nodeId) {
    if (!nodeId || routeFinderState.excludedNodes.has(nodeId)) return;

    // Can't exclude origin or destination
    if (nodeId === routeFinderState.originNodeId || nodeId === routeFinderState.destNodeId) {
      showToast('âš ï¸ Cannot exclude origin or destination node');
      return;
    }

    routeFinderState.excludedNodes.add(nodeId);
    const node = findNode(nodeId);
    showToast(`ðŸ›« Excluded node: ${node?.name || node?.code || 'Node ' + nodeId}`);
    renderExcludedNodesList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Remove excluded node
  function removeExcludedNode(nodeId) {
    routeFinderState.excludedNodes.delete(nodeId);
    renderExcludedNodesList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Add excluded link
  function addExcludedLink(edgeId) {
    if (!edgeId || routeFinderState.excludedLinks.has(edgeId)) return;

    routeFinderState.excludedLinks.add(edgeId);
    const edge = state.edges.find(e => e.id === edgeId);
    if (edge) {
      const nodeA = findNode(edge.a);
      const nodeB = findNode(edge.b);
      const nameA = nodeA?.name || nodeA?.code || `N${edge.a}`;
      const nameB = nodeB?.name || nodeB?.code || `N${edge.b}`;
      showToast(`ðŸ›« Excluded link: ${nameA} â†” ${nameB}`);
    }
    renderExcludedLinksList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Remove excluded link
  function removeExcludedLink(edgeId) {
    routeFinderState.excludedLinks.delete(edgeId);
    renderExcludedLinksList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Clear all restrictions
  function clearAllRestrictions() {
    routeFinderState.excludedNodes.clear();
    routeFinderState.excludedLinks.clear();
    routeFinderState.visibleOnly = false;

    const visibleOnlyCheckbox = document.getElementById('routeVisibleOnly');
    if (visibleOnlyCheckbox) visibleOnlyCheckbox.checked = false;

    renderExcludedNodesList();
    renderExcludedLinksList();
    routeFinderState.routes = [];
    updateRouteFinderUI();
    showToast('ðŸ—‘ï¸ All exclusions cleared');
  }

  // ========== MUST-USE FUNCTIONS ==========

  // Render must-use nodes list
  function renderMustUseNodesList() {
    const container = document.getElementById('mustUseNodesList');
    if (!container) return;

    container.innerHTML = '';

    if (routeFinderState.mustUseNodes.size === 0) {
      container.innerHTML = '<span style="font-size:10px; color:#94a3b8; font-style:italic;">No must-use nodes</span>';
      return;
    }

    routeFinderState.mustUseNodes.forEach(nodeId => {
      const node = findNode(nodeId);
      if (!node) return;

      const tag = document.createElement('span');
      tag.style.cssText = 'display:inline-flex; align-items:center; gap:4px; padding:3px 6px 3px 8px; background:#dcfce7; color:#16a34a; border-radius:12px; font-size:10px; font-weight:500;';
      tag.innerHTML = `
        ${node.name || node.code || 'Node ' + nodeId}
        <button style="background:none; border:none; color:#22c55e; cursor:pointer; font-size:12px; line-height:1; padding:0;"
                title="Remove from must-use" data-node-id="${nodeId}">âœ•</button>
      `;
      tag.querySelector('button').addEventListener('click', (ev) => {
        ev.stopPropagation();
        removeMustUseNode(nodeId);
      });
      container.appendChild(tag);
    });
  }

  // Render must-use links list
  function renderMustUseLinksList() {
    const container = document.getElementById('mustUseLinksList');
    if (!container) return;

    container.innerHTML = '';

    if (routeFinderState.mustUseLinks.size === 0) {
      container.innerHTML = '<span style="font-size:10px; color:#94a3b8; font-style:italic;">No must-use links</span>';
      return;
    }

    routeFinderState.mustUseLinks.forEach(edgeId => {
      const edge = state.edges.find(e => e.id === edgeId);
      if (!edge) return;

      const nodeA = findNode(edge.a);
      const nodeB = findNode(edge.b);
      const nameA = nodeA?.name || nodeA?.code || `N${edge.a}`;
      const nameB = nodeB?.name || nodeB?.code || `N${edge.b}`;

      const tag = document.createElement('span');
      tag.style.cssText = 'display:inline-flex; align-items:center; gap:4px; padding:3px 6px 3px 8px; background:#dcfce7; color:#16a34a; border-radius:12px; font-size:10px; font-weight:500;';
      tag.innerHTML = `
        ${nameA} â†” ${nameB}
        <button style="background:none; border:none; color:#22c55e; cursor:pointer; font-size:12px; line-height:1; padding:0;"
                title="Remove from must-use" data-edge-id="${edgeId}">âœ•</button>
      `;
      tag.querySelector('button').addEventListener('click', (ev) => {
        ev.stopPropagation();
        removeMustUseLink(edgeId);
      });
      container.appendChild(tag);
    });
  }

  // Add must-use node
  function addMustUseNode(nodeId) {
    if (!nodeId || routeFinderState.mustUseNodes.has(nodeId)) return;

    // Can't be both excluded and must-use
    if (routeFinderState.excludedNodes.has(nodeId)) {
      showToast('âš ï¸ Node is currently excluded. Remove from exclusions first.');
      return;
    }

    routeFinderState.mustUseNodes.add(nodeId);
    const node = findNode(nodeId);
    showToast(`âœ… Must-use node: ${node?.name || node?.code || 'Node ' + nodeId}`);
    renderMustUseNodesList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Remove must-use node
  function removeMustUseNode(nodeId) {
    routeFinderState.mustUseNodes.delete(nodeId);
    renderMustUseNodesList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Add must-use link
  function addMustUseLink(edgeId) {
    if (!edgeId || routeFinderState.mustUseLinks.has(edgeId)) return;

    // Can't be both excluded and must-use
    if (routeFinderState.excludedLinks.has(edgeId)) {
      showToast('âš ï¸ Link is currently excluded. Remove from exclusions first.');
      return;
    }

    routeFinderState.mustUseLinks.add(edgeId);
    const edge = state.edges.find(e => e.id === edgeId);
    if (edge) {
      const nodeA = findNode(edge.a);
      const nodeB = findNode(edge.b);
      const nameA = nodeA?.name || nodeA?.code || `N${edge.a}`;
      const nameB = nodeB?.name || nodeB?.code || `N${edge.b}`;
      showToast(`âœ… Must-use link: ${nameA} â†” ${nameB}`);
    }
    renderMustUseLinksList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Remove must-use link
  function removeMustUseLink(edgeId) {
    routeFinderState.mustUseLinks.delete(edgeId);
    renderMustUseLinksList();
    routeFinderState.routes = []; // Clear routes
    updateRouteFinderUI();
  }

  // Clear all must-use constraints
  function clearAllMustUse() {
    routeFinderState.mustUseNodes.clear();
    routeFinderState.mustUseLinks.clear();

    renderMustUseNodesList();
    renderMustUseLinksList();
    routeFinderState.routes = [];
    updateRouteFinderUI();
    showToast('ðŸ—‘ï¸ All must-use constraints cleared');
  }

  // Update transit latency row visibility
  function updateTransitLatencyVisibility() {
    if (containerLatencyRow) {
      containerLatencyRow.style.opacity = routeFinderState.enableContainerTransit ? '1' : '0.5';
    }
    if (regionLatencyRow) {
      regionLatencyRow.style.opacity = routeFinderState.enableRegionTransit ? '1' : '0.5';
    }
  }

  // Populate must-use dropdowns
  function populateMustUseDropdowns() {
    if (routeMustUseNodeSelect) {
      routeMustUseNodeSelect.innerHTML = '<option value="">-- Select node (must pass through) --</option>';
      state.nodes.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n.id;
        opt.textContent = n.name || n.code || `Node ${n.id}`;
        routeMustUseNodeSelect.appendChild(opt);
      });
    }

    if (routeMustUseLinkSelect) {
      routeMustUseLinkSelect.innerHTML = '<option value="">-- Select link (must use) --</option>';
      state.edges.forEach(e => {
        const nodeA = findNode(e.a);
        const nodeB = findNode(e.b);
        const opt = document.createElement('option');
        opt.value = e.id;
        const nameA = nodeA?.name || nodeA?.code || `N${e.a}`;
        const nameB = nodeB?.name || nodeB?.code || `N${e.b}`;
        opt.textContent = `${nameA} â†” ${nameB}`;
        routeMustUseLinkSelect.appendChild(opt);
      });
    }
  }

  // Handle exclusion pick mode click on node
  function handleExclusionNodeClick(nodeId) {
    if (!routeFinderState.active) return false;

    if (routeFinderState.pickMode === 'excludeNode') {
      addExcludedNode(nodeId);
      routeFinderState.pickMode = null;
      updatePickModeButtons();
      return true;
    }

    if (routeFinderState.pickMode === 'mustUseNode') {
      addMustUseNode(nodeId);
      routeFinderState.pickMode = null;
      updatePickModeButtons();
      return true;
    }

    return false;
  }

  // Handle exclusion pick mode click on link
  function handleExclusionLinkClick(edgeId) {
    if (!routeFinderState.active) return false;

    if (routeFinderState.pickMode === 'excludeLink') {
      addExcludedLink(edgeId);
      routeFinderState.pickMode = null;
      updatePickModeButtons();
      return true;
    }

    if (routeFinderState.pickMode === 'mustUseLink') {
      addMustUseLink(edgeId);
      routeFinderState.pickMode = null;
      updatePickModeButtons();
      return true;
    }

    return false;
  }

  // Update pick mode button styles
  function updatePickModeButtons() {
    const btnPickNode = document.getElementById('btnPickExcludeNode');
    const btnPickLink = document.getElementById('btnPickExcludeLink');
    const btnPickMustNode = document.getElementById('btnPickMustUseNode');
    const btnPickMustLink = document.getElementById('btnPickMustUseLink');
    const btnPickDiverseFrom = document.getElementById('btnPickDiverseFromLink');

    // Reset all buttons first
    [btnPickNode, btnPickLink, btnPickMustNode, btnPickMustLink, btnPickDiverseFrom].forEach(btn => {
      if (btn) {
        btn.style.background = '';
        btn.style.color = '';
      }
    });

    // Highlight active pick mode
    if (routeFinderState.pickMode === 'excludeNode' && btnPickNode) {
      btnPickNode.style.background = '#7c3aed';
      btnPickNode.style.color = 'white';
    }
    if (routeFinderState.pickMode === 'excludeLink' && btnPickLink) {
      btnPickLink.style.background = '#dc2626';
      btnPickLink.style.color = 'white';
    }
    if (routeFinderState.pickMode === 'mustUseNode' && btnPickMustNode) {
      btnPickMustNode.style.background = '#16a34a';
      btnPickMustNode.style.color = 'white';
    }
    if (routeFinderState.pickMode === 'mustUseLink' && btnPickMustLink) {
      btnPickMustLink.style.background = '#16a34a';
      btnPickMustLink.style.color = 'white';
    }
    if (routeFinderState.pickMode === 'diverseFromLink' && btnPickDiverseFrom) {
      btnPickDiverseFrom.style.background = '#22c55e';
      btnPickDiverseFrom.style.color = 'white';
    }
  }

  // Calculate routes
  function calculateRoutes() {
    // Auto-exit protection mode before recalculating primary routes
    if (routeFinderState.protectionMode) {
      exitProtectionMode();
    }

    if (!routeFinderState.originNodeId || !routeFinderState.destNodeId) {
      showToast('Please select both origin and destination');
      return;
    }

    // Check if origin or destination is excluded
    if (routeFinderState.excludedNodes.has(routeFinderState.originNodeId)) {
      showToast('âš ï¸ Origin node is excluded - remove from restrictions first');
      return;
    }
    if (routeFinderState.excludedNodes.has(routeFinderState.destNodeId)) {
      showToast('âš ï¸ Destination node is excluded - remove from restrictions first');
      return;
    }

    // Update settings from inputs
    if (routeContainerLatency) {
      routeFinderState.containerLatency = parseFloat(routeContainerLatency.value) || 1;
    }
    if (routeRegionLatency) {
      routeFinderState.regionLatency = parseFloat(routeRegionLatency.value) || 10;
    }
    if (routeEnableContainerTransit) {
      routeFinderState.enableContainerTransit = routeEnableContainerTransit.checked;
    }
    if (routeEnableRegionTransit) {
      routeFinderState.enableRegionTransit = routeEnableRegionTransit.checked;
    }

    // Choose pathfinding algorithm based on MLG preference setting
    let routes;
    if (routeFinderState.preferMLGs) {
      // Use MLG-preferred pathfinding (Phase 1: pure MLG, Phase 2: hybrid)
      console.log('[Route Finder] MLG Preference enabled - using MLG-preferred pathfinding');
      routes = findKShortestPathsWithMLGPreference(
        routeFinderState.originNodeId,
        routeFinderState.destNodeId,
        3
      );
    } else {
      // Use standard pathfinding
      routes = findKShortestPaths(
        routeFinderState.originNodeId,
        routeFinderState.destNodeId,
        3
      );
    }

    routeFinderState.routes = routes;
    routeFinderState.activeRouteIndex = 0;

    updateRouteFinderUI();

    // Build restriction/constraint summary for toast
    const constraints = [];
    if (routeFinderState.preferMLGs) constraints.push('MLG preferred');
    if (routeFinderState.visibleOnly) constraints.push('visible only');
    if (!routeFinderState.enableContainerTransit) constraints.push('no container transit');
    if (!routeFinderState.enableRegionTransit) constraints.push('no region transit');
    if (routeFinderState.excludedNodes.size > 0) constraints.push(`${routeFinderState.excludedNodes.size} node(s) excluded`);
    if (routeFinderState.excludedLinks.size > 0) constraints.push(`${routeFinderState.excludedLinks.size} link(s) excluded`);
    if (routeFinderState.mustUseNodes.size > 0) constraints.push(`${routeFinderState.mustUseNodes.size} must-use node(s)`);
    if (routeFinderState.mustUseLinks.size > 0) constraints.push(`${routeFinderState.mustUseLinks.size} must-use link(s)`);
    if (routeFinderState.mustUseMLGs.size > 0) constraints.push(`${routeFinderState.mustUseMLGs.size} must-use MLG(s)`);
    if (routeFinderState.excludedMLGs.size > 0) constraints.push(`${routeFinderState.excludedMLGs.size} MLG(s) excluded`);
    // Add diversity constraints info
    const chkLinearPhysicalDiversity = document.getElementById('chkLinearPhysicalDiversity');
    if (chkLinearPhysicalDiversity?.checked && routeFinderState.diverseFromLinks.size > 0) {
      const inputLinearRequiredDiversity = document.getElementById('inputLinearRequiredDiversity');
      const reqDiv = inputLinearRequiredDiversity ? parseInt(inputLinearRequiredDiversity.value) || 100 : 100;
      constraints.push(`diverse from ${routeFinderState.diverseFromLinks.size} link(s) â‰¥${reqDiv}%`);
    }
    const constraintText = constraints.length > 0 ? ` (${constraints.join(', ')})` : '';

    if (routes.length > 0) {
      highlightActiveRoute();
      showToast(`âœ… Found ${routes.length} route${routes.length > 1 ? 's' : ''}${constraintText}`);
    } else {
      clearRouteHighlights();
      highlightEndpoints();
      showToast(`âŒ No path found${constraintText}`);
    }
  }

  // Display route results
  function displayRouteResults() {
    if (!routeResultsContent) return;

    routeResultsContent.innerHTML = '';

    if (routeFinderState.routes.length === 0) {
      const hasRestrictions = routeFinderState.visibleOnly ||
                              routeFinderState.excludedNodes.size > 0 ||
                              routeFinderState.excludedLinks.size > 0;
      const hasMustUse = routeFinderState.mustUseNodes.size > 0 ||
                         routeFinderState.mustUseLinks.size > 0;
      const hasTransitDisabled = !routeFinderState.enableContainerTransit ||
                                 !routeFinderState.enableRegionTransit;

      let hint = 'Nodes are not connected';
      if (hasMustUse) {
        hint = 'No routes found passing through all must-use constraints';
      } else if (hasRestrictions) {
        hint = 'Try adjusting restrictions';
      } else if (hasTransitDisabled) {
        hint = 'Try enabling container/region transit';
      }

      routeResultsContent.innerHTML = `
        <div style="padding:20px; text-align:center; color:#666;">
          <div style="font-size:32px; margin-bottom:8px;">ðŸ›«</div>
          <div><strong>No path found</strong></div>
          <div style="font-size:11px; margin-top:4px;">${hint}</div>
        </div>
      `;
      return;
    }

    const routeLabels = ['Best Route', 'Alternative 1', 'Alternative 2'];
    const routeIcons = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'];
    const routeColors = ['#22c55e', '#f59e0b', '#f97316'];

    // Get cost display settings
    const currency = state.financialSettings?.baseCurrency || 'USD';
    const showCost = routeFinderState.optimizationBalance > 0;
    const costMetric = routeFinderState.costMetric || 'lease';
    const costLabel = costMetric === 'iru' ? 'IRU NPV' : 'ACV';

    routeFinderState.routes.forEach((route, index) => {
      const nodeNames = route.path.map(id => {
        const n = findNode(id);
        return n?.name || 'N' + id;
      });

      const hops = route.path.length - 1;
      const implicitCount = route.segments.filter(s => s.implicit).length;
      const isActive = index === routeFinderState.activeRouteIndex;

      // Calculate commercial cost for this route
      const commercialCost = calculateRouteCost(route.segments);
      const formattedCost = formatCurrency(commercialCost, currency);

      const option = document.createElement('div');
      option.className = 'route-option' + (isActive ? ' active' : '');
      option.style.borderLeftColor = routeColors[index];
      option.style.borderLeftWidth = '4px';
      if (isActive) {
        option.style.background = index === 0 ? '#f0fdf4' : (index === 1 ? '#fffbeb' : '#fff7ed');
      }
      option.dataset.routeIndex = index;

      // Build stats line with both latency and cost
      let statsHtml = `<span>â›¡ ${route.totalCost.toFixed(2)} ms</span>`;
      statsHtml += `<span>ðŸ’° ${formattedCost}</span>`;
      statsHtml += `<span>ðŸ“ ${hops} hop${hops !== 1 ? 's' : ''}</span>`;
      if (implicitCount > 0) {
        statsHtml += `<span>â‹¯ ${implicitCount} implicit</span>`;
      }

      option.innerHTML = `
        <div class="route-option-header">
          <span class="route-option-title">
            <span style="font-size:16px;">${routeIcons[index]}</span> ${routeLabels[index]}
          </span>
          <div style="display:flex; gap:6px; align-items:center;">
            <span style="background:#dbeafe; color:#1e40af; padding:2px 6px; border-radius:3px; font-size:10px; font-weight:600;">
              ${route.totalCost.toFixed(2)} ms
            </span>
            ${showCost ? `<span style="background:#dcfce7; color:#166534; padding:2px 6px; border-radius:3px; font-size:10px; font-weight:600;">
              ${formattedCost}
            </span>` : ''}
          </div>
        </div>
        <div class="route-option-path" style="margin:6px 0; font-size:11px; color:#555; word-break:break-word;">
          ${nodeNames.join(' â†’ ')}
        </div>
        <div class="route-option-stats" style="display:flex; gap:12px; font-size:10px; color:#888; flex-wrap:wrap;">
          ${statsHtml}
        </div>
      `;

      option.addEventListener('click', () => selectRoute(index));
      routeResultsContent.appendChild(option);
    });
  }

  // Select and highlight a route
  function selectRoute(index) {
    routeFinderState.activeRouteIndex = index;

    // Update UI
    displayRouteResults();

    // Show route details
    showRouteDetails(routeFinderState.routes[index]);

    // Highlight on canvas
    highlightActiveRoute();
  }

  // Show detailed route info
  function showRouteDetails(route) {
    if (!routeDetailsSection || !routeDetailsContent) return;

    routeDetailsSection.style.display = 'block';
    routeDetailsSection.classList.remove('collapsed');

    // Show Save as MLG button
    const saveAsMLGContainer = document.getElementById('saveAsMLGContainer');
    if (saveAsMLGContainer) {
      saveAsMLGContainer.style.display = 'block';
    }
    // Update compatible MLGs dropdown for add-to-existing feature
    if (typeof updateCompatibleMLGDropdown === 'function') {
      updateCompatibleMLGDropdown();
    }

    let html = '<div style="font-size:11px;">';

    // Add route type indicator if MLG-related
    if (route.isPureMLG) {
      html += `<div style="padding:6px 8px; margin-bottom:8px; background:linear-gradient(135deg, #fdf4ff 0%, #f5f3ff 100%); border:1px solid #e9d5ff; border-radius:6px; font-size:10px; color:#7c3aed;">
        <span style="font-weight:600;">ðŸ”— Pure MLG Route</span> â€” Uses only Multilink Groups
      </div>`;
    } else if (route.hasMLGs) {
      html += `<div style="padding:6px 8px; margin-bottom:8px; background:linear-gradient(135deg, #fef3c7 0%, #fdf4ff 100%); border:1px solid #fcd34d; border-radius:6px; font-size:10px; color:#92400e;">
        <span style="font-weight:600;">ðŸ”€ Hybrid Route</span> â€” Combines MLGs and individual links
      </div>`;
    }

    route.segments.forEach((seg, i) => {
      const fromNode = findNode(route.path[i]);
      const toNode = findNode(route.path[i + 1]);
      const fromName = fromNode?.name || 'N' + route.path[i];
      const toName = toNode?.name || 'N' + route.path[i + 1];

      const isImplicit = seg.implicit;
      const isMLG = seg.isMLG;
      const latency = seg.latency || routeFinderState.minLatency;

      // Different styling for MLG vs Link hops
      let hopStyle = '';
      let hopLabel = '';
      let hopIcon = '';
      let hopCost = '';

      // Get commercial cost for this hop
      if (seg.edgeId && !isImplicit) {
        const edge = findEdge(seg.edgeId);
        if (edge) {
          const edgeCost = getEdgeCostForPathfinding(edge);
          const currency = state.financialSettings?.baseCurrency || 'USD';
          hopCost = `<span style="color:#059669; font-size:9px; margin-left:4px;">${formatCurrency(edgeCost, currency)}</span>`;
        }
      }

      if (isMLG) {
        // MLG hop - purple/violet styling
        hopStyle = 'background:linear-gradient(135deg, #faf5ff 0%, #f3e8ff 100%); border-left:3px solid #a855f7;';
        const mlg = findMultilinkGroup(seg.mlgId);
        hopLabel = `<span style="color:#7c3aed; font-size:10px; font-weight:600;">ðŸ”— MLG: ${mlg?.name || 'Unknown'}</span>`;
        hopIcon = 'ðŸ”—';
        // Get MLG cost
        if (mlg) {
          const mlgCosts = calculateMLGCosts(mlg);
          const currency = state.financialSettings?.baseCurrency || 'USD';
          const costMetric = routeFinderState.costMetric || 'lease';
          const mlgCostValue = costMetric === 'iru' ? mlgCosts.iruNpv : mlgCosts.acv;
          hopCost = `<span style="color:#7c3aed; font-size:9px; margin-left:4px;">${formatCurrency(mlgCostValue, currency)}</span>`;
        }
      } else if (isImplicit) {
        // Implicit hop - amber styling
        hopStyle = 'background:#fffbeb; border-left:3px solid #f59e0b;';
        hopLabel = '<span style="color:#f59e0b; font-size:10px;"> (implicit)</span>';
        hopIcon = 'â‹¯';

        // Get container/region cost for implicit transit
        const groupId = seg.containerId || seg.regionId;
        if (groupId) {
          const group = findGroup(groupId);
          if (group) {
            const currency = state.financialSettings?.baseCurrency || 'USD';
            const containerCost = getContainerCostForPathfinding(group);
            hopCost = `<span style="color:#f59e0b; font-size:9px; margin-left:4px;">${formatCurrency(containerCost, currency)}</span>`;
            hopLabel = `<span style="color:#f59e0b; font-size:10px;"> (implicit via ${group.title || 'container'})</span>`;
          } else {
            hopCost = '<span style="color:#94a3b8; font-size:9px; margin-left:4px;">$0</span>';
          }
        } else {
          hopCost = '<span style="color:#94a3b8; font-size:9px; margin-left:4px;">$0</span>';
        }
      } else {
        // Regular link hop - default styling
        hopStyle = 'border-left:3px solid #e5e7eb;';
        const edge = seg.edgeId ? findEdge(seg.edgeId) : null;
        const linkCode = edge?.code || (seg.edgeId ? `L-${seg.edgeId}` : '');
        if (linkCode) {
          hopLabel = `<span style="color:#6b7280; font-size:10px;">${linkCode}</span>`;
        }
        hopIcon = 'â”€';
      }

      html += `
        <div style="padding:8px; margin-bottom:4px; border-radius:4px; ${hopStyle} display:flex; align-items:center; gap:8px;">
          <span style="color:#888; font-size:10px; width:20px;">${i + 1}.</span>
          <span style="font-size:14px; width:20px;">${hopIcon}</span>
          <span style="flex:1;">
            <div><strong>${fromName}</strong> â†’ <strong>${toName}</strong></div>
            ${hopLabel}
          </span>
          <div style="text-align:right;">
            <div style="color:#666; font-size:10px; font-weight:500;">${latency.toFixed(2)} ms</div>
            ${hopCost}
          </div>
        </div>
      `;
    });

    // Count MLG vs link hops
    const mlgHops = route.segments.filter(s => s.isMLG).length;
    const linkHops = route.segments.filter(s => !s.isMLG && !s.implicit).length;
    const implicitHops = route.segments.filter(s => s.implicit).length;

    // Calculate total commercial cost
    const commercialCost = calculateRouteCost(route.segments);
    const currency = state.financialSettings?.baseCurrency || 'USD';
    const formattedCost = formatCurrency(commercialCost, currency);
    const costMetric = routeFinderState.costMetric || 'lease';
    const costLabel = costMetric === 'iru' ? 'IRU NPV' : 'ACV';

    html += `
      <div style="padding:10px 0; margin-top:8px; border-top:1px solid #e5e7eb;">
        <div style="display:flex; justify-content:space-between; font-weight:600; margin-bottom:6px;">
          <span>â›¡ Total Latency:</span>
          <span>${route.totalCost.toFixed(3)} ms</span>
        </div>
        <div style="display:flex; justify-content:space-between; font-weight:600; margin-bottom:6px; color:#059669;">
          <span>ðŸ’° Total ${costLabel}:</span>
          <span>${formattedCost}</span>
        </div>
        <div style="display:flex; gap:12px; font-size:10px; color:#6b7280;">
          ${mlgHops > 0 ? `<span style="color:#7c3aed;">ðŸ”— ${mlgHops} MLG</span>` : ''}
          ${linkHops > 0 ? `<span>â”€ ${linkHops} link${linkHops !== 1 ? 's' : ''}</span>` : ''}
          ${implicitHops > 0 ? `<span style="color:#f59e0b;">â‹¯ ${implicitHops} implicit</span>` : ''}
        </div>
      </div>
    </div>`;

    routeDetailsContent.innerHTML = html;
  }

  // Clear route highlights from SVG
  function clearRouteHighlights() {
    // Clear standard view highlights
    svg.querySelectorAll('.node.route-origin, .node.route-dest, .node.route-path-node, .node.route-closure-node').forEach(el => {
      el.classList.remove('route-origin', 'route-dest', 'route-path-node', 'route-closure-node');
    });
    // Clear geo view highlights
    svg.querySelectorAll('.geo-node.route-origin, .geo-node.route-dest, .geo-node.route-path-node, .geo-node.route-closure-node').forEach(el => {
      el.classList.remove('route-origin', 'route-dest', 'route-path-node', 'route-closure-node');
    });
    svg.querySelectorAll('.edge.route-path-1, .edge.route-path-2, .edge.route-path-3, .edge.route-protection-path, .route-protection-path').forEach(el => {
      el.classList.remove('route-path-1', 'route-path-2', 'route-path-3', 'route-protection-path');
    });
    svg.querySelectorAll('.route-implicit-segment').forEach(el => el.remove());

    // Clear protection path lines (drawn as separate SVG elements - legacy cleanup)
    svg.querySelectorAll('.protection-path-line').forEach(el => el.remove());

    // Clear MLG-specific styling (Phase 1)
    svg.querySelectorAll('.edge.route-mlg-segment').forEach(el => {
      el.classList.remove('route-mlg-segment');
      const pathEl = el.querySelector('path:not(.edge-hit)');
      if (pathEl) {
        pathEl.style.stroke = '';
        pathEl.style.strokeWidth = '';
        pathEl.style.filter = '';
      }
    });
  }

  // Highlight just the endpoints
  function highlightEndpoints() {
    clearRouteHighlights();

    // Check if we're in Geographic View
    const inGeoView = typeof geoViewState !== 'undefined' && geoViewState.active;

    if (routeFinderState.originNodeId) {
      let el = svg.querySelector(`g.node[data-node-id="${routeFinderState.originNodeId}"]`);
      if (!el && inGeoView) {
        el = svg.querySelector(`circle.geo-node[data-node-id="${routeFinderState.originNodeId}"]`);
      }
      if (el) el.classList.add('route-origin');
    }

    if (routeFinderState.destNodeId) {
      let el = svg.querySelector(`g.node[data-node-id="${routeFinderState.destNodeId}"]`);
      if (!el && inGeoView) {
        el = svg.querySelector(`circle.geo-node[data-node-id="${routeFinderState.destNodeId}"]`);
      }
      if (el) el.classList.add('route-dest');
    }
  }

  // Highlight active route on SVG
  function highlightActiveRoute() {
    clearRouteHighlights();
    highlightEndpoints();

    if (routeFinderState.routes.length === 0) {
      // Also clear MapLibre path if no routes
      clearMapLibreRoutePath();
      return;
    }

    const route = routeFinderState.routes[routeFinderState.activeRouteIndex];
    const routeClass = `route-path-${routeFinderState.activeRouteIndex + 1}`;
    const routeColors = ['#22c55e', '#f59e0b', '#f97316'];
    const mlgColor = '#a855f7'; // Purple for MLG segments
    const color = routeColors[routeFinderState.activeRouteIndex];

    // Check if we're in Geographic View
    const inGeoView = typeof geoViewState !== 'undefined' && geoViewState.active;

    // Highlight intermediate nodes
    route.path.slice(1, -1).forEach(nodeId => {
      // Try standard view selector first, then geo view
      let el = svg.querySelector(`g.node[data-node-id="${nodeId}"]`);
      if (!el && inGeoView) {
        el = svg.querySelector(`circle.geo-node[data-node-id="${nodeId}"]`);
      }
      if (el) el.classList.add('route-path-node');
    });

    // Highlight edges (including MLG constituent links)
    route.segments.forEach((segment, i) => {
      if (segment.isMLG && segment.mlgId) {
        // MLG segment - highlight all links within the MLG
        const mlg = findMultilinkGroup(segment.mlgId);
        if (mlg && mlg.segments) {
          // Collect all link IDs from all paths in all segments of the MLG
          const mlgLinkIds = new Set();
          mlg.segments.forEach(seg => {
            if (seg.paths) {
              seg.paths.forEach(path => {
                if (path.links) {
                  path.links.forEach(linkId => mlgLinkIds.add(linkId));
                }
              });
            }
          });

          // Highlight each link in the MLG with the MLG color
          mlgLinkIds.forEach(linkId => {
            const edgeEl = svg.querySelector(`.edge[data-edge-id="${linkId}"]`);
            if (edgeEl) {
              edgeEl.classList.add(routeClass);
              edgeEl.classList.add('route-mlg-segment');
              // Apply MLG-specific styling
              const pathEl = edgeEl.querySelector('path:not(.edge-hit)');
              if (pathEl) {
                pathEl.style.stroke = mlgColor;
                pathEl.style.strokeWidth = '5';
                pathEl.style.filter = `drop-shadow(0 0 8px ${mlgColor})`;
              }
            }
          });

          // Also highlight intermediate nodes within the MLG
          mlg.segments.forEach(seg => {
            if (seg.fromNode) {
              let el = svg.querySelector(`g.node[data-node-id="${seg.fromNode}"]`);
              if (!el && inGeoView) {
                el = svg.querySelector(`circle.geo-node[data-node-id="${seg.fromNode}"]`);
              }
              if (el) el.classList.add('route-path-node');
            }
            if (seg.toNode) {
              let el = svg.querySelector(`g.node[data-node-id="${seg.toNode}"]`);
              if (!el && inGeoView) {
                el = svg.querySelector(`circle.geo-node[data-node-id="${seg.toNode}"]`);
              }
              if (el) el.classList.add('route-path-node');
            }
          });
        }
      } else if (segment.edgeId) {
        const edgeEl = svg.querySelector(`.edge[data-edge-id="${segment.edgeId}"]`);
        if (edgeEl) {
          edgeEl.classList.add(routeClass);
        }
      } else if (segment.implicit) {
        // Draw implicit edge
        const fromId = route.path[i];
        const toId = route.path[i + 1];
        const from = findNode(fromId);
        const to = findNode(toId);

        if (from && to) {
          let fromPos, toPos;

          if (inGeoView && from.gpsLat != null && from.gpsLon != null && to.gpsLat != null && to.gpsLon != null) {
            // Use GPS coordinates in geo view
            fromPos = gpsToCanvas(from.gpsLat, from.gpsLon);
            toPos = gpsToCanvas(to.gpsLat, to.gpsLon);
          } else {
            // Use canvas coordinates in standard view
            fromPos = { x: from.x, y: from.y };
            toPos = { x: to.x, y: to.y };
          }

          const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          line.setAttribute('d', `M${fromPos.x},${fromPos.y} L${toPos.x},${toPos.y}`);
          line.setAttribute('stroke', color);
          line.setAttribute('stroke-width', '5');
          line.setAttribute('stroke-dasharray', '10,5');
          line.setAttribute('fill', 'none');
          line.setAttribute('opacity', '0.9');
          line.classList.add('route-implicit-segment');
          line.style.filter = `drop-shadow(0 0 6px ${color})`;

          const gridEl = svg.querySelector('.grid');
          if (gridEl && gridEl.nextSibling) {
            svg.insertBefore(line, gridEl.nextSibling);
          } else {
            svg.appendChild(line);
          }
        }
      }
    });

    // Highlight protection path if calculated
    highlightProtectionPath();

    // Also render the route in MapLibre Geo Dynamic Map
    renderRouteInMapLibre(route, color);
  }

  // Highlight protection path on canvas by adding CSS class to edge elements
  function highlightProtectionPath() {
    const protectionPath = routeFinderState.protectionPath;

    console.log('[Protection Highlight] Called');
    console.log('[Protection Highlight] protectionPath.segments:', protectionPath?.segments);

    if (!protectionPath || !protectionPath.path || !protectionPath.segments) {
      console.log('[Protection Highlight] No protection path to highlight');
      return;
    }

    if (protectionPath.segments.length === 0) {
      console.log('[Protection Highlight] No segments to highlight');
      return;
    }

    console.log('[Protection Highlight] Highlighting', protectionPath.segments.length, 'segments');

    // Get origin and destination to avoid highlighting them as closure nodes
    const originId = routeFinderState.originNodeId;
    const destId = routeFinderState.destNodeId;

    // Highlight ONLY intermediate closure nodes
    const inGeoView = typeof geoViewState !== 'undefined' && geoViewState.active;
    routeFinderState.protectionClosureNodes.forEach(nodeId => {
      if (nodeId === originId || nodeId === destId) return;

      let el = svg.querySelector(`g.node[data-node-id="${nodeId}"]`);
      if (!el && inGeoView) {
        el = svg.querySelector(`circle.geo-node[data-node-id="${nodeId}"]`);
      }
      if (el) el.classList.add('route-closure-node');
    });

    // Highlight each segment by adding class to existing edge elements
    // This matches how highlightActiveRoute() does it for the primary path
    let highlightedCount = 0;

    protectionPath.segments.forEach((segment, i) => {
      const edgeId = segment.edgeId;

      if (edgeId === null || edgeId === undefined) {
        console.log('[Protection Highlight] Segment', i, 'has no edgeId (implicit?)');
        return;
      }

      // Find edge element using the same selector pattern as primary route
      // First try the .edge class selector (path elements have class="edge")
      let edgeEl = svg.querySelector(`path.edge[data-edge-id="${edgeId}"]`);

      // Also try line elements
      if (!edgeEl) {
        edgeEl = svg.querySelector(`line.edge[data-edge-id="${edgeId}"]`);
      }

      // Try without .edge class in case it was stripped
      if (!edgeEl) {
        edgeEl = svg.querySelector(`path[data-edge-id="${edgeId}"]`);
      }
      if (!edgeEl) {
        edgeEl = svg.querySelector(`line[data-edge-id="${edgeId}"]`);
      }

      console.log('[Protection Highlight] Edge', edgeId, '- found:', !!edgeEl);

      if (edgeEl) {
        // Add the protection path class - CSS will handle the styling
        edgeEl.classList.add('route-protection-path');
        highlightedCount++;
        console.log('[Protection Highlight] âœ“ Added route-protection-path class to edge', edgeId);
      } else {
        console.log('[Protection Highlight] âœ— Could not find edge element for id:', edgeId);
      }
    });

    console.log('[Protection Highlight] Total highlighted:', highlightedCount, 'edges');

    // Also render protection path in MapLibre if active
    renderProtectionPathInMapLibre(protectionPath);
  }

  // Render protection path in MapLibre Geo Dynamic Map
  function renderProtectionPathInMapLibre(protectionPath) {
    if (!window.mapLibreState || !window.mapLibreState.map || !window.mapLibreState.isStyleLoaded) return;
    if (!protectionPath || !protectionPath.segments || protectionPath.segments.length === 0) return;

    // Clear any existing protection path layers
    clearMapLibreProtectionPath();

    const protectionColor = '#f59e0b'; // Amber - same as CSS route-protection-path
    const useKmlPaths = mapLibreState.pathRenderMode === 'paths';
    const features = [];

    if (useKmlPaths) {
      // KML mode: use cable geometry for each segment when available
      protectionPath.segments.forEach((segment, i) => {
        if (segment.edgeId) {
          const edge = findEdge(segment.edgeId);
          if (edge && edge.cableGeometry && edge.cableGeometry.coordinates) {
            features.push({
              type: 'Feature',
              properties: {},
              geometry: edge.cableGeometry
            });
          } else {
            // No cable geometry - straight line between segment nodes
            const fromNodeId = protectionPath.path[i];
            const toNodeId = protectionPath.path[i + 1];
            const fromNode = findNode(fromNodeId);
            const toNode = findNode(toNodeId);
            if (fromNode && toNode && fromNode.gpsLat != null && fromNode.gpsLon != null &&
                toNode.gpsLat != null && toNode.gpsLon != null) {
              features.push({
                type: 'Feature',
                properties: {},
                geometry: {
                  type: 'LineString',
                  coordinates: [[fromNode.gpsLon, fromNode.gpsLat], [toNode.gpsLon, toNode.gpsLat]]
                }
              });
            }
          }
        }
      });
    }

    // Fallback: node-to-node straight line path
    if (features.length === 0 && protectionPath.path) {
      const coordinates = [];
      protectionPath.path.forEach(nodeId => {
        const node = findNode(nodeId);
        if (node && node.gpsLat != null && node.gpsLon != null) {
          coordinates.push([node.gpsLon, node.gpsLat]);
        }
      });

      if (coordinates.length >= 2) {
        features.push({
          type: 'Feature',
          properties: {},
          geometry: {
            type: 'LineString',
            coordinates: coordinates
          }
        });
      }
    }

    if (features.length === 0) return;

    try {
      mapLibreState.map.addSource('route-finder-protection', {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: features
        }
      });

      // Add outer glow layer
      mapLibreState.map.addLayer({
        id: 'route-finder-protection-glow',
        type: 'line',
        source: 'route-finder-protection',
        paint: {
          'line-color': protectionColor,
          'line-width': 10,
          'line-opacity': 0.3,
          'line-blur': 3
        },
        layout: {
          'line-cap': 'round',
          'line-join': 'round'
        }
      });

      // Add main protection path layer (dashed to distinguish from primary)
      mapLibreState.map.addLayer({
        id: 'route-finder-protection-main',
        type: 'line',
        source: 'route-finder-protection',
        paint: {
          'line-color': protectionColor,
          'line-width': 4,
          'line-opacity': 0.9,
          'line-dasharray': [4, 3]
        },
        layout: {
          'line-cap': 'round',
          'line-join': 'round'
        }
      });
    } catch (err) {
      console.warn('Failed to render protection path in MapLibre:', err);
    }
  }

  // Clear protection path from MapLibre
  function clearMapLibreProtectionPath() {
    if (!window.mapLibreState || !window.mapLibreState.map) return;

    try {
      if (mapLibreState.map.getLayer('route-finder-protection-glow')) {
        mapLibreState.map.removeLayer('route-finder-protection-glow');
      }
      if (mapLibreState.map.getLayer('route-finder-protection-main')) {
        mapLibreState.map.removeLayer('route-finder-protection-main');
      }
      if (mapLibreState.map.getSource('route-finder-protection')) {
        mapLibreState.map.removeSource('route-finder-protection');
      }
    } catch (err) {
      // Ignore errors during cleanup
    }
  }

  // Render route in MapLibre Geo Dynamic Map
  function renderRouteInMapLibre(route, color) {
    if (!window.mapLibreState || !window.mapLibreState.map || !window.mapLibreState.isStyleLoaded) return;

    // Clear any existing route path
    clearMapLibreRoutePath();

    const useKmlPaths = mapLibreState.pathRenderMode === 'paths';

    // Build geometry features from route segments
    const features = [];

    if (useKmlPaths && route.segments) {
      // KML mode: use cable geometry for each segment when available
      route.segments.forEach((segment, i) => {
        if (segment.edgeId) {
          const edge = findEdge(segment.edgeId);
          if (edge && edge.cableGeometry && edge.cableGeometry.coordinates) {
            // Use the KML cable geometry
            features.push({
              type: 'Feature',
              properties: {},
              geometry: edge.cableGeometry
            });
          } else {
            // No cable geometry - use straight line between nodes
            const fromNodeId = route.path[i];
            const toNodeId = route.path[i + 1];
            const fromNode = findNode(fromNodeId);
            const toNode = findNode(toNodeId);
            if (fromNode && toNode && fromNode.gpsLat != null && fromNode.gpsLon != null &&
                toNode.gpsLat != null && toNode.gpsLon != null) {
              features.push({
                type: 'Feature',
                properties: {},
                geometry: {
                  type: 'LineString',
                  coordinates: [[fromNode.gpsLon, fromNode.gpsLat], [toNode.gpsLon, toNode.gpsLat]]
                }
              });
            }
          }
        } else if (segment.implicit) {
          // Implicit segment - straight line between nodes
          const fromNodeId = route.path[i];
          const toNodeId = route.path[i + 1];
          const fromNode = findNode(fromNodeId);
          const toNode = findNode(toNodeId);
          if (fromNode && toNode && fromNode.gpsLat != null && fromNode.gpsLon != null &&
              toNode.gpsLat != null && toNode.gpsLon != null) {
            features.push({
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'LineString',
                coordinates: [[fromNode.gpsLon, fromNode.gpsLat], [toNode.gpsLon, toNode.gpsLat]]
              }
            });
          }
        } else if (segment.isMLG && segment.mlgId) {
          // MLG segment - collect all constituent link geometries
          const mlg = typeof findMultilinkGroup === 'function' ? findMultilinkGroup(segment.mlgId) : null;
          if (mlg && mlg.segments) {
            mlg.segments.forEach(seg => {
              if (seg.paths) {
                seg.paths.forEach(path => {
                  if (path.links) {
                    path.links.forEach(linkId => {
                      const edge = findEdge(linkId);
                      if (edge && edge.cableGeometry && edge.cableGeometry.coordinates) {
                        features.push({
                          type: 'Feature',
                          properties: {},
                          geometry: edge.cableGeometry
                        });
                      } else if (edge) {
                        const fromNode = findNode(edge.a);
                        const toNode = findNode(edge.b);
                        if (fromNode && toNode && fromNode.gpsLat != null && fromNode.gpsLon != null &&
                            toNode.gpsLat != null && toNode.gpsLon != null) {
                          features.push({
                            type: 'Feature',
                            properties: {},
                            geometry: {
                              type: 'LineString',
                              coordinates: [[fromNode.gpsLon, fromNode.gpsLat], [toNode.gpsLon, toNode.gpsLat]]
                            }
                          });
                        }
                      }
                    });
                  }
                });
              }
            });
          }
        }
      });
    }

    // If no KML features were built (KML mode off or no segments), fall back to node-to-node path
    if (features.length === 0) {
      const coordinates = [];
      route.path.forEach(nodeId => {
        const node = findNode(nodeId);
        if (node && node.gpsLat != null && node.gpsLon != null) {
          coordinates.push([node.gpsLon, node.gpsLat]);
        }
      });

      if (coordinates.length < 2) return;

      features.push({
        type: 'Feature',
        properties: {},
        geometry: {
          type: 'LineString',
          coordinates: coordinates
        }
      });
    }

    try {
      // Add the route path source as a FeatureCollection (supports multiple geometries)
      mapLibreState.map.addSource('route-finder-path', {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: features
        }
      });

      // Add outer glow layer
      mapLibreState.map.addLayer({
        id: 'route-finder-path-glow',
        type: 'line',
        source: 'route-finder-path',
        paint: {
          'line-color': color,
          'line-width': 10,
          'line-opacity': 0.3,
          'line-blur': 3
        },
        layout: {
          'line-cap': 'round',
          'line-join': 'round'
        }
      });

      // Add main route layer
      mapLibreState.map.addLayer({
        id: 'route-finder-path-main',
        type: 'line',
        source: 'route-finder-path',
        paint: {
          'line-color': color,
          'line-width': 5,
          'line-opacity': 0.9
        },
        layout: {
          'line-cap': 'round',
          'line-join': 'round'
        }
      });

      // Highlight origin and destination nodes
      highlightRouteNodesInMapLibre(route.path, color);

    } catch (err) {
      console.warn('Failed to render route in MapLibre:', err);
    }
  }

  // Clear route path from MapLibre
  function clearMapLibreRoutePath() {
    if (!window.mapLibreState || !window.mapLibreState.map) return;

    try {
      if (mapLibreState.map.getLayer('route-finder-path-glow')) {
        mapLibreState.map.removeLayer('route-finder-path-glow');
      }
      if (mapLibreState.map.getLayer('route-finder-path-main')) {
        mapLibreState.map.removeLayer('route-finder-path-main');
      }
      if (mapLibreState.map.getSource('route-finder-path')) {
        mapLibreState.map.removeSource('route-finder-path');
      }

      // Also clear protection path layers
      clearMapLibreProtectionPath();

      // Clear node highlights
      clearRouteNodeHighlightsInMapLibre();
    } catch (err) {
      // Ignore errors during cleanup
    }
  }

  // Highlight route nodes in MapLibre
  function highlightRouteNodesInMapLibre(path, color) {
    // This visually updates the node markers to show they're part of the route
    document.querySelectorAll('.maplibre-node-marker').forEach(marker => {
      const nodeId = marker.dataset.nodeId;
      if (!nodeId) return;

      const pathIndex = path.indexOf(nodeId);
      const isOrigin = pathIndex === 0;
      const isDest = pathIndex === path.length - 1;
      const isIntermediate = pathIndex > 0 && pathIndex < path.length - 1;

      const circle = marker.querySelector('circle');
      if (!circle) return;

      // Reset first
      circle.removeAttribute('data-route-node');

      if (isOrigin) {
        circle.setAttribute('stroke', '#22c55e');
        circle.setAttribute('stroke-width', '4');
        circle.setAttribute('data-route-node', 'origin');
      } else if (isDest) {
        circle.setAttribute('stroke', '#ef4444');
        circle.setAttribute('stroke-width', '4');
        circle.setAttribute('data-route-node', 'dest');
      } else if (isIntermediate) {
        circle.setAttribute('stroke', color);
        circle.setAttribute('stroke-width', '3');
        circle.setAttribute('data-route-node', 'intermediate');
      }
    });
  }

  // Clear route node highlights in MapLibre
  function clearRouteNodeHighlightsInMapLibre() {
    document.querySelectorAll('.maplibre-node-marker circle[data-route-node]').forEach(circle => {
      const node = findNode(circle.closest('.maplibre-node-marker')?.dataset.nodeId);
      if (node) {
        circle.setAttribute('stroke', node.stroke || '#6c8ebf');
        circle.setAttribute('stroke-width', '2');
      }
      circle.removeAttribute('data-route-node');
    });
  }

  // Swap endpoints
  function swapEndpoints() {
    const temp = routeFinderState.originNodeId;
    routeFinderState.originNodeId = routeFinderState.destNodeId;
    routeFinderState.destNodeId = temp;

    routeFinderState.routes = [];
    routeFinderState.activeRouteIndex = 0;
    // Clear protection state on endpoint change
    routeFinderState.protectionPath = null;
    routeFinderState.protectionClosureNodes.clear();
    routeFinderState.primaryPathForProtection = null;
    routeFinderState.storedRoutesForProtection = null;
    routeFinderState.storedActiveRouteIndex = 0;

    updateRouteFinderUI();
    highlightEndpoints();
    showToast('â‡„ Endpoints swapped');
  }

  // Event listeners
  const rfBtn = document.getElementById('btnRouteFinder');
  let rfBtnClickInProgress = false;
  if (rfBtn) {
    rfBtn.addEventListener('click', function(ev) {
      ev.stopPropagation();
      ev.preventDefault();

      // Prevent double-firing
      if (rfBtnClickInProgress) {
        console.log('[ROUTE FINDER] Click already in progress, ignoring');
        return;
      }
      rfBtnClickInProgress = true;

      console.log('[ROUTE FINDER] Button clicked');
      toggleRouteFinder();

      // Reset flag after a short delay
      setTimeout(() => { rfBtnClickInProgress = false; }, 100);
    });
  } else {
    console.error('[ROUTE FINDER] Button not found!');
  }

  if (btnCloseRouteFinder) {
    btnCloseRouteFinder.addEventListener('click', exitCalculationMode);
  }

  if (btnExitRouteFinder) {
    btnExitRouteFinder.addEventListener('click', exitCalculationMode);
  }

  if (routeOriginSelect) {
    routeOriginSelect.addEventListener('change', () => {
      const val = parseInt(routeOriginSelect.value, 10);
      if (!isNaN(val)) {
        if (val === routeFinderState.destNodeId) {
          showToast('âš ï¸ Origin cannot be same as destination');
          routeOriginSelect.value = routeFinderState.originNodeId || '';
          return;
        }
        routeFinderState.originNodeId = val;
        routeFinderState.routes = [];
        // Clear protection state on endpoint change
        routeFinderState.protectionPath = null;
        routeFinderState.protectionClosureNodes.clear();
        routeFinderState.primaryPathForProtection = null;
        routeFinderState.storedRoutesForProtection = null;
        routeFinderState.storedActiveRouteIndex = 0;
        updateRouteFinderUI();
        highlightEndpoints();
      } else {
        routeFinderState.originNodeId = null;
        routeFinderState.routes = [];
        // Clear protection state on endpoint change
        routeFinderState.protectionPath = null;
        routeFinderState.protectionClosureNodes.clear();
        routeFinderState.primaryPathForProtection = null;
        routeFinderState.storedRoutesForProtection = null;
        routeFinderState.storedActiveRouteIndex = 0;
        updateRouteFinderUI();
        highlightEndpoints();
      }
    });
  }

  if (routeDestSelect) {
    routeDestSelect.addEventListener('change', () => {
      const val = parseInt(routeDestSelect.value, 10);
      if (!isNaN(val)) {
        if (val === routeFinderState.originNodeId) {
          showToast('âš ï¸ Destination cannot be same as origin');
          routeDestSelect.value = routeFinderState.destNodeId || '';
          return;
        }
        routeFinderState.destNodeId = val;
        routeFinderState.routes = [];
        // Clear protection state on endpoint change
        routeFinderState.protectionPath = null;
        routeFinderState.protectionClosureNodes.clear();
        routeFinderState.primaryPathForProtection = null;
        routeFinderState.storedRoutesForProtection = null;
        routeFinderState.storedActiveRouteIndex = 0;
        updateRouteFinderUI();
        highlightEndpoints();
      } else {
        routeFinderState.destNodeId = null;
        routeFinderState.routes = [];
        // Clear protection state on endpoint change
        routeFinderState.protectionPath = null;
        routeFinderState.protectionClosureNodes.clear();
        routeFinderState.primaryPathForProtection = null;
        routeFinderState.storedRoutesForProtection = null;
        routeFinderState.storedActiveRouteIndex = 0;
        updateRouteFinderUI();
        highlightEndpoints();
      }
    });
  }

  if (btnCalculateRoutes) btnCalculateRoutes.addEventListener('click', calculateRoutes);
  if (btnSwapEndpoints) btnSwapEndpoints.addEventListener('click', swapEndpoints);

  // Restriction controls event handlers
  const routeVisibleOnlyCheckbox = document.getElementById('routeVisibleOnly');
  const routeExcludeNodeSelect = document.getElementById('routeExcludeNodeSelect');
  const routeExcludeLinkSelect = document.getElementById('routeExcludeLinkSelect');
  const btnAddExcludeNode = document.getElementById('btnAddExcludeNode');
  const btnPickExcludeNode = document.getElementById('btnPickExcludeNode');
  const btnAddExcludeLink = document.getElementById('btnAddExcludeLink');
  const btnPickExcludeLink = document.getElementById('btnPickExcludeLink');
  const btnClearAllRestrictions = document.getElementById('btnClearAllRestrictions');

  if (routeVisibleOnlyCheckbox) {
    routeVisibleOnlyCheckbox.addEventListener('change', () => {
      routeFinderState.visibleOnly = routeVisibleOnlyCheckbox.checked;
      routeFinderState.routes = []; // Clear routes
      updateRouteFinderUI();
      if (typeof updateActiveFiltersIndicator === 'function') {
        updateActiveFiltersIndicator();
      }
      if (routeFinderState.visibleOnly) {
        showToast('ðŸ‘ï¸ Calculating using visible elements only');
      } else {
        showToast('ðŸ“Š Calculating using all elements');
      }
    });
  }

  if (btnAddExcludeNode) {
    btnAddExcludeNode.addEventListener('click', () => {
      const val = parseInt(routeExcludeNodeSelect?.value, 10);
      if (!isNaN(val)) {
        addExcludedNode(val);
        routeExcludeNodeSelect.value = '';
      }
    });
  }

  if (btnPickExcludeNode) {
    btnPickExcludeNode.addEventListener('click', () => {
      if (routeFinderState.pickMode === 'excludeNode') {
        routeFinderState.pickMode = null;
        showToast('Node pick mode cancelled');
      } else {
        routeFinderState.pickMode = 'excludeNode';
        showToast('ðŸŽ¯ Click on a node to exclude it from calculations');
      }
      updatePickModeButtons();
    });
  }

  if (btnAddExcludeLink) {
    btnAddExcludeLink.addEventListener('click', () => {
      const val = parseInt(routeExcludeLinkSelect?.value, 10);
      if (!isNaN(val)) {
        addExcludedLink(val);
        routeExcludeLinkSelect.value = '';
      }
    });
  }

  if (btnPickExcludeLink) {
    btnPickExcludeLink.addEventListener('click', () => {
      if (routeFinderState.pickMode === 'excludeLink') {
        routeFinderState.pickMode = null;
        showToast('Link pick mode cancelled');
      } else {
        routeFinderState.pickMode = 'excludeLink';
        showToast('ðŸŽ¯ Click on a link to exclude it from calculations');
      }
      updatePickModeButtons();
    });
  }

  if (btnClearAllRestrictions) {
    btnClearAllRestrictions.addEventListener('click', clearAllRestrictions);
  }

  // Must-use node event listeners
  if (btnAddMustUseNode) {
    btnAddMustUseNode.addEventListener('click', () => {
      const val = parseInt(routeMustUseNodeSelect?.value, 10);
      if (!isNaN(val)) {
        addMustUseNode(val);
        routeMustUseNodeSelect.value = '';
      }
    });
  }

  if (btnPickMustUseNode) {
    btnPickMustUseNode.addEventListener('click', () => {
      if (routeFinderState.pickMode === 'mustUseNode') {
        routeFinderState.pickMode = null;
        showToast('Must-use node pick mode cancelled');
      } else {
        routeFinderState.pickMode = 'mustUseNode';
        showToast('âœ… Click on a node to add as must-use waypoint');
      }
      updatePickModeButtons();
    });
  }

  // Must-use link event listeners
  if (btnAddMustUseLink) {
    btnAddMustUseLink.addEventListener('click', () => {
      const val = parseInt(routeMustUseLinkSelect?.value, 10);
      if (!isNaN(val)) {
        addMustUseLink(val);
        routeMustUseLinkSelect.value = '';
      }
    });
  }

  if (btnPickMustUseLink) {
    btnPickMustUseLink.addEventListener('click', () => {
      if (routeFinderState.pickMode === 'mustUseLink') {
        routeFinderState.pickMode = null;
        showToast('Must-use link pick mode cancelled');
      } else {
        routeFinderState.pickMode = 'mustUseLink';
        showToast('âœ… Click on a link to add as must-use');
      }
      updatePickModeButtons();
    });
  }

  if (btnClearAllMustUse) {
    btnClearAllMustUse.addEventListener('click', clearAllMustUse);
  }

  // ============== PHYSICAL ROUTING DIVERSITY CONSTRAINTS ==============

  // Add diverse-from link
  function addDiverseFromLink(edgeId) {
    const edge = findEdge(edgeId);
    if (!edge) return;

    routeFinderState.diverseFromLinks.add(edgeId);
    updateDiverseFromLinksList();
    populateDiverseFromLinkDropdown();
    showToast(`Added diversity constraint: must be diverse from ${edge.code || 'L-'+edgeId}`);
  }

  // Remove diverse-from link
  function removeDiverseFromLink(edgeId) {
    routeFinderState.diverseFromLinks.delete(edgeId);
    updateDiverseFromLinksList();
    populateDiverseFromLinkDropdown();
  }

  // Update diverse-from links list display
  function updateDiverseFromLinksList() {
    const listEl = document.getElementById('diverseFromLinksList');
    if (!listEl) return;

    if (routeFinderState.diverseFromLinks.size === 0) {
      listEl.innerHTML = '<span class="muted" style="font-size:10px; color:#6b7280;">No diversity constraints</span>';
      return;
    }

    listEl.innerHTML = Array.from(routeFinderState.diverseFromLinks).map(edgeId => {
      const edge = findEdge(edgeId);
      if (!edge) return '';
      const nodeA = findNode(edge.a);
      const nodeB = findNode(edge.b);
      const linkName = edge.code || `L-${edgeId}`;
      return `
        <span style="display:inline-flex; align-items:center; gap:4px; padding:3px 8px; background:#dcfce7; border:1px solid #86efac; border-radius:12px; font-size:10px; color:#166534;">
          <strong>${linkName}</strong>
          <span style="color:#15803d; font-size:9px;">${nodeA?.code || 'N'+edge.a}â†”${nodeB?.code || 'N'+edge.b}</span>
          <button onclick="removeDiverseFromLink(${edgeId})" style="background:none; border:none; color:#dc2626; cursor:pointer; font-size:12px; padding:0 2px; line-height:1;">âœ•</button>
        </span>
      `;
    }).join('');
  }

  // Populate diverse-from link dropdown
  function populateDiverseFromLinkDropdown() {
    const selectEl = document.getElementById('routeDiverseFromLinkSelect');
    if (!selectEl) return;

    selectEl.innerHTML = '<option value="">-- Select link --</option>';
    state.edges.forEach(e => {
      if (routeFinderState.diverseFromLinks.has(e.id)) return; // Skip already added

      const nodeA = findNode(e.a);
      const nodeB = findNode(e.b);
      const linkName = e.code || `L-${e.id}`;
      const nodePair = `${nodeA?.code || 'N'+e.a} â†” ${nodeB?.code || 'N'+e.b}`;

      const opt = document.createElement('option');
      opt.value = e.id;
      opt.textContent = `${linkName}: ${nodePair}`;
      selectEl.appendChild(opt);
    });
  }

  // Clear all diversity constraints
  function clearDiversityConstraints() {
    routeFinderState.diverseFromLinks.clear();
    updateDiverseFromLinksList();
    populateDiverseFromLinkDropdown();
    showToast('Diversity constraints cleared');
  }

  // Expose for inline onclick handlers
  window.removeDiverseFromLink = removeDiverseFromLink;

  // Set up event handlers for diversity constraints
  const btnAddDiverseFromLink = document.getElementById('btnAddDiverseFromLink');
  if (btnAddDiverseFromLink) {
    btnAddDiverseFromLink.addEventListener('click', () => {
      const selectEl = document.getElementById('routeDiverseFromLinkSelect');
      const edgeId = selectEl?.value ? parseInt(selectEl.value) : null;
      if (edgeId) {
        addDiverseFromLink(edgeId);
      } else {
        showToast('Please select a link');
      }
    });
  }

  const btnPickDiverseFromLink = document.getElementById('btnPickDiverseFromLink');
  if (btnPickDiverseFromLink) {
    btnPickDiverseFromLink.addEventListener('click', () => {
      if (routeFinderState.pickMode === 'diverseFromLink') {
        routeFinderState.pickMode = null;
      } else {
        routeFinderState.pickMode = 'diverseFromLink';
        showToast('Click a link on the canvas to add as diversity constraint');
      }
      updatePickModeButtons();
    });
  }

  const btnClearDiversityConstraints = document.getElementById('btnClearDiversityConstraints');
  if (btnClearDiversityConstraints) {
    btnClearDiversityConstraints.addEventListener('click', clearDiversityConstraints);
  }

  // Initialize diversity lists when route finder opens
  function initializeDiversityConstraints() {
    updateDiverseFromLinksList();
    populateDiverseFromLinkDropdown();
  }

  // ============== ROUTE FINDER TAG FILTERS ==============

  // Populate tag filter lists when opening the section
  function populateRouteTagFilters() {
    // Collect all unique node tags using the same method as Tags panel
    const nodeTags = new Set();
    state.nodes.forEach(n => {
      // Use the same getNodeTags function if available, otherwise fallback
      if (typeof getNodeTags === 'function') {
        getNodeTags(n).forEach(t => nodeTags.add(t));
      } else if (n.tags && Array.isArray(n.tags)) {
        n.tags.forEach(t => nodeTags.add(t));
      }
      if (n.filterTags && Array.isArray(n.filterTags)) {
        n.filterTags.forEach(t => {
          const trimmed = t.trim().toLowerCase();
          if (trimmed) nodeTags.add(trimmed);
        });
      }
    });

    // Collect all unique link tags using getEdgeTags
    const linkTags = new Set();
    state.edges.forEach(e => {
      if (typeof getEdgeTags === 'function') {
        getEdgeTags(e).forEach(t => linkTags.add(t));
      } else {
        // Fallback: check filterTags array
        if (e.filterTags && Array.isArray(e.filterTags)) {
          e.filterTags.forEach(t => {
            const trimmed = t.trim().toLowerCase();
            if (trimmed) linkTags.add(trimmed);
          });
        }
        // Also check extraTags
        if (e.extraTags) {
          e.extraTags.split(',').forEach(t => {
            const trimmed = t.trim().toLowerCase();
            if (trimmed) linkTags.add(trimmed);
          });
        }
        // Add default
        linkTags.add('default');
      }
    });

    // Populate node tag list
    const nodeTagList = document.getElementById('routeNodeTagList');
    if (nodeTagList) {
      nodeTagList.innerHTML = '';
      if (nodeTags.size === 0) {
        nodeTagList.innerHTML = '<div style="font-size:10px; color:#888; padding:4px;">No node tags in diagram</div>';
      } else {
        Array.from(nodeTags).sort().forEach(tag => {
          const label = document.createElement('label');
          label.style.cssText = 'display:flex; align-items:center; gap:4px; padding:2px 4px; cursor:pointer; font-size:10px;';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.value = tag;
          cb.checked = routeFinderState.nodeTagFilter.has(tag);
          cb.addEventListener('change', () => {
            if (cb.checked) {
              routeFinderState.nodeTagFilter.add(tag);
            } else {
              routeFinderState.nodeTagFilter.delete(tag);
            }
            updateRouteTagSelectedChips('node');
            routeFinderState.routes = [];
            updateRouteFinderUI();
          });
          label.appendChild(cb);
          label.appendChild(document.createTextNode(tag));
          nodeTagList.appendChild(label);
        });
      }
    }

    // Populate link tag list
    const linkTagList = document.getElementById('routeLinkTagList');
    if (linkTagList) {
      linkTagList.innerHTML = '';
      if (linkTags.size === 0) {
        linkTagList.innerHTML = '<div style="font-size:10px; color:#888; padding:4px;">No link tags in diagram</div>';
      } else {
        Array.from(linkTags).sort().forEach(tag => {
          const label = document.createElement('label');
          label.style.cssText = 'display:flex; align-items:center; gap:4px; padding:2px 4px; cursor:pointer; font-size:10px;';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.value = tag;
          cb.checked = routeFinderState.linkTagFilter.has(tag);
          cb.addEventListener('change', () => {
            if (cb.checked) {
              routeFinderState.linkTagFilter.add(tag);
            } else {
              routeFinderState.linkTagFilter.delete(tag);
            }
            updateRouteTagSelectedChips('link');
            routeFinderState.routes = [];
            updateRouteFinderUI();
          });
          label.appendChild(cb);
          label.appendChild(document.createTextNode(tag));
          linkTagList.appendChild(label);
        });
      }
    }

    updateRouteTagSelectedChips('node');
    updateRouteTagSelectedChips('link');
  }

  // Update the selected tag chips display
  function updateRouteTagSelectedChips(type) {
    const container = document.getElementById(type === 'node' ? 'routeNodeTagSelected' : 'routeLinkTagSelected');
    const filterSet = type === 'node' ? routeFinderState.nodeTagFilter : routeFinderState.linkTagFilter;
    const mode = type === 'node' ? routeFinderState.nodeTagMode : routeFinderState.linkTagMode;

    if (!container) return;
    container.innerHTML = '';

    if (mode === 'any' || filterSet.size === 0) {
      return; // No chips to show
    }

    const modeColor = mode === 'include' ? '#22c55e' : '#ef4444';
    const modeLabel = mode === 'include' ? 'âœ“' : 'âœ—';

    filterSet.forEach(tag => {
      const chip = document.createElement('span');
      chip.style.cssText = `display:inline-flex; align-items:center; gap:2px; padding:2px 6px; border-radius:10px; font-size:9px; background:${mode === 'include' ? '#dcfce7' : '#fee2e2'}; color:${modeColor}; border:1px solid ${modeColor};`;
      chip.innerHTML = `${modeLabel} ${tag} <span style="cursor:pointer; margin-left:2px;" title="Remove">Ã—</span>`;
      chip.querySelector('span').addEventListener('click', () => {
        filterSet.delete(tag);
        // Uncheck in the list
        const list = document.getElementById(type === 'node' ? 'routeNodeTagList' : 'routeLinkTagList');
        if (list) {
          const cb = list.querySelector(`input[value="${tag}"]`);
          if (cb) cb.checked = false;
        }
        updateRouteTagSelectedChips(type);
        routeFinderState.routes = [];
        updateRouteFinderUI();
      });
      container.appendChild(chip);
    });
  }

  // Update hint text based on mode
  function updateRouteTagModeHint(type) {
    const hint = document.getElementById(type === 'node' ? 'routeNodeTagModeHint' : 'routeLinkTagModeHint');
    const mode = type === 'node' ? routeFinderState.nodeTagMode : routeFinderState.linkTagMode;
    const filterSet = type === 'node' ? routeFinderState.nodeTagFilter : routeFinderState.linkTagFilter;
    const list = document.getElementById(type === 'node' ? 'routeNodeTagList' : 'routeLinkTagList');

    if (!hint) return;

    if (mode === 'any') {
      hint.textContent = type === 'node' ? 'All nodes allowed' : 'All links allowed';
      hint.style.color = '#888';
      if (list) list.style.display = 'none';
    } else if (mode === 'include') {
      hint.textContent = filterSet.size > 0 ? `Only ${filterSet.size} tag(s)` : 'Select tags to include';
      hint.style.color = '#22c55e';
      if (list) list.style.display = 'block';
    } else if (mode === 'exclude') {
      hint.textContent = filterSet.size > 0 ? `Excluding ${filterSet.size} tag(s)` : 'Select tags to exclude';
      hint.style.color = '#ef4444';
      if (list) list.style.display = 'block';
    }
  }

  // Node tag mode change handler
  const routeNodeTagMode = document.getElementById('routeNodeTagMode');
  if (routeNodeTagMode) {
    routeNodeTagMode.addEventListener('change', () => {
      routeFinderState.nodeTagMode = routeNodeTagMode.value;
      updateRouteTagModeHint('node');
      updateRouteTagSelectedChips('node');
      routeFinderState.routes = [];
      updateRouteFinderUI();
    });
  }

  // Link tag mode change handler
  const routeLinkTagMode = document.getElementById('routeLinkTagMode');
  if (routeLinkTagMode) {
    routeLinkTagMode.addEventListener('change', () => {
      routeFinderState.linkTagMode = routeLinkTagMode.value;
      updateRouteTagModeHint('link');
      updateRouteTagSelectedChips('link');
      routeFinderState.routes = [];
      updateRouteFinderUI();
    });
  }

  // Clear tag filters button
  const btnClearRouteTagFilters = document.getElementById('btnClearRouteTagFilters');
  if (btnClearRouteTagFilters) {
    btnClearRouteTagFilters.addEventListener('click', () => {
      routeFinderState.nodeTagMode = 'any';
      routeFinderState.nodeTagFilter.clear();
      routeFinderState.linkTagMode = 'any';
      routeFinderState.linkTagFilter.clear();

      // Reset UI
      if (routeNodeTagMode) routeNodeTagMode.value = 'any';
      if (routeLinkTagMode) routeLinkTagMode.value = 'any';
      updateRouteTagModeHint('node');
      updateRouteTagModeHint('link');
      updateRouteTagSelectedChips('node');
      updateRouteTagSelectedChips('link');
      populateRouteTagFilters();

      routeFinderState.routes = [];
      updateRouteFinderUI();
      showToast('ðŸ—‘ï¸ Tag filters cleared');
    });
  }

  // Populate tag filters when route finder is opened
  const originalEnterCalcMode = enterCalculationMode;
  enterCalculationMode = function() {
    originalEnterCalcMode();
    populateRouteTagFilters();
    updateRouteTagModeHint('node');
    updateRouteTagModeHint('link');
  };

  // ============== END ROUTE FINDER TAG FILTERS ==============

  // ============== ROUTE FINDER CAPACITY FILTERS ==============

  // Show/hide capacity filter sections based on mode
  function updateCapacityFilterSections() {
    const totalSection = document.getElementById('routeCapacityTotalSection');
    const unitsSection = document.getElementById('routeCapacityUnitsSection');

    if (totalSection) totalSection.style.display = routeFinderState.capacityMode === 'total' ? 'block' : 'none';
    if (unitsSection) unitsSection.style.display = routeFinderState.capacityMode === 'units' ? 'block' : 'none';
  }

  // Capacity mode radio buttons
  const capacityModeRadios = document.querySelectorAll('input[name="routeCapacityMode"]');
  capacityModeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      routeFinderState.capacityMode = radio.value;
      updateCapacityFilterSections();
      routeFinderState.routes = [];
      updateRouteFinderUI();
    });
  });

  // Total capacity input
  const routeCapacityMinTotal = document.getElementById('routeCapacityMinTotal');
  if (routeCapacityMinTotal) {
    routeCapacityMinTotal.addEventListener('input', () => {
      routeFinderState.capacityMinTotal = parseFloat(routeCapacityMinTotal.value) || 0;
      routeFinderState.routes = [];
      updateRouteFinderUI();
    });
  }

  // Unit capacity inputs
  const routeCapacityMin1G = document.getElementById('routeCapacityMin1G');
  const routeCapacityMin10G = document.getElementById('routeCapacityMin10G');
  const routeCapacityMin100G = document.getElementById('routeCapacityMin100G');
  const routeCapacityMin400G = document.getElementById('routeCapacityMin400G');
  const routeCapacityMinTbps = document.getElementById('routeCapacityMinTbps');

  if (routeCapacityMin1G) {
    routeCapacityMin1G.addEventListener('input', () => {
      routeFinderState.capacityMin1G = parseFloat(routeCapacityMin1G.value) || 0;
      routeFinderState.routes = [];
      updateRouteFinderUI();
    });
  }
  if (routeCapacityMin10G) {
    routeCapacityMin10G.addEventListener('input', () => {
      routeFinderState.capacityMin10G = parseFloat(routeCapacityMin10G.value) || 0;
      routeFinderState.routes = [];
      updateRouteFinderUI();
    });
  }
  if (routeCapacityMin100G) {
    routeCapacityMin100G.addEventListener('input', () => {
      routeFinderState.capacityMin100G = parseFloat(routeCapacityMin100G.value) || 0;
      routeFinderState.routes = [];
      updateRouteFinderUI();
    });
  }
  if (routeCapacityMin400G) {
    routeCapacityMin400G.addEventListener('input', () => {
      routeFinderState.capacityMin400G = parseFloat(routeCapacityMin400G.value) || 0;
      routeFinderState.routes = [];
      updateRouteFinderUI();
    });
  }
  if (routeCapacityMinTbps) {
    routeCapacityMinTbps.addEventListener('input', () => {
      routeFinderState.capacityMinTbps = parseFloat(routeCapacityMinTbps.value) || 0;
      routeFinderState.routes = [];
      updateRouteFinderUI();
    });
  }

  // Include undefined capacity checkbox
  const routeCapacityIncludeUndefined = document.getElementById('routeCapacityIncludeUndefined');
  if (routeCapacityIncludeUndefined) {
    routeCapacityIncludeUndefined.addEventListener('change', () => {
      routeFinderState.capacityIncludeUndefined = routeCapacityIncludeUndefined.checked;
      routeFinderState.routes = [];
      updateRouteFinderUI();
      updateActiveFiltersIndicator();
    });
  }

  // Skip implicit transit checkbox (at top of panel)
  const routeSkipImplicitTransit = document.getElementById('routeSkipImplicitTransit');
  if (routeSkipImplicitTransit) {
    routeSkipImplicitTransit.addEventListener('change', () => {
      routeFinderState.skipImplicitTransit = routeSkipImplicitTransit.checked;
      routeFinderState.routes = [];
      updateRouteFinderUI();
      if (typeof updateActiveFiltersIndicator === 'function') {
        updateActiveFiltersIndicator();
      }
      if (routeFinderState.skipImplicitTransit) {
        showToast('ðŸ›« Implicit container transit disabled');
      } else {
        showToast('âœ… Implicit container transit enabled');
      }
    });
  }

  // ============== COST OPTIMIZATION EVENT HANDLERS (Phase 4) ==============

  // Update balance display text
  function updateOptimizationBalanceDisplay() {
    const slider = document.getElementById('routeOptimizationBalance');
    const latencyPct = document.getElementById('routeBalanceLatencyPct');
    const costPct = document.getElementById('routeBalanceCostPct');
    const valueLabel = document.getElementById('routeBalanceValue');

    if (!slider) return;

    const value = parseInt(slider.value);
    const latency = 100 - value;
    const cost = value;

    if (latencyPct) latencyPct.textContent = `${latency}%`;
    if (costPct) costPct.textContent = `${cost}%`;

    if (valueLabel) {
      if (value === 0) {
        valueLabel.textContent = 'Pure Latency';
        valueLabel.style.color = '#3b82f6';
      } else if (value === 100) {
        valueLabel.textContent = 'Pure Cost';
        valueLabel.style.color = '#059669';
      } else if (value < 30) {
        valueLabel.textContent = 'Latency Priority';
        valueLabel.style.color = '#3b82f6';
      } else if (value > 70) {
        valueLabel.textContent = 'Cost Priority';
        valueLabel.style.color = '#059669';
      } else {
        valueLabel.textContent = 'Balanced';
        valueLabel.style.color = '#6b7280';
      }
    }
  }

  // Optimization balance slider
  const routeOptimizationBalance = document.getElementById('routeOptimizationBalance');
  if (routeOptimizationBalance) {
    routeOptimizationBalance.addEventListener('input', () => {
      const value = parseInt(routeOptimizationBalance.value);
      routeFinderState.optimizationBalance = value / 100; // Convert 0-100 to 0-1
      updateOptimizationBalanceDisplay();
    });

    routeOptimizationBalance.addEventListener('change', () => {
      // Clear cached routes when optimization changes
      routeFinderState.routes = [];
      updateRouteFinderUI();
      if (typeof updateActiveFiltersIndicator === 'function') {
        updateActiveFiltersIndicator();
      }
    });
  }

  // Cost metric radio buttons
  const routeCostMetricLease = document.getElementById('routeCostMetricLease');
  const routeCostMetricIRU = document.getElementById('routeCostMetricIRU');

  [routeCostMetricLease, routeCostMetricIRU].forEach(radio => {
    if (radio) {
      radio.addEventListener('change', () => {
        routeFinderState.costMetric = radio.value;
        routeFinderState.routes = [];
        updateRouteFinderUI();
        if (typeof updateActiveFiltersIndicator === 'function') {
          updateActiveFiltersIndicator();
        }

        // Update visual styling
        const leaseLabel = document.getElementById('routeCostMetricLeaseLabel');
        const iruLabel = document.getElementById('routeCostMetricIRULabel');
        if (leaseLabel) {
          leaseLabel.style.borderColor = radio.value === 'lease' ? '#3b82f6' : '#e5e7eb';
          leaseLabel.style.background = radio.value === 'lease' ? '#eff6ff' : 'white';
        }
        if (iruLabel) {
          iruLabel.style.borderColor = radio.value === 'iru' ? '#8b5cf6' : '#e5e7eb';
          iruLabel.style.background = radio.value === 'iru' ? '#faf5ff' : 'white';
        }
      });
    }
  });

  // Cost scale radio buttons
  const routeCostScaleLog = document.getElementById('routeCostScaleLog');
  const routeCostScaleLinear = document.getElementById('routeCostScaleLinear');

  [routeCostScaleLog, routeCostScaleLinear].forEach(radio => {
    if (radio) {
      radio.addEventListener('change', () => {
        routeFinderState.costScale = radio.value;
        routeFinderState.routes = [];
        updateRouteFinderUI();
      });
    }
  });

  // Capacity tier radio buttons for pricing
  const tierRadios = ['1G', '10G', '100G', '400G'].map(t => document.getElementById(`routeCapTier${t}`));
  const tierLabels = ['1G', '10G', '100G', '400G'].map(t => document.getElementById(`routeCapTier${t}Label`));

  function updateCapacityTierLabels(selectedTier) {
    ['1G', '10G', '100G', '400G'].forEach(tier => {
      const label = document.getElementById(`routeCapTier${tier}Label`);
      if (label) {
        if (tier === selectedTier) {
          label.style.borderColor = '#059669';
          label.style.background = '#ecfdf5';
          label.style.color = '#047857';
        } else {
          label.style.borderColor = '#e5e7eb';
          label.style.background = 'white';
          label.style.color = '#374151';
        }
      }
    });
  }

  tierRadios.forEach(radio => {
    if (radio) {
      radio.addEventListener('change', () => {
        routeFinderState.capacityTier = radio.value;
        routeFinderState.routes = [];
        updateRouteFinderUI();
        updateCapacityTierLabels(radio.value);
        if (typeof updateActiveFiltersIndicator === 'function') {
          updateActiveFiltersIndicator();
        }
      });
    }
  });

  // Initialize balance display
  setTimeout(() => {
    updateOptimizationBalanceDisplay();
  }, 100);

  // ============== END COST OPTIMIZATION EVENT HANDLERS ==============

  // Clear capacity filter button
  const btnClearRouteCapacityFilter = document.getElementById('btnClearRouteCapacityFilter');
  if (btnClearRouteCapacityFilter) {
    btnClearRouteCapacityFilter.addEventListener('click', () => {
      // Reset state
      routeFinderState.capacityMode = 'none';
      routeFinderState.capacityMinTotal = 0;
      routeFinderState.capacityMin1G = 0;
      routeFinderState.capacityMin10G = 0;
      routeFinderState.capacityMin100G = 0;
      routeFinderState.capacityMin400G = 0;
      routeFinderState.capacityMinTbps = 0;
      routeFinderState.capacityIncludeUndefined = true;

      // Reset UI
      const noneRadio = document.querySelector('input[name="routeCapacityMode"][value="none"]');
      if (noneRadio) noneRadio.checked = true;
      if (routeCapacityMinTotal) routeCapacityMinTotal.value = 0;
      if (routeCapacityMin1G) routeCapacityMin1G.value = 0;
      if (routeCapacityMin10G) routeCapacityMin10G.value = 0;
      if (routeCapacityMin100G) routeCapacityMin100G.value = 0;
      if (routeCapacityMin400G) routeCapacityMin400G.value = 0;
      if (routeCapacityMinTbps) routeCapacityMinTbps.value = 0;
      if (routeCapacityIncludeUndefined) routeCapacityIncludeUndefined.checked = true;
      updateCapacityFilterSections();

      routeFinderState.routes = [];
      updateRouteFinderUI();
      updateActiveFiltersIndicator();
      showToast('ðŸ—‘ï¸ Capacity filter cleared');
    });
  }

  // ============== MLG PREFERENCE EVENT HANDLERS (Phase 1) ==============

  // Update MLG-related UI sections visibility
  function updateMLGPreferenceUI() {
    const isPreferMLGs = routeFinderState.preferMLGs;

    // Show/hide MLG-specific sections
    const mlgTopologyRow = document.getElementById('mlgTopologyFilterRow');
    const mlgMustUseRow = document.getElementById('mlgMustUseRow');
    const mlgExcludeRow = document.getElementById('mlgExcludeRow');
    const mlgCapacitySection = document.getElementById('mlgCapacitySection');
    const mlgClearRow = document.getElementById('mlgClearRow');

    if (mlgTopologyRow) mlgTopologyRow.style.display = isPreferMLGs ? 'block' : 'none';
    if (mlgMustUseRow) mlgMustUseRow.style.display = isPreferMLGs ? 'block' : 'none';
    if (mlgExcludeRow) mlgExcludeRow.style.display = isPreferMLGs ? 'block' : 'none';
    if (mlgCapacitySection) mlgCapacitySection.style.display = isPreferMLGs ? 'block' : 'none';
    if (mlgClearRow) mlgClearRow.style.display = isPreferMLGs ? 'block' : 'none';

    // Update MLG count display
    updateMLGCountDisplay();

    // Populate MLG dropdowns
    populateMLGDropdowns();
  }

  // Update MLG count display
  function updateMLGCountDisplay() {
    const display = document.getElementById('mlgCountDisplay');
    if (!display) return;

    const total = state.multilinkGroups.length;
    const filtered = state.multilinkGroups.filter(mlg => mlgPassesFilters(mlg)).length;

    if (total === 0) {
      display.textContent = 'No Multilink Groups defined';
      display.style.color = '#9ca3af';
    } else if (filtered === total) {
      display.textContent = `${total} Multilink Group${total !== 1 ? 's' : ''} available`;
      display.style.color = '#6b7280';
    } else {
      display.textContent = `${filtered} of ${total} Multilink Group${total !== 1 ? 's' : ''} match filters`;
      display.style.color = '#7c3aed';
    }
  }

  // Populate MLG dropdown selects
  function populateMLGDropdowns() {
    const mustUseSelect = document.getElementById('routeMustUseMLGSelect');
    const excludeSelect = document.getElementById('routeExcludeMLGSelect');

    const options = state.multilinkGroups.map(mlg => {
      const origin = mlg.originNode ? (findNode(mlg.originNode)?.name || 'N' + mlg.originNode) : '?';
      const dest = mlg.destinationNode ? (findNode(mlg.destinationNode)?.name || 'N' + mlg.destinationNode) : '?';
      return `<option value="${mlg.id}">${mlg.name || 'Unnamed'} (${origin}â†’${dest})</option>`;
    }).join('');

    if (mustUseSelect) {
      mustUseSelect.innerHTML = '<option value="">-- Select MLG (must use) --</option>' + options;
    }
    if (excludeSelect) {
      excludeSelect.innerHTML = '<option value="">-- Select MLG to exclude --</option>' + options;
    }
  }

  // Update Must-Use MLGs display list
  function updateMustUseMLGsList() {
    const list = document.getElementById('mustUseMLGsList');
    if (!list) return;

    if (routeFinderState.mustUseMLGs.size === 0) {
      list.innerHTML = '';
      return;
    }

    list.innerHTML = [...routeFinderState.mustUseMLGs].map(mlgId => {
      const mlg = findMultilinkGroup(mlgId);
      return `<span class="constraint-tag must-use" style="background:#dcfce7; color:#166534; padding:2px 6px; border-radius:4px; font-size:10px; display:inline-flex; align-items:center; gap:4px;">
        ðŸ”— ${mlg?.name || 'MLG-' + mlgId}
        <span style="cursor:pointer; color:#dc2626;" onclick="removeMustUseMLG(${mlgId})">Ã—</span>
      </span>`;
    }).join('');
  }

  // Update Excluded MLGs display list
  function updateExcludedMLGsList() {
    const list = document.getElementById('excludedMLGsList');
    if (!list) return;

    if (routeFinderState.excludedMLGs.size === 0) {
      list.innerHTML = '';
      return;
    }

    list.innerHTML = [...routeFinderState.excludedMLGs].map(mlgId => {
      const mlg = findMultilinkGroup(mlgId);
      return `<span class="constraint-tag excluded" style="background:#fee2e2; color:#991b1b; padding:2px 6px; border-radius:4px; font-size:10px; display:inline-flex; align-items:center; gap:4px;">
        ðŸ”— ${mlg?.name || 'MLG-' + mlgId}
        <span style="cursor:pointer; color:#dc2626;" onclick="removeExcludedMLG(${mlgId})">Ã—</span>
      </span>`;
    }).join('');
  }

  // Add MLG to must-use list
  function addMustUseMLG(mlgId) {
    if (!mlgId || routeFinderState.mustUseMLGs.has(mlgId)) return;
    routeFinderState.mustUseMLGs.add(mlgId);
    routeFinderState.excludedMLGs.delete(mlgId); // Remove from excluded if present
    updateMustUseMLGsList();
    updateExcludedMLGsList();
    updateActiveFiltersIndicator();
    routeFinderState.routes = [];
    updateRouteFinderUI();
    const mlg = findMultilinkGroup(mlgId);
    showToast(`âœ… Must-use MLG: ${mlg?.name || 'MLG-' + mlgId}`);
  }

  // Remove MLG from must-use list
  window.removeMustUseMLG = function(mlgId) {
    routeFinderState.mustUseMLGs.delete(mlgId);
    updateMustUseMLGsList();
    updateActiveFiltersIndicator();
    routeFinderState.routes = [];
    updateRouteFinderUI();
  };

  // Add MLG to excluded list
  function addExcludedMLG(mlgId) {
    if (!mlgId || routeFinderState.excludedMLGs.has(mlgId)) return;
    routeFinderState.excludedMLGs.add(mlgId);
    routeFinderState.mustUseMLGs.delete(mlgId); // Remove from must-use if present
    updateExcludedMLGsList();
    updateMustUseMLGsList();
    updateActiveFiltersIndicator();
    routeFinderState.routes = [];
    updateRouteFinderUI();
    const mlg = findMultilinkGroup(mlgId);
    showToast(`ðŸ›« Excluded MLG: ${mlg?.name || 'MLG-' + mlgId}`);
  }

  // Remove MLG from excluded list
  window.removeExcludedMLG = function(mlgId) {
    routeFinderState.excludedMLGs.delete(mlgId);
    updateExcludedMLGsList();
    updateActiveFiltersIndicator();
    routeFinderState.routes = [];
    updateRouteFinderUI();
  };

  // Update MLG capacity filter sections
  function updateMLGCapacityFilterSections() {
    const totalSection = document.getElementById('mlgCapacityTotalSection');
    const unitsSection = document.getElementById('mlgCapacityUnitsSection');

    if (totalSection) totalSection.style.display = routeFinderState.mlgCapacityMode === 'total' ? 'block' : 'none';
    if (unitsSection) unitsSection.style.display = routeFinderState.mlgCapacityMode === 'units' ? 'block' : 'none';
  }

  // Prefer MLGs toggle
  const routePreferMLGs = document.getElementById('routePreferMLGs');
  if (routePreferMLGs) {
    routePreferMLGs.addEventListener('change', () => {
      routeFinderState.preferMLGs = routePreferMLGs.checked;
      updateMLGPreferenceUI();
      routeFinderState.routes = [];
      updateRouteFinderUI();
      updateActiveFiltersIndicator();

      if (routeFinderState.preferMLGs) {
        showToast('ðŸ”— MLG Preference enabled â€” routes will prefer Multilink Groups');
      } else {
        showToast('ðŸ”— MLG Preference disabled â€” using standard pathfinding');
      }
    });
  }

  // MLG topology type checkboxes
  const mlgFilterLinear = document.getElementById('mlgFilterLinear');
  const mlgFilterRing = document.getElementById('mlgFilterRing');
  const mlgFilterRingLinear = document.getElementById('mlgFilterRingLinear');

  function updateMLGTopologyFilter() {
    routeFinderState.mlgTopologyFilter.clear();
    if (mlgFilterLinear?.checked) routeFinderState.mlgTopologyFilter.add('linear');
    if (mlgFilterRing?.checked) routeFinderState.mlgTopologyFilter.add('ring');
    if (mlgFilterRingLinear?.checked) routeFinderState.mlgTopologyFilter.add('ring_linear');
    updateMLGCountDisplay();
    routeFinderState.routes = [];
    updateRouteFinderUI();
  }

  if (mlgFilterLinear) mlgFilterLinear.addEventListener('change', updateMLGTopologyFilter);
  if (mlgFilterRing) mlgFilterRing.addEventListener('change', updateMLGTopologyFilter);
  if (mlgFilterRingLinear) mlgFilterRingLinear.addEventListener('change', updateMLGTopologyFilter);

  // Must-Use MLG add button
  const btnAddMustUseMLG = document.getElementById('btnAddMustUseMLG');
  if (btnAddMustUseMLG) {
    btnAddMustUseMLG.addEventListener('click', () => {
      const select = document.getElementById('routeMustUseMLGSelect');
      const val = parseInt(select?.value, 10);
      if (!isNaN(val)) {
        addMustUseMLG(val);
        select.value = '';
      }
    });
  }

  // Excluded MLG add button
  const btnAddExcludeMLG = document.getElementById('btnAddExcludeMLG');
  if (btnAddExcludeMLG) {
    btnAddExcludeMLG.addEventListener('click', () => {
      const select = document.getElementById('routeExcludeMLGSelect');
      const val = parseInt(select?.value, 10);
      if (!isNaN(val)) {
        addExcludedMLG(val);
        select.value = '';
      }
    });
  }

  // MLG Capacity mode radios
  const mlgCapacityModeRadios = document.querySelectorAll('input[name="routeMLGCapacityMode"]');
  mlgCapacityModeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      routeFinderState.mlgCapacityMode = radio.value;
      updateMLGCapacityFilterSections();
      updateMLGCountDisplay();
      routeFinderState.routes = [];
      updateRouteFinderUI();
    });
  });

  // MLG Capacity inputs
  const routeMLGCapacityMinTotal = document.getElementById('routeMLGCapacityMinTotal');
  if (routeMLGCapacityMinTotal) {
    routeMLGCapacityMinTotal.addEventListener('input', () => {
      routeFinderState.mlgCapacityMinTotal = parseFloat(routeMLGCapacityMinTotal.value) || 0;
      updateMLGCountDisplay();
      routeFinderState.routes = [];
      updateRouteFinderUI();
    });
  }

  // MLG Unit capacity inputs
  ['1G', '10G', '100G', '400G', 'Tbps'].forEach(tier => {
    const input = document.getElementById(`routeMLGCapacityMin${tier}`);
    if (input) {
      input.addEventListener('input', () => {
        routeFinderState[`mlgCapacityMin${tier}`] = parseFloat(input.value) || 0;
        updateMLGCountDisplay();
        routeFinderState.routes = [];
        updateRouteFinderUI();
      });
    }
  });

  // MLG include undefined capacity checkbox
  const routeMLGCapacityIncludeUndefined = document.getElementById('routeMLGCapacityIncludeUndefined');
  if (routeMLGCapacityIncludeUndefined) {
    routeMLGCapacityIncludeUndefined.addEventListener('change', () => {
      routeFinderState.mlgCapacityIncludeUndefined = routeMLGCapacityIncludeUndefined.checked;
      updateMLGCountDisplay();
      routeFinderState.routes = [];
      updateRouteFinderUI();
    });
  }

  // Clear MLG settings button
  const btnClearMLGSettings = document.getElementById('btnClearMLGSettings');
  if (btnClearMLGSettings) {
    btnClearMLGSettings.addEventListener('click', () => {
      // Reset MLG state
      routeFinderState.mustUseMLGs.clear();
      routeFinderState.excludedMLGs.clear();
      routeFinderState.mlgTopologyFilter = new Set(['linear', 'ring', 'ring_linear']);
      routeFinderState.mlgCapacityMode = 'none';
      routeFinderState.mlgCapacityMinTotal = 0;
      routeFinderState.mlgCapacityMin1G = 0;
      routeFinderState.mlgCapacityMin10G = 0;
      routeFinderState.mlgCapacityMin100G = 0;
      routeFinderState.mlgCapacityMin400G = 0;
      routeFinderState.mlgCapacityMinTbps = 0;
      routeFinderState.mlgCapacityIncludeUndefined = true;

      // Reset UI
      if (mlgFilterLinear) mlgFilterLinear.checked = true;
      if (mlgFilterRing) mlgFilterRing.checked = true;
      if (mlgFilterRingLinear) mlgFilterRingLinear.checked = true;
      if (routeMLGCapacityMinTotal) routeMLGCapacityMinTotal.value = 0;
      ['1G', '10G', '100G', '400G', 'Tbps'].forEach(tier => {
        const input = document.getElementById(`routeMLGCapacityMin${tier}`);
        if (input) input.value = 0;
      });
      const mlgCapNoneRadio = document.querySelector('input[name="routeMLGCapacityMode"][value="none"]');
      if (mlgCapNoneRadio) mlgCapNoneRadio.checked = true;
      if (routeMLGCapacityIncludeUndefined) routeMLGCapacityIncludeUndefined.checked = true;

      updateMustUseMLGsList();
      updateExcludedMLGsList();
      updateMLGCapacityFilterSections();
      updateMLGCountDisplay();
      updateActiveFiltersIndicator();
      routeFinderState.routes = [];
      updateRouteFinderUI();
      showToast('ðŸ—‘ï¸ MLG settings cleared');
    });
  }

  // ============== SAVE ROUTE AS MLG (Phase 1) ==============

  /**
   * Convert a route result into an MLG structure
   * Flattens any MLG references into their constituent segments
   */
  function convertRouteToMLGStructure(route) {
    const segments = [];
    let segmentId = 1;
    let pathId = 1;

    // Process each hop in the route
    for (let i = 0; i < route.segments.length; i++) {
      const seg = route.segments[i];
      const fromNodeId = route.path[i];
      const toNodeId = route.path[i + 1];

      if (seg.isMLG && seg.mlgId) {
        // This hop uses an MLG - flatten its segments into our structure
        const mlg = findMultilinkGroup(seg.mlgId);
        if (mlg && mlg.segments) {
          mlg.segments.forEach(mlgSeg => {
            segments.push({
              id: segmentId++,
              fromNode: mlgSeg.fromNode,
              toNode: mlgSeg.toNode,
              paths: mlgSeg.paths.map(p => ({
                id: pathId++,
                type: p.type,
                links: [...p.links],
                latency: p.latency || 0
              })),
              latency: mlgSeg.latency || 0,
              isDiverse: mlgSeg.isDiverse,
              diversityWarning: mlgSeg.diversityWarning
            });
          });
        }
      } else if (seg.edgeId) {
        // This hop uses a single link
        segments.push({
          id: segmentId++,
          fromNode: fromNodeId,
          toNode: toNodeId,
          paths: [{
            id: pathId++,
            type: 'primary',
            links: [seg.edgeId],
            latency: seg.latency || 0
          }],
          latency: seg.latency || 0,
          isDiverse: true,
          diversityWarning: null
        });
      } else if (seg.implicit) {
        // Implicit connection - create segment with no links (will need manual population)
        segments.push({
          id: segmentId++,
          fromNode: fromNodeId,
          toNode: toNodeId,
          paths: [{
            id: pathId++,
            type: 'primary',
            links: [],  // Empty - user needs to add links
            latency: seg.latency || 0
          }],
          latency: seg.latency || 0,
          isDiverse: true,
          diversityWarning: 'Implicit connection - please add links'
        });
      }
    }

    // Merge consecutive segments with same endpoints if possible
    // (this handles cases where MLG flattening creates redundant segments)

    return segments;
  }

  // Save Route as MLG button handler
  const btnSaveRouteAsMLG = document.getElementById('btnSaveRouteAsMLG');
  if (btnSaveRouteAsMLG) {
    btnSaveRouteAsMLG.addEventListener('click', () => {
      const route = routeFinderState.routes[routeFinderState.activeRouteIndex];
      if (!route || !route.path || route.path.length < 2) {
        showToast('âš ï¸ No valid route to save');
        return;
      }

      // Convert route to MLG segments structure
      const segments = convertRouteToMLGStructure(route);

      if (segments.length === 0) {
        showToast('âš ï¸ Could not convert route to MLG structure');
        return;
      }

      // Prepare tempGroup for MLG editor
      const originNode = findNode(route.path[0]);
      const destNode = findNode(route.path[route.path.length - 1]);
      const originName = originNode?.name || 'N' + route.path[0];
      const destName = destNode?.name || 'N' + route.path[route.path.length - 1];

      mlgManagerState.editingGroup = 'new';
      mlgManagerState.nextTempSegmentId = Math.max(...segments.map(s => s.id)) + 1;
      mlgManagerState.nextTempPathId = Math.max(...segments.flatMap(s => s.paths.map(p => p.id))) + 1;

      mlgManagerState.tempGroup = {
        id: null,
        name: `${originName} â†’ ${destName}`,
        color: '#f59e0b',
        description: `Created from Path Finder route\nLatency: ${route.totalCost.toFixed(3)} ms`,
        segments: segments,
        type: 'linear',  // Will be recalculated on save
        totalLatency: route.totalCost,
        isDiverse: true,
        warnings: [],
        source: 'pathfinder',  // Mark as created from pathfinder
        tags: [],
        calcCap1G: 0,
        calcCap10G: 0,
        calcCap100G: 0,
        calcCap400G: 0,
        calcCapTbps: 0,
        overrideCap1G: null,
        overrideCap10G: null,
        overrideCap100G: null,
        overrideCap400G: null,
        overrideCapTbps: null
      };

      // Show MLG manager and editor
      const multilinkManager = document.getElementById('multilinkManager');
      const multilinkEditor = document.getElementById('multilinkEditor');
      if (multilinkManager) multilinkManager.style.display = 'flex';
      if (multilinkEditor) multilinkEditor.style.display = 'flex';

      // Render the editor with pre-populated data
      if (typeof renderMultilinkEditor === 'function') {
        renderMultilinkEditor();
      }

      showToast('ðŸ“ Route loaded into MLG Editor â€” review and save');
    });
  }

  // ============== ADD TO EXISTING MLG FUNCTIONALITY ==============

  // Helper function to get MLG termination points
  function getMLGTerminations(mlg) {
    if (!mlg || !mlg.segments || mlg.segments.length === 0) return { origin: null, dest: null };
    const origin = mlg.originNode || mlg.segments[0]?.fromNode;
    const dest = mlg.destinationNode || mlg.segments[mlg.segments.length - 1]?.toNode;
    return { origin, dest };
  }

  // Helper function to find compatible MLGs (same termination points as current route)
  function findCompatibleMLGs(routeOrigin, routeDest) {
    if (!state.multilinkGroups || !routeOrigin || !routeDest) return [];

    return state.multilinkGroups.filter(mlg => {
      const { origin, dest } = getMLGTerminations(mlg);
      // Check both directions (origin->dest or dest->origin)
      return (origin === routeOrigin && dest === routeDest) ||
             (origin === routeDest && dest === routeOrigin);
    });
  }

  // Update the compatible MLG dropdown when route changes
  function updateCompatibleMLGDropdown() {
    const route = routeFinderState.routes[routeFinderState.activeRouteIndex];
    const select = document.getElementById('compatibleMLGSelect');
    const infoDiv = document.getElementById('compatibleMLGInfo');
    const existingLabel = document.getElementById('mlgSaveModeExistingLabel');

    if (!select || !route || !route.path || route.path.length < 2) {
      if (select) select.innerHTML = '<option value="">-- No route selected --</option>';
      if (infoDiv) infoDiv.textContent = '';
      if (existingLabel) existingLabel.style.opacity = '0.5';
      return;
    }

    const routeOrigin = route.path[0];
    const routeDest = route.path[route.path.length - 1];
    const compatibleMLGs = findCompatibleMLGs(routeOrigin, routeDest);

    // Build dropdown options
    select.innerHTML = '<option value="">-- Select an MLG with same endpoints --</option>';

    if (compatibleMLGs.length === 0) {
      if (infoDiv) infoDiv.innerHTML = '<span style="color:#dc2626;">No compatible MLGs found (same A-Z endpoints)</span>';
      if (existingLabel) {
        existingLabel.style.opacity = '0.5';
        existingLabel.title = 'No MLGs with matching endpoints';
      }
    } else {
      compatibleMLGs.forEach(mlg => {
        const { origin, dest } = getMLGTerminations(mlg);
        const originName = getNodeDisplayName(origin);
        const destName = getNodeDisplayName(dest);
        const pathCount = mlg.segments?.reduce((count, seg) => count + (seg.paths?.length || 0), 0) || 0;
        const option = document.createElement('option');
        option.value = mlg.id;
        option.textContent = `${mlg.name} (${pathCount} path${pathCount !== 1 ? 's' : ''})`;
        select.appendChild(option);
      });
      if (infoDiv) infoDiv.innerHTML = `<span style="color:#16a34a;">âœ“ ${compatibleMLGs.length} compatible MLG${compatibleMLGs.length !== 1 ? 's' : ''} found</span>`;
      if (existingLabel) {
        existingLabel.style.opacity = '1';
        existingLabel.title = '';
      }
    }
  }

  // MLG Save Mode radio button handlers
  const mlgSaveModeNew = document.getElementById('mlgSaveModeNew');
  const mlgSaveModeExisting = document.getElementById('mlgSaveModeExisting');
  const mlgSaveModeNewLabel = document.getElementById('mlgSaveModeNewLabel');
  const mlgSaveModeExistingLabel = document.getElementById('mlgSaveModeExistingLabel');
  const existingMLGSelection = document.getElementById('existingMLGSelection');
  const btnSaveRouteAsMLGEl = document.getElementById('btnSaveRouteAsMLG');
  const btnAddRouteToMLG = document.getElementById('btnAddRouteToMLG');
  const mlgSaveHint = document.getElementById('mlgSaveHint');

  function updateMLGSaveModeUI() {
    const isNewMode = mlgSaveModeNew?.checked;

    // Update labels styling
    if (mlgSaveModeNewLabel) {
      mlgSaveModeNewLabel.style.borderColor = isNewMode ? '#a855f7' : '#e5e7eb';
      mlgSaveModeNewLabel.style.background = isNewMode ? '#faf5ff' : 'white';
      mlgSaveModeNewLabel.style.color = isNewMode ? '#7c3aed' : '#374151';
    }
    if (mlgSaveModeExistingLabel) {
      mlgSaveModeExistingLabel.style.borderColor = isNewMode ? '#e5e7eb' : '#10b981';
      mlgSaveModeExistingLabel.style.background = isNewMode ? 'white' : '#ecfdf5';
      mlgSaveModeExistingLabel.style.color = isNewMode ? '#374151' : '#059669';
    }

    // Show/hide appropriate elements
    if (existingMLGSelection) {
      existingMLGSelection.style.display = isNewMode ? 'none' : 'block';
    }
    if (btnSaveRouteAsMLGEl) {
      btnSaveRouteAsMLGEl.style.display = isNewMode ? 'block' : 'none';
    }
    if (btnAddRouteToMLG) {
      btnAddRouteToMLG.style.display = isNewMode ? 'none' : 'block';
    }
    if (mlgSaveHint) {
      mlgSaveHint.textContent = isNewMode
        ? 'Creates a new MLG from the currently selected route'
        : 'Adds this route as a new path to the selected MLG';
    }

    // Update compatible MLGs dropdown when switching to existing mode
    if (!isNewMode) {
      updateCompatibleMLGDropdown();
    }
  }

  if (mlgSaveModeNew) {
    mlgSaveModeNew.addEventListener('change', updateMLGSaveModeUI);
  }
  if (mlgSaveModeExisting) {
    mlgSaveModeExisting.addEventListener('change', updateMLGSaveModeUI);
  }

  // Compatible MLG selection change handler
  const compatibleMLGSelect = document.getElementById('compatibleMLGSelect');
  if (compatibleMLGSelect) {
    compatibleMLGSelect.addEventListener('change', () => {
      const selectedId = compatibleMLGSelect.value;
      const infoDiv = document.getElementById('compatibleMLGInfo');

      if (selectedId && infoDiv) {
        const mlg = findMultilinkGroup(selectedId);
        if (mlg) {
          const pathCount = mlg.segments?.reduce((count, seg) => count + (seg.paths?.length || 0), 0) || 0;
          const segCount = mlg.segments?.length || 0;
          infoDiv.innerHTML = `<span style="color:#059669;">ðŸ“Š ${segCount} segment${segCount !== 1 ? 's' : ''}, ${pathCount} existing path${pathCount !== 1 ? 's' : ''}</span>`;
        }
      }
    });
  }

  // Add Route to Existing MLG button handler
  if (btnAddRouteToMLG) {
    btnAddRouteToMLG.addEventListener('click', () => {
      const route = routeFinderState.routes[routeFinderState.activeRouteIndex];
      if (!route || !route.path || route.path.length < 2) {
        showToast('âš ï¸ No valid route to add');
        return;
      }

      const selectedMLGId = document.getElementById('compatibleMLGSelect')?.value;
      if (!selectedMLGId) {
        showToast('âš ï¸ Please select an MLG to add the route to');
        return;
      }

      const targetMLG = findMultilinkGroup(selectedMLGId);
      if (!targetMLG) {
        showToast('âš ï¸ Selected MLG not found');
        return;
      }

      // Check if route direction matches MLG direction
      const routeOrigin = route.path[0];
      const routeDest = route.path[route.path.length - 1];
      const { origin: mlgOrigin, dest: mlgDest } = getMLGTerminations(targetMLG);
      const isReversed = (routeOrigin === mlgDest && routeDest === mlgOrigin);

      // Convert route to link sequence
      let routeLinks = [];
      route.segments.forEach(seg => {
        if (seg.edgeId) {
          routeLinks.push(seg.edgeId);
        } else if (seg.isMLG && seg.mlgId) {
          // Flatten MLG links - use primary path
          const mlg = findMultilinkGroup(seg.mlgId);
          if (mlg && mlg.segments) {
            mlg.segments.forEach(mlgSeg => {
              if (mlgSeg.paths && mlgSeg.paths[0] && mlgSeg.paths[0].links) {
                routeLinks.push(...mlgSeg.paths[0].links);
              }
            });
          }
        }
      });

      if (routeLinks.length === 0) {
        showToast('âš ï¸ Route has no links to add');
        return;
      }

      // If reversed, reverse the links
      if (isReversed) {
        routeLinks = routeLinks.reverse();
      }

      // Calculate the route latency
      const routeLatency = routeLinks.reduce((sum, lid) => {
        const e = state.edges.find(edge => edge.id === lid);
        return sum + (parseFloat(e?.latencyMs) || parseFloat(e?.latency) || 0);
      }, 0);

      // Generate new segment and path IDs
      let maxSegmentId = 0;
      let maxPathId = 0;
      targetMLG.segments.forEach(seg => {
        if (seg.id > maxSegmentId) maxSegmentId = seg.id;
        if (seg.paths) {
          seg.paths.forEach(p => {
            if (p.id > maxPathId) maxPathId = p.id;
          });
        }
      });
      const newSegmentId = maxSegmentId + 1;
      const newPathId = maxPathId + 1;

      // Determine new path type based on total segments count
      const existingSegmentCount = targetMLG.segments.length;
      let newPathType = 'primary';
      if (existingSegmentCount >= 1) {
        newPathType = 'protection';
      }
      if (existingSegmentCount >= 2) {
        newPathType = 'tertiary';
      }
      if (existingSegmentCount >= 3) {
        newPathType = `path_${existingSegmentCount + 1}`;
      }

      // Create a new segment with the entire route as a single path from origin to destination
      const newSegment = {
        id: newSegmentId,
        fromNode: mlgOrigin,  // Use MLG's origin (handles reversal)
        toNode: mlgDest,      // Use MLG's destination
        paths: [{
          id: newPathId,
          type: newPathType,
          role: newPathType,
          links: routeLinks,
          latency: routeLatency
        }],
        latency: routeLatency,
        isDiverse: true,
        diversityWarning: null
      };

      // Add the new segment to the MLG
      targetMLG.segments.push(newSegment);

      // Update MLG metadata
      targetMLG.modified = new Date().toISOString();

      // Recalculate total MLG latency (use minimum across all segment latencies)
      if (typeof calculateMLGLatency === 'function') {
        targetMLG.totalLatency = calculateMLGLatency(targetMLG.segments);
      } else {
        // Fallback: minimum latency across segments
        targetMLG.totalLatency = Math.min(...targetMLG.segments.map(s => s.latency || 0));
      }

      // Recalculate capacity
      if (typeof calculateMLGCapacity === 'function') {
        const capacity = calculateMLGCapacity(targetMLG.segments);
        targetMLG.calcCap1G = capacity.cap1G;
        targetMLG.calcCap10G = capacity.cap10G;
        targetMLG.calcCap100G = capacity.cap100G;
        targetMLG.calcCap400G = capacity.cap400G;
        targetMLG.calcCapTbps = capacity.capTbps;
      }

      // Reclassify MLG type (linear/ring/ring_linear) - with multiple segments it becomes ring-like
      if (typeof classifyMLGType === 'function') {
        targetMLG.type = classifyMLGType(targetMLG.segments);
        targetMLG.topology = targetMLG.type;
      }

      // Commit changes
      commit();
      render();

      showToast(`âœ“ Route added as new segment (${newPathType}) to "${targetMLG.name}"`);

      // Refresh MLG manager display
      if (typeof updateMultilinkGroupList === 'function') {
        updateMultilinkGroupList();
      }

      // Reset to new mode
      if (mlgSaveModeNew) {
        mlgSaveModeNew.checked = true;
        updateMLGSaveModeUI();
      }
    });
  }

  // ============== END ADD TO EXISTING MLG FUNCTIONALITY ==============

  // Calculate Protection Path button handler
  const btnCalculateProtection = document.getElementById('btnCalculateProtection');
  if (btnCalculateProtection) {
    btnCalculateProtection.addEventListener('click', calculateProtectionPath);
  }

  // Save Protected MLG button handler
  const btnSaveProtectedMLG = document.getElementById('btnSaveProtectedMLG');
  if (btnSaveProtectedMLG) {
    btnSaveProtectedMLG.addEventListener('click', saveProtectedMLG);
  }

  // Initialize MLG preference UI
  updateMLGPreferenceUI();

  // ============== END MLG PREFERENCE EVENT HANDLERS ==============

  // ============== ACTIVE FILTERS INDICATOR ==============

  function updateActiveFiltersIndicator() {
    const indicator = document.getElementById('activeFiltersIndicator');
    const textEl = document.getElementById('activeFiltersText');
    if (!indicator || !textEl) return;

    const activeFilters = [];

    // Check restrictions
    if (routeFinderState.excludedNodes.size > 0) {
      activeFilters.push(`${routeFinderState.excludedNodes.size} excluded node(s)`);
    }
    if (routeFinderState.excludedLinks.size > 0) {
      activeFilters.push(`${routeFinderState.excludedLinks.size} excluded link(s)`);
    }

    // Check must-use
    if (routeFinderState.mustUseNodes.size > 0) {
      activeFilters.push(`${routeFinderState.mustUseNodes.size} must-use node(s)`);
    }
    if (routeFinderState.mustUseLinks.size > 0) {
      activeFilters.push(`${routeFinderState.mustUseLinks.size} must-use link(s)`);
    }

    // Check tag filters
    if (routeFinderState.nodeTagMode !== 'any' && routeFinderState.nodeTagFilter.size > 0) {
      activeFilters.push(`node tags (${routeFinderState.nodeTagMode})`);
    }
    if (routeFinderState.linkTagMode !== 'any' && routeFinderState.linkTagFilter.size > 0) {
      activeFilters.push(`link tags (${routeFinderState.linkTagMode})`);
    }

    // Check capacity filter
    if (routeFinderState.capacityMode !== 'none') {
      if (routeFinderState.capacityMode === 'total') {
        activeFilters.push(`capacity â‰¥${routeFinderState.capacityMinTotal}G`);
      } else {
        activeFilters.push('capacity units');
      }
    }

    // Check visible only
    if (routeFinderState.visibleOnly) {
      activeFilters.push('visible only');
    }

    // Check skip implicit transit
    if (routeFinderState.skipImplicitTransit) {
      activeFilters.push('no implicit transit');
    }

    // Check MLG preference (Phase 1)
    if (routeFinderState.preferMLGs) {
      activeFilters.push('MLG preferred');
    }
    if (routeFinderState.mustUseMLGs.size > 0) {
      activeFilters.push(`${routeFinderState.mustUseMLGs.size} must-use MLG(s)`);
    }
    if (routeFinderState.excludedMLGs.size > 0) {
      activeFilters.push(`${routeFinderState.excludedMLGs.size} excluded MLG(s)`);
    }
    if (routeFinderState.mlgCapacityMode !== 'none') {
      activeFilters.push('MLG capacity filter');
    }

    if (activeFilters.length > 0) {
      indicator.style.display = 'block';
      textEl.textContent = activeFilters.join(', ');
    } else {
      indicator.style.display = 'none';
    }
  }

  // ============== RESET ALL FILTERS ==============

  function resetAllRouteFilters() {
    // Auto-exit protection mode first (restores primary state before clearing)
    if (routeFinderState.protectionMode) {
      exitProtectionMode();
    }

    // Also reset protection-specific filters
    routeFinderState.protectionFilters = {
      excludedNodes: new Set(),
      excludedLinks: new Set(),
      mustUseNodes: new Set(),
      mustUseLinks: new Set(),
      visibleOnly: false,
      nodeTagMode: 'any',
      nodeTagFilter: new Set(),
      linkTagMode: 'any',
      linkTagFilter: new Set(),
      capacityMode: 'none',
      capacityMinTotal: 0,
      capacityMin1G: 0,
      capacityMin10G: 0,
      capacityMin100G: 0,
      capacityMin400G: 0,
      capacityMinTbps: 0,
      capacityIncludeUndefined: true,
      skipImplicitTransit: false,
      diverseFromLinks: new Set()
    };

    // Reset exclusions
    routeFinderState.excludedNodes.clear();
    routeFinderState.excludedLinks.clear();

    // Reset must-use
    routeFinderState.mustUseNodes.clear();
    routeFinderState.mustUseLinks.clear();

    // Reset tag filters
    routeFinderState.nodeTagMode = 'any';
    routeFinderState.nodeTagFilter.clear();
    routeFinderState.linkTagMode = 'any';
    routeFinderState.linkTagFilter.clear();

    // Reset capacity filters
    routeFinderState.capacityMode = 'none';
    routeFinderState.capacityMinTotal = 0;
    routeFinderState.capacityMin1G = 0;
    routeFinderState.capacityMin10G = 0;
    routeFinderState.capacityMin100G = 0;
    routeFinderState.capacityMin400G = 0;
    routeFinderState.capacityMinTbps = 0;
    routeFinderState.capacityIncludeUndefined = true;

    // Reset skip implicit transit
    routeFinderState.skipImplicitTransit = false;
    const routeSkipImplicitTransit = document.getElementById('routeSkipImplicitTransit');
    if (routeSkipImplicitTransit) routeSkipImplicitTransit.checked = false;

    // Reset visible only
    routeFinderState.visibleOnly = false;
    const routeVisibleOnly = document.getElementById('routeVisibleOnly');
    if (routeVisibleOnly) routeVisibleOnly.checked = false;

    // Reset UI elements
    // Exclusions
    document.getElementById('excludedNodesList').innerHTML = '';
    document.getElementById('excludedLinksList').innerHTML = '';

    // Must-use
    document.getElementById('mustUseNodesList').innerHTML = '';
    document.getElementById('mustUseLinksList').innerHTML = '';

    // Tag filters
    const routeNodeTagMode = document.getElementById('routeNodeTagMode');
    const routeLinkTagMode = document.getElementById('routeLinkTagMode');
    if (routeNodeTagMode) routeNodeTagMode.value = 'any';
    if (routeLinkTagMode) routeLinkTagMode.value = 'any';
    updateRouteTagModeHint('node');
    updateRouteTagModeHint('link');
    updateRouteTagSelectedChips('node');
    updateRouteTagSelectedChips('link');
    populateRouteTagFilters();

    // Capacity filters
    const noneRadio = document.querySelector('input[name="routeCapacityMode"][value="none"]');
    if (noneRadio) noneRadio.checked = true;
    if (routeCapacityMinTotal) routeCapacityMinTotal.value = 0;
    if (routeCapacityMin1G) routeCapacityMin1G.value = 0;
    if (routeCapacityMin10G) routeCapacityMin10G.value = 0;
    if (routeCapacityMin100G) routeCapacityMin100G.value = 0;
    if (routeCapacityMin400G) routeCapacityMin400G.value = 0;
    if (routeCapacityMinTbps) routeCapacityMinTbps.value = 0;
    if (routeCapacityIncludeUndefined) routeCapacityIncludeUndefined.checked = true;
    updateCapacityFilterSections();

    // Reset MLG preference (Phase 1)
    routeFinderState.preferMLGs = false;
    routeFinderState.mustUseMLGs.clear();
    routeFinderState.excludedMLGs.clear();
    routeFinderState.mlgTopologyFilter = new Set(['linear', 'ring', 'ring_linear']);
    routeFinderState.mlgCapacityMode = 'none';
    routeFinderState.mlgCapacityMinTotal = 0;
    routeFinderState.mlgCapacityMin1G = 0;
    routeFinderState.mlgCapacityMin10G = 0;
    routeFinderState.mlgCapacityMin100G = 0;
    routeFinderState.mlgCapacityMin400G = 0;
    routeFinderState.mlgCapacityMinTbps = 0;
    routeFinderState.mlgCapacityIncludeUndefined = true;

    // Reset MLG UI elements
    const routePreferMLGs = document.getElementById('routePreferMLGs');
    if (routePreferMLGs) routePreferMLGs.checked = false;
    const mlgFilterLinear = document.getElementById('mlgFilterLinear');
    const mlgFilterRing = document.getElementById('mlgFilterRing');
    const mlgFilterRingLinear = document.getElementById('mlgFilterRingLinear');
    if (mlgFilterLinear) mlgFilterLinear.checked = true;
    if (mlgFilterRing) mlgFilterRing.checked = true;
    if (mlgFilterRingLinear) mlgFilterRingLinear.checked = true;
    document.getElementById('mustUseMLGsList')?.innerHTML && (document.getElementById('mustUseMLGsList').innerHTML = '');
    document.getElementById('excludedMLGsList')?.innerHTML && (document.getElementById('excludedMLGsList').innerHTML = '');
    if (typeof updateMLGPreferenceUI === 'function') updateMLGPreferenceUI();

    // Clear routes and update UI
    routeFinderState.routes = [];
    updateRouteFinderUI();
    updateActiveFiltersIndicator();

    showToast('ðŸ§¹ All filters have been reset');
  }

  const btnResetAllFilters = document.getElementById('btnResetAllFilters');
  if (btnResetAllFilters) {
    btnResetAllFilters.addEventListener('click', resetAllRouteFilters);
  }

  // Update indicator when other filters change
  // Override existing clear functions to also update indicator
  const originalClearAllRestrictions = typeof clearAllRestrictions === 'function' ? clearAllRestrictions : null;
  if (originalClearAllRestrictions) {
    window.clearAllRestrictions = function() {
      originalClearAllRestrictions();
      updateActiveFiltersIndicator();
    };
  }

  const originalClearAllMustUse = typeof clearAllMustUse === 'function' ? clearAllMustUse : null;
  if (originalClearAllMustUse) {
    window.clearAllMustUse = function() {
      originalClearAllMustUse();
      updateActiveFiltersIndicator();
    };
  }

  // ============== END ROUTE FINDER CAPACITY FILTERS ==============

  // Transit toggle event listeners
  if (routeEnableContainerTransit) {
    routeEnableContainerTransit.addEventListener('change', () => {
      routeFinderState.enableContainerTransit = routeEnableContainerTransit.checked;
      updateTransitLatencyVisibility();
      routeFinderState.routes = [];
      updateRouteFinderUI();
      showToast(routeFinderState.enableContainerTransit ? 'âœ… Container transit enabled' : 'ðŸ›« Container transit disabled');
    });
  }

  if (routeEnableRegionTransit) {
    routeEnableRegionTransit.addEventListener('change', () => {
      routeFinderState.enableRegionTransit = routeEnableRegionTransit.checked;
      updateTransitLatencyVisibility();
      routeFinderState.routes = [];
      updateRouteFinderUI();
      showToast(routeFinderState.enableRegionTransit ? 'âœ… Region transit enabled' : 'ðŸ›« Region transit disabled');
    });
  }

  // Make Route Finder panel draggable
  const routeFinderHeader = document.getElementById('routeFinderHeader');
  let rfPanelDragging = false;
  let rfPanelDragOffset = { x: 0, y: 0 };

  if (routeFinderHeader && routeFinderPanel) {
    routeFinderHeader.style.cursor = 'move';

    routeFinderHeader.addEventListener('mousedown', (ev) => {
      // Don't drag if clicking on buttons
      if (ev.target.tagName === 'BUTTON' || ev.target.closest('button')) return;

      rfPanelDragging = true;
      const rect = routeFinderPanel.getBoundingClientRect();
      rfPanelDragOffset.x = ev.clientX - rect.left;
      rfPanelDragOffset.y = ev.clientY - rect.top;
      routeFinderPanel.style.cursor = 'grabbing';
      ev.preventDefault();
    });

    window.addEventListener('mousemove', (ev) => {
      if (!rfPanelDragging) return;

      const layout = document.getElementById('layout');
      const layoutRect = layout.getBoundingClientRect();

      let newLeft = ev.clientX - layoutRect.left - rfPanelDragOffset.x;
      let newTop = ev.clientY - layoutRect.top - rfPanelDragOffset.y;

      // Constrain to layout bounds
      newLeft = Math.max(0, Math.min(newLeft, layoutRect.width - routeFinderPanel.offsetWidth));
      newTop = Math.max(0, Math.min(newTop, layoutRect.height - 50));

      routeFinderPanel.style.left = newLeft + 'px';
      routeFinderPanel.style.top = newTop + 'px';
      routeFinderPanel.style.right = 'auto';
    });

    window.addEventListener('mouseup', () => {
      if (rfPanelDragging) {
        rfPanelDragging = false;
        routeFinderPanel.style.cursor = '';
      }
    });
  }

  // Keyboard shortcuts
  window.addEventListener('keydown', (ev) => {
    // Escape to exit calculation mode
    if (ev.key === 'Escape' && routeFinderState.active) {
      exitCalculationMode();
      return;
    }

    // R to toggle route finder
    if (ev.key.toLowerCase() === 'r' && !['INPUT','TEXTAREA','SELECT'].includes(document.activeElement.tagName)) {
      toggleRouteFinder();
    }
  });

  // ============== END ROUTE FINDER / PATHFINDING SYSTEM ==============

  // ============== LABEL MANAGER ==============

  const labelManagerPanel = document.getElementById('labelManagerPanel');
  const labelManagerHeader = document.getElementById('labelManagerHeader');
  const btnLabelManager = document.getElementById('btnLabelManager');
  const btnCloseLabelManager = document.getElementById('btnCloseLabelManager');

  // Label Manager state
  const labelManagerState = {
    visible: false,
    filterType: 'all', // 'all', 'nodes', 'links', 'containers'
    selectedProjectTags: new Set(),
    pickMode: false,
    pickedElements: { nodes: new Set(), links: new Set(), containers: new Set() },
    bulkTags: new Set()
  };

  // Open/close Label Manager
  function toggleLabelManager() {
    labelManagerState.visible = !labelManagerState.visible;
    if (labelManagerPanel) {
      labelManagerPanel.classList.toggle('visible', labelManagerState.visible);
    }
    if (labelManagerState.visible) {
      refreshLabelManager();
    }
  }

  function closeLabelManager() {
    labelManagerState.visible = false;
    labelManagerState.pickMode = false;
    if (labelManagerPanel) {
      labelManagerPanel.classList.remove('visible');
    }
  }

  // Get all unique tags from the project
  function getAllProjectTags() {
    const tagCounts = new Map(); // tag -> { nodes: count, links: count, containers: count }

    // Count node tags
    state.nodes.forEach(n => {
      const tags = n.tags || [];
      tags.forEach(tag => {
        if (!tagCounts.has(tag)) tagCounts.set(tag, { nodes: 0, links: 0, containers: 0 });
        tagCounts.get(tag).nodes++;
      });
      // Also check extraTags
      if (n.extraTags) {
        n.extraTags.split(',').map(t => t.trim()).filter(Boolean).forEach(tag => {
          if (!tagCounts.has(tag)) tagCounts.set(tag, { nodes: 0, links: 0, containers: 0 });
          tagCounts.get(tag).nodes++;
        });
      }
    });

    // Count edge/link tags (filterTags)
    state.edges.forEach(e => {
      const tags = e.filterTags || [];
      tags.forEach(tag => {
        if (!tagCounts.has(tag)) tagCounts.set(tag, { nodes: 0, links: 0, containers: 0 });
        tagCounts.get(tag).links++;
      });
      if (e.extraTags) {
        e.extraTags.split(',').map(t => t.trim()).filter(Boolean).forEach(tag => {
          if (!tagCounts.has(tag)) tagCounts.set(tag, { nodes: 0, links: 0, containers: 0 });
          tagCounts.get(tag).links++;
        });
      }
    });

    // Count container tags (filterTags)
    state.groups.forEach(g => {
      const tags = g.filterTags || [];
      tags.forEach(tag => {
        if (!tagCounts.has(tag)) tagCounts.set(tag, { nodes: 0, links: 0, containers: 0 });
        tagCounts.get(tag).containers++;
      });
      if (g.extraTags) {
        g.extraTags.split(',').map(t => t.trim()).filter(Boolean).forEach(tag => {
          if (!tagCounts.has(tag)) tagCounts.set(tag, { nodes: 0, links: 0, containers: 0 });
          tagCounts.get(tag).containers++;
        });
      }
    });

    return tagCounts;
  }

  // Get tags for a specific element
  function getElementTags(type, id) {
    const tags = new Set();
    if (type === 'node') {
      const n = findNode(id);
      if (n) {
        (n.tags || []).forEach(t => tags.add(t));
        if (n.extraTags) n.extraTags.split(',').map(t => t.trim()).filter(Boolean).forEach(t => tags.add(t));
      }
    } else if (type === 'edge') {
      const e = state.edges.find(e => e.id === id);
      if (e) {
        (e.filterTags || []).forEach(t => tags.add(t));
        if (e.extraTags) e.extraTags.split(',').map(t => t.trim()).filter(Boolean).forEach(t => tags.add(t));
      }
    } else if (type === 'group') {
      const g = findGroup(id);
      if (g) {
        (g.filterTags || []).forEach(t => tags.add(t));
        if (g.extraTags) g.extraTags.split(',').map(t => t.trim()).filter(Boolean).forEach(t => tags.add(t));
      }
    }
    return tags;
  }

  // Set tags on an element
  function setElementTags(type, id, tags) {
    const tagArray = Array.from(tags);
    if (type === 'node') {
      const n = findNode(id);
      if (n) {
        n.tags = tagArray;
        n.extraTags = '';
      }
    } else if (type === 'edge') {
      const e = state.edges.find(e => e.id === id);
      if (e) {
        e.filterTags = tagArray;
        e.extraTags = '';
      }
    } else if (type === 'group') {
      const g = findGroup(id);
      if (g) {
        g.filterTags = tagArray;
        g.extraTags = '';
      }
    }
  }

  // Get current selection summary
  function getSelectionSummary() {
    const nodeCount = state.selection.nodes.size + (state.selected?.type === 'node' ? 1 : 0);
    const linkCount = state.selection.edges.size + (state.selected?.type === 'edge' ? 1 : 0);
    const containerCount = state.selection.groups.size + (state.selected?.type === 'group' ? 1 : 0);
    return { nodeCount, linkCount, containerCount, total: nodeCount + linkCount + containerCount };
  }

  // Get all selected element IDs
  function getSelectedElements() {
    const nodes = new Set(state.selection.nodes);
    const edges = new Set(state.selection.edges);
    const groups = new Set(state.selection.groups);

    if (state.selected?.type === 'node') nodes.add(state.selected.id);
    if (state.selected?.type === 'edge') edges.add(state.selected.id);
    if (state.selected?.type === 'group') groups.add(state.selected.id);

    return { nodes, edges, groups };
  }

  // Get tags across all selected elements with counts
  function getSelectionTagsWithCounts() {
    const { nodes, edges, groups } = getSelectedElements();
    const totalCount = nodes.size + edges.size + groups.size;
    const tagCounts = new Map(); // tag -> count of elements that have it

    // Count from nodes
    nodes.forEach(id => {
      const tags = getElementTags('node', id);
      tags.forEach(tag => {
        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
      });
    });

    // Count from edges
    edges.forEach(id => {
      const tags = getElementTags('edge', id);
      tags.forEach(tag => {
        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
      });
    });

    // Count from groups
    groups.forEach(id => {
      const tags = getElementTags('group', id);
      tags.forEach(tag => {
        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
      });
    });

    return { tagCounts, totalCount };
  }

  // Refresh entire Label Manager UI
  function refreshLabelManager() {
    renderProjectTagsList();
    renderSelectionTags();
    renderBulkApplySection();
    updateSelectionStatus();
    updateRenameDropdown();
  }

  // Update selection status display
  function updateSelectionStatus() {
    const summary = getSelectionSummary();
    const summaryEl = document.getElementById('lmSelectionSummary');
    const bulkCountEl = document.getElementById('lmBulkSelectionCount');

    if (summary.total === 0) {
      if (summaryEl) summaryEl.textContent = 'Nothing selected';
      if (bulkCountEl) bulkCountEl.textContent = '0 items';
    } else {
      const parts = [];
      if (summary.nodeCount > 0) parts.push(`${summary.nodeCount} node${summary.nodeCount > 1 ? 's' : ''}`);
      if (summary.linkCount > 0) parts.push(`${summary.linkCount} link${summary.linkCount > 1 ? 's' : ''}`);
      if (summary.containerCount > 0) parts.push(`${summary.containerCount} container${summary.containerCount > 1 ? 's' : ''}`);
      if (summaryEl) summaryEl.textContent = parts.join(', ');
      if (bulkCountEl) bulkCountEl.textContent = `${summary.total} item${summary.total > 1 ? 's' : ''}`;
    }
  }

  // Render project tags list
  function renderProjectTagsList() {
    const container = document.getElementById('lmProjectTagsList');
    if (!container) return;

    const searchInput = document.getElementById('lmTagSearch');
    const searchTerm = (searchInput?.value || '').toLowerCase();

    const allTags = getAllProjectTags();
    const filterType = labelManagerState.filterType;

    // Filter and sort tags
    let filteredTags = [];
    allTags.forEach((counts, tag) => {
      if (searchTerm && !tag.toLowerCase().includes(searchTerm)) return;

      // Apply type filter
      if (filterType === 'nodes' && counts.nodes === 0) return;
      if (filterType === 'links' && counts.links === 0) return;
      if (filterType === 'containers' && counts.containers === 0) return;

      filteredTags.push({ tag, ...counts, total: counts.nodes + counts.links + counts.containers });
    });

    filteredTags.sort((a, b) => a.tag.localeCompare(b.tag));

    if (filteredTags.length === 0) {
      container.innerHTML = `<div style="padding:20px; text-align:center; color:#9ca3af; font-size:11px;">
        ${searchTerm ? 'No tags matching search' : 'No tags in project'}
      </div>`;
      return;
    }

    let html = '';
    filteredTags.forEach(({ tag, nodes, links, containers }) => {
      const isChecked = labelManagerState.selectedProjectTags.has(tag);
      html += `
        <div class="lm-tag-item ${isChecked ? 'selected' : ''}" data-tag="${escapeHtml(tag)}">
          <input type="checkbox" class="lm-tag-checkbox" ${isChecked ? 'checked' : ''} />
          <span class="lm-tag-name">${escapeHtml(tag)}</span>
          <div class="lm-tag-counts">
            ${nodes > 0 ? `<span class="lm-tag-count nodes" title="Nodes">${nodes}N</span>` : ''}
            ${links > 0 ? `<span class="lm-tag-count links" title="Links">${links}L</span>` : ''}
            ${containers > 0 ? `<span class="lm-tag-count containers" title="Containers">${containers}C</span>` : ''}
          </div>
          <span class="lm-tag-menu" onclick="event.stopPropagation(); showLMTagMenu('${escapeHtml(tag)}', event)">â‹®</span>
        </div>
      `;
    });

    container.innerHTML = html;

    // Add click handlers
    container.querySelectorAll('.lm-tag-item').forEach(item => {
      item.addEventListener('click', (e) => {
        if (e.target.classList.contains('lm-tag-menu')) return;
        const tag = item.dataset.tag;
        const checkbox = item.querySelector('.lm-tag-checkbox');

        if (labelManagerState.selectedProjectTags.has(tag)) {
          labelManagerState.selectedProjectTags.delete(tag);
          checkbox.checked = false;
          item.classList.remove('selected');
        } else {
          labelManagerState.selectedProjectTags.add(tag);
          checkbox.checked = true;
          item.classList.add('selected');
        }

        updateSelectAllButton();
      });
    });

    updateSelectAllButton();
  }

  // Helper to escape HTML
  function escapeHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  // Update "Select All with Tag" button state
  function updateSelectAllButton() {
    const btn = document.getElementById('lmSelectAllWithTag');
    if (btn) {
      btn.disabled = labelManagerState.selectedProjectTags.size === 0;
    }
  }

  // Select all elements with checked tags
  function selectAllWithCheckedTags() {
    const tags = labelManagerState.selectedProjectTags;
    if (tags.size === 0) {
      showToast('No tags selected');
      return;
    }

    // Clear current selection
    state.selection.nodes.clear();
    state.selection.edges.clear();
    state.selection.groups.clear();
    state.selected = null;

    let count = 0;

    // Select nodes with any of the tags
    state.nodes.forEach(n => {
      const nodeTags = getElementTags('node', n.id);
      for (const tag of tags) {
        if (nodeTags.has(tag)) {
          state.selection.nodes.add(n.id);
          count++;
          break;
        }
      }
    });

    // Select edges with any of the tags
    state.edges.forEach(e => {
      const edgeTags = getElementTags('edge', e.id);
      for (const tag of tags) {
        if (edgeTags.has(tag)) {
          state.selection.edges.add(e.id);
          count++;
          break;
        }
      }
    });

    // Select containers with any of the tags
    state.groups.forEach(g => {
      const groupTags = getElementTags('group', g.id);
      for (const tag of tags) {
        if (groupTags.has(tag)) {
          state.selection.groups.add(g.id);
          count++;
          break;
        }
      }
    });

    render();
    refreshLabelManager();
    showToast(`ðŸŽ¯ Selected ${count} element${count !== 1 ? 's' : ''} with checked tags`);
  }

  // Render selection tags section
  function renderSelectionTags() {
    const noSelectionEl = document.getElementById('lmNoSelection');
    const selectionTagsEl = document.getElementById('lmSelectionTags');
    const listEl = document.getElementById('lmSelectionTagsList');

    const summary = getSelectionSummary();

    if (summary.total === 0) {
      if (noSelectionEl) noSelectionEl.style.display = 'block';
      if (selectionTagsEl) selectionTagsEl.style.display = 'none';
      return;
    }

    if (noSelectionEl) noSelectionEl.style.display = 'none';
    if (selectionTagsEl) selectionTagsEl.style.display = 'block';

    if (!listEl) return;

    const { tagCounts, totalCount } = getSelectionTagsWithCounts();
    const allTags = getAllProjectTags();

    // Merge all project tags with selection counts
    const mergedTags = new Map();
    allTags.forEach((counts, tag) => {
      mergedTags.set(tag, {
        inProject: true,
        inSelection: tagCounts.get(tag) || 0,
        total: totalCount
      });
    });

    // Sort: tags in selection first, then alphabetically
    const sortedTags = Array.from(mergedTags.entries())
      .sort((a, b) => {
        if (a[1].inSelection > 0 && b[1].inSelection === 0) return -1;
        if (a[1].inSelection === 0 && b[1].inSelection > 0) return 1;
        return a[0].localeCompare(b[0]);
      });

    let html = '';
    sortedTags.forEach(([tag, info]) => {
      const allHave = info.inSelection === info.total;
      const someHave = info.inSelection > 0 && info.inSelection < info.total;
      const noneHave = info.inSelection === 0;

      const checkState = allHave ? 'checked' : (someHave ? 'indeterminate' : '');
      const label = allHave ? '(all)' : (someHave ? `(${info.inSelection}/${info.total})` : '');

      html += `
        <div class="lm-tag-item" data-tag="${escapeHtml(tag)}">
          <input type="checkbox" class="lm-tag-checkbox" ${checkState} data-partial="${someHave}" />
          <span class="lm-tag-name">${escapeHtml(tag)}</span>
          <span style="font-size:10px; color:#9ca3af; margin-left:auto;">${label}</span>
        </div>
      `;
    });

    listEl.innerHTML = html || '<div style="padding:12px; text-align:center; color:#9ca3af; font-size:11px;">No tags in project</div>';

    // Set indeterminate state and add click handlers
    listEl.querySelectorAll('.lm-tag-item').forEach(item => {
      const checkbox = item.querySelector('.lm-tag-checkbox');
      if (checkbox.dataset.partial === 'true') {
        checkbox.indeterminate = true;
      }

      item.addEventListener('click', (e) => {
        if (e.target === checkbox) return; // Let checkbox handle its own click
        checkbox.checked = !checkbox.checked;
        checkbox.indeterminate = false;
      });
    });
  }

  // Apply checked tags to selection
  function applyCheckedTagsToSelection() {
    const listEl = document.getElementById('lmSelectionTagsList');
    if (!listEl) return;

    const { nodes, edges, groups } = getSelectedElements();
    if (nodes.size + edges.size + groups.size === 0) {
      showToast('Nothing selected');
      return;
    }

    const checkedTags = new Set();
    listEl.querySelectorAll('.lm-tag-checkbox:checked').forEach(cb => {
      const item = cb.closest('.lm-tag-item');
      if (item) checkedTags.add(item.dataset.tag);
    });

    let changed = 0;

    // Add checked tags to all selected elements
    nodes.forEach(id => {
      const current = getElementTags('node', id);
      checkedTags.forEach(tag => current.add(tag));
      setElementTags('node', id, current);
      changed++;
    });

    edges.forEach(id => {
      const current = getElementTags('edge', id);
      checkedTags.forEach(tag => current.add(tag));
      setElementTags('edge', id, current);
      changed++;
    });

    groups.forEach(id => {
      const current = getElementTags('group', id);
      checkedTags.forEach(tag => current.add(tag));
      setElementTags('group', id, current);
      changed++;
    });

    commit();
    render();
    refreshLabelManager();
    showToast(`âœ… Applied ${checkedTags.size} tag(s) to ${changed} element(s)`);
  }

  // Remove unchecked tags from selection
  function removeUncheckedTagsFromSelection() {
    const listEl = document.getElementById('lmSelectionTagsList');
    if (!listEl) return;

    const { nodes, edges, groups } = getSelectedElements();
    if (nodes.size + edges.size + groups.size === 0) {
      showToast('Nothing selected');
      return;
    }

    const uncheckedTags = new Set();
    listEl.querySelectorAll('.lm-tag-checkbox:not(:checked)').forEach(cb => {
      const item = cb.closest('.lm-tag-item');
      if (item) uncheckedTags.add(item.dataset.tag);
    });

    let changed = 0;

    // Remove unchecked tags from all selected elements
    nodes.forEach(id => {
      const current = getElementTags('node', id);
      uncheckedTags.forEach(tag => current.delete(tag));
      setElementTags('node', id, current);
      changed++;
    });

    edges.forEach(id => {
      const current = getElementTags('edge', id);
      uncheckedTags.forEach(tag => current.delete(tag));
      setElementTags('edge', id, current);
      changed++;
    });

    groups.forEach(id => {
      const current = getElementTags('group', id);
      uncheckedTags.forEach(tag => current.delete(tag));
      setElementTags('group', id, current);
      changed++;
    });

    commit();
    render();
    refreshLabelManager();
    showToast(`âœ— Removed ${uncheckedTags.size} tag(s) from ${changed} element(s)`);
  }

  // Render bulk apply section
  function renderBulkApplySection() {
    // Render selected tags for bulk operation
    const selectedContainer = document.getElementById('lmBulkTagsSelected');
    const availableContainer = document.getElementById('lmBulkAvailableTags');

    if (selectedContainer) {
      if (labelManagerState.bulkTags.size === 0) {
        selectedContainer.innerHTML = '<span style="color:#9ca3af; font-size:11px;">Click tags below to add</span>';
      } else {
        let html = '';
        labelManagerState.bulkTags.forEach(tag => {
          html += `<span class="lm-tag-pill" data-tag="${escapeHtml(tag)}">${escapeHtml(tag)} <span class="remove" onclick="removeBulkTag('${escapeHtml(tag)}')">Ã—</span></span>`;
        });
        selectedContainer.innerHTML = html;
      }
    }

    if (availableContainer) {
      const allTags = getAllProjectTags();
      let html = '';
      const sortedTags = Array.from(allTags.keys()).sort();
      sortedTags.forEach(tag => {
        if (!labelManagerState.bulkTags.has(tag)) {
          html += `<span class="lm-tag-pill" style="background:#f3f4f6; color:#374151; cursor:pointer;" onclick="addBulkTag('${escapeHtml(tag)}')">${escapeHtml(tag)} +</span>`;
        }
      });
      availableContainer.innerHTML = html || '<span style="color:#9ca3af; font-size:11px;">All tags selected above</span>';
    }

    // Update pick list visibility
    const pickList = document.getElementById('lmBulkPickList');
    const pickTarget = document.querySelector('input[name="lmBulkTarget"]:checked')?.value;
    if (pickList) {
      pickList.style.display = pickTarget === 'pick' ? 'block' : 'none';
    }

    renderPickedItems();
  }

  // Add tag to bulk operation
  window.addBulkTag = function(tag) {
    labelManagerState.bulkTags.add(tag);
    renderBulkApplySection();
  };

  // Remove tag from bulk operation
  window.removeBulkTag = function(tag) {
    labelManagerState.bulkTags.delete(tag);
    renderBulkApplySection();
  };

  // Render picked items list
  function renderPickedItems() {
    const container = document.getElementById('lmBulkPickedItems');
    if (!container) return;

    const { nodes, links, containers } = labelManagerState.pickedElements;

    if (nodes.size + links.size + containers.size === 0) {
      container.innerHTML = '<span style="color:#9ca3af; font-size:11px;">No elements picked yet</span>';
      return;
    }

    let html = '';
    nodes.forEach(id => {
      const n = findNode(id);
      if (n) html += `<span class="lm-tag-pill" style="background:#dbeafe;">${n.name || n.code || 'Node ' + id} <span class="remove" onclick="removePickedElement('node', ${id})">Ã—</span></span>`;
    });
    links.forEach(id => {
      const e = state.edges.find(e => e.id === id);
      if (e) {
        const nodeA = findNode(e.a);
        const nodeB = findNode(e.b);
        html += `<span class="lm-tag-pill" style="background:#fef3c7;">${nodeA?.code || 'N' + e.a}â†”${nodeB?.code || 'N' + e.b} <span class="remove" onclick="removePickedElement('link', ${id})">Ã—</span></span>`;
      }
    });
    containers.forEach(id => {
      const g = findGroup(id);
      if (g) html += `<span class="lm-tag-pill" style="background:#d1fae5;">${g.title || 'Container ' + id} <span class="remove" onclick="removePickedElement('container', ${id})">Ã—</span></span>`;
    });

    container.innerHTML = html;
  }

  // Remove picked element
  window.removePickedElement = function(type, id) {
    if (type === 'node') labelManagerState.pickedElements.nodes.delete(id);
    if (type === 'link') labelManagerState.pickedElements.links.delete(id);
    if (type === 'container') labelManagerState.pickedElements.containers.delete(id);
    renderPickedItems();
  };

  // Apply bulk tag operation
  function applyBulkOperation() {
    const action = document.querySelector('input[name="lmBulkAction"]:checked')?.value || 'add';
    const targetMode = document.querySelector('input[name="lmBulkTarget"]:checked')?.value || 'selection';

    const tags = labelManagerState.bulkTags;
    if (tags.size === 0) {
      showToast('No tags selected for bulk operation');
      return;
    }

    let targetNodes, targetEdges, targetGroups;

    if (targetMode === 'selection') {
      const selected = getSelectedElements();
      targetNodes = selected.nodes;
      targetEdges = selected.edges;
      targetGroups = selected.groups;
    } else {
      targetNodes = labelManagerState.pickedElements.nodes;
      targetEdges = labelManagerState.pickedElements.links;
      targetGroups = labelManagerState.pickedElements.containers;
    }

    const totalTargets = targetNodes.size + targetEdges.size + targetGroups.size;
    if (totalTargets === 0) {
      showToast('No target elements selected');
      return;
    }

    let changed = 0;

    // Apply to nodes
    targetNodes.forEach(id => {
      const current = getElementTags('node', id);
      if (action === 'add') {
        tags.forEach(tag => current.add(tag));
      } else if (action === 'remove') {
        tags.forEach(tag => current.delete(tag));
      } else if (action === 'set') {
        current.clear();
        tags.forEach(tag => current.add(tag));
      }
      setElementTags('node', id, current);
      changed++;
    });

    // Apply to edges
    targetEdges.forEach(id => {
      const current = getElementTags('edge', id);
      if (action === 'add') {
        tags.forEach(tag => current.add(tag));
      } else if (action === 'remove') {
        tags.forEach(tag => current.delete(tag));
      } else if (action === 'set') {
        current.clear();
        tags.forEach(tag => current.add(tag));
      }
      setElementTags('edge', id, current);
      changed++;
    });

    // Apply to groups
    targetGroups.forEach(id => {
      const current = getElementTags('group', id);
      if (action === 'add') {
        tags.forEach(tag => current.add(tag));
      } else if (action === 'remove') {
        tags.forEach(tag => current.delete(tag));
      } else if (action === 'set') {
        current.clear();
        tags.forEach(tag => current.add(tag));
      }
      setElementTags('group', id, current);
      changed++;
    });

    commit();
    render();
    refreshLabelManager();

    const actionLabel = action === 'add' ? 'Added' : (action === 'remove' ? 'Removed' : 'Set');
    showToast(`â›¡ ${actionLabel} ${tags.size} tag(s) on ${changed} element(s)`);
  }

  // Rename tag globally
  function renameTagGlobally() {
    const fromSelect = document.getElementById('lmRenameFrom');
    const toInput = document.getElementById('lmRenameTo');

    const fromTag = fromSelect?.value;
    const toTag = toInput?.value?.trim();

    if (!fromTag) {
      showToast('Select a tag to rename');
      return;
    }
    if (!toTag) {
      showToast('Enter a new name');
      return;
    }
    if (fromTag === toTag) {
      showToast('New name is same as old name');
      return;
    }

    let changed = 0;

    // Rename in nodes
    state.nodes.forEach(n => {
      const tags = getElementTags('node', n.id);
      if (tags.has(fromTag)) {
        tags.delete(fromTag);
        tags.add(toTag);
        setElementTags('node', n.id, tags);
        changed++;
      }
    });

    // Rename in edges
    state.edges.forEach(e => {
      const tags = getElementTags('edge', e.id);
      if (tags.has(fromTag)) {
        tags.delete(fromTag);
        tags.add(toTag);
        setElementTags('edge', e.id, tags);
        changed++;
      }
    });

    // Rename in groups
    state.groups.forEach(g => {
      const tags = getElementTags('group', g.id);
      if (tags.has(fromTag)) {
        tags.delete(fromTag);
        tags.add(toTag);
        setElementTags('group', g.id, tags);
        changed++;
      }
    });

    commit();
    render();
    refreshLabelManager();

    if (toInput) toInput.value = '';
    showToast(`âœï¸ Renamed "${fromTag}" to "${toTag}" in ${changed} element(s)`);
  }

  // Update rename dropdown
  function updateRenameDropdown() {
    const select = document.getElementById('lmRenameFrom');
    if (!select) return;

    const allTags = getAllProjectTags();
    const sortedTags = Array.from(allTags.keys()).sort();

    select.innerHTML = '<option value="">-- Select tag to rename --</option>';
    sortedTags.forEach(tag => {
      const opt = document.createElement('option');
      opt.value = tag;
      opt.textContent = tag;
      select.appendChild(opt);
    });
  }

  // Create new tag
  function createNewTag() {
    const tagName = prompt('Enter new tag name:');
    if (!tagName || !tagName.trim()) return;

    const tag = tagName.trim();

    // Add to bulk tags for easy application
    labelManagerState.bulkTags.add(tag);
    renderBulkApplySection();
    showToast(`Created tag "${tag}" - apply it using Bulk Apply section`);
  }

  // Delete unused tags (tags not on any element)
  function deleteUnusedTags() {
    const allTags = getAllProjectTags();
    const unusedTags = [];

    allTags.forEach((counts, tag) => {
      if (counts.nodes + counts.links + counts.containers === 0) {
        unusedTags.push(tag);
      }
    });

    if (unusedTags.length === 0) {
      showToast('No unused tags found');
      return;
    }

    // Remove from bulk tags
    unusedTags.forEach(tag => labelManagerState.bulkTags.delete(tag));

    refreshLabelManager();
    showToast(`ðŸ—‘ï¸ Removed ${unusedTags.length} unused tag(s)`);
  }

  // Show tag context menu
  window.showLMTagMenu = function(tag, event) {
    event.stopPropagation();

    // Remove existing menu
    document.querySelectorAll('.lm-context-menu').forEach(m => m.remove());

    const menu = document.createElement('div');
    menu.className = 'lm-context-menu';
    menu.style.cssText = `
      position: fixed;
      left: ${event.clientX}px;
      top: ${event.clientY}px;
      background: white;
      border: 1px solid #d0d0d0;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      padding: 4px 0;
      z-index: 1000;
      min-width: 160px;
    `;

    menu.innerHTML = `
      <div class="lm-menu-item" onclick="selectAllWithTag('${escapeHtml(tag)}')" style="padding:8px 12px; cursor:pointer; font-size:12px;">ðŸŽ¯ Select all with "${escapeHtml(tag)}"</div>
      <div class="lm-menu-item" onclick="addBulkTag('${escapeHtml(tag)}')" style="padding:8px 12px; cursor:pointer; font-size:12px;">â›¡ Add to bulk operation</div>
      <div style="border-top:1px solid #e5e7eb; margin:4px 0;"></div>
      <div class="lm-menu-item" onclick="renameTagPrompt('${escapeHtml(tag)}')" style="padding:8px 12px; cursor:pointer; font-size:12px;">âœï¸ Rename...</div>
      <div class="lm-menu-item" onclick="deleteTagGlobally('${escapeHtml(tag)}')" style="padding:8px 12px; cursor:pointer; font-size:12px; color:#dc2626;">ðŸ—‘ï¸ Delete from all elements</div>
    `;

    // Add hover styles
    menu.querySelectorAll('.lm-menu-item').forEach(item => {
      item.addEventListener('mouseenter', () => item.style.background = '#f3f4f6');
      item.addEventListener('mouseleave', () => item.style.background = '');
    });

    document.body.appendChild(menu);

    // Close on click outside
    setTimeout(() => {
      document.addEventListener('click', function closeMenu() {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }, { once: true });
    }, 0);
  };

  // Select all elements with a specific tag
  window.selectAllWithTag = function(tag) {
    state.selection.nodes.clear();
    state.selection.edges.clear();
    state.selection.groups.clear();
    state.selected = null;

    let count = 0;

    state.nodes.forEach(n => {
      if (getElementTags('node', n.id).has(tag)) {
        state.selection.nodes.add(n.id);
        count++;
      }
    });

    state.edges.forEach(e => {
      if (getElementTags('edge', e.id).has(tag)) {
        state.selection.edges.add(e.id);
        count++;
      }
    });

    state.groups.forEach(g => {
      if (getElementTags('group', g.id).has(tag)) {
        state.selection.groups.add(g.id);
        count++;
      }
    });

    render();
    refreshLabelManager();
    showToast(`ðŸŽ¯ Selected ${count} element(s) with tag "${tag}"`);
  };

  // Rename tag with prompt
  window.renameTagPrompt = function(tag) {
    const newName = prompt(`Rename tag "${tag}" to:`, tag);
    if (!newName || !newName.trim() || newName.trim() === tag) return;

    document.getElementById('lmRenameFrom').value = tag;
    document.getElementById('lmRenameTo').value = newName.trim();
    renameTagGlobally();
  };

  // Delete tag globally
  window.deleteTagGlobally = function(tag) {
    if (!confirm(`Delete tag "${tag}" from all elements?`)) return;

    let changed = 0;

    state.nodes.forEach(n => {
      const tags = getElementTags('node', n.id);
      if (tags.has(tag)) {
        tags.delete(tag);
        setElementTags('node', n.id, tags);
        changed++;
      }
    });

    state.edges.forEach(e => {
      const tags = getElementTags('edge', e.id);
      if (tags.has(tag)) {
        tags.delete(tag);
        setElementTags('edge', e.id, tags);
        changed++;
      }
    });

    state.groups.forEach(g => {
      const tags = getElementTags('group', g.id);
      if (tags.has(tag)) {
        tags.delete(tag);
        setElementTags('group', g.id, tags);
        changed++;
      }
    });

    commit();
    render();
    refreshLabelManager();
    showToast(`ðŸ—‘ï¸ Deleted tag "${tag}" from ${changed} element(s)`);
  };

  // Handle Label Manager pick mode for canvas clicks
  function handleLabelManagerCanvasClick(type, id) {
    if (!labelManagerState.pickMode) return false;

    if (type === 'node') {
      if (labelManagerState.pickedElements.nodes.has(id)) {
        labelManagerState.pickedElements.nodes.delete(id);
      } else {
        labelManagerState.pickedElements.nodes.add(id);
      }
    } else if (type === 'edge') {
      if (labelManagerState.pickedElements.links.has(id)) {
        labelManagerState.pickedElements.links.delete(id);
      } else {
        labelManagerState.pickedElements.links.add(id);
      }
    } else if (type === 'group') {
      if (labelManagerState.pickedElements.containers.has(id)) {
        labelManagerState.pickedElements.containers.delete(id);
      } else {
        labelManagerState.pickedElements.containers.add(id);
      }
    }

    renderPickedItems();
    const total = labelManagerState.pickedElements.nodes.size + labelManagerState.pickedElements.links.size + labelManagerState.pickedElements.containers.size;
    showToast(`ðŸŽ¯ Picked ${total} element(s)`);

    return true;
  }

  // Expose for external use
  window.handleLabelManagerCanvasClick = handleLabelManagerCanvasClick;
  window.labelManagerState = labelManagerState;

  // Event listeners
  if (btnLabelManager) {
    btnLabelManager.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleLabelManager();
    });
  }

  if (btnCloseLabelManager) {
    btnCloseLabelManager.addEventListener('click', closeLabelManager);
  }

  // Tag search
  const lmTagSearch = document.getElementById('lmTagSearch');
  if (lmTagSearch) {
    lmTagSearch.addEventListener('input', () => renderProjectTagsList());
  }

  // Filter buttons
  ['lmFilterAll', 'lmFilterNodes', 'lmFilterLinks', 'lmFilterContainers'].forEach(id => {
    const btn = document.getElementById(id);
    if (btn) {
      btn.addEventListener('click', () => {
        labelManagerState.filterType = id.replace('lmFilter', '').toLowerCase();
        // Update button styles
        document.querySelectorAll('#lmFilterAll, #lmFilterNodes, #lmFilterLinks, #lmFilterContainers').forEach(b => {
          b.style.background = '';
          b.style.color = '';
        });
        btn.style.background = '#8b5cf6';
        btn.style.color = 'white';
        renderProjectTagsList();
      });
    }
  });

  // Select all with checked tags
  const lmSelectAllWithTag = document.getElementById('lmSelectAllWithTag');
  if (lmSelectAllWithTag) {
    lmSelectAllWithTag.addEventListener('click', selectAllWithCheckedTags);
  }

  // New tag button
  const lmNewTag = document.getElementById('lmNewTag');
  if (lmNewTag) {
    lmNewTag.addEventListener('click', createNewTag);
  }

  // Delete unused tags
  const lmDeleteUnused = document.getElementById('lmDeleteUnused');
  if (lmDeleteUnused) {
    lmDeleteUnused.addEventListener('click', deleteUnusedTags);
  }

  // Apply/remove buttons for selection tags
  const lmApplyChecked = document.getElementById('lmApplyChecked');
  if (lmApplyChecked) {
    lmApplyChecked.addEventListener('click', applyCheckedTagsToSelection);
  }

  const lmRemoveUnchecked = document.getElementById('lmRemoveUnchecked');
  if (lmRemoveUnchecked) {
    lmRemoveUnchecked.addEventListener('click', removeUncheckedTagsFromSelection);
  }

  // Bulk apply new tag input
  const lmBulkAddNewTag = document.getElementById('lmBulkAddNewTag');
  const lmBulkNewTag = document.getElementById('lmBulkNewTag');
  if (lmBulkAddNewTag && lmBulkNewTag) {
    lmBulkAddNewTag.addEventListener('click', () => {
      const tag = lmBulkNewTag.value.trim();
      if (tag) {
        labelManagerState.bulkTags.add(tag);
        lmBulkNewTag.value = '';
        renderBulkApplySection();
      }
    });
    lmBulkNewTag.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const tag = lmBulkNewTag.value.trim();
        if (tag) {
          labelManagerState.bulkTags.add(tag);
          lmBulkNewTag.value = '';
          renderBulkApplySection();
        }
      }
    });
  }

  // Bulk target radio buttons
  document.querySelectorAll('input[name="lmBulkTarget"]').forEach(radio => {
    radio.addEventListener('change', renderBulkApplySection);
  });

  // Pick mode button
  const lmBulkPickMode = document.getElementById('lmBulkPickMode');
  if (lmBulkPickMode) {
    lmBulkPickMode.addEventListener('click', () => {
      labelManagerState.pickMode = !labelManagerState.pickMode;
      lmBulkPickMode.textContent = labelManagerState.pickMode ? 'ðŸŽ¯ Stop Pick' : 'ðŸŽ¯ Start Pick';
      lmBulkPickMode.style.background = labelManagerState.pickMode ? '#8b5cf6' : '';
      lmBulkPickMode.style.color = labelManagerState.pickMode ? 'white' : '';
      if (labelManagerState.pickMode) {
        showToast('ðŸŽ¯ Click on nodes, links, or containers to pick them');
      }
    });
  }

  // Clear picked button
  const lmBulkClearPicked = document.getElementById('lmBulkClearPicked');
  if (lmBulkClearPicked) {
    lmBulkClearPicked.addEventListener('click', () => {
      labelManagerState.pickedElements.nodes.clear();
      labelManagerState.pickedElements.links.clear();
      labelManagerState.pickedElements.containers.clear();
      renderPickedItems();
    });
  }

  // Bulk apply button
  const lmBulkApply = document.getElementById('lmBulkApply');
  if (lmBulkApply) {
    lmBulkApply.addEventListener('click', applyBulkOperation);
  }

  // Rename apply button
  const lmRenameApply = document.getElementById('lmRenameApply');
  if (lmRenameApply) {
    lmRenameApply.addEventListener('click', renameTagGlobally);
  }

  // Make Label Manager panel draggable
  if (labelManagerHeader && labelManagerPanel) {
    labelManagerHeader.style.cursor = 'move';
    let lmPanelDragging = false;
    let lmPanelDragOffset = { x: 0, y: 0 };

    labelManagerHeader.addEventListener('mousedown', (ev) => {
      if (ev.target.tagName === 'BUTTON' || ev.target.closest('button')) return;

      lmPanelDragging = true;
      const rect = labelManagerPanel.getBoundingClientRect();
      lmPanelDragOffset.x = ev.clientX - rect.left;
      lmPanelDragOffset.y = ev.clientY - rect.top;
      labelManagerPanel.style.cursor = 'grabbing';
      ev.preventDefault();
    });

    window.addEventListener('mousemove', (ev) => {
      if (!lmPanelDragging) return;

      const layout = document.getElementById('layout');
      const layoutRect = layout.getBoundingClientRect();

      let newLeft = ev.clientX - layoutRect.left - lmPanelDragOffset.x;
      let newTop = ev.clientY - layoutRect.top - lmPanelDragOffset.y;

      newLeft = Math.max(0, Math.min(newLeft, layoutRect.width - labelManagerPanel.offsetWidth));
      newTop = Math.max(0, Math.min(newTop, layoutRect.height - 50));

      labelManagerPanel.style.left = newLeft + 'px';
      labelManagerPanel.style.top = newTop + 'px';
      labelManagerPanel.style.right = 'auto';
    });

    window.addEventListener('mouseup', () => {
      if (lmPanelDragging) {
        lmPanelDragging = false;
        labelManagerPanel.style.cursor = '';
      }
    });
  }

  // Listen for selection changes to update Label Manager
  const originalRender = window.render || render;
  const renderWithLabelManager = function() {
    originalRender();
    if (labelManagerState.visible) {
      updateSelectionStatus();
      renderSelectionTags();
    }
  };
  // Override render in the window scope if available
  if (typeof window !== 'undefined') {
    window.refreshLabelManager = refreshLabelManager;
  }

  // ============== END LABEL MANAGER ==============

  // ============== GEOGRAPHIC VIEW & GPS COORDINATES ==============

  // World map SVG path (simplified continents outline)
  const worldMapPath = `
    M 52,28 L 58,26 L 64,28 L 68,32 L 72,30 L 78,32 L 82,36 L 78,42 L 82,48 L 78,54 L 72,58 L 66,54 L 60,58 L 54,54 L 48,58 L 42,54 L 38,58 L 32,54 L 28,50 L 32,44 L 28,38 L 34,32 L 40,28 L 46,32 Z
    M 18,42 L 24,38 L 30,40 L 34,46 L 30,52 L 26,56 L 22,60 L 18,64 L 14,68 L 10,72 L 6,68 L 8,62 L 6,56 L 10,50 L 14,46 Z
    M 24,72 L 30,68 L 36,70 L 40,76 L 38,82 L 34,88 L 30,92 L 26,88 L 22,82 L 20,76 Z
    M 56,42 L 62,40 L 68,42 L 74,46 L 78,52 L 74,58 L 68,62 L 62,66 L 56,70 L 50,74 L 44,70 L 40,64 L 44,58 L 50,54 L 48,48 Z
    M 80,34 L 86,32 L 92,34 L 96,38 L 92,44 L 88,48 L 84,44 L 80,40 Z
    M 78,62 L 84,58 L 90,60 L 94,66 L 90,72 L 84,76 L 78,72 L 74,66 Z
  `;

  // Geographic view state
  const geoViewState = {
    active: false,
    // Map bounds: The Wikimedia BlankMap-World-Equirectangular.svg covers exactly -180 to 180 longitude
    // and approximately -85.05 to 85.05 latitude (Web Mercator limits, though it's Equirectangular)
    // Using -90/90 causes a slight vertical stretch - the actual SVG viewBox is 2754x1398 (roughly 2:1)
    mapBounds: { minLat: -85.05, maxLat: 85.05, minLon: -180, maxLon: 180 },
    canvasWidth: 1800,
    canvasHeight: 918, // Maintain aspect ratio: 1800 * (170.1/360) â‰ˆ 850, but we add padding
    padding: 0, // No padding - draw map full bleed for accurate GPS alignment
    // Projection adjustment factors - calibrated for Wikimedia BlankMap-World-Equirectangular.svg
    // Scale: 1.0 = normal, <1 = shrink coordinates (nodes closer to center), >1 = expand
    // Offset: shifts all nodes by this many pixels
    projectionAdjust: {
      scaleX: 0.895,   // Horizontal scale factor (affects longitude mapping)
      scaleY: 0.815,   // Vertical scale factor (affects latitude mapping)
      offsetX: -61,    // Horizontal offset in pixels (positive = shift right)
      offsetY: -10     // Vertical offset in pixels (positive = shift down)
    },
    // Custom map image support
    customMapImage: null, // Base64 data URL or external URL
    customMapBounds: null, // { minLat, maxLat, minLon, maxLon } for custom image
    useCustomMap: true, // Default to using the map image
    mapSource: 'url', // 'url', 'upload', or 'builtin'
    // Default map URL (Wikimedia Equirectangular - public domain)
    defaultMapUrl: 'https://upload.wikimedia.org/wikipedia/commons/9/9f/BlankMap-World-Equirectangular.svg',
    mapUrl: 'https://upload.wikimedia.org/wikipedia/commons/9/9f/BlankMap-World-Equirectangular.svg'
  };

  // Expose to window for access from other parts of the code
  window.geoViewState = geoViewState;

  // Load custom map settings from localStorage if available
  try {
    const savedMap = localStorage.getItem('neximap-geo-custom-map');
    if (savedMap) {
      const mapData = JSON.parse(savedMap);
      if (mapData.mapSource === 'upload' && mapData.image) {
        geoViewState.customMapImage = mapData.image;
        geoViewState.customMapBounds = mapData.bounds;
        geoViewState.mapSource = 'upload';
      } else if (mapData.mapSource === 'url' && mapData.mapUrl) {
        geoViewState.mapUrl = mapData.mapUrl;
        geoViewState.customMapBounds = mapData.bounds;
        geoViewState.mapSource = 'url';
      } else if (mapData.mapSource === 'builtin') {
        geoViewState.mapSource = 'builtin';
      }
      geoViewState.useCustomMap = mapData.useCustomMap !== false;
    }
  } catch (e) {
    console.log('No saved custom map found, using default');
  }

  // GPS format preference (stored per-session)
  let gpsDisplayFormat = 'DD'; // 'DD' or 'DMS'

  // Convert Decimal Degrees to DMS
  function ddToDms(dd, isLat) {
    const abs = Math.abs(dd);
    const deg = Math.floor(abs);
    const minFloat = (abs - deg) * 60;
    const min = Math.floor(minFloat);
    const sec = ((minFloat - min) * 60).toFixed(2);
    const dir = isLat ? (dd >= 0 ? 'N' : 'S') : (dd >= 0 ? 'E' : 'W');
    return { deg, min, sec: parseFloat(sec), dir };
  }

  // Convert DMS to Decimal Degrees
  function dmsToDd(deg, min, sec, dir) {
    let dd = Math.abs(parseFloat(deg) || 0) +
             (parseFloat(min) || 0) / 60 +
             (parseFloat(sec) || 0) / 3600;
    if (dir === 'S' || dir === 'W') dd = -dd;
    return dd;
  }

  // Validate and parse decimal degree input
  function parseDecimalDegree(str, isLat) {
    if (!str || str.trim() === '') return null;
    const val = parseFloat(str);
    if (isNaN(val)) return null;
    if (isLat && (val < -90 || val > 90)) return null;
    if (!isLat && (val < -180 || val > 180)) return null;
    return val;
  }

  // Format decimal degrees for display
  function formatDD(val, decimals = 6) {
    if (val === null || val === undefined || isNaN(val)) return '';
    return val.toFixed(decimals);
  }

  // Update GPS fields in inspector from node data
  function updateGpsFields(node) {
    const formatSelect = document.getElementById('nodeGpsFormat');
    const ddContainer = document.getElementById('gpsFormatDD');
    const dmsContainer = document.getElementById('gpsFormatDMS');

    // DD fields
    const latDD = document.getElementById('nodeLatDD');
    const lonDD = document.getElementById('nodeLonDD');

    // DMS fields
    const latDeg = document.getElementById('nodeLatDeg');
    const latMin = document.getElementById('nodeLatMin');
    const latSec = document.getElementById('nodeLatSec');
    const latDir = document.getElementById('nodeLatDir');
    const lonDeg = document.getElementById('nodeLonDeg');
    const lonMin = document.getElementById('nodeLonMin');
    const lonSec = document.getElementById('nodeLonSec');
    const lonDir = document.getElementById('nodeLonDir');

    if (!formatSelect) return;

    // Show/hide format containers
    const format = formatSelect.value || 'DD';
    if (ddContainer) ddContainer.style.display = format === 'DD' ? 'flex' : 'none';
    if (dmsContainer) dmsContainer.style.display = format === 'DMS' ? 'block' : 'none';

    // Get node GPS values (stored as decimal degrees internally)
    const lat = node?.gpsLat;
    const lon = node?.gpsLon;

    if (format === 'DD') {
      if (latDD) latDD.value = lat !== null && lat !== undefined ? formatDD(lat) : '';
      if (lonDD) lonDD.value = lon !== null && lon !== undefined ? formatDD(lon) : '';
    } else {
      // DMS format
      if (lat !== null && lat !== undefined) {
        const dmsLat = ddToDms(lat, true);
        if (latDeg) latDeg.value = dmsLat.deg;
        if (latMin) latMin.value = dmsLat.min;
        if (latSec) latSec.value = dmsLat.sec;
        if (latDir) latDir.value = dmsLat.dir;
      } else {
        if (latDeg) latDeg.value = '';
        if (latMin) latMin.value = '';
        if (latSec) latSec.value = '';
        if (latDir) latDir.value = 'N';
      }

      if (lon !== null && lon !== undefined) {
        const dmsLon = ddToDms(lon, false);
        if (lonDeg) lonDeg.value = dmsLon.deg;
        if (lonMin) lonMin.value = dmsLon.min;
        if (lonSec) lonSec.value = dmsLon.sec;
        if (lonDir) lonDir.value = dmsLon.dir;
      } else {
        if (lonDeg) lonDeg.value = '';
        if (lonMin) lonMin.value = '';
        if (lonSec) lonSec.value = '';
        if (lonDir) lonDir.value = 'E';
      }
    }
  }

  // Save GPS from DD fields
  function saveGpsFromDD() {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id);
    if (!n) return;

    const latDD = document.getElementById('nodeLatDD');
    const lonDD = document.getElementById('nodeLonDD');

    const lat = parseDecimalDegree(latDD?.value, true);
    const lon = parseDecimalDegree(lonDD?.value, false);

    n.gpsLat = lat;
    n.gpsLon = lon;

    commit();
    if (geoViewState.active) render();
  }

  // Save GPS from DMS fields
  function saveGpsFromDMS() {
    if (state.selected?.type !== 'node') return;
    const n = findNode(state.selected.id);
    if (!n) return;

    const latDeg = document.getElementById('nodeLatDeg');
    const latMin = document.getElementById('nodeLatMin');
    const latSec = document.getElementById('nodeLatSec');
    const latDir = document.getElementById('nodeLatDir');
    const lonDeg = document.getElementById('nodeLonDeg');
    const lonMin = document.getElementById('nodeLonMin');
    const lonSec = document.getElementById('nodeLonSec');
    const lonDir = document.getElementById('nodeLonDir');

    // Check if any lat fields have values
    if (latDeg?.value || latMin?.value || latSec?.value) {
      n.gpsLat = dmsToDd(latDeg?.value, latMin?.value, latSec?.value, latDir?.value || 'N');
    } else {
      n.gpsLat = null;
    }

    // Check if any lon fields have values
    if (lonDeg?.value || lonMin?.value || lonSec?.value) {
      n.gpsLon = dmsToDd(lonDeg?.value, lonMin?.value, lonSec?.value, lonDir?.value || 'E');
    } else {
      n.gpsLon = null;
    }

    commit();
    if (geoViewState.active) render();
  }

  // Convert GPS coordinates to canvas position (Equirectangular projection)
  // This maps GPS coordinates directly to canvas pixel positions
  // Applies adjustable scale and offset factors for fine-tuning alignment
  function gpsToCanvas(lat, lon, applyAdjustment = true) {
    // Use custom bounds if set, otherwise use default map bounds
    const bounds = geoViewState.customMapBounds || geoViewState.mapBounds;
    const { minLat, maxLat, minLon, maxLon } = bounds;

    const width = geoViewState.canvasWidth;
    const height = geoViewState.canvasHeight;

    // Calculate center point of the canvas
    const centerX = width / 2;
    const centerY = height / 2;

    // X: longitude range maps to [0, width]
    const lonRange = maxLon - minLon;
    let x = ((lon - minLon) / lonRange) * width;

    // Y: latitude range maps to [0, height], inverted (north at top)
    const latRange = maxLat - minLat;
    let y = ((maxLat - lat) / latRange) * height;

    // Apply projection adjustment if enabled (for node positioning, not map background)
    if (applyAdjustment && geoViewState.projectionAdjust) {
      const adj = geoViewState.projectionAdjust;

      // Scale from center point
      x = centerX + (x - centerX) * adj.scaleX;
      y = centerY + (y - centerY) * adj.scaleY;

      // Apply offset
      x += adj.offsetX;
      y += adj.offsetY;
    }

    return { x, y };
  }

  // Version without adjustment - used for drawing the map background and graticule
  function gpsToCanvasRaw(lat, lon) {
    return gpsToCanvas(lat, lon, false);
  }

  // Accurate world map coordinate data (simplified but geographically correct)
  // Each array is [lat, lon] pairs forming polygon outlines
  const worldMapData = {
    // North America (mainland)
    northAmerica: [
      [83, -70], [83, -80], [76, -90], [72, -96], [71, -104], [70, -128], [71, -156], [66, -168], [64, -167], [62, -164],
      [60, -162], [59, -157], [58, -153], [57, -155], [56, -158], [55, -160], [54, -164], [52, -169], [52, -175], [54, -178],
      [57, 179], [59, 178], [62, 175], [65, 174], [67, 171], [68, 167], [69, 164], [70, 158], [72, 156], [70, -168],
      [68, -164], [66, -162], [65, -168], [61, -166], [60, -147], [60, -141], [57, -136], [55, -132], [54, -130], [50, -127],
      [48, -123], [46, -124], [43, -124], [42, -124], [39, -123], [35, -120], [33, -117], [32, -117], [31, -114], [29, -112],
      [26, -110], [24, -108], [22, -105], [20, -105], [19, -104], [17, -100], [16, -96], [18, -91], [20, -87], [21, -87],
      [23, -88], [26, -90], [29, -89], [29, -85], [27, -82], [25, -80], [25, -79], [27, -77], [30, -81], [31, -81],
      [32, -79], [34, -77], [35, -75], [37, -76], [38, -75], [39, -74], [40, -74], [41, -72], [42, -70], [43, -70],
      [44, -68], [44, -66], [46, -64], [47, -61], [46, -59], [47, -56], [47, -53], [51, -56], [52, -56], [53, -59],
      [47, -63], [46, -67], [45, -73], [46, -78], [48, -85], [48, -88], [49, -95], [49, -101], [49, -110], [49, -123],
      [54, -130], [55, -130], [58, -136], [60, -140], [61, -150], [63, -165], [64, -167], [67, -164], [71, -156], [69, -140],
      [69, -130], [70, -117], [75, -95], [78, -80], [83, -70]
    ],

    // South America
    southAmerica: [
      [12, -72], [12, -68], [10, -64], [10, -61], [8, -60], [7, -56], [5, -52], [4, -51], [2, -50], [0, -50],
      [-3, -42], [-5, -35], [-8, -35], [-13, -39], [-18, -40], [-22, -41], [-23, -44], [-26, -48], [-30, -51],
      [-34, -54], [-38, -58], [-42, -63], [-46, -66], [-52, -68], [-55, -67], [-55, -68], [-54, -71], [-52, -74],
      [-48, -75], [-45, -74], [-41, -73], [-38, -73], [-35, -72], [-33, -71], [-30, -71], [-27, -71], [-24, -70],
      [-22, -70], [-20, -70], [-18, -70], [-15, -75], [-12, -77], [-8, -79], [-5, -81], [-2, -80], [0, -80],
      [2, -78], [5, -77], [8, -77], [10, -75], [12, -72]
    ],

    // Europe (mainland - excluding Iberia which is separate)
    europe: [
      // Scandinavia and Northern Europe
      [71, 28], [70, 32], [68, 28], [67, 24], [65, 22], [63, 20], [61, 18], [60, 16], [59, 14],
      [57, 10], [56, 8], [55, 9], [54, 8], [54, 10], [55, 12], [54, 14], [53, 14],
      // Germany, Netherlands, Belgium
      [54, 8], [53, 7], [52, 5], [51, 4], [51, 2],
      // France Atlantic coast
      [49, 0], [48, -2], [47, -3], [46, -2], [45, -1], [44, -1], [43.5, -2],
      // French-Spanish border (Pyrenees) - stop here, don't go into Spain
      [43, 0], [42.5, 1], [42.5, 3],
      // French Mediterranean & Riviera
      [43, 4], [43, 6], [43.5, 7],
      // Alps region
      [45, 7], [46, 8], [47, 10], [47, 13],
      // Balkans coastline
      [46, 14], [45, 14], [44, 15], [43, 16], [42, 17], [41, 19], [40, 20], [39, 20],
      [38, 22], [37, 23], [36, 23], [35, 25],
      // Turkey / Black Sea
      [37, 27], [39, 28], [41, 29], [42, 32], [43, 34], [42, 37], [41, 40],
      // Ukraine, Russia west
      [44, 40], [46, 38], [48, 35], [50, 32], [52, 28], [54, 24], [56, 22],
      // Baltic
      [58, 24], [60, 26], [62, 28], [64, 26], [66, 24], [68, 26], [70, 28], [71, 28]
    ],

    // Scandinavia (Norway, Sweden)
    scandinavia: [
      [71, 28], [70, 25], [69, 20], [67, 16], [65, 12], [63, 10], [61, 8], [59, 6],
      [58, 8], [57, 8], [56, 10], [55, 12], [56, 14], [57, 16], [58, 18],
      [60, 18], [62, 19], [64, 20], [66, 22], [68, 24], [70, 26], [71, 28]
    ],

    // British Isles (Great Britain)
    britain: [
      [58.5, -5], [58, -3], [57, -2], [56, -3], [55, -3], [54, -3], [53.5, -3],
      [53, -4], [52, -4], [51.5, -3], [51, -1], [51, 1], [51.5, 1], [52.5, 1],
      [53, 0], [54, -1], [55, -2], [56, -2], [57, -3], [58, -4], [58.5, -5]
    ],

    // Ireland
    ireland: [
      [55, -6], [54.5, -8], [54, -10], [53, -10], [52, -10], [51.5, -10], [51.5, -9],
      [52, -7], [53, -6], [54, -6], [55, -6]
    ],

    // Iberian Peninsula (Spain and Portugal) - accurate for Madrid at 40.4Â°N, 3.7Â°W
    iberia: [
      // Northern coast (Galicia to Basque)
      [43.8, -7.9], [43.5, -8], [43.3, -6], [43.5, -4], [43.4, -2], [43.3, -1.5],
      // Pyrenees to Mediterranean
      [42.7, -0.5], [42.5, 0.5], [42.5, 2], [42, 3.2], [41.5, 2.5], [41, 1.5],
      // East coast (Catalonia to Valencia to Murcia)
      [40.5, 0.8], [39.5, 0.2], [38.5, -0.2], [38, -0.5], [37.5, -1],
      // Southeast (AlmerÃ­a) to Gibraltar
      [37, -2], [36.8, -3], [36.5, -4.5], [36.1, -5.5], [36, -5.6],
      // Southwest coast (Cadiz, Huelva)
      [36.5, -6.3], [37, -7], [37.2, -7.5],
      // Portugal west coast
      [37.5, -8.8], [38.5, -9.2], [39, -9.4], [39.5, -9.3], [40, -8.9],
      [40.5, -8.8], [41, -8.8], [41.8, -8.8],
      // Northwest (back to Galicia)
      [42.2, -8.6], [42.8, -9.2], [43.2, -9], [43.8, -7.9]
    ],

    // Italy
    italy: [
      [46, 7], [45.5, 10], [45, 12], [44, 12.5], [43.5, 11], [42, 11.5], [41, 13.5], [40.5, 15],
      [40, 16], [39, 16.5], [38, 16], [37.5, 15], [38, 13], [39, 14], [40, 14.5], [41, 13],
      [42.5, 11], [43.5, 10], [44, 8], [45.5, 7], [46, 7]
    ],

    // Sardinia
    sardinia: [
      [41, 8.5], [40, 8], [39, 8.5], [39, 9.5], [40, 10], [41, 9.5], [41, 8.5]
    ],

    // Sicily
    sicily: [
      [38, 12.5], [37.5, 13], [37, 15], [37.5, 15.5], [38.5, 15], [38, 13], [38, 12.5]
    ],

    // Africa
    africa: [
      [37, -6], [36, -2], [35, 0], [33, 8], [32, 10], [31, 10], [30, 32], [27, 33], [22, 36], [15, 42],
      [12, 44], [11, 50], [5, 46], [2, 42], [-2, 41], [-5, 40], [-10, 40], [-15, 35], [-22, 35], [-26, 33],
      [-30, 31], [-33, 27], [-35, 22], [-34, 18], [-31, 17], [-29, 16], [-26, 15], [-22, 14], [-17, 12],
      [-14, 12], [-10, 9], [-6, 5], [-5, 0], [0, -2], [5, 1], [6, 2], [5, 5], [7, 10], [10, 8], [12, 5],
      [15, -5], [17, -12], [20, -17], [24, -17], [27, -15], [29, -13], [32, -9], [35, -8], [37, -6]
    ],

    // Madagascar
    madagascar: [
      [-12, 49], [-16, 50], [-20, 44], [-25, 47], [-26, 45], [-22, 43], [-18, 44], [-14, 48], [-12, 49]
    ],

    // Asia (mainland including Middle East)
    asia: [
      [77, 100], [76, 110], [73, 120], [71, 130], [69, 140], [68, 150], [66, 160], [65, 169], [63, 172],
      [60, 165], [58, 163], [56, 160], [54, 155], [52, 150], [50, 143], [47, 142], [45, 143], [43, 145],
      [43, 140], [40, 140], [38, 138], [36, 136], [35, 133], [32, 130], [30, 122], [27, 120], [22, 114],
      [20, 110], [18, 107], [15, 108], [11, 108], [8, 105], [6, 103], [5, 100], [8, 98], [10, 99], [14, 100],
      [18, 98], [20, 93], [22, 89], [24, 89], [26, 88], [26, 84], [23, 80], [20, 73], [22, 69], [25, 62],
      [27, 57], [26, 50], [23, 45], [20, 40], [18, 38], [15, 43], [13, 44], [12, 51], [16, 52], [20, 55],
      [25, 57], [28, 57], [30, 48], [32, 46], [35, 36], [37, 36], [39, 44], [41, 45], [42, 50], [44, 51],
      [46, 54], [48, 55], [50, 53], [52, 50], [54, 50], [56, 55], [58, 58], [60, 60], [62, 65], [64, 70],
      [66, 72], [68, 75], [70, 80], [72, 85], [74, 90], [76, 95], [77, 100]
    ],

    // Japan
    japan: [
      [45, 142], [43, 145], [42, 143], [40, 140], [38, 140], [36, 140], [35, 138], [34, 135], [33, 131],
      [32, 130], [33, 132], [34, 133], [35, 134], [36, 137], [38, 139], [40, 141], [42, 141], [43, 142], [45, 142]
    ],

    // Australia
    australia: [
      [-11, 143], [-14, 142], [-17, 141], [-20, 139], [-23, 134], [-26, 129], [-28, 124], [-30, 118],
      [-32, 115], [-34, 116], [-35, 118], [-35, 123], [-34, 129], [-33, 134], [-34, 138], [-36, 140],
      [-38, 145], [-39, 147], [-37, 150], [-34, 151], [-30, 153], [-26, 153], [-22, 150], [-18, 146],
      [-15, 145], [-12, 142], [-11, 143]
    ],

    // Tasmania
    tasmania: [
      [-40, 144], [-42, 145], [-44, 147], [-43, 148], [-41, 148], [-40, 146], [-40, 144]
    ],

    // New Zealand
    newZealandNorth: [
      [-35, 173], [-37, 175], [-39, 178], [-41, 175], [-39, 174], [-37, 175], [-35, 173]
    ],
    newZealandSouth: [
      [-41, 173], [-43, 171], [-46, 168], [-47, 167], [-46, 170], [-44, 172], [-42, 174], [-41, 173]
    ],

    // Indonesia (simplified main islands)
    sumatra: [
      [5, 95], [2, 99], [-1, 104], [-5, 105], [-6, 104], [-4, 101], [-1, 98], [2, 96], [5, 95]
    ],
    borneo: [
      [7, 117], [5, 119], [2, 118], [0, 117], [-2, 116], [-4, 115], [-3, 112], [-1, 110], [2, 110],
      [5, 115], [7, 117]
    ],
    java: [
      [-6, 105], [-7, 107], [-8, 112], [-8, 114], [-7, 114], [-6, 110], [-6, 105]
    ],

    // Philippines
    philippines: [
      [18, 121], [15, 120], [12, 124], [10, 126], [7, 126], [6, 122], [9, 118], [12, 119], [15, 120], [18, 121]
    ],

    // Greenland
    greenland: [
      [83, -35], [82, -20], [78, -18], [75, -20], [72, -22], [68, -26], [65, -38], [62, -43], [60, -45],
      [60, -48], [65, -53], [70, -55], [74, -58], [78, -65], [80, -68], [82, -50], [83, -35]
    ],

    // Iceland
    iceland: [
      [66, -18], [65, -14], [64, -14], [63, -18], [64, -22], [66, -24], [66, -18]
    ],

    // Sri Lanka
    sriLanka: [
      [10, 80], [8, 80], [6, 80], [6, 81], [8, 82], [10, 80]
    ],

    // Taiwan
    taiwan: [
      [25, 121], [23, 121], [22, 120], [23, 120], [25, 121]
    ]
  };

  // Draw world map background for geographic view
  function drawGeoBackground() {
    const bg = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    bg.setAttribute('class', 'geo-background');
    bg.setAttribute('id', 'geoMapGroup');

    // Determine which map source to use
    const useUrlMap = geoViewState.mapSource === 'url' && geoViewState.mapUrl;
    const useUploadedMap = geoViewState.mapSource === 'upload' && geoViewState.customMapImage;

    // Check if using URL or uploaded image
    if (useUrlMap || useUploadedMap) {
      const imgSrc = useUrlMap ? geoViewState.mapUrl : geoViewState.customMapImage;

      // Draw the map image at full canvas size - the coordinate system is aligned
      const img = document.createElementNS('http://www.w3.org/2000/svg', 'image');
      img.setAttribute('id', 'geoMapImage');
      img.setAttribute('x', 0);
      img.setAttribute('y', 0);
      img.setAttribute('width', geoViewState.canvasWidth);
      img.setAttribute('height', geoViewState.canvasHeight);
      img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', imgSrc);
      img.setAttribute('preserveAspectRatio', 'none');
      img.style.cursor = 'grab';
      bg.appendChild(img);

      // Optional: Add subtle grid overlay on top of image
      const graticule = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      graticule.setAttribute('stroke', 'rgba(0,0,0,0.1)');
      graticule.setAttribute('stroke-width', '0.5');
      graticule.setAttribute('fill', 'none');
      graticule.style.pointerEvents = 'none';

      // Use the current bounds for graticule
      const bounds = geoViewState.customMapBounds || geoViewState.mapBounds;

      for (let lon = -180; lon <= 180; lon += 30) {
        if (lon < bounds.minLon || lon > bounds.maxLon) continue;
        const p1 = gpsToCanvas(Math.min(85, bounds.maxLat), lon);
        const p2 = gpsToCanvas(Math.max(-85, bounds.minLat), lon);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', p1.x);
        line.setAttribute('y1', p1.y);
        line.setAttribute('x2', p2.x);
        line.setAttribute('y2', p2.y);
        graticule.appendChild(line);
      }

      for (let lat = -60; lat <= 90; lat += 30) {
        if (lat < bounds.minLat || lat > bounds.maxLat) continue;
        const p1 = gpsToCanvas(lat, bounds.minLon);
        const p2 = gpsToCanvas(lat, bounds.maxLon);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', p1.x);
        line.setAttribute('y1', p1.y);
        line.setAttribute('x2', p2.x);
        line.setAttribute('y2', p2.y);
        graticule.appendChild(line);
      }

      bg.appendChild(graticule);
      return bg;
    }

    // Default: Use SVG-drawn map
    // Ocean background
    const ocean = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    ocean.setAttribute('id', 'geoOcean');
    ocean.setAttribute('x', '0');
    ocean.setAttribute('y', '0');
    ocean.setAttribute('width', geoViewState.canvasWidth);
    ocean.setAttribute('height', geoViewState.canvasHeight);
    ocean.setAttribute('fill', '#e8f4fc');
    ocean.style.cursor = 'grab';
    bg.appendChild(ocean);

    // Graticule (grid lines)
    const graticule = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    graticule.setAttribute('stroke', '#d4e4ed');
    graticule.setAttribute('stroke-width', '0.5');
    graticule.setAttribute('fill', 'none');
    graticule.style.pointerEvents = 'none'; // Allow clicks to pass through to background

    const bounds = geoViewState.mapBounds;

    // Longitude lines (every 30 degrees)
    for (let lon = -180; lon <= 180; lon += 30) {
      const p1 = gpsToCanvas(Math.min(85, bounds.maxLat), lon);
      const p2 = gpsToCanvas(Math.max(-60, bounds.minLat), lon);
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', p1.x);
      line.setAttribute('y1', p1.y);
      line.setAttribute('x2', p2.x);
      line.setAttribute('y2', p2.y);
      graticule.appendChild(line);
    }

    // Latitude lines (every 30 degrees)
    for (let lat = -60; lat <= 90; lat += 30) {
      if (lat < bounds.minLat || lat > bounds.maxLat) continue;
      const p1 = gpsToCanvas(lat, -180);
      const p2 = gpsToCanvas(lat, 180);
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', p1.x);
      line.setAttribute('y1', p1.y);
      line.setAttribute('x2', p2.x);
      line.setAttribute('y2', p2.y);
      graticule.appendChild(line);
    }

    bg.appendChild(graticule);

    // Draw all landmasses
    const continents = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    continents.setAttribute('class', 'geo-continents');
    continents.setAttribute('fill', '#c8d0d8');
    continents.setAttribute('stroke', '#9aa5b0');
    continents.setAttribute('stroke-width', '0.75');
    continents.setAttribute('stroke-linejoin', 'round');
    continents.style.cursor = 'grab';

    // Draw each landmass
    Object.values(worldMapData).forEach(coords => {
      drawLandmass(continents, coords);
    });

    bg.appendChild(continents);

    // Equator line (special highlight)
    const eqP1 = gpsToCanvas(0, -180);
    const eqP2 = gpsToCanvas(0, 180);
    const equator = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    equator.setAttribute('x1', eqP1.x);
    equator.setAttribute('y1', eqP1.y);
    equator.setAttribute('x2', eqP2.x);
    equator.setAttribute('y2', eqP2.y);
    equator.setAttribute('stroke', '#a0aab5');
    equator.setAttribute('stroke-width', '1');
    equator.setAttribute('stroke-dasharray', '8,4');
    bg.appendChild(equator);

    // Coordinate labels
    const labels = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    labels.setAttribute('fill', '#6b7280');
    labels.setAttribute('font-size', '10');
    labels.setAttribute('font-family', 'sans-serif');

    // Longitude labels
    for (let lon = -180; lon <= 180; lon += 60) {
      const p = gpsToCanvas(-60, lon);
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', p.x);
      text.setAttribute('y', p.y + 15);
      text.setAttribute('text-anchor', 'middle');
      text.textContent = lon + 'Â°';
      labels.appendChild(text);
    }

    // Latitude labels
    for (let lat = -60; lat <= 60; lat += 30) {
      const p = gpsToCanvas(lat, -180);
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', p.x - 5);
      text.setAttribute('y', p.y + 4);
      text.setAttribute('text-anchor', 'end');
      text.textContent = lat + 'Â°';
      labels.appendChild(text);
    }

    bg.appendChild(labels);

    return bg;
  }

  // Helper to draw landmass polygon from [lat, lon] coordinates
  function drawLandmass(parent, coords) {
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    let d = '';
    coords.forEach((coord, i) => {
      const p = gpsToCanvas(coord[0], coord[1]);
      d += (i === 0 ? 'M' : 'L') + p.x.toFixed(1) + ',' + p.y.toFixed(1) + ' ';
    });
    d += 'Z';
    path.setAttribute('d', d);
    parent.appendChild(path);
  }

  // Render geographic view
  function renderGeoView() {
    svg.innerHTML = '';

    // Set canvas size for geo view
    svg.setAttribute('viewBox', `0 0 ${geoViewState.canvasWidth} ${geoViewState.canvasHeight}`);

    // Draw world map background
    svg.appendChild(drawGeoBackground());

    // Determine style mode
    const useCanvasStyles = geoStaticSimplified.styleMode === 'canvas';
    const simplifiedLink = geoStaticSimplified;
    const simplifiedNode = geoStaticSimplified;

    // Get nodes with GPS data AND that pass visibility filters
    const geoNodes = state.nodes.filter(n =>
      n.gpsLat !== null && n.gpsLat !== undefined &&
      n.gpsLon !== null && n.gpsLon !== undefined &&
      isNodeVisible(n)  // Apply tag/cable system/node/container filters
    );

    // Draw edges between geo nodes (only if edge is visible)
    state.edges.forEach(e => {
      // Apply edge visibility filter
      if (!isEdgeVisible(e)) return;

      const nodeA = findNode(e.a);
      const nodeB = findNode(e.b);

      // Only draw if both nodes have GPS data
      if (nodeA?.gpsLat != null && nodeA?.gpsLon != null &&
          nodeB?.gpsLat != null && nodeB?.gpsLon != null) {

        const posA = gpsToCanvas(nodeA.gpsLat, nodeA.gpsLon);
        const posB = gpsToCanvas(nodeB.gpsLat, nodeB.gpsLon);

        // Calculate offset for parallel edges between same nodes
        const minNodeId = Math.min(e.a, e.b);
        const maxNodeId = Math.max(e.a, e.b);

        // Find all parallel edges (same node pair) that will be drawn in geo view
        const parallelEdges = state.edges.filter(edge => {
          const edgeMinId = Math.min(edge.a, edge.b);
          const edgeMaxId = Math.max(edge.a, edge.b);
          if (edgeMinId !== minNodeId || edgeMaxId !== maxNodeId) return false;
          // Check visibility
          if (!isEdgeVisible(edge)) return false;
          // Check that both nodes have GPS data
          const nA = findNode(edge.a);
          const nB = findNode(edge.b);
          return nA?.gpsLat != null && nA?.gpsLon != null && nB?.gpsLat != null && nB?.gpsLon != null;
        });

        // Sort parallel edges by id for consistent ordering
        parallelEdges.sort((x, y) => x.id - y.id);

        const edgeIndex = parallelEdges.findIndex(edge => edge.id === e.id);
        const totalParallel = parallelEdges.length;

        // Calculate perpendicular offset - use fixed spacing like main canvas
        let offsetX = 0, offsetY = 0;
        if (totalParallel > 1) {
          const dx = posB.x - posA.x;
          const dy = posB.y - posA.y;
          const len = Math.sqrt(dx*dx + dy*dy) || 1;
          // Perpendicular unit vector
          const perpX = -dy / len;
          const perpY = dx / len;

          // Use fixed spacing like main canvas (10 pixels for geo view)
          const spacing = 10;
          const offsetAmount = (edgeIndex - (totalParallel - 1) / 2) * spacing;
          offsetX = perpX * offsetAmount;
          offsetY = perpY * offsetAmount;
        }

        // Apply offset to positions
        const x1 = posA.x + offsetX;
        const y1 = posA.y + offsetY;
        const x2 = posB.x + offsetX;
        const y2 = posB.y + offsetY;

        const isSel = (state.selected?.type === 'edge' && state.selected?.id === e.id) ||
                      state.selection.edges.has(e.id);

        // Determine edge color and width based on style mode
        let edgeColor, edgeWidth, edgeLineStyle;

        // Check for heat map color first (overrides all other colors)
        const heatMapColor = (typeof getHeatMapColor === 'function') ? getHeatMapColor(e) : null;

        if (heatMapColor) {
          // Heat map is active - use heat map color
          edgeColor = heatMapColor;
          edgeWidth = useCanvasStyles ? (e.strokeW || 2) : simplifiedLink.linkWidth;
          edgeLineStyle = useCanvasStyles ? (e.lineStyle || 'solid') : simplifiedLink.linkStyle;
        } else if (useCanvasStyles) {
          edgeColor = e.strokeColor || '#666666';
          edgeWidth = e.strokeW || 2;
          edgeLineStyle = e.lineStyle || 'solid';
        } else {
          edgeColor = simplifiedLink.linkColor;
          edgeWidth = simplifiedLink.linkWidth;
          edgeLineStyle = simplifiedLink.linkStyle;
        }

        // Draw selection glow FIRST (behind the edge) if selected
        if (isSel) {
          const glowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          glowLine.setAttribute('x1', x1);
          glowLine.setAttribute('y1', y1);
          glowLine.setAttribute('x2', x2);
          glowLine.setAttribute('y2', y2);
          glowLine.setAttribute('class', 'edge-selection-glow');
          glowLine.setAttribute('stroke-width', edgeWidth + 6);
          glowLine.style.pointerEvents = 'none'; // Allow clicks to pass through
          svg.appendChild(glowLine);
        }

        // Draw the visible edge
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke', edgeColor);
        line.setAttribute('stroke-width', edgeWidth);
        // Apply line style
        if (edgeLineStyle === 'dashed') {
          line.setAttribute('stroke-dasharray', `${edgeWidth * 3},${edgeWidth * 2}`);
        } else if (edgeLineStyle === 'dotted') {
          line.setAttribute('stroke-dasharray', `${edgeWidth},${edgeWidth * 2}`);
        }
        line.setAttribute('class', 'geo-edge edge' + (isSel ? ' selected' : ''));
        line.setAttribute('data-edge-id', e.id);
        line.style.pointerEvents = 'none'; // Disable clicks on visible edge, use hit area
        svg.appendChild(line);

        // Add invisible wide hit area for easier clicking (like main canvas)
        const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        hitArea.setAttribute('x1', x1);
        hitArea.setAttribute('y1', y1);
        hitArea.setAttribute('x2', x2);
        hitArea.setAttribute('y2', y2);
        hitArea.setAttribute('stroke', 'transparent');
        hitArea.setAttribute('stroke-width', 20); // Wide invisible hit area
        hitArea.style.cursor = 'pointer';
        hitArea.addEventListener('click', (ev) => {
          ev.stopPropagation();
          window._geoClickHandled = true; // Mark that a node/edge was clicked

          // Check if in Route Finder link exclusion mode
          if (typeof routeFinderState !== 'undefined' && routeFinderState.active && routeFinderState.pickMode === 'excludeLink') {
            addExcludedLink(e.id);
            routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }

          // Check if in Route Finder must-use link mode
          if (typeof routeFinderState !== 'undefined' && routeFinderState.active && routeFinderState.pickMode === 'mustUseLink') {
            addMustUseLink(e.id);
            routeFinderState.pickMode = null;
            updatePickModeButtons();
            return;
          }

          // Apply format painter if armed
          if (state.styleBrush && state.styleBrush.type === 'edge') {
            applyStyle('edge', e, state.styleBrush.style);
            commit();
            showToast(`ðŸŽ¨ Format applied to link: ${nodeA?.name || e.a} â†” ${nodeB?.name || e.b}`);
          } else {
            state.selected = { type: 'edge', id: e.id };
            state.selection.nodes.clear();
            state.selection.edges.clear();
            state.selection.groups.clear();
          }
          renderGeoView();
          updateInspector();
        });
        svg.appendChild(hitArea);

        // Draw latency label if enabled (use offset coordinates)
        if (state.showLatency !== false && e.latency) {
          const midX = (x1 + x2) / 2;
          const midY = (y1 + y2) / 2;
          const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          label.setAttribute('x', midX);
          label.setAttribute('y', midY - 5);
          label.setAttribute('text-anchor', 'middle');
          label.setAttribute('font-size', '10');
          label.setAttribute('fill', '#666');
          label.style.pointerEvents = 'none'; // Allow clicks to pass through to canvas
          label.textContent = e.latency + ' ms';
          svg.appendChild(label);
        }
      }
    });

    // Draw nodes
    geoNodes.forEach(n => {
      const pos = gpsToCanvas(n.gpsLat, n.gpsLon);

      // Determine node size based on style mode
      let r;
      if (useCanvasStyles) {
        r = Math.max(8, (n.r || 24) / 2); // Smaller nodes in geo view
      } else {
        r = simplifiedNode.nodeSize;
      }

      const isSel = (state.selected?.type === 'node' && state.selected?.id === n.id) ||
                    state.selection.nodes.has(n.id);
      const isLinkSource = window.linkMode && window.linkSourceNode === n.id;

      // Draw selection glow ring FIRST (behind the node) if selected and not in link mode
      if (isSel && !isLinkSource) {
        const glowCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        glowCircle.setAttribute('cx', pos.x);
        glowCircle.setAttribute('cy', pos.y);
        glowCircle.setAttribute('r', r + 4);
        glowCircle.setAttribute('class', 'node-selection-glow');
        glowCircle.style.pointerEvents = 'none';
        svg.appendChild(glowCircle);
      }

      // Node circle - determine colors based on style mode
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', pos.x);
      circle.setAttribute('cy', pos.y);
      circle.setAttribute('r', r);

      let fillColor, strokeColor, strokeWidth;
      if (useCanvasStyles) {
        fillColor = n.fill || '#dae8fc';
        strokeColor = n.stroke || '#6c8ebf';
        strokeWidth = n.strokeW || 2;
      } else {
        fillColor = simplifiedNode.nodeFill;
        strokeColor = simplifiedNode.nodeStroke;
        strokeWidth = 2;
      }

      circle.setAttribute('fill', fillColor);

      // Only change stroke for link source mode - selection uses glow overlay
      if (isLinkSource) {
        strokeColor = '#ff9800'; // Orange for link source
        strokeWidth = 4;
      }

      circle.setAttribute('stroke', strokeColor);
      circle.setAttribute('stroke-width', strokeWidth);
      circle.setAttribute('class', 'geo-node' + (isSel ? ' selected' : ''));
      circle.setAttribute('data-node-id', n.id);
      circle.style.cursor = 'pointer';

      // Apply filter effects
      if (isLinkSource) {
        circle.style.filter = 'drop-shadow(0 0 6px rgba(255,152,0,0.6))';
      } else if (isSel) {
        circle.style.filter = 'drop-shadow(0 0 6px rgba(0,150,214,0.8)) drop-shadow(0 0 10px rgba(0,150,214,0.5))';
      }

      circle.addEventListener('click', (ev) => {
        ev.stopPropagation();
        window._geoClickHandled = true; // Mark that a node/edge was clicked

        // Check if in Route Finder calculation mode
        if (typeof routeFinderState !== 'undefined' && routeFinderState.active) {
          handleCalculationModeNodeClick(n.id);
          return;
        }

        // Check if in link mode
        if (window.linkMode) {
          if (window.linkSourceNode === null) {
            // First click - set source node
            window.linkSourceNode = n.id;
            // Also update the local variable if accessible
            if (typeof linkSourceNode !== 'undefined') linkSourceNode = n.id;
            state.selected = { type: 'node', id: n.id };
            renderGeoView();
            updateInspector();
            showToast(`Link source: ${n.name || 'N' + n.id} â†’ Click target node`);
          } else {
            // Second click - create link
            if (window.linkSourceNode === n.id) {
              showToast('âŒ Cannot link node to itself');
              return;
            }
            const sourceId = window.linkSourceNode;
            window.linkSourceNode = null;
            if (typeof linkSourceNode !== 'undefined') linkSourceNode = null;
            createEdge(sourceId, n.id, true);
            state.selected = null;
            state.selection.nodes.clear();
            renderGeoView();
            updateInspector();
            showToast(`âœ“ Link created! Click next source node`);
          }
          return;
        }

        // Apply format painter if armed
        if (state.styleBrush && state.styleBrush.type === 'node') {
          applyStyle('node', n, state.styleBrush.style);
          commit();
          state.selected = { type: 'node', id: n.id };
          renderGeoView();
          updateInspector();
          showToast(`ðŸŽ¨ Format applied to: ${n.name || n.code || n.id}`);
          return;
        }

        if (ev.shiftKey) {
          if (state.selection.nodes.has(n.id)) {
            state.selection.nodes.delete(n.id);
          } else {
            state.selection.nodes.add(n.id);
          }
          state.selected = { type: 'node', id: n.id };
        } else {
          state.selected = { type: 'node', id: n.id };
          state.selection.nodes.clear();
          state.selection.edges.clear();
          state.selection.groups.clear();
        }
        renderGeoView();
        updateInspector();
      });

      svg.appendChild(circle);

      // Node label (code or name)
      const label = n.code || n.name;
      if (label) {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', pos.x);
        text.setAttribute('y', pos.y - r - 4);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', '11');
        text.setAttribute('font-weight', '600');
        text.setAttribute('fill', '#333');
        text.style.pointerEvents = 'none'; // Allow clicks to pass through to canvas
        text.textContent = label;
        svg.appendChild(text);
      }
    });

    // Info text
    const info = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    info.setAttribute('x', '10');
    info.setAttribute('y', geoViewState.canvasHeight - 10);
    info.setAttribute('font-size', '11');
    info.setAttribute('fill', '#666');
    info.style.pointerEvents = 'none'; // Allow clicks to pass through to canvas
    info.textContent = `ðŸŒ Geographic View â€” ${geoNodes.length} node(s) with GPS | Drag to pan â€¢ Space+drag anywhere â€¢ Scroll to zoom`;
    svg.appendChild(info);

    updateInspector();
  }

  // Global flag to track if a geo view node/edge click was handled
  window._geoClickHandled = false;

  // Toggle geographic view
  function toggleGeoView(active) {
    geoViewState.active = active;

    // Update menu radio buttons and options visibility
    const stdRadio = document.getElementById('viewModeStandard');
    const geoRadio = document.getElementById('viewModeGeo');
    const geoOptionsEl = document.getElementById('geoViewOptions');
    if (stdRadio) stdRadio.checked = !active;
    if (geoRadio) geoRadio.checked = active;
    if (geoOptionsEl) geoOptionsEl.style.display = active ? '' : 'none';

    // Update toolbar buttons with green active state
    const btnMain = document.getElementById('btnMainView');
    const btnGeoView = document.getElementById('btnGeoView');
    const btnMapLibre = document.getElementById('btnMapLibre');
    const activeColor = '#10b981';

    if (btnMain) {
      btnMain.classList.toggle('active', !active && !mapLibreState.active);
      btnMain.style.color = (!active && !mapLibreState.active) ? activeColor : '';
    }
    if (btnGeoView) {
      btnGeoView.classList.toggle('active', active);
      btnGeoView.style.color = active ? activeColor : '';
    }
    if (btnMapLibre) {
      // Don't change MapLibre here, it's handled separately
    }

    // Show/hide floating projection panel
    const projPanel = document.getElementById('projectionPanel');
    if (projPanel) {
      projPanel.style.display = active ? 'block' : 'none';
    }

    if (active) {
      // Switch label settings from canvas to geoStatic
      if (typeof switchViewLabelSettings === 'function') {
        switchViewLabelSettings('canvas', 'geoStatic');
      }

      // Save current canvas settings
      geoViewState.savedCanvasWidth = state.canvasWidth;
      geoViewState.savedCanvasHeight = state.canvasHeight;
      geoViewState.savedZoom = state.zoom;

      // Set geo view canvas
      state.zoom = 1;
      updateViewBox();

      renderGeoView();
      showToast('ðŸŒ Geo Static Background â€” showing nodes with GPS coordinates');
    } else {
      // Switch label settings back to canvas
      if (typeof switchViewLabelSettings === 'function') {
        switchViewLabelSettings('geoStatic', 'canvas');
      }

      // Restore canvas settings
      if (geoViewState.savedCanvasWidth) {
        state.canvasWidth = geoViewState.savedCanvasWidth;
        state.canvasHeight = geoViewState.savedCanvasHeight;
        state.zoom = geoViewState.savedZoom || 1;
      }
      updateViewBox();
      render();
      showToast('ðŸ“‹ Standard Canvas View');
    }

    // Re-render route finder highlights after view switch
    if (typeof routeFinderState !== 'undefined' && routeFinderState.active && routeFinderState.routes.length > 0) {
      setTimeout(() => highlightActiveRoute(), 100);
    }
  }

  // Override render when in geo view or MapLibre view
  const originalRenderFunc = render;
  const geoAwareRender = function() {
    // Check MapLibre first (it takes priority)
    if (window.mapLibreState && window.mapLibreState.active) {
      window.mapLibreState.skipFitBounds = true;
      if (typeof window.renderMapLibreContent === 'function') {
        window.renderMapLibreContent();
      }
    } else if (geoViewState.active) {
      renderGeoView();
    } else {
      originalRenderFunc();
    }
  };
  window.render = geoAwareRender;
  // Also reassign local render for direct calls
  render = geoAwareRender;

  // GPS format toggle event listener
  const nodeGpsFormat = document.getElementById('nodeGpsFormat');
  if (nodeGpsFormat) {
    nodeGpsFormat.addEventListener('change', () => {
      gpsDisplayFormat = nodeGpsFormat.value;
      if (state.selected?.type === 'node') {
        const n = findNode(state.selected.id);
        updateGpsFields(n);
      }
    });
  }

  // DD input listeners
  const nodeLatDD = document.getElementById('nodeLatDD');
  const nodeLonDD = document.getElementById('nodeLonDD');
  if (nodeLatDD) nodeLatDD.addEventListener('change', saveGpsFromDD);
  if (nodeLonDD) nodeLonDD.addEventListener('change', saveGpsFromDD);

  // DMS input listeners
  ['nodeLatDeg', 'nodeLatMin', 'nodeLatSec', 'nodeLatDir',
   'nodeLonDeg', 'nodeLonMin', 'nodeLonSec', 'nodeLonDir'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('change', saveGpsFromDMS);
  });

  // ============== LOCATION LOOKUP DATABASE ==============
  const locationDatabase = {
    // Major World Cities
    'new york': { lat: 40.7128, lon: -74.0060, name: 'New York, USA' },
    'nyc': { lat: 40.7128, lon: -74.0060, name: 'New York, USA' },
    'los angeles': { lat: 34.0522, lon: -118.2437, name: 'Los Angeles, USA' },
    'la': { lat: 34.0522, lon: -118.2437, name: 'Los Angeles, USA' },
    'chicago': { lat: 41.8781, lon: -87.6298, name: 'Chicago, USA' },
    'houston': { lat: 29.7604, lon: -95.3698, name: 'Houston, USA' },
    'phoenix': { lat: 33.4484, lon: -112.0740, name: 'Phoenix, USA' },
    'philadelphia': { lat: 39.9526, lon: -75.1652, name: 'Philadelphia, USA' },
    'san antonio': { lat: 29.4241, lon: -98.4936, name: 'San Antonio, USA' },
    'san diego': { lat: 32.7157, lon: -117.1611, name: 'San Diego, USA' },
    'dallas': { lat: 32.7767, lon: -96.7970, name: 'Dallas, USA' },
    'san jose': { lat: 37.3382, lon: -121.8863, name: 'San Jose, USA' },
    'austin': { lat: 30.2672, lon: -97.7431, name: 'Austin, USA' },
    'san francisco': { lat: 37.7749, lon: -122.4194, name: 'San Francisco, USA' },
    'seattle': { lat: 47.6062, lon: -122.3321, name: 'Seattle, USA' },
    'denver': { lat: 39.7392, lon: -104.9903, name: 'Denver, USA' },
    'washington': { lat: 38.9072, lon: -77.0369, name: 'Washington DC, USA' },
    'washington dc': { lat: 38.9072, lon: -77.0369, name: 'Washington DC, USA' },
    'boston': { lat: 42.3601, lon: -71.0589, name: 'Boston, USA' },
    'miami': { lat: 25.7617, lon: -80.1918, name: 'Miami, USA' },
    'atlanta': { lat: 33.7490, lon: -84.3880, name: 'Atlanta, USA' },
    'detroit': { lat: 42.3314, lon: -83.0458, name: 'Detroit, USA' },
    'minneapolis': { lat: 44.9778, lon: -93.2650, name: 'Minneapolis, USA' },
    'portland': { lat: 45.5152, lon: -122.6784, name: 'Portland, USA' },
    'las vegas': { lat: 36.1699, lon: -115.1398, name: 'Las Vegas, USA' },
    'ashburn': { lat: 39.0438, lon: -77.4874, name: 'Ashburn, Virginia, USA' },
    'silicon valley': { lat: 37.3875, lon: -122.0575, name: 'Silicon Valley, USA' },

    // Canada
    'toronto': { lat: 43.6532, lon: -79.3832, name: 'Toronto, Canada' },
    'vancouver': { lat: 49.2827, lon: -123.1207, name: 'Vancouver, Canada' },
    'montreal': { lat: 45.5017, lon: -73.5673, name: 'Montreal, Canada' },
    'calgary': { lat: 51.0447, lon: -114.0719, name: 'Calgary, Canada' },
    'ottawa': { lat: 45.4215, lon: -75.6972, name: 'Ottawa, Canada' },

    // Mexico & Central America
    'mexico city': { lat: 19.4326, lon: -99.1332, name: 'Mexico City, Mexico' },
    'guadalajara': { lat: 20.6597, lon: -103.3496, name: 'Guadalajara, Mexico' },
    'monterrey': { lat: 25.6866, lon: -100.3161, name: 'Monterrey, Mexico' },
    'panama city': { lat: 8.9824, lon: -79.5199, name: 'Panama City, Panama' },

    // South America
    'sao paulo': { lat: -23.5505, lon: -46.6333, name: 'SÃ£o Paulo, Brazil' },
    'sÃ£o paulo': { lat: -23.5505, lon: -46.6333, name: 'SÃ£o Paulo, Brazil' },
    'rio de janeiro': { lat: -22.9068, lon: -43.1729, name: 'Rio de Janeiro, Brazil' },
    'rio': { lat: -22.9068, lon: -43.1729, name: 'Rio de Janeiro, Brazil' },
    'buenos aires': { lat: -34.6037, lon: -58.3816, name: 'Buenos Aires, Argentina' },
    'bogota': { lat: 4.7110, lon: -74.0721, name: 'BogotÃ¡, Colombia' },
    'bogotÃ¡': { lat: 4.7110, lon: -74.0721, name: 'BogotÃ¡, Colombia' },
    'lima': { lat: -12.0464, lon: -77.0428, name: 'Lima, Peru' },
    'santiago': { lat: -33.4489, lon: -70.6693, name: 'Santiago, Chile' },
    'caracas': { lat: 10.4806, lon: -66.9036, name: 'Caracas, Venezuela' },
    'quito': { lat: -0.1807, lon: -78.4678, name: 'Quito, Ecuador' },
    'fortaleza': { lat: -3.7172, lon: -38.5433, name: 'Fortaleza, Brazil' },

    // UK & Ireland
    'london': { lat: 51.5074, lon: -0.1278, name: 'London, UK' },
    'manchester': { lat: 53.4808, lon: -2.2426, name: 'Manchester, UK' },
    'birmingham': { lat: 52.4862, lon: -1.8904, name: 'Birmingham, UK' },
    'glasgow': { lat: 55.8642, lon: -4.2518, name: 'Glasgow, UK' },
    'edinburgh': { lat: 55.9533, lon: -3.1883, name: 'Edinburgh, UK' },
    'dublin': { lat: 53.3498, lon: -6.2603, name: 'Dublin, Ireland' },
    'belfast': { lat: 54.5973, lon: -5.9301, name: 'Belfast, UK' },
    'slough': { lat: 51.5105, lon: -0.5950, name: 'Slough, UK' },

    // Western Europe
    'paris': { lat: 48.8566, lon: 2.3522, name: 'Paris, France' },
    'marseille': { lat: 43.2965, lon: 5.3698, name: 'Marseille, France' },
    'lyon': { lat: 45.7640, lon: 4.8357, name: 'Lyon, France' },
    'amsterdam': { lat: 52.3676, lon: 4.9041, name: 'Amsterdam, Netherlands' },
    'rotterdam': { lat: 51.9244, lon: 4.4777, name: 'Rotterdam, Netherlands' },
    'brussels': { lat: 50.8503, lon: 4.3517, name: 'Brussels, Belgium' },
    'luxembourg': { lat: 49.6116, lon: 6.1319, name: 'Luxembourg' },

    // Germany
    'berlin': { lat: 52.5200, lon: 13.4050, name: 'Berlin, Germany' },
    'munich': { lat: 48.1351, lon: 11.5820, name: 'Munich, Germany' },
    'frankfurt': { lat: 50.1109, lon: 8.6821, name: 'Frankfurt, Germany' },
    'hamburg': { lat: 53.5511, lon: 9.9937, name: 'Hamburg, Germany' },
    'cologne': { lat: 50.9375, lon: 6.9603, name: 'Cologne, Germany' },
    'dÃ¼sseldorf': { lat: 51.2277, lon: 6.7735, name: 'DÃ¼sseldorf, Germany' },
    'dusseldorf': { lat: 51.2277, lon: 6.7735, name: 'DÃ¼sseldorf, Germany' },
    'stuttgart': { lat: 48.7758, lon: 9.1829, name: 'Stuttgart, Germany' },

    // Iberian Peninsula
    'madrid': { lat: 40.4168, lon: -3.7038, name: 'Madrid, Spain' },
    'barcelona': { lat: 41.3851, lon: 2.1734, name: 'Barcelona, Spain' },
    'valencia': { lat: 39.4699, lon: -0.3763, name: 'Valencia, Spain' },
    'seville': { lat: 37.3891, lon: -5.9845, name: 'Seville, Spain' },
    'sevilla': { lat: 37.3891, lon: -5.9845, name: 'Seville, Spain' },
    'bilbao': { lat: 43.2630, lon: -2.9350, name: 'Bilbao, Spain' },
    'malaga': { lat: 36.7213, lon: -4.4214, name: 'Malaga, Spain' },
    'lisbon': { lat: 38.7223, lon: -9.1393, name: 'Lisbon, Portugal' },
    'porto': { lat: 41.1579, lon: -8.6291, name: 'Porto, Portugal' },

    // Italy
    'rome': { lat: 41.9028, lon: 12.4964, name: 'Rome, Italy' },
    'roma': { lat: 41.9028, lon: 12.4964, name: 'Rome, Italy' },
    'milan': { lat: 45.4642, lon: 9.1900, name: 'Milan, Italy' },
    'milano': { lat: 45.4642, lon: 9.1900, name: 'Milan, Italy' },
    'naples': { lat: 40.8518, lon: 14.2681, name: 'Naples, Italy' },
    'turin': { lat: 45.0703, lon: 7.6869, name: 'Turin, Italy' },
    'florence': { lat: 43.7696, lon: 11.2558, name: 'Florence, Italy' },
    'venice': { lat: 45.4408, lon: 12.3155, name: 'Venice, Italy' },

    // Scandinavia & Nordic
    'stockholm': { lat: 59.3293, lon: 18.0686, name: 'Stockholm, Sweden' },
    'oslo': { lat: 59.9139, lon: 10.7522, name: 'Oslo, Norway' },
    'copenhagen': { lat: 55.6761, lon: 12.5683, name: 'Copenhagen, Denmark' },
    'helsinki': { lat: 60.1699, lon: 24.9384, name: 'Helsinki, Finland' },
    'reykjavik': { lat: 64.1466, lon: -21.9426, name: 'Reykjavik, Iceland' },

    // Central & Eastern Europe
    'vienna': { lat: 48.2082, lon: 16.3738, name: 'Vienna, Austria' },
    'zurich': { lat: 47.3769, lon: 8.5417, name: 'Zurich, Switzerland' },
    'geneva': { lat: 46.2044, lon: 6.1432, name: 'Geneva, Switzerland' },
    'prague': { lat: 50.0755, lon: 14.4378, name: 'Prague, Czech Republic' },
    'warsaw': { lat: 52.2297, lon: 21.0122, name: 'Warsaw, Poland' },
    'krakow': { lat: 50.0647, lon: 19.9450, name: 'Krakow, Poland' },
    'budapest': { lat: 47.4979, lon: 19.0402, name: 'Budapest, Hungary' },
    'bucharest': { lat: 44.4268, lon: 26.1025, name: 'Bucharest, Romania' },
    'sofia': { lat: 42.6977, lon: 23.3219, name: 'Sofia, Bulgaria' },
    'athens': { lat: 37.9838, lon: 23.7275, name: 'Athens, Greece' },

    // Russia & CIS
    'moscow': { lat: 55.7558, lon: 37.6173, name: 'Moscow, Russia' },
    'st petersburg': { lat: 59.9311, lon: 30.3609, name: 'St Petersburg, Russia' },
    'saint petersburg': { lat: 59.9311, lon: 30.3609, name: 'St Petersburg, Russia' },
    'kiev': { lat: 50.4501, lon: 30.5234, name: 'Kyiv, Ukraine' },
    'kyiv': { lat: 50.4501, lon: 30.5234, name: 'Kyiv, Ukraine' },

    // Middle East
    'dubai': { lat: 25.2048, lon: 55.2708, name: 'Dubai, UAE' },
    'abu dhabi': { lat: 24.4539, lon: 54.3773, name: 'Abu Dhabi, UAE' },
    'doha': { lat: 25.2854, lon: 51.5310, name: 'Doha, Qatar' },
    'riyadh': { lat: 24.7136, lon: 46.6753, name: 'Riyadh, Saudi Arabia' },
    'jeddah': { lat: 21.5433, lon: 39.1728, name: 'Jeddah, Saudi Arabia' },
    'tel aviv': { lat: 32.0853, lon: 34.7818, name: 'Tel Aviv, Israel' },
    'jerusalem': { lat: 31.7683, lon: 35.2137, name: 'Jerusalem, Israel' },
    'amman': { lat: 31.9454, lon: 35.9284, name: 'Amman, Jordan' },
    'beirut': { lat: 33.8938, lon: 35.5018, name: 'Beirut, Lebanon' },
    'istanbul': { lat: 41.0082, lon: 28.9784, name: 'Istanbul, Turkey' },
    'ankara': { lat: 39.9334, lon: 32.8597, name: 'Ankara, Turkey' },
    'tehran': { lat: 35.6892, lon: 51.3890, name: 'Tehran, Iran' },
    'baghdad': { lat: 33.3152, lon: 44.3661, name: 'Baghdad, Iraq' },
    'muscat': { lat: 23.5880, lon: 58.3829, name: 'Muscat, Oman' },
    'manama': { lat: 26.2285, lon: 50.5860, name: 'Manama, Bahrain' },
    'kuwait city': { lat: 29.3759, lon: 47.9774, name: 'Kuwait City, Kuwait' },

    // South Asia
    'mumbai': { lat: 19.0760, lon: 72.8777, name: 'Mumbai, India' },
    'bombay': { lat: 19.0760, lon: 72.8777, name: 'Mumbai, India' },
    'delhi': { lat: 28.7041, lon: 77.1025, name: 'Delhi, India' },
    'new delhi': { lat: 28.6139, lon: 77.2090, name: 'New Delhi, India' },
    'bangalore': { lat: 12.9716, lon: 77.5946, name: 'Bangalore, India' },
    'bengaluru': { lat: 12.9716, lon: 77.5946, name: 'Bangalore, India' },
    'chennai': { lat: 13.0827, lon: 80.2707, name: 'Chennai, India' },
    'hyderabad': { lat: 17.3850, lon: 78.4867, name: 'Hyderabad, India' },
    'kolkata': { lat: 22.5726, lon: 88.3639, name: 'Kolkata, India' },
    'calcutta': { lat: 22.5726, lon: 88.3639, name: 'Kolkata, India' },
    'pune': { lat: 18.5204, lon: 73.8567, name: 'Pune, India' },
    'ahmedabad': { lat: 23.0225, lon: 72.5714, name: 'Ahmedabad, India' },
    'karachi': { lat: 24.8607, lon: 67.0011, name: 'Karachi, Pakistan' },
    'lahore': { lat: 31.5204, lon: 74.3587, name: 'Lahore, Pakistan' },
    'islamabad': { lat: 33.6844, lon: 73.0479, name: 'Islamabad, Pakistan' },
    'dhaka': { lat: 23.8103, lon: 90.4125, name: 'Dhaka, Bangladesh' },
    'colombo': { lat: 6.9271, lon: 79.8612, name: 'Colombo, Sri Lanka' },

    // East Asia
    'tokyo': { lat: 35.6762, lon: 139.6503, name: 'Tokyo, Japan' },
    'osaka': { lat: 34.6937, lon: 135.5023, name: 'Osaka, Japan' },
    'yokohama': { lat: 35.4437, lon: 139.6380, name: 'Yokohama, Japan' },
    'nagoya': { lat: 35.1815, lon: 136.9066, name: 'Nagoya, Japan' },
    'fukuoka': { lat: 33.5904, lon: 130.4017, name: 'Fukuoka, Japan' },
    'seoul': { lat: 37.5665, lon: 126.9780, name: 'Seoul, South Korea' },
    'busan': { lat: 35.1796, lon: 129.0756, name: 'Busan, South Korea' },
    'beijing': { lat: 39.9042, lon: 116.4074, name: 'Beijing, China' },
    'shanghai': { lat: 31.2304, lon: 121.4737, name: 'Shanghai, China' },
    'guangzhou': { lat: 23.1291, lon: 113.2644, name: 'Guangzhou, China' },
    'shenzhen': { lat: 22.5431, lon: 114.0579, name: 'Shenzhen, China' },
    'hong kong': { lat: 22.3193, lon: 114.1694, name: 'Hong Kong' },
    'taipei': { lat: 25.0330, lon: 121.5654, name: 'Taipei, Taiwan' },
    'kaohsiung': { lat: 22.6273, lon: 120.3014, name: 'Kaohsiung, Taiwan' },

    // Southeast Asia
    'singapore': { lat: 1.3521, lon: 103.8198, name: 'Singapore' },
    'kuala lumpur': { lat: 3.1390, lon: 101.6869, name: 'Kuala Lumpur, Malaysia' },
    'kl': { lat: 3.1390, lon: 101.6869, name: 'Kuala Lumpur, Malaysia' },
    'bangkok': { lat: 13.7563, lon: 100.5018, name: 'Bangkok, Thailand' },
    'jakarta': { lat: -6.2088, lon: 106.8456, name: 'Jakarta, Indonesia' },
    'surabaya': { lat: -7.2575, lon: 112.7521, name: 'Surabaya, Indonesia' },
    'manila': { lat: 14.5995, lon: 120.9842, name: 'Manila, Philippines' },
    'ho chi minh': { lat: 10.8231, lon: 106.6297, name: 'Ho Chi Minh City, Vietnam' },
    'ho chi minh city': { lat: 10.8231, lon: 106.6297, name: 'Ho Chi Minh City, Vietnam' },
    'saigon': { lat: 10.8231, lon: 106.6297, name: 'Ho Chi Minh City, Vietnam' },
    'hanoi': { lat: 21.0278, lon: 105.8342, name: 'Hanoi, Vietnam' },
    'phnom penh': { lat: 11.5564, lon: 104.9282, name: 'Phnom Penh, Cambodia' },

    // Australia & Oceania
    'sydney': { lat: -33.8688, lon: 151.2093, name: 'Sydney, Australia' },
    'melbourne': { lat: -37.8136, lon: 144.9631, name: 'Melbourne, Australia' },
    'brisbane': { lat: -27.4698, lon: 153.0251, name: 'Brisbane, Australia' },
    'perth': { lat: -31.9505, lon: 115.8605, name: 'Perth, Australia' },
    'adelaide': { lat: -34.9285, lon: 138.6007, name: 'Adelaide, Australia' },
    'auckland': { lat: -36.8485, lon: 174.7633, name: 'Auckland, New Zealand' },
    'wellington': { lat: -41.2866, lon: 174.7756, name: 'Wellington, New Zealand' },

    // Africa
    'cairo': { lat: 30.0444, lon: 31.2357, name: 'Cairo, Egypt' },
    'alexandria': { lat: 31.2001, lon: 29.9187, name: 'Alexandria, Egypt' },
    'johannesburg': { lat: -26.2041, lon: 28.0473, name: 'Johannesburg, South Africa' },
    'cape town': { lat: -33.9249, lon: 18.4241, name: 'Cape Town, South Africa' },
    'durban': { lat: -29.8587, lon: 31.0218, name: 'Durban, South Africa' },
    'lagos': { lat: 6.5244, lon: 3.3792, name: 'Lagos, Nigeria' },
    'nairobi': { lat: -1.2921, lon: 36.8219, name: 'Nairobi, Kenya' },
    'mombasa': { lat: -4.0435, lon: 39.6682, name: 'Mombasa, Kenya' },
    'casablanca': { lat: 33.5731, lon: -7.5898, name: 'Casablanca, Morocco' },
    'tunis': { lat: 36.8065, lon: 10.1815, name: 'Tunis, Tunisia' },
    'algiers': { lat: 36.7538, lon: 3.0588, name: 'Algiers, Algeria' },
    'accra': { lat: 5.6037, lon: -0.1870, name: 'Accra, Ghana' },
    'addis ababa': { lat: 9.0320, lon: 38.7469, name: 'Addis Ababa, Ethiopia' },
    'dar es salaam': { lat: -6.7924, lon: 39.2083, name: 'Dar es Salaam, Tanzania' },
    'djibouti': { lat: 11.5886, lon: 43.1456, name: 'Djibouti' },

    // Countries (capital/center coordinates)
    'usa': { lat: 39.8283, lon: -98.5795, name: 'United States (center)' },
    'united states': { lat: 39.8283, lon: -98.5795, name: 'United States (center)' },
    'canada': { lat: 56.1304, lon: -106.3468, name: 'Canada (center)' },
    'mexico': { lat: 23.6345, lon: -102.5528, name: 'Mexico (center)' },
    'brazil': { lat: -14.2350, lon: -51.9253, name: 'Brazil (center)' },
    'argentina': { lat: -38.4161, lon: -63.6167, name: 'Argentina (center)' },
    'uk': { lat: 55.3781, lon: -3.4360, name: 'United Kingdom (center)' },
    'united kingdom': { lat: 55.3781, lon: -3.4360, name: 'United Kingdom (center)' },
    'france': { lat: 46.2276, lon: 2.2137, name: 'France (center)' },
    'germany': { lat: 51.1657, lon: 10.4515, name: 'Germany (center)' },
    'spain': { lat: 40.4637, lon: -3.7492, name: 'Spain (center)' },
    'italy': { lat: 41.8719, lon: 12.5674, name: 'Italy (center)' },
    'netherlands': { lat: 52.1326, lon: 5.2913, name: 'Netherlands (center)' },
    'belgium': { lat: 50.5039, lon: 4.4699, name: 'Belgium (center)' },
    'switzerland': { lat: 46.8182, lon: 8.2275, name: 'Switzerland (center)' },
    'austria': { lat: 47.5162, lon: 14.5501, name: 'Austria (center)' },
    'poland': { lat: 51.9194, lon: 19.1451, name: 'Poland (center)' },
    'sweden': { lat: 60.1282, lon: 18.6435, name: 'Sweden (center)' },
    'norway': { lat: 60.4720, lon: 8.4689, name: 'Norway (center)' },
    'denmark': { lat: 56.2639, lon: 9.5018, name: 'Denmark (center)' },
    'finland': { lat: 61.9241, lon: 25.7482, name: 'Finland (center)' },
    'russia': { lat: 61.5240, lon: 105.3188, name: 'Russia (center)' },
    'china': { lat: 35.8617, lon: 104.1954, name: 'China (center)' },
    'japan': { lat: 36.2048, lon: 138.2529, name: 'Japan (center)' },
    'south korea': { lat: 35.9078, lon: 127.7669, name: 'South Korea (center)' },
    'korea': { lat: 35.9078, lon: 127.7669, name: 'South Korea (center)' },
    'india': { lat: 20.5937, lon: 78.9629, name: 'India (center)' },
    'australia': { lat: -25.2744, lon: 133.7751, name: 'Australia (center)' },
    'new zealand': { lat: -40.9006, lon: 174.8860, name: 'New Zealand (center)' },
    'south africa': { lat: -30.5595, lon: 22.9375, name: 'South Africa (center)' },
    'egypt': { lat: 26.8206, lon: 30.8025, name: 'Egypt (center)' },
    'nigeria': { lat: 9.0820, lon: 8.6753, name: 'Nigeria (center)' },
    'kenya': { lat: -0.0236, lon: 37.9062, name: 'Kenya (center)' },
    'uae': { lat: 23.4241, lon: 53.8478, name: 'UAE (center)' },
    'saudi arabia': { lat: 23.8859, lon: 45.0792, name: 'Saudi Arabia (center)' },
    'israel': { lat: 31.0461, lon: 34.8516, name: 'Israel (center)' },
    'turkey': { lat: 38.9637, lon: 35.2433, name: 'Turkey (center)' },
    'greece': { lat: 39.0742, lon: 21.8243, name: 'Greece (center)' },
    'portugal': { lat: 39.3999, lon: -8.2245, name: 'Portugal (center)' },
    'ireland': { lat: 53.1424, lon: -7.6921, name: 'Ireland (center)' },
    'taiwan': { lat: 23.6978, lon: 120.9605, name: 'Taiwan (center)' },
    'malaysia': { lat: 4.2105, lon: 101.9758, name: 'Malaysia (center)' },
    'thailand': { lat: 15.8700, lon: 100.9925, name: 'Thailand (center)' },
    'indonesia': { lat: -0.7893, lon: 113.9213, name: 'Indonesia (center)' },
    'philippines': { lat: 12.8797, lon: 121.7740, name: 'Philippines (center)' },
    'vietnam': { lat: 14.0583, lon: 108.2772, name: 'Vietnam (center)' }
  };

  // Location lookup dialog
  function showLocationLookupDialog() {
    if (state.selected?.type !== 'node') {
      showToast('âš ï¸ Please select a node first');
      return;
    }

    const modal = document.createElement('div');
    modal.id = 'locationLookupModal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); z-index: 10000;
      display: flex; align-items: center; justify-content: center;
    `;

    modal.innerHTML = `
      <div style="background: white; border-radius: 12px; padding: 24px; max-width: 500px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
        <h3 style="margin: 0 0 16px; color:#0369a1;">ðŸ™ï¸ Lookup GPS by Location</h3>
        <p style="color: #666; font-size: 13px; margin-bottom: 16px;">
          Enter a city name, region, or country to get approximate GPS coordinates.
        </p>

        <div style="margin-bottom: 16px;">
          <label style="font-size: 11px; font-weight: 600; color: #555; display:block; margin-bottom:4px;">City, Region, or Country</label>
          <input type="text" id="locationSearchInput" placeholder="e.g. Madrid, London, Singapore, Germany..."
                 style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; box-sizing: border-box;"
                 autocomplete="off" />
        </div>

        <div id="locationSearchResults" style="max-height: 200px; overflow-y: auto; margin-bottom: 16px; border: 1px solid #e0e0e0; border-radius: 6px; display: none;">
        </div>

        <div id="locationSelected" style="display: none; background: #f0f9ff; padding: 12px; border-radius: 6px; margin-bottom: 16px;">
          <div style="font-weight: 600; color: #0369a1;" id="selectedLocationName"></div>
          <div style="font-size: 12px; color: #666; font-family: monospace;" id="selectedLocationCoords"></div>
        </div>

        <div style="font-size: 11px; color: #888; margin-bottom: 16px; background: #fef3c7; padding: 8px; border-radius: 4px;">
          ðŸ’¡ <strong>Tip:</strong> Start typing and matching locations will appear. Click to select, then click "Apply".
        </div>

        <div style="display: flex; gap: 12px; justify-content: flex-end;">
          <button id="locationLookupCancel" style="padding: 10px 20px; border: 1px solid #ddd; background: #f5f5f5; border-radius: 6px; cursor: pointer;">Cancel</button>
          <button id="locationLookupApply" style="padding: 10px 20px; border: none; background: #0369a1; color: white; border-radius: 6px; cursor: pointer; font-weight: 600;" disabled>Apply Coordinates</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    const searchInput = document.getElementById('locationSearchInput');
    const resultsDiv = document.getElementById('locationSearchResults');
    const selectedDiv = document.getElementById('locationSelected');
    const selectedName = document.getElementById('selectedLocationName');
    const selectedCoords = document.getElementById('selectedLocationCoords');
    const applyBtn = document.getElementById('locationLookupApply');

    let selectedLocation = null;

    // Search as user types
    searchInput.addEventListener('input', () => {
      const query = searchInput.value.toLowerCase().trim();

      if (query.length < 2) {
        resultsDiv.style.display = 'none';
        return;
      }

      const matches = [];
      for (const [key, loc] of Object.entries(locationDatabase)) {
        if (key.includes(query) || loc.name.toLowerCase().includes(query)) {
          matches.push({ key, ...loc });
        }
      }

      if (matches.length === 0) {
        resultsDiv.innerHTML = '<div style="padding: 12px; color: #888; text-align: center;">No locations found. Try a different search.</div>';
        resultsDiv.style.display = 'block';
        return;
      }

      // Limit results and sort by relevance
      const sorted = matches
        .sort((a, b) => {
          // Exact matches first
          if (a.key === query) return -1;
          if (b.key === query) return 1;
          // Then starts with
          if (a.key.startsWith(query) && !b.key.startsWith(query)) return -1;
          if (b.key.startsWith(query) && !a.key.startsWith(query)) return 1;
          return a.name.localeCompare(b.name);
        })
        .slice(0, 15);

      resultsDiv.innerHTML = sorted.map(loc => `
        <div class="location-result" data-lat="${loc.lat}" data-lon="${loc.lon}" data-name="${loc.name}"
             style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.1s;">
          <div style="font-weight: 500;">${loc.name}</div>
          <div style="font-size: 11px; color: #888; font-family: monospace;">${loc.lat.toFixed(4)}Â°, ${loc.lon.toFixed(4)}Â°</div>
        </div>
      `).join('');

      resultsDiv.style.display = 'block';

      // Add hover effect
      resultsDiv.querySelectorAll('.location-result').forEach(el => {
        el.addEventListener('mouseenter', () => el.style.background = '#f0f9ff');
        el.addEventListener('mouseleave', () => el.style.background = '');
        el.addEventListener('click', () => {
          selectedLocation = {
            lat: parseFloat(el.dataset.lat),
            lon: parseFloat(el.dataset.lon),
            name: el.dataset.name
          };
          selectedName.textContent = selectedLocation.name;
          selectedCoords.textContent = `Lat: ${selectedLocation.lat.toFixed(4)}Â°  Lon: ${selectedLocation.lon.toFixed(4)}Â°`;
          selectedDiv.style.display = 'block';
          resultsDiv.style.display = 'none';
          searchInput.value = selectedLocation.name;
          applyBtn.disabled = false;
          applyBtn.style.background = '#0369a1';
        });
      });
    });

    // Cancel button
    document.getElementById('locationLookupCancel').onclick = () => modal.remove();

    // Apply button
    applyBtn.onclick = () => {
      if (!selectedLocation) return;

      const node = findNode(state.selected.id);
      if (!node) return;

      node.gpsLat = selectedLocation.lat;
      node.gpsLon = selectedLocation.lon;

      updateGpsFields(node);
      commit();
      render();
      modal.remove();
      showToast(`ðŸ“ GPS set to ${selectedLocation.name}`);
    };

    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });

    // Focus input
    setTimeout(() => searchInput.focus(), 100);
  }

  // Geocode GPS from address via Nominatim API (Cloudflare Worker proxy)
  const GEOCODING_API = 'https://gpsgeolocationfromaddress.fcoroyse-spam.workers.dev';

  async function useAddressForGps() {
    if (state.selected?.type !== 'node') {
      showToast('âš ï¸ Please select a node first');
      return;
    }

    const node = findNode(state.selected.id);
    if (!node) return;

    // Collect all address fields
    const street = (node.address || '').trim();
    const city = (node.city || '').trim();
    const county = (node.county || '').trim();
    const stateVal = (node.state || '').trim();
    const postalcode = (node.postalCode || '').trim();
    const country = (node.country || '').trim();

    // Need at least one field
    if (!street && !city && !country && !postalcode) {
      showToast('âš ï¸ Please fill in at least an address, city, or country.');
      return;
    }

    // Build query params - use structured search for best accuracy
    const params = new URLSearchParams();
    if (street) params.set('street', street);
    if (city) params.set('city', city);
    if (county) params.set('county', county);
    if (stateVal) params.set('state', stateVal);
    if (postalcode) params.set('postalcode', postalcode);
    if (country) params.set('country', country);

    // If only address is filled (no city/country), use free-form query instead
    const hasStructuredFields = city || country || postalcode || stateVal;
    if (!hasStructuredFields && street) {
      params.delete('street');
      params.set('q', street);
    }

    const btn = document.getElementById('btnUseAddress');
    const originalText = btn ? btn.innerHTML : '';
    if (btn) { btn.innerHTML = 'â³ Geocoding...'; btn.disabled = true; }

    try {
      const response = await fetch(`${GEOCODING_API}?${params}`);
      if (!response.ok) throw new Error(`API error: ${response.status}`);
      const results = await response.json();

      if (!results || results.length === 0) {
        // Fallback to offline locationDatabase
        const fallback = offlineGeocodeFallback(node);
        if (fallback) {
          showToast(`ðŸ“ GPS approximated (offline): ${fallback.name}`);
        } else {
          showToast('âš ï¸ No results found. Try adding more address details (city, country, postal code).');
        }
        return;
      }

      if (results.length === 1) {
        // Single result - apply directly
        applyGeocodingResult(node, results[0]);
      } else {
        // Multiple results - show picker
        showGeocodingResultsPicker(node, results);
      }
    } catch (err) {
      console.error('[Geocoding] API error:', err);
      // Fallback to offline
      const fallback = offlineGeocodeFallback(node);
      if (fallback) {
        showToast(`ðŸ“ GPS approximated (offline fallback): ${fallback.name}`);
      } else {
        showToast('âš ï¸ Geocoding service unavailable. Check your connection.');
      }
    } finally {
      if (btn) { btn.innerHTML = originalText; btn.disabled = false; }
    }
  }

  function applyGeocodingResult(node, result) {
    const lat = parseFloat(result.lat);
    const lon = parseFloat(result.lon);
    if (isNaN(lat) || isNaN(lon)) {
      showToast('âš ï¸ Invalid coordinates in result.');
      return;
    }
    node.gpsLat = lat;
    node.gpsLon = lon;

    // Auto-fill empty address fields from result's address details
    const addr = result.address || {};
    if (!node.city && (addr.city || addr.town || addr.village)) {
      node.city = addr.city || addr.town || addr.village;
      if (nodeCity) nodeCity.value = node.city;
    }
    if (!node.country && addr.country) {
      node.country = addr.country;
      if (nodeCountry) nodeCountry.value = node.country;
    }
    if (!node.state && addr.state) {
      node.state = addr.state;
      if (nodeState) nodeState.value = node.state;
    }
    if (!node.county && addr.county) {
      node.county = addr.county;
      if (nodeCounty) nodeCounty.value = node.county;
    }
    if (!node.postalCode && addr.postcode) {
      node.postalCode = addr.postcode;
      if (nodePostalCode) nodePostalCode.value = node.postalCode;
    }

    updateGpsFields(node);
    commit();
    render();

    const displayName = result.display_name || `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
    const truncated = displayName.length > 80 ? displayName.substring(0, 77) + '...' : displayName;
    showToast(`ðŸ“ GPS from address: ${truncated}`);
  }

  function offlineGeocodeFallback(node) {
    const searchTerms = [node.address, node.city, node.county, node.state, node.country]
      .filter(Boolean).join(' ').toLowerCase();
    if (!searchTerms) return null;

    let bestMatch = null;
    let bestMatchLength = 0;
    for (const [key, loc] of Object.entries(locationDatabase)) {
      if (searchTerms.includes(key) && key.length > bestMatchLength) {
        bestMatch = { key, ...loc };
        bestMatchLength = key.length;
      }
    }
    if (bestMatch) {
      node.gpsLat = bestMatch.lat;
      node.gpsLon = bestMatch.lon;
      updateGpsFields(node);
      commit();
      render();
      return bestMatch;
    }
    return null;
  }

  function showGeocodingResultsPicker(node, results) {
    // Remove existing picker
    document.getElementById('geocodingPickerModal')?.remove();

    const modal = document.createElement('div');
    modal.id = 'geocodingPickerModal';
    modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:12000;display:flex;align-items:center;justify-content:center;';

    const card = document.createElement('div');
    card.style.cssText = 'background:white;border-radius:10px;box-shadow:0 8px 32px rgba(0,0,0,0.3);width:520px;max-width:90vw;max-height:80vh;display:flex;flex-direction:column;overflow:hidden;';

    // Header
    card.innerHTML = `
      <div style="padding:14px 18px;background:linear-gradient(135deg,#0077b6,#0096c7);color:white;display:flex;align-items:center;justify-content:space-between;">
        <div style="font-weight:600;font-size:14px;">ðŸ“ Select Location (${results.length} results)</div>
        <button id="btnCloseGeoPicker" style="background:rgba(255,255,255,0.2);border:none;color:white;width:28px;height:28px;border-radius:4px;cursor:pointer;font-size:16px;">âœ•</button>
      </div>
      <div style="padding:10px 18px;font-size:11px;color:#64748b;background:#f8fafc;border-bottom:1px solid #e0e0e0;">
        Click a result to apply its GPS coordinates to the selected node.
      </div>
      <div id="geoPickerResults" style="overflow-y:auto;flex:1;"></div>
    `;

    modal.appendChild(card);
    document.body.appendChild(modal);

    const listEl = card.querySelector('#geoPickerResults');

    results.forEach((r, idx) => {
      const lat = parseFloat(r.lat).toFixed(6);
      const lon = parseFloat(r.lon).toFixed(6);
      const type = r.type || r.class || '';
      const addr = r.address || {};
      const postcode = addr.postcode ? ` â€¢ ${addr.postcode}` : '';
      const country = addr.country_code ? ` (${addr.country_code.toUpperCase()})` : '';

      const item = document.createElement('div');
      item.style.cssText = 'padding:12px 18px;border-bottom:1px solid #f0f0f0;cursor:pointer;transition:background 0.15s;';
      item.innerHTML = `
        <div style="font-size:13px;font-weight:500;color:#1e293b;margin-bottom:3px;">
          ${escapeHtml(r.display_name || 'Unknown')}
        </div>
        <div style="font-size:10px;color:#64748b;display:flex;gap:12px;flex-wrap:wrap;">
          <span>ðŸ“Œ ${lat}, ${lon}</span>
          <span style="background:#e0f2fe;color:#0369a1;padding:1px 6px;border-radius:3px;">${escapeHtml(type)}${escapeHtml(country)}</span>
          ${postcode ? `<span>âœ‰ï¸${escapeHtml(postcode)}</span>` : ''}
        </div>
      `;
      item.addEventListener('mouseenter', () => item.style.background = '#f0f7ff');
      item.addEventListener('mouseleave', () => item.style.background = '');
      item.addEventListener('click', () => {
        applyGeocodingResult(node, r);
        modal.remove();
      });
      listEl.appendChild(item);
    });

    // Close handlers
    card.querySelector('#btnCloseGeoPicker').addEventListener('click', () => modal.remove());
    modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
  }

  // Button event handlers
  const btnLookupCity = document.getElementById('btnLookupCity');
  if (btnLookupCity) {
    btnLookupCity.addEventListener('click', showLocationLookupDialog);
  }

  const btnUseAddress = document.getElementById('btnUseAddress');
  if (btnUseAddress) {
    btnUseAddress.addEventListener('click', useAddressForGps);
  }

  // ============== END LOCATION LOOKUP ==============

  // Helper function to update view button states (green color for active)
  function updateViewButtonStates(activeView) {
    // activeView: 'main', 'geo', or 'map'
    const btnMain = document.getElementById('btnMainView');
    const btnGeo = document.getElementById('btnGeoView');
    const btnMap = document.getElementById('btnMapLibre');
    const btnShowPaths = document.getElementById('btnShowPaths');

    const activeColor = '#10b981'; // green
    const inactiveColor = ''; // default

    if (btnMain) {
      btnMain.classList.toggle('active', activeView === 'main');
      btnMain.style.color = activeView === 'main' ? activeColor : inactiveColor;
    }
    if (btnGeo) {
      btnGeo.classList.toggle('active', activeView === 'geo');
      btnGeo.style.color = activeView === 'geo' ? activeColor : inactiveColor;
    }
    if (btnMap) {
      btnMap.classList.toggle('active', activeView === 'map');
      btnMap.style.color = activeView === 'map' ? activeColor : inactiveColor;
    }

    // Show/hide Paths button only in map view
    if (btnShowPaths) {
      btnShowPaths.style.display = activeView === 'map' ? 'flex' : 'none';
    }
  }

  // Main view button
  const btnMainView = document.getElementById('btnMainView');
  if (btnMainView) {
    btnMainView.addEventListener('click', () => {
      // Deactivate other views if active
      if (mapLibreState && mapLibreState.active) {
        toggleMapLibreView(false);
      }
      if (geoViewState && geoViewState.active) {
        toggleGeoView(false);
      }
      updateViewButtonStates('main');
      render();
    });
  }

  // Geo view button
  const btnGeoView = document.getElementById('btnGeoView');
  if (btnGeoView) {
    btnGeoView.addEventListener('click', () => {
      // If MapLibre is active, deactivate it first
      if (mapLibreState && mapLibreState.active) {
        toggleMapLibreView(false);
      }
      toggleGeoView(!geoViewState.active);
      // Update button states based on new geo state
      updateViewButtonStates(geoViewState.active ? 'geo' : 'main');
    });
  }

  // Interactive Map (MapLibre) button
  const btnMapLibre = document.getElementById('btnMapLibre');
  const btnShowPaths = document.getElementById('btnShowPaths');

  if (btnMapLibre) {
    btnMapLibre.addEventListener('click', () => {
      // If Geo view is active, deactivate it first
      if (geoViewState && geoViewState.active) {
        toggleGeoView(false);
      }
      toggleMapLibreView(!mapLibreState.active);
      // Update button states based on new map state
      updateViewButtonStates(mapLibreState.active ? 'map' : 'main');

      // If deactivating, re-render the canvas
      if (!mapLibreState.active) {
        render();
      }
    });
  }

  // Show Paths toggle button
  if (btnShowPaths) {
    btnShowPaths.addEventListener('click', () => {
      // Toggle path render mode
      mapLibreState.pathRenderMode = mapLibreState.pathRenderMode === 'paths' ? 'lines' : 'paths';

      // Update button appearance
      const isPathsMode = mapLibreState.pathRenderMode === 'paths';
      btnShowPaths.classList.toggle('active', isPathsMode);
      btnShowPaths.style.background = isPathsMode ? '#e0e7ff' : '';
      btnShowPaths.style.borderColor = isPathsMode ? '#6366f1' : '';

      // Update button label
      const labelSpan = btnShowPaths.querySelector('span');
      if (labelSpan) {
        labelSpan.textContent = isPathsMode ? 'KML âœ“' : 'KML';
      }

      // Re-render map
      if (mapLibreState.active && mapLibreState.map && mapLibreState.isStyleLoaded) {
        mapLibreState.skipFitBounds = true;
        renderMapLibreContent();
      }

      // Re-render route finder path highlights with the new render mode (KML vs straight lines)
      if (typeof routeFinderState !== 'undefined' && routeFinderState.active && routeFinderState.routes.length > 0) {
        setTimeout(() => highlightActiveRoute(), 200);
      }

      // Count links with geometry
      const linksWithPaths = state.edges.filter(e => e.cableGeometry && e.cableGeometry.coordinates).length;

      if (isPathsMode) {
        showToast(`KML view ON (${linksWithPaths} link${linksWithPaths !== 1 ? 's' : ''} with geometry)`);
      } else {
        showToast('KML view OFF â€” straight lines');
      }
    });
  }

  // View menu radio buttons
  const viewModeStandard = document.getElementById('viewModeStandard');
  const viewModeGeo = document.getElementById('viewModeGeo');
  const mapSourceUrl = document.getElementById('mapSourceUrl');
  const mapSourceUpload = document.getElementById('mapSourceUpload');
  const mapSourceBuiltin = document.getElementById('mapSourceBuiltin');
  const miLoadMapUrl = document.getElementById('miLoadMapUrl');
  const miUploadGeoMap = document.getElementById('miUploadGeoMap');

  if (viewModeStandard) {
    viewModeStandard.addEventListener('change', () => {
      if (viewModeStandard.checked) {
        if (mapLibreState && mapLibreState.active) {
          toggleMapLibreView(false);
        }
        toggleGeoView(false);
        updateViewButtonStates('main');
      }
    });
  }
  if (viewModeGeo) {
    viewModeGeo.addEventListener('change', () => {
      if (viewModeGeo.checked) {
        if (mapLibreState && mapLibreState.active) {
          toggleMapLibreView(false);
        }
        toggleGeoView(true);
        updateViewButtonStates('geo');
      }
    });
  }

  // Map source radio buttons
  function updateMapSourceRadios() {
    if (mapSourceUrl) mapSourceUrl.checked = geoViewState.mapSource === 'url';
    if (mapSourceUpload) mapSourceUpload.checked = geoViewState.mapSource === 'upload';
    if (mapSourceBuiltin) mapSourceBuiltin.checked = geoViewState.mapSource === 'builtin';
  }
  updateMapSourceRadios();

  // Projection adjustment controls
  const projScaleX = document.getElementById('projScaleX');
  const projScaleXVal = document.getElementById('projScaleXVal');
  const projScaleY = document.getElementById('projScaleY');
  const projScaleYVal = document.getElementById('projScaleYVal');
  const projOffsetX = document.getElementById('projOffsetX');
  const projOffsetXVal = document.getElementById('projOffsetXVal');
  const projOffsetY = document.getElementById('projOffsetY');
  const projOffsetYVal = document.getElementById('projOffsetYVal');
  const projResetBtn = document.getElementById('projResetBtn');
  const projShowValuesBtn = document.getElementById('projShowValuesBtn');

  function updateProjectionFromControls() {
    geoViewState.projectionAdjust.scaleX = parseFloat(projScaleX?.value) || 1.0;
    geoViewState.projectionAdjust.scaleY = parseFloat(projScaleY?.value) || 1.0;
    geoViewState.projectionAdjust.offsetX = parseFloat(projOffsetX?.value) || 0;
    geoViewState.projectionAdjust.offsetY = parseFloat(projOffsetY?.value) || 0;

    // Update number inputs
    if (projScaleXVal) projScaleXVal.value = geoViewState.projectionAdjust.scaleX;
    if (projScaleYVal) projScaleYVal.value = geoViewState.projectionAdjust.scaleY;
    if (projOffsetXVal) projOffsetXVal.value = geoViewState.projectionAdjust.offsetX;
    if (projOffsetYVal) projOffsetYVal.value = geoViewState.projectionAdjust.offsetY;

    // Save to localStorage
    try {
      localStorage.setItem('neximap-geo-projection-adjust', JSON.stringify(geoViewState.projectionAdjust));
    } catch(e) {}

    if (geoViewState.active) render();
  }

  function updateControlsFromProjection() {
    const adj = geoViewState.projectionAdjust;
    if (projScaleX) projScaleX.value = adj.scaleX;
    if (projScaleXVal) projScaleXVal.value = adj.scaleX;
    if (projScaleY) projScaleY.value = adj.scaleY;
    if (projScaleYVal) projScaleYVal.value = adj.scaleY;
    if (projOffsetX) projOffsetX.value = adj.offsetX;
    if (projOffsetXVal) projOffsetXVal.value = adj.offsetX;
    if (projOffsetY) projOffsetY.value = adj.offsetY;
    if (projOffsetYVal) projOffsetYVal.value = adj.offsetY;
  }

  // Load saved projection adjustment
  try {
    const savedAdj = localStorage.getItem('neximap-geo-projection-adjust');
    if (savedAdj) {
      const adj = JSON.parse(savedAdj);
      geoViewState.projectionAdjust = { ...geoViewState.projectionAdjust, ...adj };
      updateControlsFromProjection();
    }
  } catch(e) {}

  // Slider event handlers
  if (projScaleX) {
    projScaleX.addEventListener('input', updateProjectionFromControls);
  }
  if (projScaleY) {
    projScaleY.addEventListener('input', updateProjectionFromControls);
  }
  if (projOffsetX) {
    projOffsetX.addEventListener('input', updateProjectionFromControls);
  }
  if (projOffsetY) {
    projOffsetY.addEventListener('input', updateProjectionFromControls);
  }

  // Number input event handlers
  if (projScaleXVal) {
    projScaleXVal.addEventListener('change', () => {
      if (projScaleX) projScaleX.value = projScaleXVal.value;
      updateProjectionFromControls();
    });
  }
  if (projScaleYVal) {
    projScaleYVal.addEventListener('change', () => {
      if (projScaleY) projScaleY.value = projScaleYVal.value;
      updateProjectionFromControls();
    });
  }
  if (projOffsetXVal) {
    projOffsetXVal.addEventListener('change', () => {
      if (projOffsetX) projOffsetX.value = projOffsetXVal.value;
      updateProjectionFromControls();
    });
  }
  if (projOffsetYVal) {
    projOffsetYVal.addEventListener('change', () => {
      if (projOffsetY) projOffsetY.value = projOffsetYVal.value;
      updateProjectionFromControls();
    });
  }

  // Reset button
  if (projResetBtn) {
    projResetBtn.addEventListener('click', () => {
      geoViewState.projectionAdjust = { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 };
      updateControlsFromProjection();
      try {
        localStorage.removeItem('neximap-geo-projection-adjust');
      } catch(e) {}
      if (geoViewState.active) render();
      showToast('ðŸ”„ Projection reset to defaults');
    });
  }

  // Copy values button
  if (projShowValuesBtn) {
    projShowValuesBtn.addEventListener('click', () => {
      const adj = geoViewState.projectionAdjust;
      const values = `scaleX: ${adj.scaleX}, scaleY: ${adj.scaleY}, offsetX: ${adj.offsetX}, offsetY: ${adj.offsetY}`;
      navigator.clipboard.writeText(values).then(() => {
        showToast('ðŸ“‹ Values copied: ' + values);
      }).catch(() => {
        showToast('ðŸ“‹ ' + values);
      });
    });
  }

  // ============ FLOATING PROJECTION PANEL ============
  const projectionPanel = document.getElementById('projectionPanel');
  const projPanelClose = document.getElementById('projPanelClose');
  const projScaleX2 = document.getElementById('projScaleX2');
  const projScaleXVal2 = document.getElementById('projScaleXVal2');
  const projScaleY2 = document.getElementById('projScaleY2');
  const projScaleYVal2 = document.getElementById('projScaleYVal2');
  const projOffsetX2 = document.getElementById('projOffsetX2');
  const projOffsetXVal2 = document.getElementById('projOffsetXVal2');
  const projOffsetY2 = document.getElementById('projOffsetY2');
  const projOffsetYVal2 = document.getElementById('projOffsetYVal2');
  const projResetBtn2 = document.getElementById('projResetBtn2');
  const projCopyBtn2 = document.getElementById('projCopyBtn2');

  // Show/hide floating panel based on geo view state
  function updateProjectionPanelVisibility() {
    if (projectionPanel) {
      projectionPanel.style.display = geoViewState.active ? 'block' : 'none';
    }
  }

  // Sync floating panel controls with geoViewState
  function syncFloatingPanelControls() {
    const adj = geoViewState.projectionAdjust;
    if (projScaleX2) projScaleX2.value = adj.scaleX;
    if (projScaleXVal2) projScaleXVal2.value = adj.scaleX;
    if (projScaleY2) projScaleY2.value = adj.scaleY;
    if (projScaleYVal2) projScaleYVal2.value = adj.scaleY;
    if (projOffsetX2) projOffsetX2.value = adj.offsetX;
    if (projOffsetXVal2) projOffsetXVal2.value = adj.offsetX;
    if (projOffsetY2) projOffsetY2.value = adj.offsetY;
    if (projOffsetYVal2) projOffsetYVal2.value = adj.offsetY;
  }

  // Update from floating panel controls
  function updateFromFloatingPanel() {
    geoViewState.projectionAdjust.scaleX = parseFloat(projScaleX2?.value) || 1.0;
    geoViewState.projectionAdjust.scaleY = parseFloat(projScaleY2?.value) || 1.0;
    geoViewState.projectionAdjust.offsetX = parseFloat(projOffsetX2?.value) || 0;
    geoViewState.projectionAdjust.offsetY = parseFloat(projOffsetY2?.value) || 0;

    // Sync number inputs
    if (projScaleXVal2) projScaleXVal2.value = geoViewState.projectionAdjust.scaleX;
    if (projScaleYVal2) projScaleYVal2.value = geoViewState.projectionAdjust.scaleY;
    if (projOffsetXVal2) projOffsetXVal2.value = geoViewState.projectionAdjust.offsetX;
    if (projOffsetYVal2) projOffsetYVal2.value = geoViewState.projectionAdjust.offsetY;

    // Also sync menu controls
    updateControlsFromProjection();

    // Save to localStorage
    try {
      localStorage.setItem('neximap-geo-projection-adjust', JSON.stringify(geoViewState.projectionAdjust));
    } catch(e) {}

    if (geoViewState.active) render();
  }

  // Close button
  if (projPanelClose) {
    projPanelClose.addEventListener('click', () => {
      if (projectionPanel) projectionPanel.style.display = 'none';
    });
  }

  // Slider event handlers for floating panel
  if (projScaleX2) projScaleX2.addEventListener('input', updateFromFloatingPanel);
  if (projScaleY2) projScaleY2.addEventListener('input', updateFromFloatingPanel);
  if (projOffsetX2) projOffsetX2.addEventListener('input', updateFromFloatingPanel);
  if (projOffsetY2) projOffsetY2.addEventListener('input', updateFromFloatingPanel);

  // Number input event handlers for floating panel
  if (projScaleXVal2) {
    projScaleXVal2.addEventListener('change', () => {
      if (projScaleX2) projScaleX2.value = projScaleXVal2.value;
      updateFromFloatingPanel();
    });
  }
  if (projScaleYVal2) {
    projScaleYVal2.addEventListener('change', () => {
      if (projScaleY2) projScaleY2.value = projScaleYVal2.value;
      updateFromFloatingPanel();
    });
  }
  if (projOffsetXVal2) {
    projOffsetXVal2.addEventListener('change', () => {
      if (projOffsetX2) projOffsetX2.value = projOffsetXVal2.value;
      updateFromFloatingPanel();
    });
  }
  if (projOffsetYVal2) {
    projOffsetYVal2.addEventListener('change', () => {
      if (projOffsetY2) projOffsetY2.value = projOffsetYVal2.value;
      updateFromFloatingPanel();
    });
  }

  // Reset button for floating panel
  if (projResetBtn2) {
    projResetBtn2.addEventListener('click', () => {
      geoViewState.projectionAdjust = { scaleX: 1.0, scaleY: 1.0, offsetX: 0, offsetY: 0 };
      syncFloatingPanelControls();
      updateControlsFromProjection();
      try {
        localStorage.removeItem('neximap-geo-projection-adjust');
      } catch(e) {}
      if (geoViewState.active) render();
      showToast('ðŸ”„ Projection reset to defaults');
    });
  }

  // Copy button for floating panel
  if (projCopyBtn2) {
    projCopyBtn2.addEventListener('click', () => {
      const adj = geoViewState.projectionAdjust;
      const values = `scaleX: ${adj.scaleX}, scaleY: ${adj.scaleY}, offsetX: ${adj.offsetX}, offsetY: ${adj.offsetY}`;
      navigator.clipboard.writeText(values).then(() => {
        showToast('ðŸ“‹ Values copied: ' + values);
      }).catch(() => {
        showToast('ðŸ“‹ ' + values);
      });
    });
  }

  // Initialize floating panel state
  syncFloatingPanelControls();
  // ============ END FLOATING PROJECTION PANEL ============

  if (mapSourceUrl) {
    mapSourceUrl.addEventListener('change', () => {
      if (mapSourceUrl.checked) {
        geoViewState.mapSource = 'url';
        saveCustomMapSettings();
        if (geoViewState.active) render();
      }
    });
  }

  if (mapSourceUpload) {
    mapSourceUpload.addEventListener('change', () => {
      if (mapSourceUpload.checked) {
        if (!geoViewState.customMapImage) {
          showToast('âš ï¸ No uploaded map - please upload one first');
          updateMapSourceRadios();
          return;
        }
        geoViewState.mapSource = 'upload';
        saveCustomMapSettings();
        if (geoViewState.active) render();
      }
    });
  }

  if (mapSourceBuiltin) {
    mapSourceBuiltin.addEventListener('change', () => {
      if (mapSourceBuiltin.checked) {
        geoViewState.mapSource = 'builtin';
        saveCustomMapSettings();
        if (geoViewState.active) render();
      }
    });
  }

  // Load map from URL handler
  if (miLoadMapUrl) {
    miLoadMapUrl.addEventListener('click', () => {
      closeAllMenus();
      showMapUrlDialog();
    });
  }

  // Upload map image handler
  if (miUploadGeoMap) {
    miUploadGeoMap.addEventListener('click', () => {
      closeAllMenus();

      // Create file input
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (ev) => {
          const dataUrl = ev.target.result;

          // Show bounds configuration dialog
          showMapBoundsDialog(dataUrl, 'upload');
        };
        reader.readAsDataURL(file);
      };
      input.click();
    });
  }

  // Save custom map settings to localStorage
  function saveCustomMapSettings() {
    try {
      localStorage.setItem('neximap-geo-custom-map', JSON.stringify({
        mapSource: geoViewState.mapSource,
        image: geoViewState.customMapImage,
        mapUrl: geoViewState.mapUrl,
        bounds: geoViewState.customMapBounds,
        useCustomMap: geoViewState.mapSource !== 'builtin'
      }));
    } catch (e) {
      console.warn('Could not save custom map to localStorage:', e);
    }
  }

  // Show dialog to load map from URL
  function showMapUrlDialog() {
    const modal = document.createElement('div');
    modal.id = 'geoMapUrlModal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); z-index: 10000;
      display: flex; align-items: center; justify-content: center;
    `;

    modal.innerHTML = `
      <div style="background: white; border-radius: 12px; padding: 24px; max-width: 550px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
        <h3 style="margin: 0 0 16px; color: #1d4ed8;">ðŸ”— Load Map from URL</h3>
        <p style="color: #666; font-size: 13px; margin-bottom: 16px;">
          Enter the URL of an <strong>Equirectangular projection</strong> map image (PNG, JPG, or SVG).
        </p>

        <div style="margin-bottom: 16px;">
          <label style="font-size: 11px; font-weight: 600; color: #555;">Map URL</label>
          <input type="url" id="mapUrlInput" value="${geoViewState.mapUrl || geoViewState.defaultMapUrl}"
                 placeholder="https://example.com/world-map.svg"
                 style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; box-sizing: border-box;">
        </div>

        <div style="background: #f0f9ff; padding: 12px; border-radius: 6px; margin-bottom: 16px;">
          <div style="font-size: 11px; font-weight: 600; color: #1e40af; margin-bottom: 8px;">ðŸ“‹ Preset Maps</div>
          <button class="preset-btn" data-url="https://upload.wikimedia.org/wikipedia/commons/9/9f/BlankMap-World-Equirectangular.svg"
                  style="display: block; width: 100%; text-align: left; padding: 8px; margin-bottom: 4px; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 11px;">
            ðŸŒ Wikimedia Blank World Map (SVG)
          </button>
          <button class="preset-btn" data-url="https://upload.wikimedia.org/wikipedia/commons/e/e8/Equirectangular_projection_SW.jpg"
                  style="display: block; width: 100%; text-align: left; padding: 8px; margin-bottom: 4px; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer; font-size: 11px;">
            ðŸ—ºï¸ Wikimedia Physical Map (JPG)
          </button>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Min Latitude (South)</label>
            <input type="number" id="urlMapMinLat" value="-85.05" min="-90" max="90" step="0.01"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Max Latitude (North)</label>
            <input type="number" id="urlMapMaxLat" value="85.05" min="-90" max="90" step="0.01"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Min Longitude (West)</label>
            <input type="number" id="urlMapMinLon" value="-180" min="-180" max="180" step="0.1"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Max Longitude (East)</label>
            <input type="number" id="urlMapMaxLon" value="180" min="-180" max="180" step="0.1"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
        </div>

        <div style="display: flex; gap: 12px; justify-content: flex-end;">
          <button id="mapUrlCancel" style="padding: 10px 20px; border: 1px solid #ddd; background: #f5f5f5; border-radius: 6px; cursor: pointer;">Cancel</button>
          <button id="mapUrlApply" style="padding: 10px 20px; border: none; background: #1d4ed8; color: white; border-radius: 6px; cursor: pointer; font-weight: 600;">Load Map</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // Preset button handlers
    modal.querySelectorAll('.preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.getElementById('mapUrlInput').value = btn.dataset.url;
        // Auto-set bounds for known maps
        const url = btn.dataset.url;
        if (url.includes('BlankMap-World-Equirectangular') || url.includes('Equirectangular_projection')) {
          document.getElementById('urlMapMinLat').value = '-85.05';
          document.getElementById('urlMapMaxLat').value = '85.05';
        }
      });
    });

    // Event handlers
    document.getElementById('mapUrlCancel').onclick = () => modal.remove();

    document.getElementById('mapUrlApply').onclick = () => {
      const url = document.getElementById('mapUrlInput').value.trim();
      if (!url) {
        showToast('âš ï¸ Please enter a URL');
        return;
      }

      const bounds = {
        minLat: parseFloat(document.getElementById('urlMapMinLat').value) || -85.05,
        maxLat: parseFloat(document.getElementById('urlMapMaxLat').value) || 85.05,
        minLon: parseFloat(document.getElementById('urlMapMinLon').value) || -180,
        maxLon: parseFloat(document.getElementById('urlMapMaxLon').value) || 180
      };

      geoViewState.mapUrl = url;
      geoViewState.mapBounds = { ...bounds };
      geoViewState.customMapBounds = bounds;
      geoViewState.mapSource = 'url';

      updateMapSourceRadios();
      saveCustomMapSettings();
      modal.remove();

      if (geoViewState.active) {
        render();
      } else {
        toggleGeoView(true);
        if (viewModeGeo) viewModeGeo.checked = true;
      }

      showToast('ðŸ—ºï¸ Map loaded from URL!');
    };

    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
  }

  // Show dialog to configure map bounds (for uploaded images)
  function showMapBoundsDialog(imageDataUrl, source = 'upload') {
    // Create modal dialog
    const modal = document.createElement('div');
    modal.id = 'geoMapBoundsModal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); z-index: 10000;
      display: flex; align-items: center; justify-content: center;
    `;

    modal.innerHTML = `
      <div style="background: white; border-radius: 12px; padding: 24px; max-width: 500px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
        <h3 style="margin: 0 0 16px; color: #1d4ed8;">ðŸ—ºï¸ Configure Map Bounds</h3>
        <p style="color: #666; font-size: 13px; margin-bottom: 16px;">
          Specify the geographic bounds of your map image. For a standard world map (Equirectangular/EPSG:4326), use the default values.
        </p>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Min Latitude (South)</label>
            <input type="number" id="mapBoundMinLat" value="-85.05" min="-90" max="90" step="0.01"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Max Latitude (North)</label>
            <input type="number" id="mapBoundMaxLat" value="85.05" min="-90" max="90" step="0.01"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Min Longitude (West)</label>
            <input type="number" id="mapBoundMinLon" value="-180" min="-180" max="180" step="0.1"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
          <div>
            <label style="font-size: 11px; font-weight: 600; color: #555;">Max Longitude (East)</label>
            <input type="number" id="mapBoundMaxLon" value="180" min="-180" max="180" step="0.1"
                   style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
          </div>
        </div>

        <div style="background: #f0f9ff; padding: 10px; border-radius: 6px; margin-bottom: 16px; font-size: 11px; color: #1e40af;">
          <strong>ðŸ’¡ Common projections:</strong><br>
          â€¢ <strong>Equirectangular (EPSG:4326)</strong>: Use -85 to 85 lat, -180 to 180 lon<br>
          â€¢ <strong>Web Mercator</strong>: Use -85.05 to 85.05 lat, -180 to 180 lon
        </div>

        <div style="display: flex; gap: 12px; justify-content: flex-end;">
          <button id="mapBoundsCancel" style="padding: 10px 20px; border: 1px solid #ddd; background: #f5f5f5; border-radius: 6px; cursor: pointer;">Cancel</button>
          <button id="mapBoundsApply" style="padding: 10px 20px; border: none; background: #1d4ed8; color: white; border-radius: 6px; cursor: pointer; font-weight: 600;">Apply Map</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // Event handlers
    document.getElementById('mapBoundsCancel').onclick = () => modal.remove();

    document.getElementById('mapBoundsApply').onclick = () => {
      const bounds = {
        minLat: parseFloat(document.getElementById('mapBoundMinLat').value) || -85.05,
        maxLat: parseFloat(document.getElementById('mapBoundMaxLat').value) || 85.05,
        minLon: parseFloat(document.getElementById('mapBoundMinLon').value) || -180,
        maxLon: parseFloat(document.getElementById('mapBoundMaxLon').value) || 180
      };

      // Update geoViewState for uploaded image
      geoViewState.mapBounds = { ...bounds };
      geoViewState.customMapImage = imageDataUrl;
      geoViewState.customMapBounds = bounds;
      geoViewState.mapSource = 'upload';

      updateMapSourceRadios();
      saveCustomMapSettings();
      modal.remove();

      if (geoViewState.active) {
        render();
      } else {
        toggleGeoView(true);
        if (viewModeGeo) viewModeGeo.checked = true;
      }

      showToast('ðŸ—ºï¸ Uploaded map applied!');
    };

    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
  }

  // Update inspector to include GPS fields
  const origUpdateInspector = updateInspector;
  window.updateInspectorWithGps = function() {
    origUpdateInspector();
    if (state.selected?.type === 'node') {
      const n = findNode(state.selected.id);
      if (n) updateGpsFields(n);
    }
  };

  // Hook into inspector updates
  if (typeof updateInspector === 'function') {
    const hookedUpdateInspector = updateInspector;
    window.updateInspector = function() {
      hookedUpdateInspector();
      if (state.selected?.type === 'node') {
        const n = findNode(state.selected.id);
        if (n) updateGpsFields(n);
      }
    };
  }

  // ============== MAPLIBRE INTERACTIVE MAP ==============

  // MapLibre state
  const mapLibreState = {
    active: false,
    map: null,
    markers: [],
    lines: [],
    style: 'liberty',
    isStyleLoaded: false,
    renderPending: false,
    // Selection state
    selectedNode: null,
    selectedEdge: null,
    selectedNodes: new Set(),
    selectedEdges: new Set(),
    selectionEnabled: true,
    // Style mode: 'canvas' or 'simplified'
    styleMode: 'canvas',
    // Path rendering mode: 'lines' or 'paths'
    pathRenderMode: 'lines', // 'lines' = straight lines, 'paths' = KML view (show cableGeometry)
    // Simplified view settings (used when styleMode is 'simplified')
    simplified: {
      nodeFill: '#dae8fc',
      nodeStroke: '#6c8ebf',
      nodeSize: 20,
      linkColor: '#6c8ebf',
      linkWidth: 2,
      linkStyle: 'solid'
    },
    // Legacy default colors (kept for backwards compatibility)
    defaultLinkColor: '#6c8ebf',
    defaultLinkWidth: 2,
    useCanvasColors: true,
    // Available map styles from OpenFreeMap
    styles: {
      liberty: 'https://tiles.openfreemap.org/styles/liberty',
      bright: 'https://tiles.openfreemap.org/styles/bright',
      positron: 'https://tiles.openfreemap.org/styles/positron',
      darkMatter: 'https://tiles.openfreemap.org/styles/dark'
    }
  };

  // Geo Static view simplified settings
  const geoStaticSimplified = {
    styleMode: 'canvas', // 'canvas' or 'simplified'
    nodeFill: '#dae8fc',
    nodeStroke: '#6c8ebf',
    nodeSize: 12,
    linkColor: '#666666',
    linkWidth: 2,
    linkStyle: 'solid'
  };
  window.geoStaticSimplified = geoStaticSimplified;

  // Expose globally for label toggle handlers
  window.mapLibreState = mapLibreState;

  // ============== PATH EDIT MODE FUNCTIONS ==============

  // Update path geometry UI in inspector
  function updatePathGeometryUI(edge) {
    const statusIcon = document.getElementById('pathStatusIcon');
    const statusText = document.getElementById('pathStatusText');
    const statusDetails = document.getElementById('pathStatusDetails');
    const noPathDiv = document.getElementById('pathGeometryNoPath');
    const hasPathDiv = document.getElementById('pathGeometryHasPath');

    if (!statusIcon || !statusText) return;

    const waypointCount = edge.cableGeometry ? extractCoordsFromGeometry(edge.cableGeometry).length : 0;
    if (edge.cableGeometry && waypointCount > 0) {
      // Has path
      statusIcon.textContent = 'ðŸ›¤ï¸';
      statusText.textContent = `Path defined (${waypointCount} waypoints)`;
      statusText.style.color = '#059669';

      let details = [];
      if (edge.pathSource) {
        const sourceLabels = {
          'manual': 'Manually drawn',
          'telegeography': 'Cable Database import',
          'kml-import': 'KML/GeoJSON import'
        };
        details.push(sourceLabels[edge.pathSource] || edge.pathSource);
      }
      if (edge.pathCableRef) {
        details.push(`Cable: ${edge.pathCableRef}`);
      }
      statusDetails.textContent = details.join(' â€¢ ');

      if (noPathDiv) noPathDiv.style.display = 'none';
      if (hasPathDiv) hasPathDiv.style.display = 'block';
    } else {
      // No path
      statusIcon.textContent = 'âž–';
      statusText.textContent = 'No path defined (straight line)';
      statusText.style.color = '#6b7280';
      statusDetails.textContent = '';

      if (noPathDiv) noPathDiv.style.display = 'block';
      if (hasPathDiv) hasPathDiv.style.display = 'none';
    }
  }

  // Enter Path Edit Mode
  function enterPathEditMode(linkId) {
    const edge = findEdge(linkId);
    if (!edge) {
      showToast('Link not found');
      return;
    }

    const nodeA = findNode(edge.a);
    const nodeB = findNode(edge.b);
    if (!nodeA || !nodeB) {
      showToast('Link endpoints not found');
      return;
    }

    // Check if both nodes have GPS coordinates
    if (!nodeA.gpsLat || !nodeA.gpsLon || !nodeB.gpsLat || !nodeB.gpsLon) {
      showToast('Both link endpoints need GPS coordinates for path editing');
      return;
    }

    // Store coordinates in state for reliable access
    const sourceCoords = [parseFloat(nodeA.gpsLon), parseFloat(nodeA.gpsLat)];
    const targetCoords = [parseFloat(nodeB.gpsLon), parseFloat(nodeB.gpsLat)];


    // Save original geometry for cancel/restore (keep full GeoJSON object)
    state.pathEditMode.originalPath = edge.cableGeometry ? JSON.parse(JSON.stringify(edge.cableGeometry)) : null;
    // Extract flat coordinate array for editing
    state.pathEditMode.currentPath = edge.cableGeometry ? extractCoordsFromGeometry(edge.cableGeometry) : [];
    // Preserve separate segments for MultiLineString geometries
    if (edge.cableGeometry && edge.cableGeometry.type === 'MultiLineString') {
      state.pathEditMode.currentSegments = edge.cableGeometry.coordinates.map(seg => seg.map(c => [c[0], c[1]]));
    } else {
      state.pathEditMode.currentSegments = null;
    }
    state.pathEditMode.linkId = linkId;
    state.pathEditMode.hasUnsavedChanges = false;
    state.pathEditMode.editMethod = null;
    state.pathEditMode.active = true;
    state.pathEditMode._boundsFitted = false;
    // Store coordinates for reliable access
    state.pathEditMode.sourceCoords = sourceCoords;
    state.pathEditMode.targetCoords = targetCoords;
    state.pathEditMode.sourceName = nodeA.name || nodeA.code || 'Source';
    state.pathEditMode.targetName = nodeB.name || nodeB.code || 'Target';

    // Update UI
    const banner = document.getElementById('pathEditModeBanner');
    const overlay = document.getElementById('pathEditModeOverlay');
    const controlPanel = document.getElementById('pathEditControlPanel');
    const linkName = document.getElementById('pathEditLinkName');
    const btnShowPaths = document.getElementById('btnShowPaths');

    if (banner) banner.classList.add('active');
    // Don't show overlay - it blocks interaction
    // if (overlay) overlay.classList.add('active');
    if (controlPanel) controlPanel.classList.add('active');
    if (linkName) linkName.textContent = `Editing: ${edge.code || 'Link ' + linkId} (${nodeA.name || nodeA.code} â†’ ${nodeB.name || nodeB.code})`;

    // Show the Paths toggle button
    if (btnShowPaths) btnShowPaths.style.display = 'flex';

    updatePathEditStatus();
    updateWaypointCount();

    // FORCE switch to Dynamic Map view using proper toggle function
    if (!mapLibreState.active) {
      // Use the proper toggle function which handles all setup including:
      // - Container visibility
      // - Button states (Main/Geo/Map with green highlight)
      // - Radio button sync
      // - Map initialization
      // - Wrap overflow
      toggleMapLibreView(true);
    }

    // Wait for map to be ready, then center on link and render
    const centerAndRender = () => {
      if (!mapLibreState.map) return;

      const map = mapLibreState.map;
      const srcCoords = state.pathEditMode.sourceCoords;
      const tgtCoords = state.pathEditMode.targetCoords;


      // Ensure zoom/pan interactions are enabled
      map.scrollZoom.enable();
      map.dragPan.enable();
      map.doubleClickZoom.enable();
      map.touchZoomRotate.enable();

      // Validate coordinates
      if (!srcCoords || !tgtCoords ||
          !isFinite(srcCoords[0]) || !isFinite(srcCoords[1]) ||
          !isFinite(tgtCoords[0]) || !isFinite(tgtCoords[1])) {
        console.error('[PATH EDIT] Invalid coordinates in centerAndRender');
        renderPathEditingView();
        return;
      }

      // Use fitBounds with proper padding - this is the correct approach for fitting to a link
      const bounds = new maplibregl.LngLatBounds();
      bounds.extend(srcCoords);
      bounds.extend(tgtCoords);


      // Use fitBounds with large padding to ensure the link is well-framed
      map.fitBounds(bounds, {
        padding: { top: 150, bottom: 200, left: 400, right: 150 },
        maxZoom: 10,
        duration: 1000
      });

      // Mark bounds as fitted so renderPathEditingView doesn't re-fit
      state.pathEditMode._boundsFitted = true;

      // Render after the fly animation completes
      setTimeout(() => {
        renderPathEditingView();
      }, 1100);
    };

    // Wait for map and style to be ready
    setTimeout(() => {
      if (mapLibreState.map && mapLibreState.isStyleLoaded) {
        centerAndRender();
      } else if (mapLibreState.map) {
        mapLibreState.map.once('style.load', () => {
          centerAndRender();
        });
      }
    }, 150);

    showToast('Path Edit Mode activated. Select a method below, then click on the map.');
  }

  // Exit Path Edit Mode
  function exitPathEditMode(save = false) {
    if (!state.pathEditMode.active) return;

    const linkId = state.pathEditMode.linkId;
    const edge = findEdge(linkId);

    if (save && edge) {
      // Save the path as unified cableGeometry (GeoJSON format)
      if (state.pathEditMode.currentPath && state.pathEditMode.currentPath.length > 0) {
        if (state.pathEditMode.currentSegments) {
          // Preserve separate segments as MultiLineString
          edge.cableGeometry = {
            type: 'MultiLineString',
            coordinates: state.pathEditMode.currentSegments.map(seg => seg.map(c => [c[0], c[1]]))
          };
        } else {
          edge.cableGeometry = {
            type: 'LineString',
            coordinates: [...state.pathEditMode.currentPath]
          };
        }
        edge.pathSource = state.pathEditMode.editMethod || 'manual';
      } else {
        edge.cableGeometry = null;
        edge.pathSource = null;
        edge.pathCableRef = null;
      }
      commit();
      showToast('Path saved successfully');
    } else if (!save && edge && state.pathEditMode.hasUnsavedChanges) {
      // Restore original GeoJSON geometry
      edge.cableGeometry = state.pathEditMode.originalPath;
      showToast('Changes discarded');
    }

    // Clear path editing layers from map
    clearPathEditLayers();

    // Clear tracked markers

    pathEditMarkers.forEach(marker => {
      try {
        marker.remove();
      } catch (e) {}
    });
    pathEditMarkers = [];

    // Remove map click handler
    if (mapLibreState.map) {
      mapLibreState.map.off('click', handleMapClickForPath);
    }

    // Reset state
    state.pathEditMode.active = false;
    state.pathEditMode.linkId = null;
    state.pathEditMode.originalPath = null;
    state.pathEditMode.currentPath = [];
    state.pathEditMode.currentSegments = null;
    state.pathEditMode.hasUnsavedChanges = false;
    state.pathEditMode.editMethod = null;
    state.pathEditMode._boundsFitted = false;

    // Update UI
    const banner = document.getElementById('pathEditModeBanner');
    const overlay = document.getElementById('pathEditModeOverlay');
    const controlPanel = document.getElementById('pathEditControlPanel');

    if (banner) banner.classList.remove('active');
    if (overlay) overlay.classList.remove('active');
    if (controlPanel) controlPanel.classList.remove('active');

    // Reset method buttons
    document.querySelectorAll('#pathEditControlPanel .method-btn').forEach(b => b.classList.remove('active'));

    // Re-enable interactions
    enableNonPathInteractions();

    // Refresh views
    render();
    if (mapLibreState.active && mapLibreState.map) {
      renderMapLibreContent();
    }
    updateInspector();

  }

  // Update path edit status display
  function updatePathEditStatus() {
    const statusDiv = document.getElementById('pathEditStatus');
    const statusIcon = document.getElementById('pathEditStatusIcon');
    const statusText = document.getElementById('pathEditStatusText');

    if (!statusDiv) return;

    if (state.pathEditMode.hasUnsavedChanges) {
      statusDiv.classList.add('unsaved');
      if (statusIcon) statusIcon.textContent = 'â—';
      if (statusText) statusText.textContent = 'Unsaved changes';
    } else {
      statusDiv.classList.remove('unsaved');
      if (statusIcon) statusIcon.textContent = 'â—';
      if (statusText) statusText.textContent = state.pathEditMode.currentPath.length > 0 ? 'Path defined' : 'No changes';
    }
  }

  // Update waypoint count display
  function updateWaypointCount() {
    const countEl = document.getElementById('pathWaypointCount');
    if (countEl) {
      const count = state.pathEditMode.currentPath.length;
      countEl.textContent = `${count} waypoint${count !== 1 ? 's' : ''}`;
    }
  }

  // Disable non-path interactions during edit mode
  function disableNonPathInteractions() {
    // Disable toolbar buttons (except essential ones)
    document.querySelectorAll('.tool-btn:not(#btnPathSaveExit):not(#btnPathCancelExit)').forEach(btn => {
      btn.dataset.pathEditDisabled = btn.disabled ? 'was-disabled' : 'was-enabled';
      btn.disabled = true;
      btn.style.opacity = '0.5';
      btn.style.pointerEvents = 'none';
    });

    // Disable inspector inputs
    document.querySelectorAll('#inspectorPanel input, #inspectorPanel select, #inspectorPanel button').forEach(el => {
      if (!el.closest('#pathEditControlPanel')) {
        el.dataset.pathEditDisabled = el.disabled ? 'was-disabled' : 'was-enabled';
        el.disabled = true;
      }
    });

    // Disable canvas interactions
    const canvas = document.getElementById('svg');
    if (canvas) {
      canvas.style.pointerEvents = 'none';
      canvas.style.opacity = '0.3';
    }
  }

  // Re-enable interactions after exiting edit mode
  function enableNonPathInteractions() {

    // Re-enable toolbar buttons
    const disabledButtons = document.querySelectorAll('.tool-btn[data-path-edit-disabled]');
    disabledButtons.forEach(btn => {
      if (btn.dataset.pathEditDisabled === 'was-enabled') {
        btn.disabled = false;
      }
      btn.style.opacity = '';
      btn.style.pointerEvents = '';
      delete btn.dataset.pathEditDisabled;
    });

    // Re-enable inspector inputs
    const disabledInputs = document.querySelectorAll('[data-path-edit-disabled]');
    disabledInputs.forEach(el => {
      if (el.dataset.pathEditDisabled === 'was-enabled') {
        el.disabled = false;
      }
      delete el.dataset.pathEditDisabled;
    });

    // Re-enable canvas
    const canvas = document.getElementById('svg');
    if (canvas) {
      canvas.style.pointerEvents = '';
      canvas.style.opacity = '';
    } else {
    }
  }

  // Track path edit markers for proper cleanup
  let pathEditMarkers = [];

  /**
   * Find the index of the closest point on a path to a given target point.
   * Uses cos-lat-corrected distance for geographic coordinates.
   * Returns { index, distance }.
   */
  function findClosestPointOnPath(path, targetCoord) {
    if (!path || path.length === 0 || !targetCoord) return { index: -1, distance: Infinity };
    let minDist = Infinity;
    let minIndex = 0;
    const tLon = targetCoord[0];
    const tLat = targetCoord[1];
    const cosLat = Math.cos(tLat * Math.PI / 180);
    for (let i = 0; i < path.length; i++) {
      const dLon = (path[i][0] - tLon) * cosLat;
      const dLat = path[i][1] - tLat;
      const dist = dLon * dLon + dLat * dLat;
      if (dist < minDist) {
        minDist = dist;
        minIndex = i;
      }
    }
    return { index: minIndex, distance: Math.sqrt(minDist) };
  }

  /**
   * Build smart path coordinates that connect nodes to an imported path.
   * Instead of drawing long lines from node position to path start/end,
   * finds the closest point on the path to each node and trims accordingly.
   * Short connector lines from node to nearest path point are added.
   */

  /**
   * Extract flat coordinate array from a GeoJSON geometry object.
   * For LineString: returns coordinates directly.
   * For MultiLineString: flattens all segments into one array.
   */
  function extractCoordsFromGeometry(geom) {
    if (!geom || !geom.coordinates) return [];
    if (geom.type === 'LineString') return geom.coordinates.map(c => [c[0], c[1]]);
    if (geom.type === 'MultiLineString') {
      return geom.coordinates.reduce((acc, seg) => acc.concat(seg.map(c => [c[0], c[1]])), []);
    }
    return [];
  }

  /**
   * Find the closest coordinate on a GeoJSON geometry (LineString or MultiLineString)
   * to a given target coordinate. Returns [lng, lat] of the closest point.
   */
  function findClosestPointOnGeometry(geometry, targetCoords) {
    if (!geometry || !geometry.coordinates) return null;

    let closestPoint = null;
    let closestDist = Infinity;
    const tLon = targetCoords[0];
    const tLat = targetCoords[1];
    const cosLat = Math.cos(tLat * Math.PI / 180);

    const checkCoords = (coords) => {
      for (const coord of coords) {
        const dLon = (coord[0] - tLon) * cosLat;
        const dLat = coord[1] - tLat;
        const dist = dLon * dLon + dLat * dLat;
        if (dist < closestDist) {
          closestDist = dist;
          closestPoint = [coord[0], coord[1]];
        }
      }
    };

    if (geometry.type === 'LineString') {
      checkCoords(geometry.coordinates);
    } else if (geometry.type === 'MultiLineString') {
      for (const segment of geometry.coordinates) {
        checkCoords(segment);
      }
    }

    return closestPoint;
  }

  function buildSmartPathCoords(sourceCoords, targetCoords, pathPoints) {
    if (!pathPoints || pathPoints.length === 0) {
      return [sourceCoords, targetCoords];
    }
    
    const closestToSource = findClosestPointOnPath(pathPoints, sourceCoords);
    const closestToTarget = findClosestPointOnPath(pathPoints, targetCoords);
    
    let startIdx, endIdx, reversed;
    if (closestToSource.index <= closestToTarget.index) {
      startIdx = closestToSource.index;
      endIdx = closestToTarget.index;
      reversed = false;
    } else {
      startIdx = closestToTarget.index;
      endIdx = closestToSource.index;
      reversed = true;
    }
    
    const trimmedPath = pathPoints.slice(startIdx, endIdx + 1);
    
    if (trimmedPath.length === 0) {
      return [sourceCoords, targetCoords];
    }
    
    const result = [sourceCoords];
    
    if (!reversed) {
      for (const pt of trimmedPath) result.push(pt);
    } else {
      for (let i = trimmedPath.length - 1; i >= 0; i--) result.push(trimmedPath[i]);
    }
    
    result.push(targetCoords);
    return result;
  }

  // Render map view focused on path editing
  function renderPathEditingView() {


    if (!mapLibreState.map || !state.pathEditMode.active) {

      return;
    }

    const map = mapLibreState.map;

    // Use stored coordinates from state
    const sourceCoords = state.pathEditMode.sourceCoords;
    const targetCoords = state.pathEditMode.targetCoords;
    const sourceName = state.pathEditMode.sourceName || 'Source';
    const targetName = state.pathEditMode.targetName || 'Target';


    // CRITICAL: Validate coordinates before proceeding
    if (!sourceCoords || !targetCoords ||
        !Array.isArray(sourceCoords) || !Array.isArray(targetCoords) ||
        sourceCoords.length < 2 || targetCoords.length < 2 ||
        !isFinite(sourceCoords[0]) || !isFinite(sourceCoords[1]) ||
        !isFinite(targetCoords[0]) || !isFinite(targetCoords[1]) ||
        (sourceCoords[0] === 0 && sourceCoords[1] === 0) ||
        (targetCoords[0] === 0 && targetCoords[1] === 0)) {
      console.error('[PATH EDIT] INVALID coordinates - aborting render');
      return;
    }

    // Clear all normal map content (nodes, edges, labels) - we only want to show the editing link

    clearMapLibreContent();

    // PROPER CLEANUP: Remove all our tracked markers

    pathEditMarkers.forEach(marker => {
      try {
        marker.remove();
      } catch (e) {
        console.warn('[PATH EDIT] Error removing marker:', e);
      }
    });
    pathEditMarkers = [];

    // Ensure map interactions are enabled
    map.scrollZoom.enable();
    map.dragPan.enable();
    map.boxZoom.enable();
    map.keyboard.enable();
    map.doubleClickZoom.enable();
    map.touchZoomRotate.enable();



    try {
      // Build the current editing link path (grey baseline + blue editing path)
      const baselineCoords = [sourceCoords, targetCoords];

      // Build the editing path with waypoints - smart snap to nearest point
      let pathData;
      if (state.pathEditMode.currentSegments) {
        // Multi-segment import: render each segment separately as MultiLineString
        pathData = {
          type: 'Feature',
          geometry: { type: 'MultiLineString', coordinates: state.pathEditMode.currentSegments }
        };
      } else {
        const pathCoords = state.pathEditMode.currentPath.length > 0
          ? buildSmartPathCoords(sourceCoords, targetCoords, state.pathEditMode.currentPath)
          : baselineCoords;
        pathData = {
          type: 'Feature',
          geometry: { type: 'LineString', coordinates: pathCoords }
        };
      }

      // === BASELINE LINK (grey, shows original straight line or connector lines) ===
      let baselineData;
      if (state.pathEditMode.currentSegments) {
        // Multi-segment: show dotted connector lines from nodes to closest points on cable
        const multiGeom = { type: 'MultiLineString', coordinates: state.pathEditMode.currentSegments };
        const closestToSource = findClosestPointOnGeometry(multiGeom, sourceCoords);
        const closestToTarget = findClosestPointOnGeometry(multiGeom, targetCoords);
        const connectorLines = [];
        if (closestToSource) connectorLines.push([sourceCoords, closestToSource]);
        if (closestToTarget) connectorLines.push([targetCoords, closestToTarget]);
        baselineData = {
          type: 'Feature',
          geometry: connectorLines.length > 0
            ? { type: 'MultiLineString', coordinates: connectorLines }
            : { type: 'LineString', coordinates: baselineCoords }
        };
      } else {
        baselineData = {
          type: 'Feature',
          geometry: { type: 'LineString', coordinates: baselineCoords }
        };
      }

      if (map.getSource('path-edit-baseline')) {
        map.getSource('path-edit-baseline').setData(baselineData);
      } else {
        map.addSource('path-edit-baseline', { type: 'geojson', data: baselineData });
        map.addLayer({
          id: 'path-edit-baseline-layer',
          type: 'line',
          source: 'path-edit-baseline',
          paint: {
            'line-color': '#9ca3af',
            'line-width': 2,
            'line-dasharray': [4, 4],
            'line-opacity': 0.6
          }
        });
      }

      // === CURRENT EDITING PATH (blue) ===

      if (map.getSource('path-edit-current')) {
        map.getSource('path-edit-current').setData(pathData);
      } else {
        map.addSource('path-edit-current', { type: 'geojson', data: pathData });
        map.addLayer({
          id: 'path-edit-current-layer',
          type: 'line',
          source: 'path-edit-current',
          paint: {
            'line-color': '#3b82f6',
            'line-width': 3,
            'line-opacity': 1
          }
        });
      }

      // === WAYPOINT MARKERS (using HTML markers for interactivity) ===
      // Remove old waypoint markers
      document.querySelectorAll('.path-edit-waypoint').forEach(el => {
        el.closest('.maplibregl-marker')?.remove();
      });

      // Add new waypoint markers
      state.pathEditMode.currentPath.forEach((coord, idx) => {
        // Validate coordinates
        if (!Array.isArray(coord) || coord.length < 2 ||
            typeof coord[0] !== 'number' || typeof coord[1] !== 'number' ||
            !isFinite(coord[0]) || !isFinite(coord[1])) {
          console.warn('[PATH EDIT] Invalid coordinate at index', idx, coord);
          return;
        }

        const waypointEl = document.createElement('div');
        waypointEl.className = 'path-edit-waypoint';
        waypointEl.dataset.index = idx;
        waypointEl.style.cssText = `
          width: 16px;
          height: 16px;
          background: #ffffff;
          border: 3px solid #3b82f6;
          border-radius: 50%;
          cursor: pointer;
          box-shadow: 0 2px 4px rgba(0,0,0,0.3);
          transition: background 0.15s, border-color 0.15s;
        `;
        waypointEl.title = `Waypoint ${idx + 1} - Click to delete, drag to move`;
        let isDragging = false;
        let mouseDownTime = 0;

        // Hover effect
        waypointEl.addEventListener('mouseenter', () => {
          if (!isDragging) {
            waypointEl.style.transform = 'scale(1.3)';
            waypointEl.style.background = '#fee2e2';
            waypointEl.style.borderColor = '#ef4444';
          }
        });
        waypointEl.addEventListener('mouseleave', () => {
          if (!isDragging) {
            waypointEl.style.transform = 'scale(1)';
            waypointEl.style.background = '#ffffff';
            waypointEl.style.borderColor = '#3b82f6';
          }
        });

        // Track mousedown time to distinguish click from drag
        waypointEl.addEventListener('mousedown', (e) => {
          mouseDownTime = Date.now();
        });

        // Use mouseup with timing check - only delete if it was a quick click, not a drag
        waypointEl.addEventListener('mouseup', (e) => {
          e.stopPropagation();

          const clickDuration = Date.now() - mouseDownTime;

          // If click was longer than 200ms, treat it as a drag attempt, not a click
          if (clickDuration > 200) {

            return;
          }

          // Don't delete if we were dragging
          if (isDragging) {

            isDragging = false;
            return;
          }


          const index = parseInt(waypointEl.dataset.index);
          if (!isNaN(index) && index >= 0 && index < state.pathEditMode.currentPath.length) {
            state.pathEditMode.currentPath.splice(index, 1);
            state.pathEditMode.currentSegments = null; // Manual edit breaks segments
            state.pathEditMode.hasUnsavedChanges = true;
            updatePathEditStatus();
            updateWaypointCount();
            renderPathEditingView();
            showToast(`Waypoint ${index + 1} deleted`);
          }
        });


        if (coord[0] === 0 && coord[1] === 0) {
          console.error('[MARKER DEBUG] WARNING: Creating waypoint at 0,0!');
        }

        const marker = new maplibregl.Marker({
          element: waypointEl,
          draggable: true,
          anchor: 'center'
        })
          .setLngLat([coord[0], coord[1]])
          .on('dragstart', function() {
            isDragging = true;
          })
          .on('dragend', function() {
            isDragging = false;
            const lngLat = this.getLngLat();
            state.pathEditMode.currentPath[idx] = [lngLat.lng, lngLat.lat];
            state.pathEditMode.currentSegments = null; // Manual edit breaks segments
            state.pathEditMode.hasUnsavedChanges = true;
            updatePathEditStatus();
            // Update the path line using stored coordinates
            const src = state.pathEditMode.sourceCoords;
            const tgt = state.pathEditMode.targetCoords;
            const newPathCoords = [src, ...state.pathEditMode.currentPath, tgt];
            if (map.getSource('path-edit-current')) {
              map.getSource('path-edit-current').setData({
                type: 'Feature',
                geometry: { type: 'LineString', coordinates: newPathCoords }
              });
            }
          })
          .addTo(map);

        // Track this marker for cleanup
        pathEditMarkers.push(marker);

        // Log the marker's actual position after adding
        const pos = marker.getLngLat();

      });

      // === ENDPOINT MARKERS (create fresh each time since we cleared them above) ===
      const endpointMarkerA = document.createElement('div');
      endpointMarkerA.className = 'path-edit-endpoint path-edit-endpoint-a';
      endpointMarkerA.style.cssText = 'width:20px; height:20px; background:#22c55e; border:3px solid white; border-radius:50%; box-shadow:0 2px 6px rgba(0,0,0,0.3);';
      endpointMarkerA.title = `Source: ${sourceName}`;

      if (sourceCoords[0] === 0 && sourceCoords[1] === 0) {
        console.error('[MARKER DEBUG] WARNING: Creating source endpoint at 0,0!');
      }
      const markerA = new maplibregl.Marker({ element: endpointMarkerA, anchor: 'center' })
        .setLngLat(sourceCoords)
        .addTo(map);
      pathEditMarkers.push(markerA);

      const endpointMarkerB = document.createElement('div');
      endpointMarkerB.className = 'path-edit-endpoint path-edit-endpoint-b';
      endpointMarkerB.style.cssText = 'width:20px; height:20px; background:#ef4444; border:3px solid white; border-radius:50%; box-shadow:0 2px 6px rgba(0,0,0,0.3);';
      endpointMarkerB.title = `Target: ${targetName}`;

      if (targetCoords[0] === 0 && targetCoords[1] === 0) {
        console.error('[MARKER DEBUG] WARNING: Creating target endpoint at 0,0!');
      }
      const markerB = new maplibregl.Marker({ element: endpointMarkerB, anchor: 'center' })
        .setLngLat(targetCoords)
        .addTo(map);
      pathEditMarkers.push(markerB);



      // Fit bounds ONLY on very first render (when entering edit mode)
      // Don't re-fit when adding waypoints to avoid jarring camera movements
      if (!state.pathEditMode._boundsFitted) {
        const bounds = new maplibregl.LngLatBounds();
        bounds.extend(sourceCoords);
        bounds.extend(targetCoords);


        map.fitBounds(bounds, {
          padding: { top: 150, bottom: 200, left: 400, right: 150 },
          maxZoom: 10,
          duration: 1000
        });

        state.pathEditMode._boundsFitted = true;
      }

    } catch (err) {
      console.error('[PATH EDIT] Error rendering path:', err);
    }
  }

  // Clear MapLibre layers for path editing
  function clearPathEditLayers() {
    if (!mapLibreState.map) return;

    const map = mapLibreState.map;
    const layersToRemove = [
      'path-edit-baseline-layer',
      'path-edit-current-layer',
      'path-edit-waypoints-layer'
    ];
    const sourcesToRemove = [
      'path-edit-baseline',
      'path-edit-current',
      'path-edit-waypoints'
    ];

    layersToRemove.forEach(id => {
      if (map.getLayer(id)) {
        map.removeLayer(id);
      }
    });
    sourcesToRemove.forEach(id => {
      if (map.getSource(id)) {
        map.removeSource(id);
      }
    });

    // Remove endpoint markers
    document.querySelectorAll('.path-edit-endpoint').forEach(el => {
      el.closest('.maplibregl-marker')?.remove();
    });

    // Remove waypoint markers
    document.querySelectorAll('.path-edit-waypoint').forEach(el => {
      el.closest('.maplibregl-marker')?.remove();
    });
  }

  // Remove path from link
  function removePathFromLink(linkId) {
    const edge = findEdge(linkId);
    if (!edge) return;

    edge.cableGeometry = null;
    edge.pathSource = null;
    edge.pathCableRef = null;

    commit();
    render();
    if (mapLibreState.active && mapLibreState.map) {
      renderMapLibreContent();
    }
    updateInspector();
    showToast('Path removed from link');
  }

  // Expose functions globally
  window.enterPathEditMode = enterPathEditMode;
  window.exitPathEditMode = exitPathEditMode;
  window.updatePathGeometryUI = updatePathGeometryUI;
  window.removePathFromLink = removePathFromLink;
  window.updatePathEditStatus = updatePathEditStatus;
  window.updateWaypointCount = updateWaypointCount;
  window.renderPathEditingView = renderPathEditingView;
  window.clearPathEditLayers = clearPathEditLayers;

  // Manual path drawing functions
  function enableManualPathDrawing() {
    if (!mapLibreState.map) return;

    // Remove existing click handler if any
    mapLibreState.map.off('click', handleMapClickForPath);

    // Add click handler for adding waypoints
    mapLibreState.map.on('click', handleMapClickForPath);

    showToast('Click on map to add waypoints');
  }

  function handleMapClickForPath(e) {
    if (!state.pathEditMode.active || state.pathEditMode.editMethod !== 'manual') return;

    const lngLat = [e.lngLat.lng, e.lngLat.lat];
    state.pathEditMode.currentPath.push(lngLat);
    state.pathEditMode.currentSegments = null; // Manual edit breaks segments
    state.pathEditMode.hasUnsavedChanges = true;

    updatePathEditStatus();
    updateWaypointCount();
    renderPathEditingView();
  }

  // Handle KML/GeoJSON file import

function handlePathKmlImport(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(event) {
      try {
        // Collect coordinates as separate segments to preserve individual LineStrings
        let segments = [];

        if (file.name.endsWith('.kml')) {
          // Convert KML to GeoJSON (simplified parsing)
          const parser = new DOMParser();
          const kmlDoc = parser.parseFromString(event.target.result, 'text/xml');

          // Check for XML parse errors
          const parseErr = kmlDoc.querySelector('parsererror');
          if (parseErr) {
            showToast('KML parse error â€” file may be malformed');
            return;
          }

          // Extract each <coordinates> element as a separate segment
          const coordElements = kmlDoc.querySelectorAll('coordinates');
          coordElements.forEach(coordEl => {
            const coordText = coordEl.textContent.trim();
            const points = coordText.split(/\s+/);
            const segCoords = [];
            points.forEach(point => {
              const parts = point.split(',');
              if (parts.length >= 2) {
                const lon = parseFloat(parts[0]);
                const lat = parseFloat(parts[1]);
                if (isFinite(lon) && isFinite(lat) && Math.abs(lat) <= 90 && Math.abs(lon) <= 180) {
                  segCoords.push([lon, lat]);
                }
              }
            });
            if (segCoords.length > 0) {
              segments.push(segCoords);
            }
          });
        } else {
          // Parse GeoJSON - extract each LineString as a separate segment
          const geojson = JSON.parse(event.target.result);

          function extractSegments(geom) {
            if (!geom) return;
            switch (geom.type) {
              case 'LineString':
                if (geom.coordinates.length > 0) {
                  segments.push(geom.coordinates.map(c => [c[0], c[1]]));
                }
                break;
              case 'MultiLineString':
                geom.coordinates.forEach(ring => {
                  if (ring.length > 0) segments.push(ring.map(c => [c[0], c[1]]));
                });
                break;
              case 'Polygon':
                geom.coordinates.forEach(ring => {
                  if (ring.length > 0) segments.push(ring.map(c => [c[0], c[1]]));
                });
                break;
              case 'MultiPolygon':
                geom.coordinates.forEach(poly => poly.forEach(ring => {
                  if (ring.length > 0) segments.push(ring.map(c => [c[0], c[1]]));
                }));
                break;
              case 'Point':
                segments.push([geom.coordinates]);
                break;
              case 'MultiPoint':
                geom.coordinates.forEach(c => segments.push([c]));
                break;
              case 'GeometryCollection':
                (geom.geometries || []).forEach(g => extractSegments(g));
                break;
            }
          }

          if (geojson.type === 'FeatureCollection') {
            (geojson.features || []).forEach(f => extractSegments(f.geometry));
          } else if (geojson.type === 'Feature') {
            extractSegments(geojson.geometry);
          } else {
            extractSegments(geojson);
          }
        }

        // Flatten segments into a single array for currentPath (backward compat)
        const coordinates = segments.reduce((acc, seg) => acc.concat(seg), []);

        if (coordinates.length === 0) {
          showToast('No coordinates found in file. Check the format.');
          return;
        }

        state.pathEditMode.currentPath = coordinates;
        // Store separate segments for MultiLineString rendering (preserves separate lines)
        state.pathEditMode.currentSegments = segments.length > 1 ? segments : null;
        state.pathEditMode.hasUnsavedChanges = true;
        state.pathEditMode.editMethod = 'kml-import';

        // Update instructions to show success and allow re-import
        const instructions = document.getElementById('pathEditInstructions');
        if (instructions) {
          const segInfo = segments.length > 1 ? ` (${segments.length} segments)` : '';
          instructions.innerHTML = '<strong>Imported:</strong> ' + coordinates.length + ' waypoints' + segInfo + ' from <em>' + file.name + '</em>. <a href="#" id="pathReImportLink" style="color:#0369a1; text-decoration:underline;">Import another file</a>';
          document.getElementById('pathReImportLink')?.addEventListener('click', (ev) => {
            ev.preventDefault();
            const reInput = document.createElement('input');
            reInput.type = 'file';
            reInput.accept = '.kml,.geojson,.json';
            reInput.style.display = 'none';
            reInput.addEventListener('change', (e2) => {
              handlePathKmlImport(e2);
              reInput.remove();
            });
            document.body.appendChild(reInput);
            reInput.click();
          });
        }

        updatePathEditStatus();
        updateWaypointCount();
        renderPathEditingView();

        const segMsg = segments.length > 1 ? ` (${segments.length} segments)` : '';
        showToast(`Imported ${coordinates.length} waypoints${segMsg} from ${file.name}`);
      } catch (err) {
        console.error('[PATH EDIT] Error parsing file:', err);
        showToast('Error parsing file: ' + err.message);
      }
    };
    reader.readAsText(file);
  }

  window.enableManualPathDrawing = enableManualPathDrawing;
  window.handlePathKmlImport = handlePathKmlImport;

  // ============== TELEGEOGRAPHY CABLE IMPORT ==============

  // Embedded submarine cable data (curated from public sources)
  // These are simplified routes for major cables - coordinates are [lon, lat]
  // ============== EXTERNAL SUBMARINE CABLE DATABASE ==============

  // URL to the external submarine cable database
  const SUBMARINE_CABLE_DB_URL = './data/submarine_cables_db.json';

  // Cache for loaded cable data
  let submarineCableCache = null;
  let cableDbLoadPromise = null;

  // Load submarine cable database from external JSON file
  async function loadSubmarineCableDb() {
    // Return cached data if available
    if (submarineCableCache) {
      return submarineCableCache;
    }

    // Return existing promise if already loading
    if (cableDbLoadPromise) {
      return cableDbLoadPromise;
    }

    // Start loading
    cableDbLoadPromise = (async () => {
      try {
        const response = await fetch(SUBMARINE_CABLE_DB_URL);
        if (!response.ok) {
          throw new Error(`Failed to load cable database: ${response.status}`);
        }
        const data = await response.json();

        // Transform the data into the format expected by NexiMap
        submarineCableCache = transformCableDatabase(data);
        return submarineCableCache;
      } catch (error) {
        console.error('[NexiMap] Error loading submarine cable database:', error);
        cableDbLoadPromise = null; // Allow retry
        throw error;
      }
    })();

    return cableDbLoadPromise;
  }

  // Transform external database format to NexiMap internal format
  function transformCableDatabase(dbData) {
    const cables = {};

    if (!dbData || !dbData.cables) {
      console.warn('[NexiMap] Invalid cable database format');
      return { cables: {} };
    }

    for (const [key, cable] of Object.entries(dbData.cables)) {
      // Build description from landing points
      const landingPointNames = cable.landingPoints?.map(lp => `${lp.name}, ${lp.country}`).join(' â†’ ') || '';
      const ownersList = cable.owners?.join(', ') || 'Unknown';

      // Check if this is a MultiLineString with multiple segments
      const isMultiSegment = cable.geometry?.type === 'MultiLineString' &&
                             cable.geometry?.coordinates?.length > 1;

      // Resolve status: if 'Unknown' or missing, infer from RFS year
      let resolvedStatus = cable.status || 'Unknown';
      if (resolvedStatus === 'Unknown' || resolvedStatus === '') {
        const rfsCheck = cable.rfsYear || parseInt(cable.rfs);
        const curYear = new Date().getFullYear();
        if (!isNaN(rfsCheck) && rfsCheck <= curYear) {
          resolvedStatus = 'Active';
        } else if (!isNaN(rfsCheck) && rfsCheck <= curYear + 2) {
          resolvedStatus = 'Under Construction';
        } else if (!isNaN(rfsCheck)) {
          resolvedStatus = 'Planned';
        }
      }

      cables[key] = {
        id: cable.id || key,
        name: cable.name,
        shortName: cable.shortName || cable.name,  // Include shortName from JSON
        description: landingPointNames || `${cable.region} submarine cable`,
        region: cable.region || 'Unknown',
        rfs: cable.rfs || 'Unknown',
        length: cable.length_km ? `${cable.length_km.toLocaleString()} km` : 'Unknown',
        length_km: cable.length_km || 0,
        owners: cable.owners || [],
        ownersText: ownersList,
        fiberPairs: cable.fiberPairs || 0,
        designCapacity: cable.designCapacity || 'Unknown',
        landingPoints: cable.landingPoints || [],
        geometry: cable.geometry,
        segments: cable.segments || null, // Named segments if available
        isMultiSegment: isMultiSegment,
        segmentCount: isMultiSegment ? cable.geometry.coordinates.length : 1,
        // Enriched metadata fields
        status: resolvedStatus,                      // 'Active', 'Under Construction', 'Planned'
        rfsYear: cable.rfsYear || null,              // Numeric year (e.g., 2022)
        capacityTbps: cable.capacityTbps || null     // Total capacity in Tbps (e.g., 200)
      };
    }

    return { cables: cables };
  }

  // Extract coordinates from GeoJSON geometry (LineString or MultiLineString)
  // Can extract specific segments if selectedSegments array is provided
  function extractCoordinatesFromGeometry(geometry, selectedSegments = null) {
    if (!geometry || !geometry.coordinates) {
      return [];
    }

    let allCoords = [];

    if (geometry.type === 'LineString') {
      // Simple LineString: [[lng, lat], [lng, lat], ...]
      allCoords = geometry.coordinates.map(coord => [coord[0], coord[1]]);
    } else if (geometry.type === 'MultiLineString') {
      // MultiLineString: [[[lng, lat], ...], [[lng, lat], ...], ...]
      // If selectedSegments is provided, only include those segments
      const segmentsToInclude = selectedSegments ||
        Array.from({length: geometry.coordinates.length}, (_, i) => i);

      for (const segmentIndex of segmentsToInclude) {
        if (segmentIndex >= 0 && segmentIndex < geometry.coordinates.length) {
          const segment = geometry.coordinates[segmentIndex];
          for (let j = 0; j < segment.length; j++) {
            const coord = [segment[j][0], segment[j][1]];

            // Skip if it's the same as the last point (junction point)
            if (allCoords.length > 0) {
              const last = allCoords[allCoords.length - 1];
              if (Math.abs(last[0] - coord[0]) < 0.0001 && Math.abs(last[1] - coord[1]) < 0.0001) {
                continue;
              }
            }

            allCoords.push(coord);
          }
        }
      }
    }

    return allCoords;
  }

  // Reduce waypoints if too many (keep shape but reduce complexity)
  function reduceWaypoints(coordinates, maxPoints = 100) {
    if (coordinates.length <= maxPoints) {
      return coordinates;
    }

    // Always keep first and last points
    const result = [coordinates[0]];

    // Calculate step to get roughly maxPoints
    const step = (coordinates.length - 2) / (maxPoints - 2);

    for (let i = 1; i < maxPoints - 1; i++) {
      const idx = Math.round(i * step);
      if (idx < coordinates.length - 1) {
        result.push(coordinates[idx]);
      }
    }

    // Add last point
    result.push(coordinates[coordinates.length - 1]);

    return result;
  }

  // Currently selected cable for segment selection
  let currentSelectedCable = null;
  let currentSelectedSegments = [];

  // Show Cable Database search interface
  async function showCableDbSearch() {
    const instructions = document.getElementById('pathEditInstructions');
    if (!instructions) return;

    // Reset selection state
    currentSelectedCable = null;
    currentSelectedSegments = [];

    // Show loading state
    instructions.innerHTML = `
      <div style="text-align: center; padding: 20px;">
        <div style="font-size: 24px; margin-bottom: 10px;">ðŸŒ</div>
        <div style="color: #666;">Loading submarine cable database...</div>
      </div>
    `;

    try {
      // Load the cable database
      const db = await loadSubmarineCableDb();
      const cables = db.cables || {};
      const cableCount = Object.keys(cables).length;

      if (cableCount === 0) {
        instructions.innerHTML = `
          <div style="color: #ef4444; padding: 10px;">
            âš ï¸ No cables found in database. Please check the data file.
          </div>
        `;
        return;
      }

      // Sort cables alphabetically by name
      const sortedCables = Object.entries(cables)
        .sort((a, b) => a[1].name.localeCompare(b[1].name));

      // Get unique regions for filtering
      const regions = [...new Set(Object.values(cables).map(c => c.region))].sort();

      // Build region filter options
      const regionOptions = regions.map(r => `<option value="${r}">${r}</option>`).join('');

      // Build cable list HTML (alphabetically sorted)
      const cableOptions = sortedCables.map(([key, cable]) => {
        const multiIcon = cable.isMultiSegment ? ' ðŸ”€' : '';
        return `<option value="${key}" data-region="${cable.region}">${cable.name}${multiIcon}</option>`;
      }).join('');

      instructions.innerHTML = `
        <div style="margin-bottom: 10px;">
          <strong>ðŸŒ Submarine Cable Database</strong>
          <span style="font-size: 10px; color: #888; margin-left: 8px;">${cableCount} cables</span>
        </div>

        <div style="margin-bottom: 8px;">
          <input type="text" id="cableSearchInput" placeholder="Search cables by name, owner..."
            style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; box-sizing: border-box;" />
        </div>

        <div style="margin-bottom: 8px;">
          <select id="cableRegionFilter" style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; font-size: 11px;">
            <option value="">All Corridors</option>
            ${regionOptions}
          </select>
        </div>

        <div style="margin-bottom: 10px;">
          <select id="cableDbSelect" size="6" style="width: 100%; padding: 4px; border: 1px solid #ccc; border-radius: 4px; font-size: 11px;">
            ${cableOptions}
          </select>
        </div>

        <div id="cableDbInfo" style="font-size: 11px; color: #666; margin-bottom: 10px; min-height: 60px; max-height: 100px; overflow-y: auto; background: #f8f9fa; padding: 8px; border-radius: 4px;">
          Select a cable to see details.<br>
          <span style="font-size: 10px; color: #888;">ðŸ”€ = Multiple segments (you can select which ones to import)</span>
        </div>

        <div id="segmentSelectorContainer" style="display: none; margin-bottom: 10px;">
          <!-- Segment checkboxes will be inserted here -->
        </div>

        <button id="btnCableDbImport" style="padding: 8px 16px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%; font-weight: 500;" disabled>
          ðŸ“¥ Import Selected Cable
        </button>

        <div style="margin-top: 10px; font-size: 10px; color: #888;">
          Data: Public Cable System DB + NexiMap enrichment<br>
          For unlisted cables, use <strong>Import KML/GeoJSON</strong>.
        </div>
      `;

      // Set up event handlers
      setupCableDbEventHandlers(cables);

    } catch (error) {
      instructions.innerHTML = `
        <div style="color: #ef4444; padding: 10px;">
          âš ï¸ Failed to load cable database:<br>
          <span style="font-size: 11px;">${error.message}</span>
          <div style="margin-top: 10px;">
            <button onclick="window.showCableDbSearch()" style="padding: 6px 12px; background: #f3f4f6; border: 1px solid #ccc; border-radius: 4px; cursor: pointer;">
              ðŸ”„ Retry
            </button>
          </div>
        </div>
      `;
    }
  }

  // Set up event handlers for cable database UI
  function setupCableDbEventHandlers(cables) {
    const searchInput = document.getElementById('cableSearchInput');
    const regionFilter = document.getElementById('cableRegionFilter');
    const select = document.getElementById('cableDbSelect');
    const importBtn = document.getElementById('btnCableDbImport');
    const infoDiv = document.getElementById('cableDbInfo');
    const segmentContainer = document.getElementById('segmentSelectorContainer');

    // Filter function
    function filterCables() {
      const searchTerm = searchInput?.value.toLowerCase() || '';
      const selectedRegion = regionFilter?.value || '';

      const options = select?.querySelectorAll('option');
      options?.forEach(option => {
        const cableKey = option.value;
        const cable = cables[cableKey];
        if (!cable) return;

        const matchesSearch =
          cable.name.toLowerCase().includes(searchTerm) ||
          cable.ownersText.toLowerCase().includes(searchTerm) ||
          cable.description.toLowerCase().includes(searchTerm);

        const matchesRegion = !selectedRegion || cable.region === selectedRegion;

        option.style.display = (matchesSearch && matchesRegion) ? '' : 'none';
      });
    }

    // Search input handler
    searchInput?.addEventListener('input', filterCables);

    // Region filter handler
    regionFilter?.addEventListener('change', filterCables);

    // Cable selection handler
    select?.addEventListener('change', () => {
      const cableKey = select.value;
      if (cableKey && cables[cableKey]) {
        const cable = cables[cableKey];
        currentSelectedCable = cable;

        // Build landing points list
        const landingPointsHtml = cable.landingPoints.length > 0
          ? cable.landingPoints.map(lp => `<span style="background: #e5e7eb; padding: 1px 4px; border-radius: 2px; margin-right: 3px; display: inline-block; margin-bottom: 2px;">${lp.name}</span>`).join('')
          : '<em>Not specified</em>';

        infoDiv.innerHTML = `
          <div style="margin-bottom: 6px;">
            <strong style="font-size: 13px; color: #111;">${cable.name}</strong>
            ${cable.isMultiSegment ? '<span style="font-size: 10px; background: #dbeafe; color: #1d4ed8; padding: 1px 4px; border-radius: 3px; margin-left: 6px;">ðŸ”€ Multi-segment</span>' : ''}
            <span style="font-size: 10px; color: #888; margin-left: 6px;">${cable.region}</span>
          </div>
          <div style="margin-bottom: 4px; font-size: 10px;">
            <span style="color: #666;">RFS:</span> <strong>${cable.rfs}</strong> &nbsp;|&nbsp;
            <span style="color: #666;">Length:</span> <strong>${cable.length}</strong> &nbsp;|&nbsp;
            <span style="color: #666;">Fiber Pairs:</span> <strong>${cable.fiberPairs || '?'}</strong>
          </div>
          <div style="margin-bottom: 4px; font-size: 10px;">
            <span style="color: #666;">Capacity:</span> <strong>${cable.designCapacity}</strong>
          </div>
          <div style="margin-bottom: 4px; font-size: 10px;">
            <span style="color: #666;">Owners:</span> ${cable.ownersText}
          </div>
          <div style="font-size: 10px;">
            <span style="color: #666;">Landing Points:</span><br>
            ${landingPointsHtml}
          </div>
        `;

        // Show segment selector if this is a multi-segment cable
        if (cable.isMultiSegment && segmentContainer) {
          // Reset selected segments - select all by default
          currentSelectedSegments = Array.from({length: cable.segmentCount}, (_, i) => i);

          // Build segment checkboxes
          let segmentHtml = `
            <div style="font-size: 11px; font-weight: 600; margin-bottom: 6px; color: #374151;">
              ðŸ“ Select Segments to Import:
              <button id="btnSelectAllSegments" style="margin-left: 8px; font-size: 10px; padding: 2px 6px; border: 1px solid #ccc; border-radius: 3px; background: #fff; cursor: pointer;">All</button>
              <button id="btnSelectNoneSegments" style="margin-left: 4px; font-size: 10px; padding: 2px 6px; border: 1px solid #ccc; border-radius: 3px; background: #fff; cursor: pointer;">None</button>
            </div>
            <div style="max-height: 100px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 4px; padding: 6px; background: #fff;">
          `;

          for (let i = 0; i < cable.segmentCount; i++) {
            const segmentName = cable.segments?.[i]?.name || `Segment ${i + 1}`;
            const coordCount = cable.geometry.coordinates[i]?.length || 0;
            segmentHtml += `
              <label style="display: flex; align-items: center; gap: 6px; padding: 3px 0; cursor: pointer; font-size: 11px;">
                <input type="checkbox" class="segment-checkbox" data-index="${i}" checked style="cursor: pointer;">
                <span>${segmentName}</span>
                <span style="color: #999; font-size: 9px;">(${coordCount} pts)</span>
              </label>
            `;
          }

          segmentHtml += `</div>`;
          segmentContainer.innerHTML = segmentHtml;
          segmentContainer.style.display = 'block';

          // Set up segment checkbox handlers
          segmentContainer.querySelectorAll('.segment-checkbox').forEach(cb => {
            cb.addEventListener('change', () => {
              updateSelectedSegments();
            });
          });

          // Select All button
          document.getElementById('btnSelectAllSegments')?.addEventListener('click', () => {
            segmentContainer.querySelectorAll('.segment-checkbox').forEach(cb => cb.checked = true);
            updateSelectedSegments();
          });

          // Select None button
          document.getElementById('btnSelectNoneSegments')?.addEventListener('click', () => {
            segmentContainer.querySelectorAll('.segment-checkbox').forEach(cb => cb.checked = false);
            updateSelectedSegments();
          });

        } else if (segmentContainer) {
          segmentContainer.style.display = 'none';
          currentSelectedSegments = [];
        }

        importBtn.disabled = false;
      } else {
        infoDiv.innerHTML = 'Select a cable to see details.<br><span style="font-size: 10px; color: #888;">ðŸ”€ = Multiple segments (you can select which ones to import)</span>';
        importBtn.disabled = true;
        if (segmentContainer) segmentContainer.style.display = 'none';
      }
    });

    // Update selected segments from checkboxes
    function updateSelectedSegments() {
      currentSelectedSegments = [];
      segmentContainer?.querySelectorAll('.segment-checkbox:checked').forEach(cb => {
        currentSelectedSegments.push(parseInt(cb.dataset.index));
      });

      // Update import button state
      if (importBtn) {
        importBtn.disabled = currentSelectedCable?.isMultiSegment && currentSelectedSegments.length === 0;
      }
    }

    // Double-click to import
    select?.addEventListener('dblclick', () => {
      const cableKey = select.value;
      if (cableKey && cables[cableKey]) {
        importCableFromDb(cables[cableKey], currentSelectedSegments, false);
      }
    });

    // Import button handler
    importBtn?.addEventListener('click', () => {
      const cableKey = select?.value;
      if (cableKey && cables[cableKey]) {
        importCableFromDb(cables[cableKey], currentSelectedSegments, true);
      }
    });
  }

  // Import a cable from the database
  // If showLiveEditor is true, keep the segment selector visible for live editing
  function importCableFromDb(cable, selectedSegments = null, showLiveEditor = false) {
    if (!cable || !cable.geometry) {
      showToast('Invalid cable data - no geometry found');
      return;
    }

    // Extract coordinates, optionally filtering by selected segments
    const segmentsToUse = (cable.isMultiSegment && selectedSegments && selectedSegments.length > 0)
      ? selectedSegments
      : null;

    let waypoints = extractCoordinatesFromGeometry(cable.geometry, segmentsToUse);

    if (waypoints.length === 0) {
      showToast('No coordinates found for selected segments');
      return;
    }

    // Reduce waypoints if there are too many
    if (waypoints.length > 150) {
      const originalCount = waypoints.length;
      waypoints = reduceWaypoints(waypoints, 150);
      console.log(`[NexiMap] Reduced waypoints from ${originalCount} to ${waypoints.length}`);
    }

    // Apply to current path
    state.pathEditMode.currentPath = waypoints;
    state.pathEditMode.hasUnsavedChanges = true;
    state.pathEditMode.editMethod = 'telegeography';

    // Store reference on the edge
    const edge = findEdge(state.pathEditMode.linkId);
    if (edge) {
      edge.pathCableRef = cable.name;
      edge.pathCableId = cable.id;
      if (segmentsToUse) {
        edge.pathCableSegments = segmentsToUse;
      }
      // Store original full-fidelity geometry for map rendering
      if (segmentsToUse && cable.geometry.type === 'MultiLineString') {
        const filteredCoords = segmentsToUse
          .filter(i => i >= 0 && i < cable.geometry.coordinates.length)
          .map(i => cable.geometry.coordinates[i]);
        edge.cableGeometry = filteredCoords.length === 1
          ? { type: 'LineString', coordinates: filteredCoords[0] }
          : { type: 'MultiLineString', coordinates: filteredCoords };
      } else {
        edge.cableGeometry = JSON.parse(JSON.stringify(cable.geometry));
      }
    }

    // Update UI
    updatePathEditStatus();
    updateWaypointCount();
    renderPathEditingView();

    // Build segment info for display
    const instructions = document.getElementById('pathEditInstructions');

    // If multi-segment cable and showLiveEditor, show live segment editor
    if (cable.isMultiSegment && showLiveEditor && instructions) {
      showLiveSegmentEditor(cable, segmentsToUse || []);
    } else if (instructions) {
      // Show simple success message
      let segmentInfo = '';
      if (cable.isMultiSegment && segmentsToUse) {
        const segmentNames = segmentsToUse.map(i => cable.segments?.[i]?.name || `Segment ${i + 1}`).join(', ');
        segmentInfo = `<br><span style="color: #888;">Segments: ${segmentNames}</span>`;
      }

      instructions.innerHTML = `
        <div style="color: #10b981; font-weight: 500; margin-bottom: 8px;">
          âœ… Imported "${cable.name}"
        </div>
        <div style="font-size: 11px; color: #666; background: #f0fdf4; padding: 8px; border-radius: 4px; border: 1px solid #86efac;">
          <strong>${waypoints.length} waypoints</strong> loaded<br>
          <span style="color: #888;">${cable.region} â€¢ RFS ${cable.rfs} â€¢ ${cable.length}</span><br>
          <span style="color: #888;">${cable.ownersText}</span>
          ${segmentInfo}
        </div>
        <div style="font-size: 11px; color: #666; margin-top: 8px;">
          Click <strong>Save</strong> to apply this path, or switch to <strong>Manual</strong> mode to edit waypoints.
        </div>
        <button onclick="window.showCableDbSearch()" style="margin-top: 10px; padding: 6px 12px; background: #f3f4f6; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 11px;">
          â† Select Different Cable
        </button>
      `;
    }

    const segmentText = cable.isMultiSegment && segmentsToUse
      ? ` (${segmentsToUse.length} of ${cable.segmentCount} segments)`
      : '';
    showToast(`Imported ${waypoints.length} waypoints from ${cable.name}${segmentText}`);
  }

  // Show live segment editor after import - allows toggling segments and seeing changes on map
  function showLiveSegmentEditor(cable, initialSelectedSegments) {
    const instructions = document.getElementById('pathEditInstructions');
    if (!instructions) return;

    // Store current cable for live updates
    currentSelectedCable = cable;
    currentSelectedSegments = [...initialSelectedSegments];

    // Build the live editor UI
    let segmentListHtml = '';
    for (let i = 0; i < cable.segmentCount; i++) {
      const seg = cable.segments?.[i] || {};
      const segmentName = seg.name || `Segment ${i + 1}`;
      const description = seg.description || '';
      const isChecked = currentSelectedSegments.includes(i);
      const coordCount = cable.geometry.coordinates[i]?.length || 0;
      const approxKm = seg.approxLength_km ? `~${seg.approxLength_km} km` : `${coordCount} pts`;

      segmentListHtml += `
        <label style="display: flex; align-items: flex-start; gap: 8px; padding: 6px 8px; cursor: pointer; font-size: 11px; background: ${isChecked ? '#f0fdf4' : '#fff'}; border: 1px solid ${isChecked ? '#86efac' : '#e5e7eb'}; border-radius: 4px; margin-bottom: 4px;">
          <input type="checkbox" class="live-segment-checkbox" data-index="${i}" ${isChecked ? 'checked' : ''} style="cursor: pointer; margin-top: 2px;">
          <div style="flex: 1;">
            <div style="font-weight: 500; color: #111;">${segmentName}</div>
            <div style="font-size: 10px; color: #666;">${approxKm}</div>
            ${description && description !== segmentName ? `<div style="font-size: 9px; color: #888; margin-top: 2px;">${description}</div>` : ''}
          </div>
        </label>
      `;
    }

    instructions.innerHTML = `
      <div style="color: #10b981; font-weight: 500; margin-bottom: 8px; display: flex; align-items: center; justify-content: space-between;">
        <span>âœ… ${cable.name}</span>
        <span style="font-size: 10px; font-weight: normal; color: #666;">${cable.length}</span>
      </div>

      <div style="font-size: 11px; font-weight: 600; margin-bottom: 6px; color: #374151; display: flex; align-items: center; justify-content: space-between;">
        <span>ðŸ“ Toggle Segments (live preview):</span>
        <div>
          <button id="btnLiveSelectAll" style="font-size: 9px; padding: 2px 6px; border: 1px solid #ccc; border-radius: 3px; background: #fff; cursor: pointer; margin-right: 4px;">All</button>
          <button id="btnLiveSelectNone" style="font-size: 9px; padding: 2px 6px; border: 1px solid #ccc; border-radius: 3px; background: #fff; cursor: pointer;">None</button>
        </div>
      </div>

      <div id="liveSegmentList" style="max-height: 180px; overflow-y: auto; margin-bottom: 10px;">
        ${segmentListHtml}
      </div>

      <div style="font-size: 10px; color: #666; background: #f8f9fa; padding: 6px 8px; border-radius: 4px; margin-bottom: 8px;">
        <strong id="liveWaypointInfo">${state.pathEditMode.currentPath?.length || 0} waypoints</strong> from
        <strong>${currentSelectedSegments.length}</strong> of ${cable.segmentCount} segments
      </div>

      <div style="font-size: 10px; color: #666;">
        Toggle checkboxes to see changes on map instantly.<br>
        Click <strong>Save</strong> when done.
      </div>

      <button onclick="window.showCableDbSearch()" style="margin-top: 8px; padding: 6px 12px; background: #f3f4f6; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 11px;">
        â† Select Different Cable
      </button>
    `;

    // Set up live toggle handlers
    const checkboxes = instructions.querySelectorAll('.live-segment-checkbox');
    checkboxes.forEach(cb => {
      cb.addEventListener('change', () => {
        updateLiveSegments(cable);
      });
    });

    // Select All button
    document.getElementById('btnLiveSelectAll')?.addEventListener('click', () => {
      instructions.querySelectorAll('.live-segment-checkbox').forEach(cb => cb.checked = true);
      updateLiveSegments(cable);
    });

    // Select None button
    document.getElementById('btnLiveSelectNone')?.addEventListener('click', () => {
      instructions.querySelectorAll('.live-segment-checkbox').forEach(cb => cb.checked = false);
      updateLiveSegments(cable);
    });
  }

  // Update path live when segments are toggled
  function updateLiveSegments(cable) {
    const instructions = document.getElementById('pathEditInstructions');
    if (!instructions) return;

    // Get currently checked segments
    currentSelectedSegments = [];
    instructions.querySelectorAll('.live-segment-checkbox:checked').forEach(cb => {
      currentSelectedSegments.push(parseInt(cb.dataset.index));
    });

    // Update visual state of checkboxes
    instructions.querySelectorAll('.live-segment-checkbox').forEach(cb => {
      const label = cb.closest('label');
      if (label) {
        label.style.background = cb.checked ? '#f0fdf4' : '#fff';
        label.style.borderColor = cb.checked ? '#86efac' : '#e5e7eb';
      }
    });

    // Extract new waypoints
    let waypoints = extractCoordinatesFromGeometry(cable.geometry,
      currentSelectedSegments.length > 0 ? currentSelectedSegments : null);

    // Reduce if needed
    if (waypoints.length > 150) {
      waypoints = reduceWaypoints(waypoints, 150);
    }

    // Update the path
    state.pathEditMode.currentPath = waypoints;
    state.pathEditMode.hasUnsavedChanges = true;

    // Update edge reference
    const edge = findEdge(state.pathEditMode.linkId);
    if (edge) {
      edge.pathCableSegments = currentSelectedSegments.length > 0 ? [...currentSelectedSegments] : null;
      // Update full-fidelity geometry for map rendering
      const segsToUse = currentSelectedSegments.length > 0 ? currentSelectedSegments : null;
      if (segsToUse && cable.geometry.type === 'MultiLineString') {
        const filteredCoords = segsToUse
          .filter(i => i >= 0 && i < cable.geometry.coordinates.length)
          .map(i => cable.geometry.coordinates[i]);
        edge.cableGeometry = filteredCoords.length === 1
          ? { type: 'LineString', coordinates: filteredCoords[0] }
          : { type: 'MultiLineString', coordinates: filteredCoords };
      } else {
        edge.cableGeometry = JSON.parse(JSON.stringify(cable.geometry));
      }
    }

    // Update UI
    updatePathEditStatus();
    updateWaypointCount();
    renderPathEditingView();

    // Update info display
    const infoEl = document.getElementById('liveWaypointInfo');
    if (infoEl) {
      infoEl.textContent = `${waypoints.length} waypoints`;
    }

    // Update parent info
    const parentInfo = infoEl?.closest('div');
    if (parentInfo) {
      parentInfo.innerHTML = `<strong id="liveWaypointInfo">${waypoints.length} waypoints</strong> from <strong>${currentSelectedSegments.length}</strong> of ${cable.segmentCount} segments`;
    }
  }

  // Expose functions globally
  window.showCableDbSearch = showCableDbSearch;
  window.loadSubmarineCableDb = loadSubmarineCableDb;

  // Pre-load the database in the background after a short delay
  setTimeout(() => {
    loadSubmarineCableDb().then(db => {
      const cables = db.cables || {};
      console.log(`[NexiMap] Submarine cable database loaded: ${Object.keys(cables).length} cables`);
    }).catch(err => {
      console.warn('[NexiMap] Failed to preload cable database:', err.message);
    });
  }, 2000);

  // ============== END EXTERNAL SUBMARINE CABLE DATABASE ==============


  // Initialize MapLibre map
  function initMapLibre() {
    if (mapLibreState.map) return; // Already initialized

    const container = document.getElementById('maplibreMap');
    if (!container) return;

    // Set container size
    container.style.width = '100%';
    container.style.height = '100%';

    // Load saved settings
    try {
      const savedSettings = localStorage.getItem('neximap-maplibre-settings');
      if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        if (settings.defaultLinkColor) mapLibreState.defaultLinkColor = settings.defaultLinkColor;
        if (settings.defaultLinkWidth) mapLibreState.defaultLinkWidth = settings.defaultLinkWidth;
        if (settings.useCanvasColors !== undefined) mapLibreState.useCanvasColors = settings.useCanvasColors;
      }
    } catch(e) {}

    try {
      mapLibreState.map = new maplibregl.Map({
        container: 'maplibreMap',
        style: mapLibreState.styles[mapLibreState.style],
        center: [0, 20], // Default center
        zoom: 1.5,
        attributionControl: true
      });

      // Add navigation controls
      mapLibreState.map.addControl(new maplibregl.NavigationControl(), 'top-right');

      // Add scale control
      mapLibreState.map.addControl(new maplibregl.ScaleControl({ unit: 'metric' }), 'bottom-left');

      // When map style is fully loaded, render the nodes
      mapLibreState.map.on('load', () => {
        mapLibreState.isStyleLoaded = true;

        // Only render normal content if NOT in path edit mode
        if (state.pathEditMode && state.pathEditMode.active) {
          console.log('[MAP LOAD] Skipping renderMapLibreContent - path edit mode active');
        } else {
          renderMapLibreContent();
        }

        // Set up a PERSISTENT click handler for edge selection
        // This uses queryRenderedFeatures with a bbox for better hit detection
        mapLibreState.map.on('click', (e) => {
          if (!mapLibreState.selectionEnabled) return;

          // Check if the hitarea layer exists
          if (!mapLibreState.map.getLayer('neximap-edges-hitarea')) return;

          // Query with a tolerance box around the click point for better detection
          const tolerance = 4; // pixels â€“ keep tight so nearby cables can be distinguished
          const bbox = [
            [e.point.x - tolerance, e.point.y - tolerance],
            [e.point.x + tolerance, e.point.y + tolerance]
          ];

          // Try querying the hit area layer first
          let features = mapLibreState.map.queryRenderedFeatures(bbox, {
            layers: ['neximap-edges-hitarea']
          });

          // If no features found in hit area, try the visible layer as fallback
          if (features.length === 0 && mapLibreState.map.getLayer('neximap-edges-layer')) {
            features = mapLibreState.map.queryRenderedFeatures(bbox, {
              layers: ['neximap-edges-layer']
            });
          }

          if (features.length === 0) return;

          // Filter out glow features and find the closest one to click point
          const validFeatures = features.filter(f => !f.properties.isGlow && f.properties.id);
          if (validFeatures.length === 0) return;

          // Use the first valid feature
          const clickedFeature = validFeatures[0];
          const clickedId = clickedFeature.properties.id;

          // Prevent event from being handled by the deselect handler
          e.preventDefault();
          e.defaultPrevented = true;
          mapLibreState._edgeClickHandled = true;

          // Check if route finder is active with link pick modes
          if (window.routeFinderState && window.routeFinderState.active) {
            const edge = state.edges.find(ed => ed.id === clickedId || `edge-${state.edges.indexOf(ed)}` === clickedId);
            if (edge) {
              const edgeId = edge.id || clickedId;
              if (routeFinderState.pickMode === 'excludeLink') {
                if (typeof addExcludedLink === 'function') {
                  addExcludedLink(edgeId);
                }
                routeFinderState.pickMode = null;
                if (typeof updatePickModeButtons === 'function') {
                  updatePickModeButtons();
                }
                mapLibreState.skipFitBounds = true;
                renderMapLibreContent();
                return;
              }
              if (routeFinderState.pickMode === 'mustUseLink') {
                if (typeof addMustUseLink === 'function') {
                  addMustUseLink(edgeId);
                }
                routeFinderState.pickMode = null;
                if (typeof updatePickModeButtons === 'function') {
                  updatePickModeButtons();
                }
                mapLibreState.skipFitBounds = true;
                renderMapLibreContent();
                return;
              }
            }
            // Route finder is active but no pick mode - don't select edges
            return;
          }

          // Normal selection (route finder not active)
          selectEdgeOnMap(clickedId, e.originalEvent?.shiftKey);
        });

        // Set up persistent mousemove handler for cursor changes
        mapLibreState.map.on('mousemove', (e) => {
          if (!mapLibreState.selectionEnabled) return;

          if (!mapLibreState.map.getLayer('neximap-edges-hitarea') &&
              !mapLibreState.map.getLayer('neximap-edges-layer')) {
            return;
          }

          // Use bbox for more reliable hover detection
          const tolerance = 4;
          const bbox = [
            [e.point.x - tolerance, e.point.y - tolerance],
            [e.point.x + tolerance, e.point.y + tolerance]
          ];

          let features = [];
          if (mapLibreState.map.getLayer('neximap-edges-hitarea')) {
            features = mapLibreState.map.queryRenderedFeatures(bbox, {
              layers: ['neximap-edges-hitarea']
            });
          }
          if (features.length === 0 && mapLibreState.map.getLayer('neximap-edges-layer')) {
            features = mapLibreState.map.queryRenderedFeatures(bbox, {
              layers: ['neximap-edges-layer']
            });
          }

          if (features.length > 0 && features.some(f => !f.properties.isGlow && f.properties.id)) {
            mapLibreState.map.getCanvas().style.cursor = 'pointer';
          } else {
            mapLibreState.map.getCanvas().style.cursor = '';
          }
        });
      });

      // Handle style changes - wait for style to fully load before re-rendering
      mapLibreState.map.on('style.load', () => {
        console.log('[MapLibre] Style loaded, re-rendering content');
        mapLibreState.isStyleLoaded = true;

        if (mapLibreState.active) {
          // Small delay to ensure style is fully applied
          setTimeout(() => {
            mapLibreState.skipFitBounds = true; // Don't re-center the map
            renderMapLibreContent();
          }, 100);
        }
      });

    } catch (e) {
      console.error('Failed to initialize MapLibre:', e);
      showToast('âš ï¸ Failed to load interactive map. Check your internet connection.');
    }
  }

  // Change map style
  function changeMapLibreStyle(styleName) {
    if (!mapLibreState.map) return;
    if (!mapLibreState.styles[styleName]) return;

    console.log('[MapLibre] Changing style to:', styleName);

    mapLibreState.style = styleName;
    mapLibreState.isStyleLoaded = false;

    // Clear markers only (layers will be gone after style change anyway)
    mapLibreState.markers.forEach(m => m.remove());
    mapLibreState.markers = [];
    mapLibreState.lines = [];

    // Set the new style
    mapLibreState.map.setStyle(mapLibreState.styles[styleName]);

    // Use 'idle' event which fires when map is completely ready after style change
    const onIdle = () => {
      console.log('[MapLibre] Map idle after style change, rendering content');
      mapLibreState.map.off('idle', onIdle); // Remove listener after first fire
      mapLibreState.isStyleLoaded = true;
      mapLibreState.skipFitBounds = true;
      renderMapLibreContent();
    };
    mapLibreState.map.on('idle', onIdle);

    // Save preference
    try {
      localStorage.setItem('neximap-maplibre-style', styleName);
    } catch(e) {}

    showToast(`ðŸ—ºï¸ Map style: ${styleName.charAt(0).toUpperCase() + styleName.slice(1)}`);
  }

  // Clear all markers and lines from the map
  function clearMapLibreContent() {
    // Remove markers from the tracking array
    mapLibreState.markers.forEach(m => m.remove());
    mapLibreState.markers = [];

    // ALSO remove any markers in DOM that might not be in the array
    // But preserve path-edit markers during path edit mode
    // MapLibre puts markers in a separate container, so search the whole document
    document.querySelectorAll('.maplibregl-marker').forEach(marker => {
      // Skip path edit markers
      if (marker.querySelector('.path-edit-endpoint') ||
          marker.querySelector('.path-edit-waypoint')) {
        return;
      }
      marker.remove();
    });

    // Remove line layers and sources safely
    if (mapLibreState.map && mapLibreState.isStyleLoaded) {
      // Remove the hit area layer first
      try {
        if (mapLibreState.map.getLayer('neximap-edges-hitarea')) {
          mapLibreState.map.removeLayer('neximap-edges-hitarea');
        }
      } catch(e) {}

      // Remove the combined edges layer and source
      try {
        if (mapLibreState.map.getLayer('neximap-edges-layer')) {
          mapLibreState.map.removeLayer('neximap-edges-layer');
        }
        if (mapLibreState.map.getSource('neximap-edges')) {
          mapLibreState.map.removeSource('neximap-edges');
        }
      } catch(e) {
        // Ignore errors during style transitions
      }

      // Remove edge connector layer and source
      try {
        if (mapLibreState.map.getLayer('neximap-edge-connectors-layer')) {
          mapLibreState.map.removeLayer('neximap-edge-connectors-layer');
        }
        if (mapLibreState.map.getSource('neximap-edge-connectors')) {
          mapLibreState.map.removeSource('neximap-edge-connectors');
        }
      } catch(e) {}


      // Also clean up any legacy individual edge layers
      mapLibreState.lines.forEach(lineId => {
        try {
          if (mapLibreState.map.getLayer(lineId)) {
            mapLibreState.map.removeLayer(lineId);
          }
          if (mapLibreState.map.getSource(lineId)) {
            mapLibreState.map.removeSource(lineId);
          }
        } catch(e) {
          // Ignore errors during style transitions
        }
      });
    }
    mapLibreState.lines = [];
  }

  // Render nodes and edges on the MapLibre map
  function renderMapLibreContent() {


    if (!mapLibreState.map || !mapLibreState.active) {

      return;
    }
    if (!mapLibreState.isStyleLoaded) {

      return; // Wait for style to load
    }

    // SKIP normal rendering when in path edit mode - let renderPathEditingView handle it
    if (state.pathEditMode && state.pathEditMode.active) {

      return;
    }



    // Clear existing content first
    clearMapLibreContent();

    // Get visibility settings from state.ui (shared with main Labels menu)
    const showNodes = document.getElementById('mlShowNodes')?.checked !== false;
    const showLinks = document.getElementById('mlShowLinks')?.checked !== false;
    const showNodeLabels = state.ui.showNodeName || state.ui.showNodeCode || state.ui.showNodeTags || state.ui.showExtraTags; // Show label if any node label is enabled
    const showLinkLabels = state.ui.showLinkTag || state.ui.showLatency || state.ui.showLinkCode; // Show label if any link label is enabled

    // Determine style mode: 'canvas' uses individual element styles, 'simplified' uses uniform styles
    const useCanvasStyles = mapLibreState.styleMode === 'canvas';
    // Selection is always enabled (removed the checkbox)
    const selectionEnabled = true;
    mapLibreState.selectionEnabled = true;

    // Get simplified view settings
    const simplifiedNode = mapLibreState.simplified;
    const simplifiedLink = mapLibreState.simplified;

    // Get nodes with GPS coordinates AND that pass visibility filters
    const geoNodes = state.nodes.filter(n =>
      n.gpsLat !== null && n.gpsLat !== undefined &&
      n.gpsLon !== null && n.gpsLon !== undefined &&
      isNodeVisible(n)  // Apply tag/cable system/node/container filters
    );

    if (geoNodes.length === 0) {
      showToast('â„¹ï¸ No visible nodes with GPS coordinates to display');
      return;
    }

    // Create a map of node IDs to their GPS coordinates and data for edge drawing
    const nodeGpsMap = new Map();
    const nodeDataMap = new Map();
    geoNodes.forEach(n => {
      nodeGpsMap.set(n.id, [n.gpsLon, n.gpsLat]);
      nodeDataMap.set(n.id, n);
    });

    // Collect all edges as GeoJSON features for a single layer (more efficient, no flickering)
    const edgeFeatures = [];
    const connectorFeatures = []; // Dotted lines connecting nodes to cable geometry
    const edgeLabelData = []; // For link labels
    const edgeDataForSelection = []; // For click detection

    // Helper function to calculate perpendicular offset for parallel edges in geographic coordinates
    function getParallelEdgeOffset(fromCoords, toCoords, edgeIndex, totalParallel, multiplier = 1) {
      if (totalParallel <= 1) {
        return { from: fromCoords, to: toCoords };
      }

      // Calculate direction vector
      const dx = toCoords[0] - fromCoords[0];
      const dy = toCoords[1] - fromCoords[1];
      const len = Math.sqrt(dx*dx + dy*dy) || 1;

      // Perpendicular unit vector (in lon/lat space)
      const perpX = -dy / len;
      const perpY = dx / len;

      // Spacing in degrees (approximately 0.0001 degrees â‰ˆ 11 meters at equator)
      // Use multiplier for labels to make them more spread out
      const spacing = 0.0003 * multiplier;
      const offsetAmount = (edgeIndex - (totalParallel - 1) / 2) * spacing;

      const offsetX = perpX * offsetAmount;
      const offsetY = perpY * offsetAmount;

      return {
        from: [fromCoords[0] + offsetX, fromCoords[1] + offsetY],
        to: [toCoords[0] + offsetX, toCoords[1] + offsetY]
      };
    }

    if (showLinks) {
      state.edges.forEach((e, idx) => {
        // Apply edge visibility filter (tag/cable system filters)
        if (!isEdgeVisible(e)) return;

        const fromCoords = nodeGpsMap.get(e.a);
        const toCoords = nodeGpsMap.get(e.b);

        if (fromCoords && toCoords) {
          // Calculate offset for parallel edges between same nodes
          const minNodeId = Math.min(e.a, e.b);
          const maxNodeId = Math.max(e.a, e.b);

          const parallelEdges = state.edges.filter(edge => {
            if (!isEdgeVisible(edge)) return false;
            const fromC = nodeGpsMap.get(edge.a);
            const toC = nodeGpsMap.get(edge.b);
            if (!fromC || !toC) return false;
            const edgeMinId = Math.min(edge.a, edge.b);
            const edgeMaxId = Math.max(edge.a, edge.b);
            return edgeMinId === minNodeId && edgeMaxId === maxNodeId;
          });

          // Sort parallel edges by id for consistent ordering
          parallelEdges.sort((x, y) => x.id - y.id);

          const edgeIndex = parallelEdges.findIndex(edge => edge.id === e.id);
          const totalParallel = parallelEdges.length;

          // Get offset coordinates
          const offsetCoords = getParallelEdgeOffset(fromCoords, toCoords, edgeIndex, totalParallel);
          const offsetFrom = offsetCoords.from;
          const offsetTo = offsetCoords.to;

          // Determine edge color and width based on style mode
          let edgeColor, edgeWidth;

          // Check for heat map color first (overrides all other colors)
          const heatMapColor = (typeof getHeatMapColor === 'function') ? getHeatMapColor(e) : null;

          if (heatMapColor) {
            // Heat map is active - use heat map color
            edgeColor = heatMapColor;
            edgeWidth = e.strokeW || e.strokeWidth || simplifiedLink.linkWidth;
          } else if (useCanvasStyles) {
            // Use individual canvas colors
            edgeColor = e.strokeColor || e.stroke || simplifiedLink.linkColor;
            edgeWidth = e.strokeW || e.strokeWidth || simplifiedLink.linkWidth;
          } else {
            // Use simplified uniform style
            edgeColor = simplifiedLink.linkColor;
            edgeWidth = simplifiedLink.linkWidth;
          }

          // Check if selected - but DON'T change color
          const isSelected = mapLibreState.selectedEdge === e.id || mapLibreState.selectedEdges.has(e.id);

          const edgeId = e.id || `edge-${idx}`;

          // Determine geometry: KML view shows cableGeometry, otherwise straight lines
          let edgeGeometry;
          if (mapLibreState.pathRenderMode === 'paths' && e.cableGeometry && e.cableGeometry.coordinates) {
            // KML view ON - use cable geometry (supports LineString & MultiLineString)
            edgeGeometry = e.cableGeometry;

            // Create dotted connector lines from each node to closest point on cable
            const closestToFrom = findClosestPointOnGeometry(e.cableGeometry, fromCoords);
            const closestToTo = findClosestPointOnGeometry(e.cableGeometry, toCoords);
            if (closestToFrom) {
              const dx = closestToFrom[0] - fromCoords[0], dy = closestToFrom[1] - fromCoords[1];
              if (dx * dx + dy * dy > 1e-10) {
                connectorFeatures.push({
                  type: 'Feature',
                  properties: { color: edgeColor, width: Math.max(1, edgeWidth * 0.6) },
                  geometry: { type: 'LineString', coordinates: [fromCoords, closestToFrom] }
                });
              }
            }
            if (closestToTo) {
              const dx = closestToTo[0] - toCoords[0], dy = closestToTo[1] - toCoords[1];
              if (dx * dx + dy * dy > 1e-10) {
                connectorFeatures.push({
                  type: 'Feature',
                  properties: { color: edgeColor, width: Math.max(1, edgeWidth * 0.6) },
                  geometry: { type: 'LineString', coordinates: [toCoords, closestToTo] }
                });
              }
            }
          } else {
            // Straight line (KML view OFF or no geometry defined)
            edgeGeometry = {
              type: 'LineString',
              coordinates: [offsetFrom, offsetTo]
            };
          }

          // Add selection glow feature FIRST (rendered behind) if selected
          if (isSelected) {
            edgeFeatures.push({
              type: 'Feature',
              properties: {
                id: edgeId + '-glow',
                color: 'rgba(0,150,214,0.5)', // Cyan glow
                width: edgeWidth + 6,
                selected: true,
                isGlow: true
              },
              geometry: edgeGeometry
            });
          }

          edgeFeatures.push({
            type: 'Feature',
            properties: {
              id: edgeId,
              color: edgeColor, // Keep original color
              width: edgeWidth,
              selected: isSelected,
              hasPath: !!(e.cableGeometry && e.cableGeometry.coordinates)
            },
            geometry: edgeGeometry
          });

          // Store edge data for click detection (use offset coordinates)
          edgeDataForSelection.push({
            id: edgeId,
            edge: e,
            fromCoords: offsetFrom,
            toCoords: offsetTo
          });

          // Collect label data for this edge - respect individual label settings
          if (showLinkLabels) {
            // For parallel edges, shift labels ALONG the line (not perpendicular)
            // so they appear at different positions between the endpoints
            // Position ranges from 0.3 to 0.7 of the line length
            let labelPosition = 0.5; // Default: middle of line
            if (totalParallel > 1) {
              // Spread labels along the line from 30% to 70%
              const positionRange = 0.4; // Total range (0.3 to 0.7)
              const positionStep = positionRange / (totalParallel - 1);
              labelPosition = 0.3 + (edgeIndex * positionStep);
            }

            // Interpolate position along the line
            const labelLon = fromCoords[0] + (toCoords[0] - fromCoords[0]) * labelPosition;
            const labelLat = fromCoords[1] + (toCoords[1] - fromCoords[1]) * labelPosition;

            // Build label text based on what's enabled (match main canvas: e.tag, e.latencyMs, e.code)
            let labelParts = [];
            if (state.ui.showLinkCode && e.code && e.code.trim()) {
              labelParts.push(e.code.trim());
            }
            if (state.ui.showLinkTag && e.tag && e.tag.trim()) {
              labelParts.push(e.tag.trim());
            }
            if (state.ui.showLatency && typeof e.latencyMs === 'number' && isFinite(e.latencyMs)) {
              labelParts.push(e.latencyMs + ' ms');
            }
            const labelText = labelParts.join(' Â· ');



            if (labelText) {
              edgeLabelData.push({
                coords: [labelLon, labelLat],
                text: labelText,
                color: edgeColor, // Use original color for label
                edgeId: edgeId,
                edge: e
              });
            }
          }
        }
      });
    }

    // Store edge data for selection handling
    mapLibreState.edgeDataForSelection = edgeDataForSelection;



    // Add all edges as a single source and layer (prevents flickering)
    if (edgeFeatures.length > 0) {
      const edgesSourceId = 'neximap-edges';
      const edgesLayerId = 'neximap-edges-layer';
      const edgesHitAreaLayerId = 'neximap-edges-hitarea'; // Invisible wider layer for easier clicking

      try {
        mapLibreState.map.addSource(edgesSourceId, {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features: edgeFeatures
          }
        });

        // Add invisible hit area layer FIRST (below visible layer) for easier clicking
        // Use a slightly visible color so MapLibre can detect it in queryRenderedFeatures
        mapLibreState.map.addLayer({
          id: edgesHitAreaLayerId,
          type: 'line',
          source: edgesSourceId,
          paint: {
            'line-color': 'rgba(0,0,0,0.005)', // Very faint but detectable
            'line-width': 10 // Modest hit area â€“ wide enough to click, narrow enough to distinguish nearby cables
          },
          filter: ['!=', ['get', 'isGlow'], true] // Don't create hit area for glow features
        });

        // Add visible edge layer on top
        mapLibreState.map.addLayer({
          id: edgesLayerId,
          type: 'line',
          source: edgesSourceId,
          paint: {
            'line-color': ['get', 'color'],
            'line-width': ['get', 'width'],
            'line-opacity': 0.85
          },
          layout: {
            'line-cap': 'round',
            'line-join': 'round'
          }
        });

        mapLibreState.lines.push(edgesHitAreaLayerId);
        mapLibreState.lines.push(edgesLayerId);
        mapLibreState.lines.push(edgesSourceId); // Track source for cleanup

        // Click and hover handlers are set up once during map initialization
        // using queryRenderedFeatures for reliability
      } catch (err) {
        console.warn('Failed to add edges layer:', err);
      }
    }

    // Add dotted connector lines (node-to-cable extensions)
    if (connectorFeatures.length > 0) {
      const connSourceId = 'neximap-edge-connectors';
      const connLayerId = 'neximap-edge-connectors-layer';

      try {
        mapLibreState.map.addSource(connSourceId, {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: connectorFeatures }
        });

        mapLibreState.map.addLayer({
          id: connLayerId,
          type: 'line',
          source: connSourceId,
          paint: {
            'line-color': ['get', 'color'],
            'line-width': ['get', 'width'],
            'line-opacity': 0.7,
            'line-dasharray': [2, 3]
          },
          layout: {
            'line-cap': 'round',
            'line-join': 'round'
          }
        });

        mapLibreState.lines.push(connLayerId);
        mapLibreState.lines.push(connSourceId);
      } catch (err) {
        console.warn('Failed to add connector layer:', err);
      }
    }

    // Add link labels as markers (with selection support)
    if (showLinkLabels && edgeLabelData.length > 0) {
      edgeLabelData.forEach(labelInfo => {
        const labelEl = document.createElement('div');
        labelEl.className = 'maplibre-link-label';
        labelEl.dataset.edgeId = labelInfo.edgeId;
        labelEl.textContent = labelInfo.text;

        const isSelected = mapLibreState.selectedEdge === labelInfo.edgeId || mapLibreState.selectedEdges.has(labelInfo.edgeId);
        labelEl.style.cssText = `
          background: ${isSelected ? '#e0f2fe' : 'rgba(255,255,255,0.9)'};
          padding: 1px 4px;
          border-radius: 2px;
          font-size: 9px;
          font-weight: 500;
          color: #333;
          white-space: nowrap;
          pointer-events: ${selectionEnabled ? 'auto' : 'none'};
          cursor: ${selectionEnabled ? 'pointer' : 'default'};
          box-shadow: 0 1px 2px rgba(0,0,0,0.15);
          border-left: 3px solid ${isSelected ? '#0096D6' : labelInfo.color};
          ${isSelected ? 'outline: 2px solid #0096D6;' : ''}
        `;

        // Add click handler for label selection
        if (selectionEnabled) {
          labelEl.addEventListener('click', (ev) => {
            ev.stopPropagation();
            selectEdgeOnMap(labelInfo.edgeId, ev.shiftKey);
          });
        }

        console.log('[MARKER DEBUG] Creating EDGE LABEL marker at:', labelInfo.coords, 'edge:', labelInfo.edgeId);
        if (labelInfo.coords[0] === 0 && labelInfo.coords[1] === 0) {
          console.error('[MARKER DEBUG] WARNING: Creating edge label at 0,0!');
        }
        const labelMarker = new maplibregl.Marker({
          element: labelEl,
          anchor: 'center'
        })
          .setLngLat(labelInfo.coords)
          .addTo(mapLibreState.map);

        mapLibreState.markers.push(labelMarker);
      });
    }

    // Draw nodes as markers (only if showNodes is enabled)
    if (showNodes) {
    geoNodes.forEach(n => {
      // Create marker element
      const el = document.createElement('div');
      el.className = 'maplibre-node-marker';
      el.dataset.nodeId = n.id; // Store node ID for selection and path finder

      const isSelected = mapLibreState.selectedNode === n.id || mapLibreState.selectedNodes.has(n.id);

      // Check if in link mode (creating links)
      const isLinkSource = window.linkMode && window.linkSourceNode === n.id;

      // Check if this node is a route finder origin/destination or path node
      const isRouteOrigin = window.routeFinderState && routeFinderState.originNodeId === n.id;
      const isRouteDest = window.routeFinderState && routeFinderState.destNodeId === n.id;
      const isRoutePathNode = window.routeFinderState && routeFinderState.routes.length > 0 &&
        routeFinderState.routes[routeFinderState.activeRouteIndex]?.path?.includes(n.id) &&
        !isRouteOrigin && !isRouteDest;
      const isExcluded = window.routeFinderState && routeFinderState.excludedNodes.has(n.id);
      const isMustUse = window.routeFinderState && routeFinderState.mustUseNodes.has(n.id);

      // Determine base size based on style mode
      let baseSize;
      if (useCanvasStyles) {
        baseSize = Math.max(16, Math.min(40, (n.r || 20) * 1.2));
      } else {
        // Simplified mode - use uniform size
        baseSize = simplifiedNode.nodeSize;
      }
      let size = baseSize;
      if (isSelected || isRouteOrigin || isRouteDest || isLinkSource) size = baseSize + 4;

      // Determine colors based on state and style mode
      let fill, stroke, strokeWidth;
      if (useCanvasStyles) {
        // Use individual canvas colors
        fill = n.fill || '#dae8fc';
        stroke = n.stroke || '#6c8ebf';
        strokeWidth = n.strokeW || 2;
      } else {
        // Simplified mode - use uniform colors
        fill = simplifiedNode.nodeFill;
        stroke = simplifiedNode.nodeStroke;
        strokeWidth = 2;
      }

      let extraCircle = '';
      let glowFilter = '';

      if (isLinkSource) {
        stroke = '#ff9800'; // Orange for link source - same as main canvas
        strokeWidth = 4;
        extraCircle = `<circle cx="${size/2}" cy="${size/2}" r="${size/2 + 3}" fill="none" stroke="#ff9800" stroke-width="2" opacity="0.7">
                         <animate attributeName="opacity" values="1;0.5;1" dur="1s" repeatCount="indefinite"/>
                       </circle>`;
      } else if (isRouteOrigin) {
        stroke = '#22c55e'; // Green for origin
        strokeWidth = 4;
        extraCircle = `<circle cx="${size/2}" cy="${size/2}" r="${size/2 + 3}" fill="none" stroke="#22c55e" stroke-width="2" stroke-dasharray="4,2"/>`;
      } else if (isRouteDest) {
        stroke = '#ef4444'; // Red for destination
        strokeWidth = 4;
        extraCircle = `<circle cx="${size/2}" cy="${size/2}" r="${size/2 + 3}" fill="none" stroke="#ef4444" stroke-width="2" stroke-dasharray="4,2"/>`;
      } else if (isRoutePathNode) {
        stroke = '#f59e0b'; // Amber for path nodes
        strokeWidth = 3;
      } else if (isMustUse) {
        stroke = '#8b5cf6'; // Purple for must-use
        strokeWidth = 3;
        extraCircle = `<circle cx="${size/2}" cy="${size/2}" r="${size/2 + 2}" fill="none" stroke="#8b5cf6" stroke-width="1.5"/>`;
      } else if (isExcluded) {
        stroke = '#9ca3af'; // Gray for excluded
        strokeWidth = 2;
        extraCircle = `<line x1="${size*0.2}" y1="${size*0.2}" x2="${size*0.8}" y2="${size*0.8}" stroke="#ef4444" stroke-width="2"/>
                       <line x1="${size*0.8}" y1="${size*0.2}" x2="${size*0.2}" y2="${size*0.8}" stroke="#ef4444" stroke-width="2"/>`;
      } else if (isSelected) {
        // Selection - use glow overlay, KEEP original stroke color
        glowFilter = 'drop-shadow(0 0 6px rgba(0,150,214,0.9)) drop-shadow(0 0 10px rgba(0,150,214,0.6)) drop-shadow(0 0 14px rgba(0,150,214,0.3))';
        extraCircle = `<circle cx="${size/2}" cy="${size/2}" r="${size/2 + 3}" fill="none" stroke="rgba(0,150,214,0.6)" stroke-width="3">
                         <animate attributeName="stroke-opacity" values="0.6;0.9;0.6" dur="2s" repeatCount="indefinite"/>
                       </circle>`;
      }

      el.innerHTML = `
        <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="${glowFilter ? 'filter:' + glowFilter + ';' : ''}">
          ${extraCircle}
          <circle cx="${size/2}" cy="${size/2}" r="${size/2 - 2}"
                  fill="${fill}" stroke="${stroke}" stroke-width="${strokeWidth}"/>
        </svg>
      `;
      el.style.width = size + 'px';
      el.style.height = size + 'px';
      el.style.cursor = selectionEnabled ? 'pointer' : 'default';

      // Create the marker
      console.log('[MARKER DEBUG] Creating NODE marker at:', [n.gpsLon, n.gpsLat], 'node:', n.name || n.id);
      if (n.gpsLon === 0 && n.gpsLat === 0) {
        console.error('[MARKER DEBUG] WARNING: Creating node marker at 0,0!', n);
      }
      const marker = new maplibregl.Marker({
        element: el,
        anchor: 'center'
      })
        .setLngLat([n.gpsLon, n.gpsLat])
        .addTo(mapLibreState.map);

      // Add popup with node info
      const popupContent = `
        <div style="font-family: system-ui, sans-serif; font-size: 12px; min-width: 140px;">
          <div style="font-weight: 600; margin-bottom: 4px;">${n.name || n.id}</div>
          ${n.code ? `<div style="color: #666; font-size: 11px;">Code: ${n.code}</div>` : ''}
          <div style="color: #888; font-size: 10px; margin-top: 4px;">
            ðŸ“ ${n.gpsLat.toFixed(4)}Â°, ${n.gpsLon.toFixed(4)}Â°
          </div>
          ${mapLibreState.pathFinderActive ? `<button class="ml-pathfinder-btn" data-node-id="${n.id}" style="margin-top:6px; padding:4px 8px; font-size:10px; cursor:pointer; background:#10b981; color:white; border:none; border-radius:3px;">Select for Path</button>` : ''}
        </div>
      `;

      const popup = new maplibregl.Popup({ offset: 15, closeOnClick: false })
        .setHTML(popupContent);

      // Handle path finder node selection from popup
      popup.on('open', () => {
        const btn = document.querySelector(`.ml-pathfinder-btn[data-node-id="${n.id}"]`);
        if (btn) {
          btn.addEventListener('click', () => {
            selectNodeForMapLibrePathFinder(n.id);
            popup.remove();
          });
        }
      });

      marker.setPopup(popup);

      // Click handler for selection, route finder, link mode, and path finder mode
      el.addEventListener('click', (ev) => {
        ev.stopPropagation();

        // Check if main route finder is active - use same handler as main canvas
        if (window.routeFinderState && window.routeFinderState.active) {
          // Use the same function as main canvas for consistent behavior
          if (typeof handleCalculationModeNodeClick === 'function') {
            handleCalculationModeNodeClick(n.id);
            // Re-render MapLibre to show the visual feedback (green/red highlighting)
            mapLibreState.skipFitBounds = true;
            renderMapLibreContent();
          }
          return;
        }

        // Check if in link mode
        if (window.linkMode) {
          if (window.linkSourceNode === null) {
            // First click - set source node
            window.linkSourceNode = n.id;
            if (typeof linkSourceNode !== 'undefined') linkSourceNode = n.id;
            state.selected = { type: 'node', id: n.id };
            mapLibreState.selectedNode = n.id;
            mapLibreState.selectedEdge = null;
            mapLibreState.skipFitBounds = true;
            renderMapLibreContent();
            updateInspector();
            showToast(`Link source: ${n.name || 'N' + n.id} â†’ Click target node`);
          } else {
            // Second click - create link
            if (window.linkSourceNode === n.id) {
              showToast('âŒ Cannot link node to itself');
              return;
            }
            const sourceId = window.linkSourceNode;
            window.linkSourceNode = null;
            if (typeof linkSourceNode !== 'undefined') linkSourceNode = null;
            createEdge(sourceId, n.id, true);
            state.selected = null;
            state.selection.nodes.clear();
            mapLibreState.selectedNode = null;
            mapLibreState.skipFitBounds = true;
            renderMapLibreContent();
            updateInspector();
            showToast(`âœ“ Link created! Click next source node`);
          }
          return;
        }

        // Check if MapLibre's own path finder is active
        if (mapLibreState.pathFinderActive) {
          selectNodeForMapLibrePathFinder(n.id);
        } else if (mapLibreState.selectionEnabled) {
          selectNodeOnMap(n.id, ev.shiftKey);
        }
      });

      // Add label if enabled - build label text based on what's enabled
      if (showNodeLabels) {
        let labelParts = [];

        // Node Code
        if (state.ui.showNodeCode && n.code && n.code.trim()) {
          labelParts.push(n.code.trim());
        }
        // Node Name (only if code not shown, to avoid redundancy - or show both separated)
        if (state.ui.showNodeName && n.name && n.name.trim()) {
          // If code is already shown, add name in parentheses; otherwise just show name
          if (labelParts.length > 0) {
            labelParts.push('(' + n.name.trim() + ')');
          } else {
            labelParts.push(n.name.trim());
          }
        }
        // Node Tags
        if (state.ui.showNodeTags && n.tags && n.tags.length > 0) {
          labelParts.push('[' + n.tags.join(', ') + ']');
        }
        // Extra Tags
        if (state.ui.showExtraTags && n.extraTags && n.extraTags.trim()) {
          labelParts.push(n.extraTags.trim());
        }

        const labelText = labelParts.join(' ');

        if (labelText) {
          const labelEl = document.createElement('div');
          labelEl.className = 'maplibre-node-label';
          labelEl.dataset.nodeId = n.id;
          labelEl.textContent = labelText;
          labelEl.style.transform = 'translate(-50%, 8px)';

          // Highlight if selected
          if (isSelected) {
            labelEl.style.background = '#e0f2fe'; // Light blue background
            labelEl.style.outline = '2px solid #0096D6'; // Blue outline - same as main canvas
          }

          console.log('[MARKER DEBUG] Creating NODE LABEL marker at:', [n.gpsLon, n.gpsLat], 'node:', n.name || n.id);
          if (n.gpsLon === 0 && n.gpsLat === 0) {
            console.error('[MARKER DEBUG] WARNING: Creating node label at 0,0!');
          }
          const labelMarker = new maplibregl.Marker({
            element: labelEl,
            anchor: 'top'
          })
            .setLngLat([n.gpsLon, n.gpsLat])
            .addTo(mapLibreState.map);

          mapLibreState.markers.push(labelMarker);
        }
      }

      mapLibreState.markers.push(marker);
    });
    } // End of if (showNodes)

    // If path finder is active and we have a path, draw it
    if (mapLibreState.pathFinderActive && mapLibreState.currentPath && mapLibreState.currentPath.length > 1) {
      drawMapLibrePath(mapLibreState.currentPath);
    }

    // Fit map to show all nodes (only on initial render, not during selection changes)
    if (!mapLibreState.pathFinderActive && !mapLibreState.skipFitBounds) {
      if (geoNodes.length > 1) {
        const bounds = new maplibregl.LngLatBounds();
        geoNodes.forEach(n => {
          bounds.extend([n.gpsLon, n.gpsLat]);
        });
        mapLibreState.map.fitBounds(bounds, { padding: 50, maxZoom: 10 });
      } else if (geoNodes.length === 1) {
        mapLibreState.map.flyTo({
          center: [geoNodes[0].gpsLon, geoNodes[0].gpsLat],
          zoom: 5
        });
      }
    }
    mapLibreState.skipFitBounds = false; // Reset flag
  }

  // Expose renderMapLibreContent globally for label toggle handlers
  window.renderMapLibreContent = renderMapLibreContent;

  // ============== MAPLIBRE SELECTION FUNCTIONS ==============

  // Select a node on the map and show in Inspector
  function selectNodeOnMap(nodeId, shiftKey) {
    const node = findNode(nodeId);
    if (!node) return;

    if (shiftKey) {
      // Shift+click: toggle node in multi-selection
      if (mapLibreState.selectedNodes.has(nodeId)) {
        mapLibreState.selectedNodes.delete(nodeId);
        state.selection.nodes.delete(nodeId);
      } else {
        mapLibreState.selectedNodes.add(nodeId);
        state.selection.nodes.add(nodeId);
      }
      // Clear single selection pointers
      mapLibreState.selectedNode = null;
      mapLibreState.selectedEdge = null;
      state.selected = null;

      const count = mapLibreState.selectedNodes.size + mapLibreState.selectedEdges.size;
      showToast(`Selected ${count} item(s)`);
    } else {
      // Normal click: clear multi-selection, select single node
      mapLibreState.selectedNodes.clear();
      mapLibreState.selectedEdges.clear();
      state.selection.nodes.clear();
      state.selection.edges.clear();

      mapLibreState.selectedEdge = null;
      mapLibreState.selectedNode = nodeId;
      state.selected = { type: 'node', id: nodeId };

      // Apply format painter if armed
      if (state.styleBrush && state.styleBrush.type === 'node') {
        applyStyle('node', node, state.styleBrush.style);
        commit();
        showToast(`ðŸŽ¨ Format applied to: ${node.name || node.code || nodeId}`);
      } else {
        showToast(`ðŸ”µ Selected: ${node.name || node.code || nodeId}`);
      }
    }

    // Update Inspector
    if (typeof updateInspector === 'function') {
      updateInspector();
    }

    // Re-render to show selection highlight (without re-fitting bounds)
    mapLibreState.skipFitBounds = true;
    renderMapLibreContent();
  }

  // Select an edge on the map and show in Inspector
  function selectEdgeOnMap(edgeId, shiftKey) {
    // Find the edge
    const edge = state.edges.find(e => e.id === edgeId || `edge-${state.edges.indexOf(e)}` === edgeId);
    if (!edge) return;

    const resolvedId = edge.id || edgeId;

    if (shiftKey) {
      // Shift+click: toggle edge in multi-selection
      if (mapLibreState.selectedEdges.has(resolvedId)) {
        mapLibreState.selectedEdges.delete(resolvedId);
        state.selection.edges.delete(resolvedId);
      } else {
        mapLibreState.selectedEdges.add(resolvedId);
        state.selection.edges.add(resolvedId);
      }
      // Clear single selection pointers
      mapLibreState.selectedNode = null;
      mapLibreState.selectedEdge = null;
      state.selected = null;

      const count = mapLibreState.selectedNodes.size + mapLibreState.selectedEdges.size;
      showToast(`Selected ${count} item(s)`);
    } else {
      // Normal click: clear multi-selection, select single edge
      mapLibreState.selectedNodes.clear();
      mapLibreState.selectedEdges.clear();
      state.selection.nodes.clear();
      state.selection.edges.clear();

      mapLibreState.selectedNode = null;
      mapLibreState.selectedEdge = resolvedId;
      state.selected = { type: 'edge', id: resolvedId, a: edge.a, b: edge.b };

      // Apply format painter if armed
      if (state.styleBrush && state.styleBrush.type === 'edge') {
        applyStyle('edge', edge, state.styleBrush.style);
        commit();
        const nodeA = findNode(edge.a);
        const nodeB = findNode(edge.b);
        showToast(`ðŸŽ¨ Format applied to link: ${nodeA?.name || edge.a} â†” ${nodeB?.name || edge.b}`);
      } else {
        const nodeA = findNode(edge.a);
        const nodeB = findNode(edge.b);
        const label = edge.label || edge.tag || '';
        showToast(`ðŸ”— Selected link: ${nodeA?.name || edge.a} â†” ${nodeB?.name || edge.b}${label ? ' (' + label + ')' : ''}`);
      }
    }

    // Update Inspector
    if (typeof updateInspector === 'function') {
      updateInspector();
    }

    // Re-render to show selection highlight (without re-fitting bounds)
    mapLibreState.skipFitBounds = true;
    renderMapLibreContent();
  }

  // Clear selection on map
  function clearMapSelection() {
    mapLibreState.selectedNode = null;
    mapLibreState.selectedEdge = null;
    mapLibreState.selectedNodes.clear();
    mapLibreState.selectedEdges.clear();
    state.selected = null;
    state.selection.nodes.clear();
    state.selection.edges.clear();

    if (typeof updateInspector === 'function') {
      updateInspector();
    }

    mapLibreState.skipFitBounds = true;
    renderMapLibreContent();
  }

  // Click on empty map area to deselect
  function setupMapClickToDeselect() {
    if (!mapLibreState.map || mapLibreState.deselectHandlerAdded) return;

    mapLibreState.map.on('click', (e) => {
      // Check if this click was already handled by edge selection
      if (mapLibreState._edgeClickHandled) {
        mapLibreState._edgeClickHandled = false;
        return;
      }

      // Query both edge layers to check if we clicked on an edge
      const tolerance = 10;
      const bbox = [
        [e.point.x - tolerance, e.point.y - tolerance],
        [e.point.x + tolerance, e.point.y + tolerance]
      ];

      let edgeFeatures = [];
      if (mapLibreState.map.getLayer('neximap-edges-hitarea')) {
        edgeFeatures = mapLibreState.map.queryRenderedFeatures(bbox, {
          layers: ['neximap-edges-hitarea']
        });
      }
      if (edgeFeatures.length === 0 && mapLibreState.map.getLayer('neximap-edges-layer')) {
        edgeFeatures = mapLibreState.map.queryRenderedFeatures(bbox, {
          layers: ['neximap-edges-layer']
        });
      }

      // If we found edge features, don't deselect (edge handler should have handled it)
      const validEdgeFeatures = edgeFeatures.filter(f => !f.properties.isGlow && f.properties.id);
      if (validEdgeFeatures.length > 0) {
        return;
      }

      // Only deselect if not clicking on a marker and Shift is not held
      if (mapLibreState.selectionEnabled && !e.originalEvent?.shiftKey) {
        const target = e.originalEvent?.target;
        if (target && !target.closest('.maplibre-node-marker') && !target.closest('.maplibre-link-label')) {
          clearMapSelection();
        }
      }
    });

    mapLibreState.deselectHandlerAdded = true;
  }

  // ============== END MAPLIBRE SELECTION FUNCTIONS ==============

  // ============== MAPLIBRE PATH FINDER ==============

  // Initialize path finder state in mapLibreState
  mapLibreState.pathFinderActive = false;
  mapLibreState.pathFinderSource = null;
  mapLibreState.pathFinderTarget = null;
  mapLibreState.currentPath = null;

  // Select a node for path finding
  function selectNodeForMapLibrePathFinder(nodeId) {
    if (!mapLibreState.pathFinderActive) return;

    if (!mapLibreState.pathFinderSource) {
      mapLibreState.pathFinderSource = nodeId;
      const node = findNode(nodeId);
      showToast(`ðŸŸ¢ Source: ${node?.name || node?.code || nodeId} â€” Now select destination`);
      highlightMapLibreNode(nodeId, '#22c55e'); // Green for source
    } else if (!mapLibreState.pathFinderTarget) {
      if (nodeId === mapLibreState.pathFinderSource) {
        showToast('âš ï¸ Please select a different node as destination');
        return;
      }
      mapLibreState.pathFinderTarget = nodeId;
      const node = findNode(nodeId);
      showToast(`ðŸ”´ Destination: ${node?.name || node?.code || nodeId} â€” Calculating path...`);
      highlightMapLibreNode(nodeId, '#ef4444'); // Red for target

      // Calculate and display path
      calculateMapLibrePath();
    } else {
      // Reset and start new path
      mapLibreState.pathFinderSource = nodeId;
      mapLibreState.pathFinderTarget = null;
      mapLibreState.currentPath = null;
      renderMapLibreContent();
      const node = findNode(nodeId);
      showToast(`ðŸŸ¢ New Source: ${node?.name || node?.code || nodeId} â€” Select destination`);
      highlightMapLibreNode(nodeId, '#22c55e');
    }
  }

  // Highlight a node on the map
  function highlightMapLibreNode(nodeId, color) {
    const markerEl = document.querySelector(`.maplibre-node-marker[data-node-id="${nodeId}"]`);
    if (markerEl) {
      const circle = markerEl.querySelector('circle');
      if (circle) {
        circle.setAttribute('stroke', color);
        circle.setAttribute('stroke-width', '4');
      }
    }
  }

  // Calculate the shortest path using the existing pathfinder logic
  function calculateMapLibrePath() {
    if (!mapLibreState.pathFinderSource || !mapLibreState.pathFinderTarget) return;

    // Use the existing route finder if available
    if (typeof window.routeFinderState !== 'undefined' && typeof findShortestPath === 'function') {
      const path = findShortestPath(mapLibreState.pathFinderSource, mapLibreState.pathFinderTarget);
      if (path && path.length > 0) {
        mapLibreState.currentPath = path;
        drawMapLibrePath(path);

        // Calculate total latency/distance
        let totalLatency = 0;
        for (let i = 0; i < path.length - 1; i++) {
          const edge = state.edges.find(e =>
            (e.a === path[i] && e.b === path[i+1]) ||
            (e.b === path[i] && e.a === path[i+1])
          );
          if (edge && edge.latency) {
            totalLatency += parseFloat(edge.latency) || 0;
          }
        }

        const sourceNode = findNode(mapLibreState.pathFinderSource);
        const targetNode = findNode(mapLibreState.pathFinderTarget);
        showToast(`âœ… Path found: ${path.length} nodes, ${totalLatency > 0 ? totalLatency.toFixed(1) + ' ms' : 'distance calculated'}`);
      } else {
        showToast('âŒ No path found between these nodes');
        mapLibreState.currentPath = null;
      }
    } else {
      // Simple BFS pathfinding if route finder not available
      const path = simpleBFSPath(mapLibreState.pathFinderSource, mapLibreState.pathFinderTarget);
      if (path) {
        mapLibreState.currentPath = path;
        drawMapLibrePath(path);
        showToast(`âœ… Path found: ${path.length} nodes`);
      } else {
        showToast('âŒ No path found between these nodes');
      }
    }
  }

  // Simple BFS pathfinding fallback
  function simpleBFSPath(startId, endId) {
    const visited = new Set();
    const queue = [[startId]];

    while (queue.length > 0) {
      const path = queue.shift();
      const node = path[path.length - 1];

      if (node === endId) return path;
      if (visited.has(node)) continue;
      visited.add(node);

      // Find connected nodes
      state.edges.forEach(e => {
        let neighbor = null;
        if (e.a === node && !visited.has(e.b)) neighbor = e.b;
        if (e.b === node && !visited.has(e.a)) neighbor = e.a;
        if (neighbor) {
          queue.push([...path, neighbor]);
        }
      });
    }
    return null;
  }

  // Draw the path on the MapLibre map
  function drawMapLibrePath(path) {
    if (!mapLibreState.map || !path || path.length < 2) return;

    // Remove existing path layer
    try {
      if (mapLibreState.map.getLayer('neximap-path-layer')) {
        mapLibreState.map.removeLayer('neximap-path-layer');
      }
      if (mapLibreState.map.getSource('neximap-path')) {
        mapLibreState.map.removeSource('neximap-path');
      }
    } catch(e) {}

    // Build path coordinates
    const coordinates = [];
    path.forEach(nodeId => {
      const node = findNode(nodeId);
      if (node && node.gpsLat != null && node.gpsLon != null) {
        coordinates.push([node.gpsLon, node.gpsLat]);
      }
    });

    if (coordinates.length < 2) return;

    // Add path source and layer
    mapLibreState.map.addSource('neximap-path', {
      type: 'geojson',
      data: {
        type: 'Feature',
        geometry: {
          type: 'LineString',
          coordinates: coordinates
        }
      }
    });

    mapLibreState.map.addLayer({
      id: 'neximap-path-layer',
      type: 'line',
      source: 'neximap-path',
      paint: {
        'line-color': '#f59e0b',
        'line-width': 5,
        'line-opacity': 0.9
      },
      layout: {
        'line-cap': 'round',
        'line-join': 'round'
      }
    });

    // Fit bounds to show the path
    const bounds = new maplibregl.LngLatBounds();
    coordinates.forEach(coord => bounds.extend(coord));
    mapLibreState.map.fitBounds(bounds, { padding: 80, maxZoom: 8 });
  }

  // Toggle MapLibre path finder mode
  function toggleMapLibrePathFinder(active) {
    mapLibreState.pathFinderActive = active;
    mapLibreState.pathFinderSource = null;
    mapLibreState.pathFinderTarget = null;
    mapLibreState.currentPath = null;

    // Update UI
    const btn = document.getElementById('mlPathFinderBtn');
    if (btn) {
      btn.style.background = active ? '#10b981' : '';
      btn.style.color = active ? 'white' : '#10b981';
      btn.style.borderRadius = active ? '4px' : '';
      btn.textContent = active ? 'âœ“ Path Finder Active' : 'ðŸ” Path Finder on Map';
    }

    if (active) {
      showToast('ðŸ” Path Finder: Click on a node to set as source');
    } else {
      // Remove path layer
      try {
        if (mapLibreState.map?.getLayer('neximap-path-layer')) {
          mapLibreState.map.removeLayer('neximap-path-layer');
        }
        if (mapLibreState.map?.getSource('neximap-path')) {
          mapLibreState.map.removeSource('neximap-path');
        }
      } catch(e) {}
    }

    renderMapLibreContent();
  }

  // Path Finder button handler
  const mlPathFinderBtn = document.getElementById('mlPathFinderBtn');
  if (mlPathFinderBtn) {
    mlPathFinderBtn.addEventListener('click', () => {
      toggleMapLibrePathFinder(!mapLibreState.pathFinderActive);
    });
  }

  // Display option toggle handlers
  const mlShowNodeLabels = document.getElementById('mlShowNodeLabels');
  const mlShowLinkLabels = document.getElementById('mlShowLinkLabels');
  const mlShowLinks = document.getElementById('mlShowLinks');
  const mlUseCanvasColors = document.getElementById('mlUseCanvasColors');
  const mlDefaultLinkColor = document.getElementById('mlDefaultLinkColor');
  const mlDefaultLinkColorHex = document.getElementById('mlDefaultLinkColorHex');
  const mlDefaultLinkWidth = document.getElementById('mlDefaultLinkWidth');
  const mlDefaultLinkWidthVal = document.getElementById('mlDefaultLinkWidthVal');

  // Function to save MapLibre settings
  function saveMapLibreSettings() {
    try {
      localStorage.setItem('neximap-maplibre-settings', JSON.stringify({
        defaultLinkColor: mapLibreState.defaultLinkColor,
        defaultLinkWidth: mapLibreState.defaultLinkWidth,
        useCanvasColors: mapLibreState.useCanvasColors,
        styleMode: mapLibreState.styleMode,
        simplified: mapLibreState.simplified
      }));
    } catch(e) {}
  }

  // Initialize UI from saved settings
  function initMapLibreUI() {
    // Load saved settings
    try {
      const savedSettings = localStorage.getItem('neximap-maplibre-settings');
      if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        if (settings.styleMode) mapLibreState.styleMode = settings.styleMode;
        if (settings.simplified) {
          Object.assign(mapLibreState.simplified, settings.simplified);
        }
      }
    } catch(e) {}

    // Update style mode radio buttons
    if (mapLibreState.styleMode === 'simplified') {
      const simplifiedRadio = document.getElementById('mlStyleModeSimplified');
      if (simplifiedRadio) simplifiedRadio.checked = true;
      const settingsDiv = document.getElementById('mlSimplifiedSettings');
      if (settingsDiv) settingsDiv.style.display = 'block';
    }

    // Update simplified controls with current values
    const mlSimplifiedNodeFill = document.getElementById('mlSimplifiedNodeFill');
    const mlSimplifiedNodeFillBtn = document.getElementById('mlSimplifiedNodeFillBtn');
    const mlSimplifiedNodeFillHex = document.getElementById('mlSimplifiedNodeFillHex');
    const mlSimplifiedNodeStroke = document.getElementById('mlSimplifiedNodeStroke');
    const mlSimplifiedNodeStrokeBtn = document.getElementById('mlSimplifiedNodeStrokeBtn');
    const mlSimplifiedNodeStrokeHex = document.getElementById('mlSimplifiedNodeStrokeHex');
    const mlSimplifiedNodeSize = document.getElementById('mlSimplifiedNodeSize');
    const mlSimplifiedNodeSizeVal = document.getElementById('mlSimplifiedNodeSizeVal');
    const mlSimplifiedLinkColor = document.getElementById('mlSimplifiedLinkColor');
    const mlSimplifiedLinkColorBtn = document.getElementById('mlSimplifiedLinkColorBtn');
    const mlSimplifiedLinkColorHex = document.getElementById('mlSimplifiedLinkColorHex');
    const mlSimplifiedLinkWidth = document.getElementById('mlSimplifiedLinkWidth');
    const mlSimplifiedLinkWidthVal = document.getElementById('mlSimplifiedLinkWidthVal');
    const mlSimplifiedLinkStyle = document.getElementById('mlSimplifiedLinkStyle');

    if (mlSimplifiedNodeFill) mlSimplifiedNodeFill.value = mapLibreState.simplified.nodeFill;
    if (mlSimplifiedNodeFillBtn) mlSimplifiedNodeFillBtn.style.background = mapLibreState.simplified.nodeFill;
    if (mlSimplifiedNodeFillHex) mlSimplifiedNodeFillHex.textContent = mapLibreState.simplified.nodeFill;
    if (mlSimplifiedNodeStroke) mlSimplifiedNodeStroke.value = mapLibreState.simplified.nodeStroke;
    if (mlSimplifiedNodeStrokeBtn) mlSimplifiedNodeStrokeBtn.style.background = mapLibreState.simplified.nodeStroke;
    if (mlSimplifiedNodeStrokeHex) mlSimplifiedNodeStrokeHex.textContent = mapLibreState.simplified.nodeStroke;
    if (mlSimplifiedNodeSize) mlSimplifiedNodeSize.value = mapLibreState.simplified.nodeSize;
    if (mlSimplifiedNodeSizeVal) mlSimplifiedNodeSizeVal.textContent = mapLibreState.simplified.nodeSize + 'px';
    if (mlSimplifiedLinkColor) mlSimplifiedLinkColor.value = mapLibreState.simplified.linkColor;
    if (mlSimplifiedLinkColorBtn) mlSimplifiedLinkColorBtn.style.background = mapLibreState.simplified.linkColor;
    if (mlSimplifiedLinkColorHex) mlSimplifiedLinkColorHex.textContent = mapLibreState.simplified.linkColor;
    if (mlSimplifiedLinkWidth) mlSimplifiedLinkWidth.value = mapLibreState.simplified.linkWidth;
    if (mlSimplifiedLinkWidthVal) mlSimplifiedLinkWidthVal.textContent = mapLibreState.simplified.linkWidth + 'px';
    if (mlSimplifiedLinkStyle) mlSimplifiedLinkStyle.value = mapLibreState.simplified.linkStyle;
  }
  initMapLibreUI();

  if (mlShowNodeLabels) {
    mlShowNodeLabels.addEventListener('change', () => {
      if (mapLibreState.active) {
        mapLibreState.skipFitBounds = true;
        renderMapLibreContent();
      }
    });
  }
  if (mlShowLinkLabels) {
    mlShowLinkLabels.addEventListener('change', () => {
      if (mapLibreState.active) {
        mapLibreState.skipFitBounds = true;
        renderMapLibreContent();
      }
    });
  }
  if (mlShowLinks) {
    mlShowLinks.addEventListener('change', () => {
      if (mapLibreState.active) {
        mapLibreState.skipFitBounds = true;
        renderMapLibreContent();
      }
    });
  }

  // Selection is always enabled now (no checkbox)
  if (mlUseCanvasColors) {
    mlUseCanvasColors.addEventListener('change', () => {
      mapLibreState.useCanvasColors = mlUseCanvasColors.checked;
      saveMapLibreSettings();
      if (mapLibreState.active) {
        mapLibreState.skipFitBounds = true;
        renderMapLibreContent();
      }
    });
  }
  if (mlDefaultLinkColor) {
    mlDefaultLinkColor.addEventListener('input', () => {
      mapLibreState.defaultLinkColor = mlDefaultLinkColor.value;
      updateMLColorPaletteSelection(mlDefaultLinkColor.value);
      saveMapLibreSettings();
      if (mapLibreState.active && !mapLibreState.useCanvasColors) {
        mapLibreState.skipFitBounds = true;
        renderMapLibreContent();
      }
    });
  }

  // Color palette click handlers
  function updateMLColorPaletteSelection(color) {
    document.querySelectorAll('#mlDefaultLinkColorPalette .ml-color-swatch').forEach(swatch => {
      if (swatch.dataset.color.toLowerCase() === color.toLowerCase()) {
        swatch.style.borderColor = '#0096D6';
      } else {
        swatch.style.borderColor = 'transparent';
      }
    });
  }

  document.querySelectorAll('#mlDefaultLinkColorPalette .ml-color-swatch').forEach(swatch => {
    swatch.addEventListener('click', () => {
      const color = swatch.dataset.color;
      mapLibreState.defaultLinkColor = color;
      if (mlDefaultLinkColor) mlDefaultLinkColor.value = color;
      updateMLColorPaletteSelection(color);
      saveMapLibreSettings();
      if (mapLibreState.active && !mapLibreState.useCanvasColors) {
        mapLibreState.skipFitBounds = true;
        renderMapLibreContent();
      }
    });
  });

  if (mlDefaultLinkWidth) {
    mlDefaultLinkWidth.addEventListener('input', () => {
      mapLibreState.defaultLinkWidth = parseFloat(mlDefaultLinkWidth.value);
      if (mlDefaultLinkWidthVal) mlDefaultLinkWidthVal.textContent = mlDefaultLinkWidth.value + 'px';
      saveMapLibreSettings();
      if (mapLibreState.active && !mapLibreState.useCanvasColors) {
        mapLibreState.skipFitBounds = true;
        renderMapLibreContent();
      }
    });
  }

  // ============== SIMPLIFIED VIEW CONTROLS ==============

  // Create a compact color picker with palette for menus
  function createMenuColorPicker(containerId, inputId, onChange) {
    const container = document.getElementById(containerId);
    const input = document.getElementById(inputId);
    if (!container || !input) return;

    const wrapper = document.createElement('div');
    wrapper.style.cssText = 'position:relative; display:inline-block;';

    const swatch = document.createElement('div');
    swatch.style.cssText = `width:24px; height:24px; background:${input.value}; border:1px solid #999; border-radius:3px; cursor:pointer;`;

    const palette = document.createElement('div');
    palette.style.cssText = 'display:none; position:absolute; left:0; top:28px; background:#fff; border:1px solid #ccc; border-radius:4px; padding:6px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:1000; width:180px;';

    // Add color rows
    [colorPalette.row1, colorPalette.row2, colorPalette.row3, colorPalette.row4].forEach(row => {
      const rowDiv = document.createElement('div');
      rowDiv.style.cssText = 'display:flex; gap:2px; margin-bottom:2px;';
      row.forEach(color => {
        const item = document.createElement('div');
        item.style.cssText = `width:18px; height:18px; background:${color}; border:1px solid #ddd; border-radius:2px; cursor:pointer;`;
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          input.value = color;
          swatch.style.background = color;
          palette.style.display = 'none';
          if (onChange) onChange(color);
          input.dispatchEvent(new Event('input', { bubbles: true }));
        });
        item.addEventListener('mouseenter', () => item.style.transform = 'scale(1.1)');
        item.addEventListener('mouseleave', () => item.style.transform = 'scale(1)');
        rowDiv.appendChild(item);
      });
      palette.appendChild(rowDiv);
    });

    // Custom color input
    const customRow = document.createElement('div');
    customRow.style.cssText = 'display:flex; align-items:center; gap:6px; margin-top:6px; padding-top:6px; border-top:1px solid #eee;';
    const customInput = document.createElement('input');
    customInput.type = 'color';
    customInput.value = input.value;
    customInput.style.cssText = 'width:24px; height:24px; border:none; cursor:pointer;';
    customInput.addEventListener('input', (e) => {
      input.value = e.target.value;
      swatch.style.background = e.target.value;
      if (onChange) onChange(e.target.value);
      input.dispatchEvent(new Event('input', { bubbles: true }));
    });
    const customLabel = document.createElement('span');
    customLabel.textContent = 'Custom';
    customLabel.style.cssText = 'font-size:10px; color:#666;';
    customRow.appendChild(customInput);
    customRow.appendChild(customLabel);
    palette.appendChild(customRow);

    wrapper.appendChild(swatch);
    wrapper.appendChild(palette);
    container.appendChild(wrapper);

    swatch.addEventListener('click', (e) => {
      e.stopPropagation();
      document.querySelectorAll('.menu-color-palette').forEach(p => p.style.display = 'none');
      palette.style.display = palette.style.display === 'none' ? 'block' : 'none';
    });

    palette.classList.add('menu-color-palette');

    document.addEventListener('click', () => {
      palette.style.display = 'none';
    });

    // Return update function
    return {
      update: (color) => {
        swatch.style.background = color;
        customInput.value = color;
      }
    };
  }

  // Style mode toggle for MapLibre
  const mlStyleModeCanvas = document.getElementById('mlStyleModeCanvas');
  const mlStyleModeSimplified = document.getElementById('mlStyleModeSimplified');
  const mlSimplifiedSettings = document.getElementById('mlSimplifiedSettings');

  function updateMapLibreStyleMode() {
    const isSimplified = mlStyleModeSimplified?.checked;
    mapLibreState.styleMode = isSimplified ? 'simplified' : 'canvas';
    if (mlSimplifiedSettings) {
      mlSimplifiedSettings.style.display = isSimplified ? 'block' : 'none';
    }
    saveMapLibreSettings();
    if (mapLibreState.active) {
      mapLibreState.skipFitBounds = true;
      renderMapLibreContent();
    }
  }

  if (mlStyleModeCanvas) mlStyleModeCanvas.addEventListener('change', updateMapLibreStyleMode);
  if (mlStyleModeSimplified) mlStyleModeSimplified.addEventListener('change', updateMapLibreStyleMode);

  // MapLibre simplified color pickers with palette
  const mlNodeFillPicker = createMenuColorPicker('mlSimplifiedNodeFillPicker', 'mlSimplifiedNodeFill');
  const mlNodeStrokePicker = createMenuColorPicker('mlSimplifiedNodeStrokePicker', 'mlSimplifiedNodeStroke');
  const mlLinkColorPicker = createMenuColorPicker('mlSimplifiedLinkColorPicker', 'mlSimplifiedLinkColor');

  const mlSimplifiedNodeFill = document.getElementById('mlSimplifiedNodeFill');
  const mlSimplifiedNodeStroke = document.getElementById('mlSimplifiedNodeStroke');
  const mlSimplifiedNodeSize = document.getElementById('mlSimplifiedNodeSize');
  const mlSimplifiedNodeSizeVal = document.getElementById('mlSimplifiedNodeSizeVal');
  const mlSimplifiedLinkColor = document.getElementById('mlSimplifiedLinkColor');
  const mlSimplifiedLinkWidth = document.getElementById('mlSimplifiedLinkWidth');
  const mlSimplifiedLinkWidthVal = document.getElementById('mlSimplifiedLinkWidthVal');
  const mlSimplifiedLinkStyle = document.getElementById('mlSimplifiedLinkStyle');

  function updateSimplifiedAndRender() {
    mapLibreState.simplified.nodeFill = mlSimplifiedNodeFill?.value || '#dae8fc';
    mapLibreState.simplified.nodeStroke = mlSimplifiedNodeStroke?.value || '#6c8ebf';
    mapLibreState.simplified.nodeSize = parseInt(mlSimplifiedNodeSize?.value) || 20;
    mapLibreState.simplified.linkColor = mlSimplifiedLinkColor?.value || '#6c8ebf';
    mapLibreState.simplified.linkWidth = parseFloat(mlSimplifiedLinkWidth?.value) || 2;
    mapLibreState.simplified.linkStyle = mlSimplifiedLinkStyle?.value || 'solid';
    saveMapLibreSettings();
    if (mapLibreState.active && mapLibreState.styleMode === 'simplified') {
      mapLibreState.skipFitBounds = true;
      renderMapLibreContent();
    }
  }

  if (mlSimplifiedNodeFill) mlSimplifiedNodeFill.addEventListener('input', updateSimplifiedAndRender);
  if (mlSimplifiedNodeStroke) mlSimplifiedNodeStroke.addEventListener('input', updateSimplifiedAndRender);
  if (mlSimplifiedNodeSize) {
    mlSimplifiedNodeSize.addEventListener('input', () => {
      if (mlSimplifiedNodeSizeVal) mlSimplifiedNodeSizeVal.textContent = mlSimplifiedNodeSize.value + 'px';
      updateSimplifiedAndRender();
    });
  }
  if (mlSimplifiedLinkColor) mlSimplifiedLinkColor.addEventListener('input', updateSimplifiedAndRender);
  if (mlSimplifiedLinkWidth) {
    mlSimplifiedLinkWidth.addEventListener('input', () => {
      if (mlSimplifiedLinkWidthVal) mlSimplifiedLinkWidthVal.textContent = mlSimplifiedLinkWidth.value + 'px';
      updateSimplifiedAndRender();
    });
  }
  if (mlSimplifiedLinkStyle) mlSimplifiedLinkStyle.addEventListener('change', updateSimplifiedAndRender);

  // Geo Static view simplified controls
  const geoStaticStyleModeCanvas = document.getElementById('geoStaticStyleModeCanvas');
  const geoStaticStyleModeSimplified = document.getElementById('geoStaticStyleModeSimplified');
  const geoStaticSimplifiedSettings = document.getElementById('geoStaticSimplifiedSettings');

  function updateGeoStaticStyleMode() {
    const isSimplified = geoStaticStyleModeSimplified?.checked;
    geoStaticSimplified.styleMode = isSimplified ? 'simplified' : 'canvas';
    if (geoStaticSimplifiedSettings) {
      geoStaticSimplifiedSettings.style.display = isSimplified ? 'block' : 'none';
    }
    if (geoViewState.active) {
      renderGeoView();
    }
  }

  if (geoStaticStyleModeCanvas) geoStaticStyleModeCanvas.addEventListener('change', updateGeoStaticStyleMode);
  if (geoStaticStyleModeSimplified) geoStaticStyleModeSimplified.addEventListener('change', updateGeoStaticStyleMode);

  // Geo Static simplified color pickers with palette
  const geoStaticNodeFillPicker = createMenuColorPicker('geoStaticNodeFillPicker', 'geoStaticNodeFill');
  const geoStaticNodeStrokePicker = createMenuColorPicker('geoStaticNodeStrokePicker', 'geoStaticNodeStroke');
  const geoStaticLinkColorPicker = createMenuColorPicker('geoStaticLinkColorPicker', 'geoStaticLinkColor');

  const geoStaticNodeFill = document.getElementById('geoStaticNodeFill');
  const geoStaticNodeStroke = document.getElementById('geoStaticNodeStroke');
  const geoStaticNodeSize = document.getElementById('geoStaticNodeSize');
  const geoStaticNodeSizeVal = document.getElementById('geoStaticNodeSizeVal');
  const geoStaticLinkColor = document.getElementById('geoStaticLinkColor');
  const geoStaticLinkWidth = document.getElementById('geoStaticLinkWidth');
  const geoStaticLinkWidthVal = document.getElementById('geoStaticLinkWidthVal');
  const geoStaticLinkStyleSelect = document.getElementById('geoStaticLinkStyle');

  function updateGeoStaticSimplifiedAndRender() {
    geoStaticSimplified.nodeFill = geoStaticNodeFill?.value || '#dae8fc';
    geoStaticSimplified.nodeStroke = geoStaticNodeStroke?.value || '#6c8ebf';
    geoStaticSimplified.nodeSize = parseInt(geoStaticNodeSize?.value) || 12;
    geoStaticSimplified.linkColor = geoStaticLinkColor?.value || '#666666';
    geoStaticSimplified.linkWidth = parseFloat(geoStaticLinkWidth?.value) || 2;
    geoStaticSimplified.linkStyle = geoStaticLinkStyleSelect?.value || 'solid';
    if (geoViewState.active) {
      renderGeoView();
    }
  }

  if (geoStaticNodeFill) geoStaticNodeFill.addEventListener('input', updateGeoStaticSimplifiedAndRender);
  if (geoStaticNodeStroke) geoStaticNodeStroke.addEventListener('input', updateGeoStaticSimplifiedAndRender);
  if (geoStaticNodeSize) {
    geoStaticNodeSize.addEventListener('input', () => {
      if (geoStaticNodeSizeVal) geoStaticNodeSizeVal.textContent = geoStaticNodeSize.value + 'px';
      updateGeoStaticSimplifiedAndRender();
    });
  }
  if (geoStaticLinkColor) geoStaticLinkColor.addEventListener('input', updateGeoStaticSimplifiedAndRender);
  if (geoStaticLinkWidth) {
    geoStaticLinkWidth.addEventListener('input', () => {
      if (geoStaticLinkWidthVal) geoStaticLinkWidthVal.textContent = geoStaticLinkWidth.value + 'px';
      updateGeoStaticSimplifiedAndRender();
    });
  }
  if (geoStaticLinkStyleSelect) geoStaticLinkStyleSelect.addEventListener('change', updateGeoStaticSimplifiedAndRender);

  // Show Nodes checkbox handler for MapLibre
  const mlShowNodes = document.getElementById('mlShowNodes');
  if (mlShowNodes) {
    mlShowNodes.addEventListener('change', () => {
      if (mapLibreState.active) {
        mapLibreState.skipFitBounds = true;
        renderMapLibreContent();
      }
    });
  }

  // ============== END SIMPLIFIED VIEW CONTROLS ==============

  // ============== END MAPLIBRE PATH FINDER ==============

  // Toggle MapLibre view
  function toggleMapLibreView(active) {
    mapLibreState.active = active;

    const mapContainer = document.getElementById('maplibreContainer');
    const svgContainer = document.getElementById('svgContainer');
    const projPanel = document.getElementById('projectionPanel');
    const btnShowPaths = document.getElementById('btnShowPaths');

    // Update radio buttons
    const stdRadio = document.getElementById('viewModeStandard');
    const geoRadio = document.getElementById('viewModeGeo');
    const mapLibreRadio = document.getElementById('viewModeMapLibre');

    if (active) {
      // Determine what view we're coming from
      const fromView = geoViewState.active ? 'geoStatic' : 'canvas';

      // Deactivate other views
      geoViewState.active = false;

      // Switch label settings to geoDynamic
      if (typeof switchViewLabelSettings === 'function') {
        switchViewLabelSettings(fromView, 'geoDynamic');
      }

      // Show MapLibre, hide SVG
      if (mapContainer) {
        mapContainer.classList.add('active');
        // Reset any forced inline styles from deactivation
        mapContainer.style.display = '';
        mapContainer.style.visibility = '';
        mapContainer.style.zIndex = '';
      }
      if (svgContainer) {
        svgContainer.style.display = 'none';
        // Reset other styles
        svgContainer.style.visibility = '';
        svgContainer.style.opacity = '';
        svgContainer.style.zIndex = '';
      }
      if (projPanel) projPanel.style.display = 'none';

      // CRITICAL: Hide wrap overflow to prevent scrollbar interference with map zoom
      const wrap = document.getElementById('wrap');
      if (wrap) wrap.style.overflow = 'hidden';

      // Show Paths toggle button
      if (btnShowPaths) btnShowPaths.style.display = 'flex';

      // Update radios
      if (stdRadio) stdRadio.checked = false;
      if (geoRadio) geoRadio.checked = false;
      if (mapLibreRadio) mapLibreRadio.checked = true;

      // Update toolbar buttons with green active state
      const btnMain = document.getElementById('btnMainView');
      const btnGeoView = document.getElementById('btnGeoView');
      const btnMapBtn = document.getElementById('btnMapLibre');
      const activeColor = '#10b981';

      if (btnMain) {
        btnMain.classList.remove('active');
        btnMain.style.color = '';
      }
      if (btnGeoView) {
        btnGeoView.classList.remove('active');
        btnGeoView.style.color = '';
      }
      if (btnMapBtn) {
        btnMapBtn.classList.add('active');
        btnMapBtn.style.color = activeColor;
      }

      // Initialize and render
      initMapLibre();
      if (mapLibreState.map) {
        mapLibreState.map.resize();
        setupMapClickToDeselect();
        renderMapLibreContent();

        // Re-render route finder highlights after MapLibre is ready
        if (typeof routeFinderState !== 'undefined' && routeFinderState.active && routeFinderState.routes.length > 0) {
          setTimeout(() => highlightActiveRoute(), 300);
        }
      }

      showToast('ðŸ—ºï¸ Geo Dynamic Map â€” click to select, Inspector shows details');
    } else {

      // If path edit mode was active, exit it first (without saving)
      if (state.pathEditMode && state.pathEditMode.active) {
        // Force exit path edit mode - this will call enableNonPathInteractions()
        exitPathEditMode(false);
      } else {
        // Make sure interactions are enabled even if pathEditMode wasn't formally active
        enableNonPathInteractions();
      }

      // Switch label settings back to canvas (will be updated if going to geoStatic)
      if (typeof switchViewLabelSettings === 'function') {
        switchViewLabelSettings('geoDynamic', 'canvas');
      }

      // Hide MapLibre, show SVG
      if (mapContainer) {
        mapContainer.classList.remove('active');
        // Force hide the container with all style properties
        mapContainer.style.display = 'none';
        mapContainer.style.visibility = 'hidden';
        mapContainer.style.zIndex = '-1';
      }
      if (svgContainer) {
        // Force show with all style properties
        svgContainer.style.display = 'block';
        svgContainer.style.visibility = 'visible';
        svgContainer.style.opacity = '1';
        svgContainer.style.zIndex = '1';
      }

      // Also force show the SVG element itself
      const svgEl = document.getElementById('svg');
      if (svgEl) {
        svgEl.style.display = 'block';
        svgEl.style.visibility = 'visible';
        svgEl.style.opacity = '1';
        svgEl.style.pointerEvents = 'auto';
      }

      // RESTORE: wrap overflow when leaving map view
      const wrap = document.getElementById('wrap');
      if (wrap) wrap.style.overflow = 'auto';

      // Hide Paths toggle button
      if (btnShowPaths) btnShowPaths.style.display = 'none';

      // Sync radio buttons back to Standard
      if (stdRadio) stdRadio.checked = true;
      if (geoRadio) geoRadio.checked = false;
      if (mapLibreRadio) mapLibreRadio.checked = false;

      // Update toolbar buttons - back to Main view
      const btnMain = document.getElementById('btnMainView');
      const btnGeoView = document.getElementById('btnGeoView');
      const btnMapBtn = document.getElementById('btnMapLibre');
      const activeColor = '#10b981';

      if (btnMain) {
        btnMain.classList.add('active');
        btnMain.style.color = activeColor;
      }
      if (btnGeoView) {
        btnGeoView.classList.remove('active');
        btnGeoView.style.color = '';
      }
      if (btnMapBtn) {
        btnMapBtn.classList.remove('active');
        btnMapBtn.style.color = '';
      }

      // Clear MapLibre route path when leaving
      clearMapLibreRoutePath();

      // Re-render canvas
      render();
    }
  }

  // Event handlers for MapLibre view mode
  const viewModeMapLibre = document.getElementById('viewModeMapLibre');
  if (viewModeMapLibre) {
    viewModeMapLibre.addEventListener('change', () => {
      if (viewModeMapLibre.checked) {
        if (geoViewState && geoViewState.active) {
          toggleGeoView(false);
        }
        toggleMapLibreView(true);
        updateViewButtonStates('map');
      }
    });
  }

  // Update standard view handler to deactivate MapLibre
  const viewModeStd = document.getElementById('viewModeStandard');
  if (viewModeStd) {
    const origHandler = viewModeStd.onchange;
    viewModeStd.addEventListener('change', () => {
      if (viewModeStd.checked) {
        toggleMapLibreView(false);
        toggleGeoView(false);
        updateViewButtonStates('main');
        render();
      }
    });
  }

  // Update geo view handler to deactivate MapLibre
  const viewModeGeoRadio = document.getElementById('viewModeGeo');
  if (viewModeGeoRadio) {
    viewModeGeoRadio.addEventListener('change', () => {
      if (viewModeGeoRadio.checked) {
        toggleMapLibreView(false);
        toggleGeoView(true);
        updateViewButtonStates('geo');
      }
    });
  }

  // Map style radio handlers
  const mapStyleLiberty = document.getElementById('mapStyleLiberty');
  const mapStyleBright = document.getElementById('mapStyleBright');
  const mapStylePositron = document.getElementById('mapStylePositron');
  const mapStyleDarkMatter = document.getElementById('mapStyleDarkMatter');

  if (mapStyleLiberty) {
    mapStyleLiberty.addEventListener('change', () => {
      if (mapStyleLiberty.checked) changeMapLibreStyle('liberty');
    });
  }
  if (mapStyleBright) {
    mapStyleBright.addEventListener('change', () => {
      if (mapStyleBright.checked) changeMapLibreStyle('bright');
    });
  }
  if (mapStylePositron) {
    mapStylePositron.addEventListener('change', () => {
      if (mapStylePositron.checked) changeMapLibreStyle('positron');
    });
  }
  if (mapStyleDarkMatter) {
    mapStyleDarkMatter.addEventListener('change', () => {
      if (mapStyleDarkMatter.checked) changeMapLibreStyle('darkMatter');
    });
  }

  // Load saved style preference
  try {
    const savedStyle = localStorage.getItem('neximap-maplibre-style');
    if (savedStyle && mapLibreState.styles[savedStyle]) {
      mapLibreState.style = savedStyle;
      const radioId = 'mapStyle' + savedStyle.charAt(0).toUpperCase() + savedStyle.slice(1);
      const radio = document.getElementById(radioId);
      if (radio) radio.checked = true;
    }
  } catch(e) {}

  // Expose for external updates
  window.renderMapLibreContent = renderMapLibreContent;
  window.mapLibreState = mapLibreState;

  // ============== END MAPLIBRE INTERACTIVE MAP ==============

  // ============== END GEOGRAPHIC VIEW ==============

  // ============== FINANCIAL SETTINGS & COMMERCIAL COST ==============

  // Currency symbol mapping
  const currencySymbols = {
    USD: '$', EUR: 'â‚¬', GBP: 'Â£', JPY: 'Â¥', CNY: 'Â¥',
    SGD: 'S$', HKD: 'HK$', AUD: 'A$', CHF: 'Fr', CAD: 'C$',
    INR: 'â‚¹', KRW: 'â‚©', BRL: 'R$', MXN: 'Mex$', AED: 'Ã˜Â¯.Ã˜Â¥', SAR: 'ï·¼'
  };

  function getCurrencySymbol(code) {
    return currencySymbols[code] || code;
  }

  // Calculate Annual Contract Value (ACV) for Lease
  function calculateLeaseACV(nrc, mrc) {
    return nrc + (12 * mrc);
  }

  // Calculate IRU NPV (Net Present Value)
  // NPV = IRU_fee + ÃŽÂ£(OAM_year_n / (1 + r)^n) for n = 1 to term
  // Where OAM_year_n = IRU_fee Ã— OAM% Ã— (1 + annual_increment%)^(n-1)
  function calculateIRUNPV(iruFee, term, oamPercent, oamIncrement, discountRate) {
    const r = discountRate / 100; // Convert percentage to decimal
    const oam = oamPercent / 100;
    const increment = oamIncrement / 100;

    let npv = iruFee; // Initial IRU fee (at year 0)

    for (let n = 1; n <= term; n++) {
      const oamYearN = iruFee * oam * Math.pow(1 + increment, n - 1);
      const presentValue = oamYearN / Math.pow(1 + r, n);
      npv += presentValue;
    }

    return npv;
  }

  // Format currency value
  function formatCurrency(value, currencyCode) {
    const symbol = getCurrencySymbol(currencyCode || state.financialSettings.baseCurrency);
    if (value >= 1000000) {
      return symbol + (value / 1000000).toFixed(2) + 'M';
    } else if (value >= 1000) {
      return symbol + (value / 1000).toFixed(2) + 'K';
    }
    return symbol + value.toFixed(2);
  }

  // Get commercial cost for edge (based on mode)
  function getEdgeCommercialCost(edge) {
    const mode = edge.commercialCostMode || state.pathfinderSettings.costMetric || 'lease';
    if (mode === 'iru') {
      return calculateIRUNPV(
        edge.iruFee || 1,
        edge.iruTerm || 15,
        edge.iruOamPercent ?? 3,
        edge.iruOamAnnualIncrement ?? 2,
        state.financialSettings.npvDiscountRate || 12.5
      );
    } else {
      return calculateLeaseACV(edge.leaseNRC || 0, edge.leaseMRC || 1);
    }
  }

  // Update edge commercial cost display in inspector - TIER BASED
  function updateEdgeCostDisplay() {
    if (!state.selected || state.selected.type !== 'edge') return;

    const edge = findEdge(state.selected.id);
    if (!edge) return;

    const currency = state.financialSettings.baseCurrency || 'USD';
    const symbol = getCurrencySymbol(currency);
    const discountRate = state.financialSettings.npvDiscountRate || 12.5;

    // Update currency labels
    const edgeLeaseCurrency = document.getElementById('edgeLeaseCurrency');
    const edgeIRUCurrency = document.getElementById('edgeIRUCurrency');
    const edgeIRUDiscountRate = document.getElementById('edgeIRUDiscountRate');

    if (edgeLeaseCurrency) edgeLeaseCurrency.textContent = currency;
    if (edgeIRUCurrency) edgeIRUCurrency.textContent = currency;
    if (edgeIRUDiscountRate) edgeIRUDiscountRate.textContent = discountRate.toFixed(1);

    // Calculate and display ACV for each tier
    const tiers = ['1G', '10G', '100G', '400G'];
    const iruTerm = parseFloat(document.getElementById('edgeIRUTerm')?.value) || 15;
    const iruOAM = parseFloat(document.getElementById('edgeIRUOAM')?.value) || 3;
    const iruIncrement = parseFloat(document.getElementById('edgeIRUOAMIncrement')?.value) || 2;

    tiers.forEach(tier => {
      // Calculate Lease ACV for this tier
      const nrc = parseFloat(document.getElementById(`edgeLeaseNRC_${tier}`)?.value) || 0;
      const mrc = parseFloat(document.getElementById(`edgeLeaseMRC_${tier}`)?.value) || 1;
      const acv = calculateLeaseACV(nrc, mrc);
      const acvEl = document.getElementById(`edgeLeaseACV_${tier}`);
      if (acvEl) acvEl.textContent = formatCurrency(acv, currency);

      // Calculate IRU NPV for this tier
      const iruFee = parseFloat(document.getElementById(`edgeIRUFee_${tier}`)?.value) || 1;
      const iruNPV = calculateIRUNPV(iruFee, iruTerm, iruOAM, iruIncrement, discountRate);
      const npvEl = document.getElementById(`edgeIRUNPV_${tier}`);
      if (npvEl) npvEl.textContent = formatCurrency(iruNPV, currency);
    });
  }

  // Set up commercial cost inspector handlers - TIER BASED
  function setupCommercialCostHandlers() {
    const tiers = ['1G', '10G', '100G', '400G'];

    // Cost mode radio handlers
    const costModeRadios = document.querySelectorAll('input[name="edgeCostMode"]');
    costModeRadios.forEach(radio => {
      radio.addEventListener('change', () => {
        if (!state.selected || state.selected.type !== 'edge') return;
        const edge = findEdge(state.selected.id);
        if (edge) {
          edge.commercialCostMode = radio.value;
          commit();
        }
      });
    });

    // Lease NRC/MRC fields for each tier
    tiers.forEach(tier => {
      const nrcEl = document.getElementById(`edgeLeaseNRC_${tier}`);
      const mrcEl = document.getElementById(`edgeLeaseMRC_${tier}`);

      if (nrcEl) {
        nrcEl.addEventListener('input', () => updateEdgeCostDisplay());
        nrcEl.addEventListener('change', () => {
          if (!state.selected || state.selected.type !== 'edge') return;
          const edge = findEdge(state.selected.id);
          if (edge) {
            if (typeof edge.leaseNRC !== 'object') {
              edge.leaseNRC = normalizeTierPricing(edge.leaseNRC, 0);
            }
            edge.leaseNRC[tier] = parseFloat(nrcEl.value) || 0;
            commit();
          }
        });
      }

      if (mrcEl) {
        mrcEl.addEventListener('input', () => updateEdgeCostDisplay());
        mrcEl.addEventListener('change', () => {
          if (!state.selected || state.selected.type !== 'edge') return;
          const edge = findEdge(state.selected.id);
          if (edge) {
            if (typeof edge.leaseMRC !== 'object') {
              edge.leaseMRC = normalizeTierPricing(edge.leaseMRC, 1);
            }
            edge.leaseMRC[tier] = parseFloat(mrcEl.value) || 1;
            commit();
          }
        });
      }

      // IRU Fee for each tier
      const iruFeeEl = document.getElementById(`edgeIRUFee_${tier}`);
      if (iruFeeEl) {
        iruFeeEl.addEventListener('input', () => updateEdgeCostDisplay());
        iruFeeEl.addEventListener('change', () => {
          if (!state.selected || state.selected.type !== 'edge') return;
          const edge = findEdge(state.selected.id);
          if (edge) {
            if (typeof edge.iruFee !== 'object') {
              edge.iruFee = normalizeTierPricing(edge.iruFee, 1);
            }
            edge.iruFee[tier] = parseFloat(iruFeeEl.value) || 1;
            commit();
          }
        });
      }
    });

    // Common IRU fields (apply to all tiers)
    const iruTerm = document.getElementById('edgeIRUTerm');
    const iruOAM = document.getElementById('edgeIRUOAM');
    const iruIncrement = document.getElementById('edgeIRUOAMIncrement');

    [iruTerm, iruOAM, iruIncrement].forEach(input => {
      if (input) {
        input.addEventListener('input', () => updateEdgeCostDisplay());
        input.addEventListener('change', () => {
          if (!state.selected || state.selected.type !== 'edge') return;
          const edge = findEdge(state.selected.id);
          if (edge) {
            if (input.id === 'edgeIRUTerm') edge.iruTerm = parseInt(input.value) || 15;
            if (input.id === 'edgeIRUOAM') edge.iruOamPercent = parseFloat(input.value) || 3;
            if (input.id === 'edgeIRUOAMIncrement') edge.iruOamAnnualIncrement = parseFloat(input.value) || 2;
            commit();
          }
        });
      }
    });

    // Auto-fill buttons for tier pricing
    const btnAutoFillLeaseTiers = document.getElementById('btnAutoFillLeaseTiers');
    if (btnAutoFillLeaseTiers) {
      btnAutoFillLeaseTiers.addEventListener('click', () => {
        if (!state.selected || state.selected.type !== 'edge') return;
        const edge = findEdge(state.selected.id);
        if (!edge) return;

        // Get 1G values
        const nrc1G = parseFloat(document.getElementById('edgeLeaseNRC_1G')?.value) || 0;
        const mrc1G = parseFloat(document.getElementById('edgeLeaseMRC_1G')?.value) || 1;

        // Get multipliers from settings (with defaults)
        const tierMults = state.financialSettings.tierMultipliers || {};
        const multipliers = {
          '10G': tierMults['10G'] || 2.5,
          '100G': tierMults['100G'] || 6.25,
          '400G': tierMults['400G'] || 15.625
        };

        // Ensure edge fields are objects
        if (typeof edge.leaseNRC !== 'object') edge.leaseNRC = normalizeTierPricing(edge.leaseNRC, 0);
        if (typeof edge.leaseMRC !== 'object') edge.leaseMRC = normalizeTierPricing(edge.leaseMRC, 1);

        // Apply multipliers
        Object.entries(multipliers).forEach(([tier, mult]) => {
          const nrcVal = Math.round(nrc1G * mult * 100) / 100;
          const mrcVal = Math.round(mrc1G * mult * 100) / 100;

          edge.leaseNRC[tier] = nrcVal;
          edge.leaseMRC[tier] = mrcVal;

          const nrcEl = document.getElementById(`edgeLeaseNRC_${tier}`);
          const mrcEl = document.getElementById(`edgeLeaseMRC_${tier}`);
          if (nrcEl) nrcEl.value = nrcVal;
          if (mrcEl) mrcEl.value = mrcVal;
        });

        commit();
        updateEdgeCostDisplay();
        showToast('Lease tiers auto-filled from 1G pricing');
      });
    }

    const btnAutoFillIRUTiers = document.getElementById('btnAutoFillIRUTiers');
    if (btnAutoFillIRUTiers) {
      btnAutoFillIRUTiers.addEventListener('click', () => {
        if (!state.selected || state.selected.type !== 'edge') return;
        const edge = findEdge(state.selected.id);
        if (!edge) return;

        // Get 1G value
        const fee1G = parseFloat(document.getElementById('edgeIRUFee_1G')?.value) || 1;

        // Get multipliers from settings (with defaults)
        const tierMults = state.financialSettings.tierMultipliers || {};
        const multipliers = {
          '10G': tierMults['10G'] || 2.5,
          '100G': tierMults['100G'] || 6.25,
          '400G': tierMults['400G'] || 15.625
        };

        // Ensure edge field is object
        if (typeof edge.iruFee !== 'object') edge.iruFee = normalizeTierPricing(edge.iruFee, 1);

        // Apply multipliers
        Object.entries(multipliers).forEach(([tier, mult]) => {
          const feeVal = Math.round(fee1G * mult * 100) / 100;
          edge.iruFee[tier] = feeVal;

          const feeEl = document.getElementById(`edgeIRUFee_${tier}`);
          if (feeEl) feeEl.value = feeVal;
        });

        commit();
        updateEdgeCostDisplay();
        showToast('IRU tiers auto-filled from 1G pricing');
      });
    }

    // Settings link in cost section
    const edgeCostSettingsLink = document.getElementById('edgeCostSettingsLink');
    if (edgeCostSettingsLink) {
      edgeCostSettingsLink.addEventListener('click', (e) => {
        e.preventDefault();
        showFinancialSettingsModal();
      });
    }
  }

  // Financial Settings Modal handlers
  function showFinancialSettingsModal() {
    const modal = document.getElementById('financialSettingsModal');
    if (!modal) return;

    // Populate fields with current settings
    const finBaseCurrency = document.getElementById('finBaseCurrency');
    const finDiscountRate = document.getElementById('finDiscountRate');
    const finDefaultNRC = document.getElementById('finDefaultNRC');
    const finDefaultMRC = document.getElementById('finDefaultMRC');
    const finDefaultIRU = document.getElementById('finDefaultIRU');
    const finDefaultIRUTerm = document.getElementById('finDefaultIRUTerm');
    const finDefaultOAM = document.getElementById('finDefaultOAM');
    const finDefaultCostMetric = document.getElementById('finDefaultCostMetric');
    const finCostScale = document.getElementById('finCostScale');
    const finTierMult10G = document.getElementById('finTierMult10G');
    const finTierMult100G = document.getElementById('finTierMult100G');
    const finTierMult400G = document.getElementById('finTierMult400G');

    // Container defaults
    const finContainerDefaultNRC = document.getElementById('finContainerDefaultNRC');
    const finContainerDefaultMRC = document.getElementById('finContainerDefaultMRC');
    const finContainerDefaultIRU = document.getElementById('finContainerDefaultIRU');
    const finContainerDefaultIRUTerm = document.getElementById('finContainerDefaultIRUTerm');
    const finContainerDefaultOAM = document.getElementById('finContainerDefaultOAM');

    if (finBaseCurrency) finBaseCurrency.value = state.financialSettings.baseCurrency || 'USD';
    if (finDiscountRate) finDiscountRate.value = state.financialSettings.npvDiscountRate || 12.5;
    if (finDefaultNRC) finDefaultNRC.value = state.financialSettings.defaultNRC || 0;
    if (finDefaultMRC) finDefaultMRC.value = state.financialSettings.defaultMRC || 1;
    if (finDefaultIRU) finDefaultIRU.value = state.financialSettings.defaultIRU || 1;
    if (finDefaultIRUTerm) finDefaultIRUTerm.value = state.financialSettings.defaultIRUTerm || 15;
    if (finDefaultOAM) finDefaultOAM.value = state.financialSettings.defaultOAM || 5;
    if (finDefaultCostMetric) finDefaultCostMetric.value = state.pathfinderSettings.costMetric || 'lease';
    if (finCostScale) finCostScale.value = state.pathfinderSettings.costScale || 'logarithmic';

    // Populate container defaults
    if (finContainerDefaultNRC) finContainerDefaultNRC.value = state.financialSettings.containerDefaultNRC || 0;
    if (finContainerDefaultMRC) finContainerDefaultMRC.value = state.financialSettings.containerDefaultMRC || 1;
    if (finContainerDefaultIRU) finContainerDefaultIRU.value = state.financialSettings.containerDefaultIRU || 1;
    if (finContainerDefaultIRUTerm) finContainerDefaultIRUTerm.value = state.financialSettings.containerDefaultIRUTerm || 15;
    if (finContainerDefaultOAM) finContainerDefaultOAM.value = state.financialSettings.containerDefaultOAM || 3;

    // Load tier multipliers
    const multipliers = state.financialSettings.tierMultipliers || { '10G': 2.5, '100G': 6.25, '400G': 15.625 };
    if (finTierMult10G) finTierMult10G.value = multipliers['10G'] || 2.5;
    if (finTierMult100G) finTierMult100G.value = multipliers['100G'] || 6.25;
    if (finTierMult400G) finTierMult400G.value = multipliers['400G'] || 15.625;

    // Load IRU from MRC multiplier
    const finIRUFromMRCMultiplier = document.getElementById('finIRUFromMRCMultiplier');
    if (finIRUFromMRCMultiplier) {
      finIRUFromMRCMultiplier.value = state.financialSettings.iruFromMRCMultiplier || 36;
      updateIRUExampleResult();
    }

    // Update currency unit labels
    updateFinancialSettingsUnits();

    // Update exchange rates display
    updateExchangeRatesDisplay();

    modal.classList.add('show');
  }

  function hideFinancialSettingsModal() {
    const modal = document.getElementById('financialSettingsModal');
    if (modal) modal.classList.remove('show');
  }

  function updateFinancialSettingsUnits() {
    const currency = document.getElementById('finBaseCurrency')?.value || 'USD';
    const finDefaultNRCUnit = document.getElementById('finDefaultNRCUnit');
    const finDefaultMRCUnit = document.getElementById('finDefaultMRCUnit');
    const finDefaultIRUUnit = document.getElementById('finDefaultIRUUnit');
    if (finDefaultNRCUnit) finDefaultNRCUnit.textContent = currency;
    if (finDefaultMRCUnit) finDefaultMRCUnit.textContent = currency;
    if (finDefaultIRUUnit) finDefaultIRUUnit.textContent = currency;

    // Container default units
    const finContainerDefaultNRCUnit = document.getElementById('finContainerDefaultNRCUnit');
    const finContainerDefaultMRCUnit = document.getElementById('finContainerDefaultMRCUnit');
    const finContainerDefaultIRUUnit = document.getElementById('finContainerDefaultIRUUnit');
    if (finContainerDefaultNRCUnit) finContainerDefaultNRCUnit.textContent = currency;
    if (finContainerDefaultMRCUnit) finContainerDefaultMRCUnit.textContent = currency;
    if (finContainerDefaultIRUUnit) finContainerDefaultIRUUnit.textContent = currency;
  }

  function updateExchangeRatesDisplay() {
    const grid = document.getElementById('currencyRatesGrid');
    const updatedEl = document.getElementById('ratesUpdatedTime');

    if (grid && state.financialSettings.exchangeRates) {
      const rates = state.financialSettings.exchangeRates;
      const displayCurrencies = ['EUR', 'GBP', 'JPY', 'SGD', 'HKD', 'AUD', 'CHF', 'CNY'];

      grid.innerHTML = displayCurrencies.map(code => {
        const rate = rates[code];
        const rateText = rate ? rate.toFixed(4) : 'â€”';
        return `<div class="currency-rate-item"><span class="code">${code}</span><span class="rate">${rateText}</span></div>`;
      }).join('');
    }

    if (updatedEl) {
      if (state.financialSettings.exchangeRatesUpdated) {
        const date = new Date(state.financialSettings.exchangeRatesUpdated);
        updatedEl.textContent = `Last updated: ${date.toLocaleString()}`;
      } else {
        updatedEl.textContent = 'Exchange rates not yet loaded';
      }
    }
  }

  // Fetch exchange rates from Frankfurter API
  async function fetchExchangeRates() {
    const btn = document.getElementById('btnFetchRates');
    const icon = document.getElementById('fetchRatesIcon');

    if (btn) btn.disabled = true;
    if (icon) icon.textContent = 'â³';

    try {
      const response = await fetch('https://api.frankfurter.app/latest?from=USD');
      if (!response.ok) throw new Error('Failed to fetch rates');

      const data = await response.json();

      state.financialSettings.exchangeRates = data.rates;
      state.financialSettings.exchangeRatesUpdated = new Date().toISOString();

      updateExchangeRatesDisplay();
      showToast('Exchange rates updated successfully');

    } catch (error) {
      console.error('Failed to fetch exchange rates:', error);
      showToast('Failed to fetch exchange rates. Check your internet connection.');
    } finally {
      if (btn) btn.disabled = false;
      if (icon) icon.textContent = 'ðŸ”„';
    }
  }

  function saveFinancialSettings() {
    const finBaseCurrency = document.getElementById('finBaseCurrency');
    const finDiscountRate = document.getElementById('finDiscountRate');
    const finDefaultNRC = document.getElementById('finDefaultNRC');
    const finDefaultMRC = document.getElementById('finDefaultMRC');
    const finDefaultIRU = document.getElementById('finDefaultIRU');
    const finDefaultIRUTerm = document.getElementById('finDefaultIRUTerm');
    const finDefaultOAM = document.getElementById('finDefaultOAM');
    const finDefaultCostMetric = document.getElementById('finDefaultCostMetric');
    const finCostScale = document.getElementById('finCostScale');
    const finTierMult10G = document.getElementById('finTierMult10G');
    const finTierMult100G = document.getElementById('finTierMult100G');
    const finTierMult400G = document.getElementById('finTierMult400G');

    // Container defaults
    const finContainerDefaultNRC = document.getElementById('finContainerDefaultNRC');
    const finContainerDefaultMRC = document.getElementById('finContainerDefaultMRC');
    const finContainerDefaultIRU = document.getElementById('finContainerDefaultIRU');
    const finContainerDefaultIRUTerm = document.getElementById('finContainerDefaultIRUTerm');
    const finContainerDefaultOAM = document.getElementById('finContainerDefaultOAM');

    // Update financial settings
    state.financialSettings.baseCurrency = finBaseCurrency?.value || 'USD';
    state.financialSettings.npvDiscountRate = parseFloat(finDiscountRate?.value) || 12.5;
    state.financialSettings.defaultNRC = parseFloat(finDefaultNRC?.value) || 0;
    state.financialSettings.defaultMRC = parseFloat(finDefaultMRC?.value) || 1;
    state.financialSettings.defaultIRU = parseFloat(finDefaultIRU?.value) || 1;
    state.financialSettings.defaultIRUTerm = parseInt(finDefaultIRUTerm?.value) || 15;
    state.financialSettings.defaultOAM = parseFloat(finDefaultOAM?.value) || 5;

    // Update container defaults
    state.financialSettings.containerDefaultNRC = parseFloat(finContainerDefaultNRC?.value) || 0;
    state.financialSettings.containerDefaultMRC = parseFloat(finContainerDefaultMRC?.value) || 1;
    state.financialSettings.containerDefaultIRU = parseFloat(finContainerDefaultIRU?.value) || 1;
    state.financialSettings.containerDefaultIRUTerm = parseInt(finContainerDefaultIRUTerm?.value) || 15;
    state.financialSettings.containerDefaultOAM = parseFloat(finContainerDefaultOAM?.value) || 3;

    // Update tier multipliers
    state.financialSettings.tierMultipliers = {
      '10G': parseFloat(finTierMult10G?.value) || 2.5,
      '100G': parseFloat(finTierMult100G?.value) || 6.25,
      '400G': parseFloat(finTierMult400G?.value) || 15.625
    };

    // Update IRU from MRC multiplier
    const finIRUFromMRCMultiplier = document.getElementById('finIRUFromMRCMultiplier');
    state.financialSettings.iruFromMRCMultiplier = parseFloat(finIRUFromMRCMultiplier?.value) || 36;

    // Update pathfinder settings
    state.pathfinderSettings.costMetric = finDefaultCostMetric?.value || 'lease';
    state.pathfinderSettings.costScale = finCostScale?.value || 'logarithmic';

    commit();
    hideFinancialSettingsModal();

    // Update any open cost displays
    updateEdgeCostDisplay();

    // Update hint text on auto-fill buttons
    updateAutoFillHints();

    showToast('Financial settings saved');
  }

  // Update auto-fill button hints with current multipliers
  function updateAutoFillHints() {
    const mult10G = state.financialSettings.tierMultipliers?.['10G'] || 2.5;
    const mult100G = state.financialSettings.tierMultipliers?.['100G'] || 6.25;
    const mult400G = state.financialSettings.tierMultipliers?.['400G'] || 15.625;

    const hints = document.querySelectorAll('.tier-multiplier-help .hint');
    hints.forEach(hint => {
      hint.textContent = `Ã—${mult10G} (10G), Ã—${mult100G} (100G), Ã—${mult400G} (400G)`;
    });
  }

  // Initialize Financial Settings modal handlers
  function initFinancialSettingsModal() {
    // Close button
    const btnClose = document.getElementById('btnCloseFinancialSettings');
    if (btnClose) btnClose.addEventListener('click', hideFinancialSettingsModal);

    // Cancel button
    const btnCancel = document.getElementById('btnCancelFinancialSettings');
    if (btnCancel) btnCancel.addEventListener('click', hideFinancialSettingsModal);

    // Save button
    const btnSave = document.getElementById('btnSaveFinancialSettings');
    if (btnSave) btnSave.addEventListener('click', saveFinancialSettings);

    // Fetch rates button
    const btnFetchRates = document.getElementById('btnFetchRates');
    if (btnFetchRates) btnFetchRates.addEventListener('click', fetchExchangeRates);

    // Currency change updates units
    const finBaseCurrency = document.getElementById('finBaseCurrency');
    if (finBaseCurrency) {
      finBaseCurrency.addEventListener('change', updateFinancialSettingsUnits);
    }

    // Close on escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const modal = document.getElementById('financialSettingsModal');
        if (modal?.classList.contains('show')) {
          hideFinancialSettingsModal();
        }
      }
    });

    // Close on backdrop click
    const modal = document.getElementById('financialSettingsModal');
    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) hideFinancialSettingsModal();
      });
    }

    // Settings menu item
    const miFinancialSettings = document.getElementById('miFinancialSettings');
    if (miFinancialSettings) {
      miFinancialSettings.addEventListener('click', () => {
        closeAllMenus();
        showFinancialSettingsModal();
      });
    }

    // Reset multipliers button
    const btnResetMultipliers = document.getElementById('btnResetMultipliers');
    if (btnResetMultipliers) {
      btnResetMultipliers.addEventListener('click', () => {
        const finTierMult10G = document.getElementById('finTierMult10G');
        const finTierMult100G = document.getElementById('finTierMult100G');
        const finTierMult400G = document.getElementById('finTierMult400G');
        if (finTierMult10G) finTierMult10G.value = 2.5;
        if (finTierMult100G) finTierMult100G.value = 6.25;
        if (finTierMult400G) finTierMult400G.value = 15.625;
      });
    }

    // IRU from MRC multiplier - update example in real-time
    const finIRUFromMRCMultiplier = document.getElementById('finIRUFromMRCMultiplier');
    if (finIRUFromMRCMultiplier) {
      finIRUFromMRCMultiplier.addEventListener('input', updateIRUExampleResult);
    }
  }

  // Update IRU example calculation display
  function updateIRUExampleResult() {
    const finIRUFromMRCMultiplier = document.getElementById('finIRUFromMRCMultiplier');
    const finIRUExampleResult = document.getElementById('finIRUExampleResult');
    if (finIRUFromMRCMultiplier && finIRUExampleResult) {
      const mult = parseFloat(finIRUFromMRCMultiplier.value) || 36;
      const result = 1000 * mult;
      finIRUExampleResult.textContent = result.toLocaleString();
    }
  }

  // Initialize on load
  setTimeout(() => {
    initFinancialSettingsModal();
    setupCommercialCostHandlers();
    initDataTable();
    setupMLGCostHandlers();
  }, 200);

  // Expose functions globally
  window.showFinancialSettingsModal = showFinancialSettingsModal;
  window.calculateLeaseACV = calculateLeaseACV;
  window.calculateIRUNPV = calculateIRUNPV;
  window.getEdgeCommercialCost = getEdgeCommercialCost;
  window.formatCurrency = formatCurrency;
  window.updateEdgeCostDisplay = updateEdgeCostDisplay;

  // ============== END FINANCIAL SETTINGS & COMMERCIAL COST ==============

  // ============== HEAT MAP FUNCTIONALITY ==============

  // Get heat map value for an edge based on current mode
  // Returns null if no data is available
  function getHeatMapValue(edge) {
    if (heatMapState.mode === 'capacity') {
      // Calculate total capacity in Gbps
      const cap1G = edge.cap1G || 0;
      const cap10G = edge.cap10G || 0;
      const cap100G = edge.cap100G || 0;
      const cap400G = edge.cap400G || 0;
      const capTbps = edge.capTbps || 0;
      const total = cap1G + (10 * cap10G) + (100 * cap100G) + (400 * cap400G) + (1000 * capTbps);
      // Return null if all capacity fields are zero/undefined (no data)
      if (cap1G === 0 && cap10G === 0 && cap100G === 0 && cap400G === 0 && capTbps === 0) {
        return null;
      }
      return total;
    } else if (heatMapState.mode === 'price') {
      // Get MRC for selected tier
      const mrc = getValueForTier(edge.leaseMRC, heatMapState.priceTier, 0);
      // Return null if MRC is 0 or undefined (no data)
      if (mrc === 0 || mrc === undefined || mrc === null) {
        return null;
      }
      return mrc;
    }
    return null;
  }

  // Calculate min/max values for current heat map mode (excluding null values)
  function calculateHeatMapRange() {
    if (!heatMapState.active || heatMapState.mode === 'off') return;

    let min = Infinity;
    let max = -Infinity;
    let hasData = false;

    state.edges.forEach(e => {
      if (!isEdgeVisible(e)) return;
      const val = getHeatMapValue(e);
      if (val !== null) {
        hasData = true;
        if (val < min) min = val;
        if (val > max) max = val;
      }
    });

    // Handle edge cases
    if (!hasData || min === Infinity) min = 0;
    if (!hasData || max === -Infinity) max = 100;
    if (min === max) max = min + 1; // Avoid division by zero

    heatMapState.minValue = min;
    heatMapState.maxValue = max;
  }

  // Interpolate between two colors based on a ratio (0-1)
  function interpolateColor(color1, color2, ratio) {
    // Parse hex colors
    const r1 = parseInt(color1.slice(1, 3), 16);
    const g1 = parseInt(color1.slice(3, 5), 16);
    const b1 = parseInt(color1.slice(5, 7), 16);

    const r2 = parseInt(color2.slice(1, 3), 16);
    const g2 = parseInt(color2.slice(3, 5), 16);
    const b2 = parseInt(color2.slice(5, 7), 16);

    // Interpolate
    const r = Math.round(r1 + (r2 - r1) * ratio);
    const g = Math.round(g1 + (g2 - g1) * ratio);
    const b = Math.round(b1 + (b2 - b1) * ratio);

    // Convert back to hex
    return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
  }

  // Grey color for links with no data
  const HEAT_MAP_NO_DATA_COLOR = '#9ca3af';

  // Helper function to render the current active view (canvas, geo static, or geo dynamic)
  function renderCurrentView() {
    if (window.mapLibreState && window.mapLibreState.active && typeof window.renderMapLibreContent === 'function') {
      window.mapLibreState.skipFitBounds = true;
      window.renderMapLibreContent();
    } else if (window.geoViewState && window.geoViewState.active && typeof window.renderGeoView === 'function') {
      window.renderGeoView();
    } else {
      render();
    }
  }

  // Get heat map color for an edge
  function getHeatMapColor(edge) {
    if (!heatMapState.active || heatMapState.mode === 'off') {
      return null; // Return null to use normal color
    }

    const value = getHeatMapValue(edge);
    console.log('[HeatMap] getHeatMapColor called for edge', edge.id, '- value:', value);

    // Return grey for links with no data
    if (value === null) {
      return HEAT_MAP_NO_DATA_COLOR;
    }

    const min = heatMapState.minValue;
    const max = heatMapState.maxValue;
    const range = max - min;

    let ratio;
    if (range <= 0) {
      ratio = 0;
    } else if (heatMapState.useLogarithmic && min >= 0 && value >= 0) {
      // Logarithmic scale for better visualization of wide ranges
      // Add 1 to avoid log(0), then normalize
      const logMin = Math.log10(min + 1);
      const logMax = Math.log10(max + 1);
      const logValue = Math.log10(value + 1);
      const logRange = logMax - logMin;
      ratio = logRange > 0 ? (logValue - logMin) / logRange : 0;
    } else {
      // Linear scale
      ratio = (value - min) / range;
    }

    return interpolateColor(heatMapState.coldColor, heatMapState.hotColor, Math.min(1, Math.max(0, ratio)));
  }

  // Update heat map legend and active indicator
  function updateHeatMapLegend() {
    const legend = document.getElementById('heatMapLegend');
    const title = document.getElementById('heatMapLegendTitle');
    const subtitle = document.getElementById('heatMapLegendSubtitle');
    const gradient = document.getElementById('heatMapLegendGradient');
    const minLabel = document.getElementById('heatMapLegendMin');
    const maxLabel = document.getElementById('heatMapLegendMax');
    const activeIndicator = document.getElementById('heatMapActiveIndicator');
    const activeLabel = document.getElementById('heatMapActiveLabel');

    if (!legend) return;

    if (!heatMapState.active || heatMapState.mode === 'off') {
      legend.style.display = 'none';
      if (activeIndicator) activeIndicator.style.display = 'none';
      return;
    }

    // Show active indicator
    if (activeIndicator) {
      activeIndicator.style.display = 'flex';
      if (activeLabel) {
        const scaleLabel = heatMapState.useLogarithmic ? ' (log)' : '';
        if (heatMapState.mode === 'capacity') {
          activeLabel.textContent = `Heat Map: Capacity${scaleLabel}`;
        } else if (heatMapState.mode === 'price') {
          activeLabel.textContent = `Heat Map: Price @ ${heatMapState.priceTier}${scaleLabel}`;
        }
      }
      // Update scale toggle button
      const scaleToggle = document.getElementById('heatMapScaleToggle');
      if (scaleToggle) {
        scaleToggle.textContent = heatMapState.useLogarithmic ? 'Log' : 'Lin';
        scaleToggle.title = heatMapState.useLogarithmic ?
          'Currently logarithmic - click for linear scale' :
          'Currently linear - click for logarithmic scale';
      }
    }

    // Show legend if enabled
    if (heatMapState.showLegend) {
      legend.style.display = 'block';
    } else {
      legend.style.display = 'none';
    }

    const scaleLabel = heatMapState.useLogarithmic ? ' (log)' : '';

    // Update title and subtitle
    if (heatMapState.mode === 'capacity') {
      title.textContent = 'ðŸŒ¡ï¸ Capacity Heat Map';
      subtitle.textContent = `Total Available Capacity (Gbps)${scaleLabel}`;
      minLabel.textContent = heatMapState.minValue.toFixed(0) + ' Gbps';
      maxLabel.textContent = heatMapState.maxValue.toFixed(0) + ' Gbps';
    } else if (heatMapState.mode === 'price') {
      title.textContent = 'ðŸŒ¡ï¸ Price Heat Map';
      subtitle.textContent = `MRC @ ${heatMapState.priceTier}${scaleLabel}`;
      const currency = state.financialSettings?.baseCurrency || 'USD';
      const symbol = getCurrencySymbol(currency);
      minLabel.textContent = symbol + heatMapState.minValue.toFixed(0);
      maxLabel.textContent = symbol + heatMapState.maxValue.toFixed(0);
    }

    // Update gradient
    gradient.style.background = `linear-gradient(to right, ${heatMapState.coldColor}, ${heatMapState.hotColor})`;
  }

  // Update heat map gradient preview in menu
  function updateHeatMapGradientPreview() {
    const preview = document.getElementById('heatMapGradientPreview');
    if (preview) {
      preview.style.background = `linear-gradient(to right, ${heatMapState.coldColor}, ${heatMapState.hotColor})`;
    }
  }

  // Apply heat map mode change
  function applyHeatMapMode(mode) {
    console.log('[HeatMap] Applying mode:', mode);
    heatMapState.mode = mode;
    heatMapState.active = mode !== 'off';
    console.log('[HeatMap] State active:', heatMapState.active);

    // Set mode-specific default colors
    if (mode === 'capacity') {
      heatMapState.coldColor = heatMapState.capacityColdColor;
      heatMapState.hotColor = heatMapState.capacityHotColor;
    } else if (mode === 'price') {
      heatMapState.coldColor = heatMapState.priceColdColor;
      heatMapState.hotColor = heatMapState.priceHotColor;
    }

    // Update color swatches in UI
    updateHeatMapColorSwatches();

    // Show/hide price tier section
    const priceTierSection = document.getElementById('heatMapPriceTierSection');
    if (priceTierSection) {
      priceTierSection.style.display = mode === 'price' ? 'block' : 'none';
    }

    // Show/hide active indicator immediately
    const activeIndicator = document.getElementById('heatMapActiveIndicator');
    const activeLabel = document.getElementById('heatMapActiveLabel');
    console.log('[HeatMap] Active indicator element:', activeIndicator);

    if (activeIndicator) {
      if (heatMapState.active) {
        activeIndicator.style.display = 'flex';
        if (activeLabel) {
          const scaleLabel = heatMapState.useLogarithmic ? ' (log)' : '';
          if (mode === 'capacity') {
            activeLabel.textContent = `Heat Map: Capacity${scaleLabel}`;
          } else if (mode === 'price') {
            activeLabel.textContent = `Heat Map: Price @ ${heatMapState.priceTier}${scaleLabel}`;
          }
        }
        console.log('[HeatMap] Showing active indicator');
      } else {
        activeIndicator.style.display = 'none';
        console.log('[HeatMap] Hiding active indicator');
      }
    }

    if (heatMapState.active) {
      calculateHeatMapRange();
      console.log('[HeatMap] Range calculated:', heatMapState.minValue, '-', heatMapState.maxValue);
    }

    updateHeatMapGradientPreview();
    updateHeatMapLegend();

    // Render the appropriate view
    console.log('[HeatMap] Rendering view...');
    if (window.mapLibreState && window.mapLibreState.active && typeof window.renderMapLibreContent === 'function') {
      console.log('[HeatMap] Rendering MapLibre view');
      window.mapLibreState.skipFitBounds = true;
      window.renderMapLibreContent();
    } else if (window.geoViewState && window.geoViewState.active && typeof window.renderGeoView === 'function') {
      console.log('[HeatMap] Rendering GeoStatic view');
      window.renderGeoView();
    } else {
      console.log('[HeatMap] Rendering Canvas view');
      render();
    }

    if (mode === 'off') {
      showToast('Heat map disabled');
    } else if (mode === 'capacity') {
      showToast('ðŸŒ¡ï¸ Heat map: Capacity (red=low, green=high)');
    } else if (mode === 'price') {
      showToast(`ðŸŒ¡ï¸ Heat map: Price @ ${heatMapState.priceTier} (green=low, red=high)`);
    }
  }

  // Update color swatches to reflect current colors
  function updateHeatMapColorSwatches() {
    const coldSwatch = document.getElementById('heatMapColdColorSwatch');
    const hotSwatch = document.getElementById('heatMapHotColorSwatch');
    const coldHex = document.getElementById('heatMapColdColorHex');
    const hotHex = document.getElementById('heatMapHotColorHex');

    if (coldSwatch) coldSwatch.style.background = heatMapState.coldColor;
    if (hotSwatch) hotSwatch.style.background = heatMapState.hotColor;
    if (coldHex) coldHex.textContent = heatMapState.coldColor;
    if (hotHex) hotHex.textContent = heatMapState.hotColor;
  }

  // Initialize heat map controls
  function initHeatMapControls() {
    console.log('[HeatMap] initHeatMapControls starting...');

    // Use event delegation on document body to handle radio button changes
    // This works even after the submenu is cloned
    document.body.addEventListener('change', (e) => {
      console.log('[HeatMap] Change event on:', e.target.id, e.target.name, e.target.type);

      if (e.target.name === 'heatMapMode') {
        console.log('[HeatMap] Mode changed via delegation:', e.target.id, 'checked:', e.target.checked);
        if (e.target.id === 'heatMapModeOff' && e.target.checked) {
          applyHeatMapMode('off');
        } else if (e.target.id === 'heatMapModeCapacity' && e.target.checked) {
          applyHeatMapMode('capacity');
        } else if (e.target.id === 'heatMapModePrice' && e.target.checked) {
          applyHeatMapMode('price');
        }
      }

      // Price tier radio buttons
      if (e.target.name === 'heatMapPriceTier' && e.target.checked) {
        console.log('[HeatMap] Price tier changed:', e.target.value);
        heatMapState.priceTier = e.target.value;
        // Update label styles
        ['1G', '10G', '100G', '400G'].forEach(t => {
          const l = document.getElementById(`heatMapTier${t}Label`);
          if (l) {
            if (t === e.target.value) {
              l.style.borderColor = '#3b82f6';
              l.style.background = '#eff6ff';
              l.style.color = '#1d4ed8';
            } else {
              l.style.borderColor = '#e5e7eb';
              l.style.background = 'white';
              l.style.color = '';
            }
          }
        });
        if (heatMapState.active && heatMapState.mode === 'price') {
          calculateHeatMapRange();
          updateHeatMapLegend();
          renderCurrentView();
          showToast(`ðŸŒ¡ï¸ Heat map: Price (${e.target.value})`);
        }
      }

      // Show legend checkbox
      if (e.target.id === 'heatMapShowLegend') {
        heatMapState.showLegend = e.target.checked;
        updateHeatMapLegend();
      }

      // Logarithmic scale checkbox
      if (e.target.id === 'heatMapUseLogarithmic') {
        console.log('[HeatMap] Logarithmic checkbox changed:', e.target.checked);
        console.log('[HeatMap] Current state - active:', heatMapState.active, 'mode:', heatMapState.mode);
        heatMapState.useLogarithmic = e.target.checked;
        updateHeatMapLegend();
        console.log('[HeatMap] After updateHeatMapLegend - checking indicator');
        const indicator = document.getElementById('heatMapActiveIndicator');
        console.log('[HeatMap] Indicator element:', indicator, 'display:', indicator?.style.display);
        if (heatMapState.active) renderCurrentView();
        showToast(e.target.checked ? 'ðŸ“ˆ Logarithmic scale enabled' : 'ðŸ“Š Linear scale enabled');
      }
    });

    // Color picker click handlers using delegation
    document.body.addEventListener('click', (e) => {
      // Cold color swatch
      if (e.target.id === 'heatMapColdColorSwatch' || e.target.closest('#heatMapColdColorSwatch')) {
        e.stopPropagation();
        const coldColorPicker = document.getElementById('heatMapColdColorPicker');
        const hotColorPicker = document.getElementById('heatMapHotColorPicker');
        if (coldColorPicker) {
          const isVisible = coldColorPicker.style.display !== 'none';
          if (hotColorPicker) hotColorPicker.style.display = 'none';
          coldColorPicker.style.display = isVisible ? 'none' : 'block';
        }
      }

      // Hot color swatch
      if (e.target.id === 'heatMapHotColorSwatch' || e.target.closest('#heatMapHotColorSwatch')) {
        e.stopPropagation();
        const coldColorPicker = document.getElementById('heatMapColdColorPicker');
        const hotColorPicker = document.getElementById('heatMapHotColorPicker');
        if (hotColorPicker) {
          const isVisible = hotColorPicker.style.display !== 'none';
          if (coldColorPicker) coldColorPicker.style.display = 'none';
          hotColorPicker.style.display = isVisible ? 'none' : 'block';
        }
      }

      // Close legend button
      if (e.target.id === 'btnCloseHeatMapLegend') {
        heatMapState.showLegend = false;
        const showLegendCheck = document.getElementById('heatMapShowLegend');
        if (showLegendCheck) showLegendCheck.checked = false;
        updateHeatMapLegend();
      }

      // Scale toggle button in active indicator
      if (e.target.id === 'heatMapScaleToggle') {
        e.stopPropagation();
        heatMapState.useLogarithmic = !heatMapState.useLogarithmic;
        // Update the checkbox in the menu if it exists
        const logCheckbox = document.getElementById('heatMapUseLogarithmic');
        if (logCheckbox) logCheckbox.checked = heatMapState.useLogarithmic;
        // Update the toggle button text
        e.target.textContent = heatMapState.useLogarithmic ? 'Log' : 'Lin';
        updateHeatMapLegend();
        if (heatMapState.active) renderCurrentView();
        showToast(heatMapState.useLogarithmic ? 'ðŸ“ˆ Logarithmic scale' : 'ðŸ“Š Linear scale');
        return; // Don't process further
      }

      // Exit button click to disable heat map
      if (e.target.id === 'heatMapExitBtn') {
        e.stopPropagation();
        console.log('[HeatMap] Exit button clicked - disabling heatmap');
        const modeOff = document.getElementById('heatMapModeOff');
        if (modeOff) modeOff.checked = true;
        applyHeatMapMode('off');
        return; // Don't process further
      }

      // Active indicator click (but not on buttons) to disable heat map
      // Make sure we're not clicking on a form element inside a menu
      if ((e.target.id === 'heatMapActiveIndicator' || e.target.closest('#heatMapActiveIndicator')) &&
          !e.target.closest('.menu') && !e.target.closest('.submenu') &&
          e.target.id !== 'heatMapScaleToggle' && e.target.id !== 'heatMapExitBtn') {
        // Don't do anything on general indicator click - only exit button exits
      }
    });

    // Initialize color swatches
    const coldSwatch = document.getElementById('heatMapColdColorSwatch');
    const hotSwatch = document.getElementById('heatMapHotColorSwatch');
    if (coldSwatch) coldSwatch.style.background = heatMapState.coldColor;
    if (hotSwatch) hotSwatch.style.background = heatMapState.hotColor;

    // Create color palette pickers
    const coldColorPicker = document.getElementById('heatMapColdColorPicker');
    const hotColorPicker = document.getElementById('heatMapHotColorPicker');

    if (coldColorPicker) {
      createHeatMapPalettePicker(coldColorPicker, heatMapState.coldColor, (color) => {
        heatMapState.coldColor = color;
        if (heatMapState.mode === 'capacity') {
          heatMapState.capacityColdColor = color;
        } else if (heatMapState.mode === 'price') {
          heatMapState.priceColdColor = color;
        }
        const swatch = document.getElementById('heatMapColdColorSwatch');
        const hex = document.getElementById('heatMapColdColorHex');
        if (swatch) swatch.style.background = color;
        if (hex) hex.textContent = color;
        updateHeatMapGradientPreview();
        updateHeatMapLegend();
        if (heatMapState.active) renderCurrentView();
        coldColorPicker.style.display = 'none';
      });
    }

    if (hotColorPicker) {
      createHeatMapPalettePicker(hotColorPicker, heatMapState.hotColor, (color) => {
        heatMapState.hotColor = color;
        if (heatMapState.mode === 'capacity') {
          heatMapState.capacityHotColor = color;
        } else if (heatMapState.mode === 'price') {
          heatMapState.priceHotColor = color;
        }
        const swatch = document.getElementById('heatMapHotColorSwatch');
        const hex = document.getElementById('heatMapHotColorHex');
        if (swatch) swatch.style.background = color;
        if (hex) hex.textContent = color;
        updateHeatMapGradientPreview();
        updateHeatMapLegend();
        if (heatMapState.active) renderCurrentView();
        hotColorPicker.style.display = 'none';
      });
    }

    // Make legend draggable
    makeLegendDraggable();

    console.log('[HeatMap] Event delegation setup complete');
  }

  // Helper function to make the legend draggable
  function makeLegendDraggable() {
    const legend = document.getElementById('heatMapLegend');
    if (legend) {
      let isDragging = false;
      let startX, startY, startLeft, startTop;

      legend.addEventListener('mousedown', (e) => {
        if (e.target.tagName === 'BUTTON') return;

        isDragging = true;
        const rect = legend.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;

        if (!legend.style.left || legend.style.left === '') {
          legend.style.left = rect.left + 'px';
          legend.style.right = 'auto';
        }
        if (!legend.style.top || legend.style.top === '') {
          legend.style.top = rect.top + 'px';
          legend.style.bottom = 'auto';
        }

        startLeft = parseInt(legend.style.left) || rect.left;
        startTop = parseInt(legend.style.top) || rect.top;

        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        let newLeft = startLeft + dx;
        let newTop = startTop + dy;

        newLeft = Math.max(10, Math.min(newLeft, window.innerWidth - legend.offsetWidth - 10));
        newTop = Math.max(10, Math.min(newTop, window.innerHeight - legend.offsetHeight - 10));

        legend.style.left = newLeft + 'px';
        legend.style.top = newTop + 'px';
        legend.style.right = 'auto';
        legend.style.bottom = 'auto';
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    }

    updateHeatMapGradientPreview();
  }

  // Helper: Create palette picker for heat map colors (popup style)
  function createHeatMapPalettePicker(container, initialColor, onChange) {
    // Heat map color palette - professional gradients
    const palette = [
      // Greens (cold/low)
      '#22c55e', '#16a34a', '#15803d', '#166534', '#14532d',
      // Blues
      '#3b82f6', '#2563eb', '#1d4ed8', '#1e40af', '#1e3a8a',
      // Cyans
      '#06b6d4', '#0891b2', '#0e7490', '#155e75', '#164e63',
      // Yellows/Oranges
      '#eab308', '#f59e0b', '#f97316', '#ea580c', '#c2410c',
      // Reds (hot/high)
      '#ef4444', '#dc2626', '#b91c1c', '#991b1b', '#7f1d1d',
      // Purples
      '#a855f7', '#9333ea', '#7c3aed', '#6d28d9', '#5b21b6',
      // Grays
      '#6b7280', '#4b5563', '#374151', '#1f2937', '#111827'
    ];

    container.innerHTML = '';
    container.style.cssText = 'display:none; position:absolute; left:0; top:28px; flex-wrap:wrap; gap:3px; padding:8px; background:#fff; border:1px solid #d0d0d0; border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); width:185px; z-index:1000;';

    const paletteGrid = document.createElement('div');
    paletteGrid.style.cssText = 'display:flex; flex-wrap:wrap; gap:3px;';

    palette.forEach(color => {
      const swatch = document.createElement('div');
      swatch.style.cssText = `
        width: 20px; height: 20px;
        background: ${color};
        border-radius: 3px;
        cursor: pointer;
        border: 2px solid ${color === initialColor ? '#000' : 'transparent'};
        box-sizing: border-box;
        transition: transform 0.1s;
      `;
      swatch.title = color;
      swatch.addEventListener('mouseenter', () => { swatch.style.transform = 'scale(1.1)'; });
      swatch.addEventListener('mouseleave', () => { swatch.style.transform = 'scale(1)'; });
      swatch.addEventListener('click', (e) => {
        e.stopPropagation();
        // Update selection border
        paletteGrid.querySelectorAll('div').forEach(s => s.style.borderColor = 'transparent');
        swatch.style.borderColor = '#000';
        onChange(color);
      });
      paletteGrid.appendChild(swatch);
    });

    container.appendChild(paletteGrid);

    // Add custom color option
    const customContainer = document.createElement('div');
    customContainer.style.cssText = 'width:100%; margin-top:8px; padding-top:8px; border-top:1px solid #e5e7eb; display:flex; align-items:center; gap:6px;';
    customContainer.innerHTML = `
      <span style="font-size:10px; color:#666;">Custom:</span>
      <input type="color" value="${initialColor}" style="width:28px; height:22px; border:1px solid #ccc; border-radius:4px; cursor:pointer; padding:0;">
    `;
    const customInput = customContainer.querySelector('input');
    customInput.addEventListener('click', (e) => e.stopPropagation());
    customInput.addEventListener('input', (e) => {
      e.stopPropagation();
      paletteGrid.querySelectorAll('div').forEach(s => s.style.borderColor = 'transparent');
      onChange(customInput.value);
    });
    container.appendChild(customContainer);
  }

  // Initialize on load - use DOMContentLoaded for reliability
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      console.log('[HeatMap] DOMContentLoaded - Initializing heat map controls...');
      initHeatMapControls();
      console.log('[HeatMap] Heat map controls initialized');
    });
  } else {
    // DOM already loaded
    console.log('[HeatMap] DOM ready - Initializing heat map controls...');
    setTimeout(() => {
      initHeatMapControls();
      console.log('[HeatMap] Heat map controls initialized');
    }, 100);
  }

  // ============== CAPACITY EDITOR ==============

  const capacityEditorState = {
    searchQuery: '',
    filterBySelection: false,
    selectedEdgeIds: new Set(),
    maxCapacity: 100 // For capacity bar scaling
  };

  function showCapacityEditor() {
    const modal = document.getElementById('capacityEditorModal');
    const content = document.getElementById('capacityEditorContent');
    if (!modal) return;

    // Capture current selection
    updateCapacityEditorSelectionFilter();

    // Reset position to center
    if (content) {
      content.style.left = '';
      content.style.top = '';
      content.style.position = 'relative';
      setTimeout(() => {
        const rect = content.getBoundingClientRect();
        content.style.position = 'absolute';
        content.style.left = rect.left + 'px';
        content.style.top = rect.top + 'px';
      }, 10);
    }

    modal.style.display = 'flex';
    renderCapacityEditor();
  }

  function hideCapacityEditor() {
    const modal = document.getElementById('capacityEditorModal');
    if (modal) modal.style.display = 'none';
  }

  function updateCapacityEditorSelectionFilter() {
    const selectedEdges = new Set();

    // Add from multi-selection
    state.selection.edges.forEach(id => selectedEdges.add(id));

    // Add single selection
    if (state.selected && state.selected.type === 'edge') {
      selectedEdges.add(state.selected.id);
    }

    capacityEditorState.selectedEdgeIds = selectedEdges;

    const filterLabel = document.getElementById('capacityEditorSelectionFilterLabel');
    const filterCheckbox = document.getElementById('capacityEditorSelectionFilter');
    const countSpan = document.getElementById('capacityEditorSelectionCount');

    if (filterLabel && filterCheckbox && countSpan) {
      // Always keep the filter visible
      countSpan.textContent = `(${selectedEdges.size})`;

      if (selectedEdges.size > 0) {
        // Style as having active selection
        filterLabel.style.opacity = '1';
        filterLabel.style.background = '#ecfdf5';
        // Auto-enable filter when there's a selection
        filterCheckbox.checked = true;
        capacityEditorState.filterBySelection = true;
      } else {
        // No selection - keep visible but style subtly different
        filterLabel.style.opacity = '0.8';
        filterLabel.style.background = '#f8fdfb';
        // Don't auto-disable if user had it checked
        if (!filterCheckbox.checked) {
          capacityEditorState.filterBySelection = false;
        }
      }
    }
  }

  function syncCapacityEditorWithSelection() {
    const modal = document.getElementById('capacityEditorModal');
    if (!modal || modal.style.display === 'none') return;

    const selectedEdges = new Set();
    state.selection.edges.forEach(id => selectedEdges.add(id));
    if (state.selected && state.selected.type === 'edge') {
      selectedEdges.add(state.selected.id);
    }

    capacityEditorState.selectedEdgeIds = selectedEdges;

    const filterLabel = document.getElementById('capacityEditorSelectionFilterLabel');
    const filterCheckbox = document.getElementById('capacityEditorSelectionFilter');
    const countSpan = document.getElementById('capacityEditorSelectionCount');

    if (filterLabel && filterCheckbox && countSpan) {
      // Always update count
      countSpan.textContent = `(${selectedEdges.size})`;

      if (selectedEdges.size > 0) {
        filterLabel.style.opacity = '1';
        filterLabel.style.background = '#ecfdf5';

        // If filter mode is enabled, refresh
        if (capacityEditorState.filterBySelection || filterCheckbox.checked) {
          filterCheckbox.checked = true;
          capacityEditorState.filterBySelection = true;
          renderCapacityEditor();
        }
      } else {
        filterLabel.style.opacity = '0.8';
        filterLabel.style.background = '#f8fdfb';
        // Keep filter state as-is, just re-render
        renderCapacityEditor();
      }
    }
  }

  function calculateLinkCapacity(edge) {
    const cap1G = edge.cap1G || 0;
    const cap10G = edge.cap10G || 0;
    const cap100G = edge.cap100G || 0;
    const cap400G = edge.cap400G || 0;
    const capTbps = edge.capTbps || 0;
    return cap1G + (10 * cap10G) + (100 * cap100G) + (400 * cap400G) + (1000 * capTbps);
  }

  function renderCapacityEditor() {
    const tbody = document.getElementById('capacityEditorRows');
    const countEl = document.getElementById('capacityEditorCount');
    const rowCountEl = document.getElementById('capacityEditorRowCount');
    const totalGbpsEl = document.getElementById('capacityEditorTotalGbps');
    const filteredInfoEl = document.getElementById('capacityEditorFilteredInfo');

    if (!tbody) return;

    const search = capacityEditorState.searchQuery.toLowerCase();

    // Filter edges
    let filteredEdges = state.edges.filter(e => {
      // Filter by selection first if enabled
      if (capacityEditorState.filterBySelection && capacityEditorState.selectedEdgeIds.size > 0) {
        if (!capacityEditorState.selectedEdgeIds.has(e.id)) return false;
      }

      if (!search) return true;

      const aNode = findNode(e.a);
      const bNode = findNode(e.b);
      const aName = aNode?.name || '';
      const bName = bNode?.name || '';
      const linkTag = e.tag || '';

      return (e.code || '').toLowerCase().includes(search) ||
             linkTag.toLowerCase().includes(search) ||
             aName.toLowerCase().includes(search) ||
             bName.toLowerCase().includes(search);
    });

    // Calculate max capacity for scaling bars
    let maxCap = 0;
    let totalCap = 0;
    filteredEdges.forEach(e => {
      const cap = calculateLinkCapacity(e);
      if (cap > maxCap) maxCap = cap;
      totalCap += cap;
    });
    capacityEditorState.maxCapacity = maxCap || 100;

    // Build rows
    let html = '';
    filteredEdges.forEach(e => {
      const aNode = findNode(e.a);
      const bNode = findNode(e.b);
      const aName = aNode?.name || `Node ${e.a}`;
      const bName = bNode?.name || `Node ${e.b}`;
      const totalGbps = calculateLinkCapacity(e);
      const barWidth = maxCap > 0 ? (totalGbps / maxCap * 100) : 0;

      // Determine bar color based on capacity
      let barColor = '#d1d5db'; // Grey for zero
      if (totalGbps > 0) {
        if (totalGbps < 100) barColor = '#fbbf24'; // Yellow for low
        else if (totalGbps < 500) barColor = '#34d399'; // Green for medium
        else barColor = '#10b981'; // Dark green for high
      }

      html += `
        <tr data-edge-id="${e.id}" style="border-bottom:1px solid #f1f5f9;">
          <td style="padding:8px 12px; color:#374151; font-weight:500;">${escapeHtml(e.code || `L-${e.id}`)}</td>
          <td style="padding:8px 12px; color:#6b7280; font-size:11px;">${escapeHtml(e.tag || '')}</td>
          <td style="padding:8px 12px; color:#6b7280;">${escapeHtml(aName)}</td>
          <td style="padding:8px 12px; color:#6b7280;">${escapeHtml(bName)}</td>
          <td style="padding:8px 8px; text-align:center; background:#f0fdf4;">
            <input type="number" class="cap-input" data-field="cap1G" value="${e.cap1G || 0}" min="0" step="1" style="width:50px; padding:4px 6px; border:1px solid #d1d5db; border-radius:4px; text-align:center; font-size:11px;" />
          </td>
          <td style="padding:8px 8px; text-align:center; background:#f0fdf4;">
            <input type="number" class="cap-input" data-field="cap10G" value="${e.cap10G || 0}" min="0" step="1" style="width:50px; padding:4px 6px; border:1px solid #d1d5db; border-radius:4px; text-align:center; font-size:11px;" />
          </td>
          <td style="padding:8px 8px; text-align:center; background:#f0fdf4;">
            <input type="number" class="cap-input" data-field="cap100G" value="${e.cap100G || 0}" min="0" step="1" style="width:50px; padding:4px 6px; border:1px solid #d1d5db; border-radius:4px; text-align:center; font-size:11px;" />
          </td>
          <td style="padding:8px 8px; text-align:center; background:#f0fdf4;">
            <input type="number" class="cap-input" data-field="cap400G" value="${e.cap400G || 0}" min="0" step="1" style="width:50px; padding:4px 6px; border:1px solid #d1d5db; border-radius:4px; text-align:center; font-size:11px;" />
          </td>
          <td style="padding:8px 8px; text-align:center; background:#f0fdf4;">
            <input type="number" class="cap-input" data-field="capTbps" value="${e.capTbps || 0}" min="0" step="0.1" style="width:50px; padding:4px 6px; border:1px solid #d1d5db; border-radius:4px; text-align:center; font-size:11px;" />
          </td>
          <td style="padding:8px 12px; text-align:right; font-weight:600; color:#047857; background:#ecfdf5;" class="total-cell">${totalGbps.toLocaleString()}</td>
          <td style="padding:8px 12px;">
            <div style="width:100px; height:14px; background:#f1f5f9; border-radius:3px; overflow:hidden;">
              <div class="cap-bar" style="width:${barWidth}%; height:100%; background:${barColor}; transition:width 0.2s;"></div>
            </div>
          </td>
        </tr>
      `;
    });

    tbody.innerHTML = html;

    // Update counts
    if (countEl) countEl.textContent = `${filteredEdges.length} links`;
    if (rowCountEl) rowCountEl.textContent = `${filteredEdges.length} links`;
    if (totalGbpsEl) totalGbpsEl.textContent = `${totalCap.toLocaleString()} Gbps`;

    if (filteredInfoEl) {
      if (capacityEditorState.filterBySelection && capacityEditorState.selectedEdgeIds.size > 0) {
        filteredInfoEl.textContent = `(filtered by selection)`;
      } else if (search) {
        filteredInfoEl.textContent = `(filtered by search)`;
      } else {
        filteredInfoEl.textContent = '';
      }
    }

    // Add input handlers
    tbody.querySelectorAll('.cap-input').forEach(input => {
      input.addEventListener('change', (ev) => {
        const row = ev.target.closest('tr');
        const edgeId = parseInt(row.dataset.edgeId);
        const field = ev.target.dataset.field;
        const edge = state.edges.find(e => e.id === edgeId);

        if (edge && field) {
          const val = parseFloat(ev.target.value) || 0;
          edge[field] = val;

          // Update total and bar in this row
          const totalGbps = calculateLinkCapacity(edge);
          const totalCell = row.querySelector('.total-cell');
          if (totalCell) totalCell.textContent = totalGbps.toLocaleString();

          // Update bar
          const barWidth = capacityEditorState.maxCapacity > 0 ? (totalGbps / capacityEditorState.maxCapacity * 100) : 0;
          let barColor = '#d1d5db';
          if (totalGbps > 0) {
            if (totalGbps < 100) barColor = '#fbbf24';
            else if (totalGbps < 500) barColor = '#34d399';
            else barColor = '#10b981';
          }
          const bar = row.querySelector('.cap-bar');
          if (bar) {
            bar.style.width = barWidth + '%';
            bar.style.background = barColor;
          }

          // Update grand total
          let grandTotal = 0;
          state.edges.forEach(e => {
            if (!capacityEditorState.filterBySelection || capacityEditorState.selectedEdgeIds.has(e.id)) {
              grandTotal += calculateLinkCapacity(e);
            }
          });
          if (totalGbpsEl) totalGbpsEl.textContent = `${grandTotal.toLocaleString()} Gbps`;

          commit();

          // Re-render canvas if heat map is active
          if (heatMapState.active) {
            render();
          }
        }
      });

      // Select all on focus for easy editing
      input.addEventListener('focus', (ev) => {
        ev.target.select();
      });

      // Tab navigation
      input.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') {
          ev.preventDefault();
          ev.target.blur();
          // Move to next row same column
          const row = ev.target.closest('tr');
          const nextRow = row.nextElementSibling;
          if (nextRow) {
            const field = ev.target.dataset.field;
            const nextInput = nextRow.querySelector(`input[data-field="${field}"]`);
            if (nextInput) nextInput.focus();
          }
        }
      });
    });
  }

  function exportCapacityEditorCSV() {
    const search = capacityEditorState.searchQuery.toLowerCase();

    let filteredEdges = state.edges.filter(e => {
      if (capacityEditorState.filterBySelection && capacityEditorState.selectedEdgeIds.size > 0) {
        if (!capacityEditorState.selectedEdgeIds.has(e.id)) return false;
      }
      if (!search) return true;
      const aNode = findNode(e.a);
      const bNode = findNode(e.b);
      return (e.code || '').toLowerCase().includes(search) ||
             (aNode?.name || '').toLowerCase().includes(search) ||
             (bNode?.name || '').toLowerCase().includes(search);
    });

    let csv = 'Code,A-End,B-End,1G Units,10G Units,100G Units,400G Units,Tbps Units,Total Gbps\n';

    filteredEdges.forEach(e => {
      const aNode = findNode(e.a);
      const bNode = findNode(e.b);
      const totalGbps = calculateLinkCapacity(e);
      csv += `"${e.code || ''}","${aNode?.name || ''}","${bNode?.name || ''}",${e.cap1G || 0},${e.cap10G || 0},${e.cap100G || 0},${e.cap400G || 0},${e.capTbps || 0},${totalGbps}\n`;
    });

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'capacity_data.csv';
    a.click();
    URL.revokeObjectURL(url);
    showToast('ðŸ“¤ Capacity data exported');
  }

  function initCapacityEditor() {
    // Menu item
    const miCapacityEditor = document.getElementById('miCapacityEditor');
    if (miCapacityEditor) {
      miCapacityEditor.addEventListener('click', () => {
        const dataMenu = document.getElementById('dataMenu');
        if (dataMenu) dataMenu.hidden = true;
        showCapacityEditor();
      });
    }

    // Close button
    const btnClose = document.getElementById('btnCloseCapacityEditor');
    if (btnClose) btnClose.addEventListener('click', hideCapacityEditor);

    // Search
    const searchInput = document.getElementById('capacityEditorSearch');
    if (searchInput) {
      searchInput.addEventListener('input', () => {
        capacityEditorState.searchQuery = searchInput.value;
        renderCapacityEditor();
      });
    }

    // Selection filter
    const selectionFilter = document.getElementById('capacityEditorSelectionFilter');
    if (selectionFilter) {
      selectionFilter.addEventListener('change', () => {
        capacityEditorState.filterBySelection = selectionFilter.checked;
        renderCapacityEditor();
      });
    }

    // Export button
    const btnExport = document.getElementById('btnCapacityEditorExport');
    if (btnExport) btnExport.addEventListener('click', exportCapacityEditorCSV);

    // Close on Escape
    document.addEventListener('keydown', (e) => {
      const modal = document.getElementById('capacityEditorModal');
      if (e.key === 'Escape' && modal && modal.style.display !== 'none') {
        hideCapacityEditor();
      }
      // Ctrl+K to open
      if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        const modal = document.getElementById('capacityEditorModal');
        if (modal && modal.style.display !== 'none') {
          hideCapacityEditor();
        } else {
          showCapacityEditor();
        }
      }
    });

    // Close on background click
    const modal = document.getElementById('capacityEditorModal');
    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) hideCapacityEditor();
      });
    }

    // Draggable header
    const content = document.getElementById('capacityEditorContent');
    const header = document.getElementById('capacityEditorHeader');

    if (content && header) {
      let isDragging = false;
      let startX, startY, startLeft, startTop;

      header.addEventListener('mousedown', (e) => {
        if (e.target.tagName === 'BUTTON') return;
        isDragging = true;
        const rect = content.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;
        startLeft = rect.left;
        startTop = rect.top;
        if (!content.style.left) {
          content.style.left = rect.left + 'px';
          content.style.top = rect.top + 'px';
        }
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        let newLeft = Math.max(0, Math.min(startLeft + dx, window.innerWidth - 100));
        let newTop = Math.max(0, Math.min(startTop + dy, window.innerHeight - 50));
        content.style.left = newLeft + 'px';
        content.style.top = newTop + 'px';
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    }
  }

  // Initialize capacity editor
  setTimeout(initCapacityEditor, 100);

  // ============== DATA TABLE ==============

  let dataTableState = {
    type: 'links',
    sortColumn: null,
    sortDirection: 'asc',
    searchQuery: '',
    showCostColumns: true,
    filterBySelection: false,
    selectedNodeIds: new Set(),
    selectedEdgeIds: new Set()
  };

  function showDataTable() {
    const modal = document.getElementById('dataTableModal');
    const content = document.getElementById('dataTableContent');
    if (!modal) return;

    // Capture current selection
    updateDataTableSelectionFilter();

    // Reset position to center
    if (content) {
      content.style.left = '';
      content.style.top = '';
      content.style.position = 'relative';
      // After showing, switch to absolute for dragging
      setTimeout(() => {
        const rect = content.getBoundingClientRect();
        content.style.position = 'absolute';
        content.style.left = rect.left + 'px';
        content.style.top = rect.top + 'px';
      }, 10);
    }

    modal.classList.add('show');
    renderDataTable();
  }

  // Update data table selection filter based on current canvas selection
  function updateDataTableSelectionFilter() {
    // Collect all selected node and edge IDs
    const selectedNodes = new Set();
    const selectedEdges = new Set();

    // Add from multi-selection
    state.selection.nodes.forEach(id => selectedNodes.add(id));
    state.selection.edges.forEach(id => selectedEdges.add(id));

    // Add single selection if not already in multi-select
    if (state.selected) {
      if (state.selected.type === 'node') {
        selectedNodes.add(state.selected.id);
      } else if (state.selected.type === 'edge') {
        selectedEdges.add(state.selected.id);
      }
    }

    // Store in dataTableState
    dataTableState.selectedNodeIds = selectedNodes;
    dataTableState.selectedEdgeIds = selectedEdges;

    const totalSelected = selectedNodes.size + selectedEdges.size;

    // Update UI
    const filterLabel = document.getElementById('dataTableSelectionFilterLabel');
    const filterCheckbox = document.getElementById('dataTableSelectionFilter');
    const countSpan = document.getElementById('dataTableSelectionCount');

    if (filterLabel && filterCheckbox && countSpan) {
      // Always keep the filter visible and enabled
      countSpan.textContent = `(${totalSelected})`;

      if (totalSelected > 0) {
        // Style as having active selection
        filterLabel.style.opacity = '1';
        filterLabel.style.background = '#eef2ff';
        // Auto-enable filter when there's a selection
        filterCheckbox.checked = true;
        dataTableState.filterBySelection = true;

        // Auto-switch to appropriate tab based on selection
        if (selectedEdges.size > 0 && selectedNodes.size === 0) {
          dataTableState.type = 'links';
          const typeSelect = document.getElementById('dataTableType');
          if (typeSelect) typeSelect.value = 'links';
        } else if (selectedNodes.size > 0 && selectedEdges.size === 0) {
          dataTableState.type = 'nodes';
          const typeSelect = document.getElementById('dataTableType');
          if (typeSelect) typeSelect.value = 'nodes';
        }
      } else {
        // No selection - keep enabled but style subtly different
        filterLabel.style.opacity = '0.8';
        filterLabel.style.background = '#f8f9ff';
        // Don't auto-disable - let user keep it on if they want to select items next
        // Only auto-disable if checkbox wasn't already checked
        if (!filterCheckbox.checked) {
          dataTableState.filterBySelection = false;
        }
      }
    }
  }

  // Sync data table with current selection (called when selection changes while data table is open)
  function syncDataTableWithSelection() {
    const modal = document.getElementById('dataTableModal');
    if (!modal || !modal.classList.contains('show')) return; // Only sync if data table is open

    // Collect all selected node and edge IDs
    const selectedNodes = new Set();
    const selectedEdges = new Set();

    // Add from multi-selection
    state.selection.nodes.forEach(id => selectedNodes.add(id));
    state.selection.edges.forEach(id => selectedEdges.add(id));

    // Add single selection if not already in multi-select
    if (state.selected) {
      if (state.selected.type === 'node') {
        selectedNodes.add(state.selected.id);
      } else if (state.selected.type === 'edge') {
        selectedEdges.add(state.selected.id);
      }
    }

    // Store in dataTableState
    dataTableState.selectedNodeIds = selectedNodes;
    dataTableState.selectedEdgeIds = selectedEdges;

    const totalSelected = selectedNodes.size + selectedEdges.size;

    // Update UI
    const filterLabel = document.getElementById('dataTableSelectionFilterLabel');
    const filterCheckbox = document.getElementById('dataTableSelectionFilter');
    const countSpan = document.getElementById('dataTableSelectionCount');

    if (filterLabel && filterCheckbox && countSpan) {
      // Always keep visible and enabled, update count
      countSpan.textContent = `(${totalSelected})`;

      if (totalSelected > 0) {
        filterLabel.style.opacity = '1';
        filterLabel.style.background = '#eef2ff';

        // If filter mode is enabled, auto-check and refresh
        if (dataTableState.filterBySelection || filterCheckbox.checked) {
          filterCheckbox.checked = true;
          dataTableState.filterBySelection = true;
        }

        // Auto-switch to appropriate tab based on selection
        if (selectedEdges.size > 0 && selectedNodes.size === 0) {
          dataTableState.type = 'links';
          const typeSelect = document.getElementById('dataTableType');
          if (typeSelect) typeSelect.value = 'links';
        } else if (selectedNodes.size > 0 && selectedEdges.size === 0) {
          dataTableState.type = 'nodes';
          const typeSelect = document.getElementById('dataTableType');
          if (typeSelect) typeSelect.value = 'nodes';
        }

        // Re-render to apply filter
        renderDataTable();
      } else {
        filterLabel.style.opacity = '0.8';
        filterLabel.style.background = '#f8f9ff';
        // Keep filter state as-is (user may want to select items next)
        // Just re-render to show empty or all items based on filter state
        renderDataTable();
      }
    }
  }

  function hideDataTable() {
    const modal = document.getElementById('dataTableModal');
    if (modal) modal.classList.remove('show');
  }

  function renderDataTable() {
    const type = dataTableState.type;
    const thead = document.getElementById('dataTableHead');
    const tbody = document.getElementById('dataTableRows');
    const rowCount = document.getElementById('dataTableRowCount');
    const totalACVEl = document.getElementById('dataTableTotalACV');
    const totalIRUEl = document.getElementById('dataTableTotalIRU');
    const resetPricesGroup = document.getElementById('dataTableResetPricesGroup');

    if (!thead || !tbody) return;

    const currency = state.financialSettings.baseCurrency || 'USD';
    const showCost = dataTableState.showCostColumns;

    // Show/hide reset prices button based on table type (only for links)
    if (resetPricesGroup) {
      resetPricesGroup.style.display = (type === 'links') ? 'flex' : 'none';
    }

    if (type === 'links') {
      renderLinksTable(thead, tbody, showCost, currency);
    } else if (type === 'nodes') {
      renderNodesTable(thead, tbody);
    } else if (type === 'containers') {
      renderContainersTable(thead, tbody, showCost, currency);
    } else if (type === 'mlg') {
      renderMLGTable(thead, tbody, showCost, currency);
    }

    // Update row count
    const rows = tbody.querySelectorAll('tr');
    if (rowCount) rowCount.textContent = `${rows.length} items`;

    // Calculate totals for links using selected tier
    if (type === 'links') {
      let totalACV = 0, totalIRUNPV = 0;
      const discountRate = state.financialSettings.npvDiscountRate || 12.5;
      const tier = document.getElementById('dataTableCapacityTier')?.value || '10G';
      const defaultOAM = state.financialSettings.defaultOAM || 3;
      const defaultOAMInc = state.financialSettings.defaultOAMIncrement || 2;

      state.edges.forEach(e => {
        const nrc = getValueForTier(e.leaseNRC, tier, 0);
        const mrc = getValueForTier(e.leaseMRC, tier, 1);
        const iruFee = getValueForTier(e.iruFee, tier, 1);
        const acv = calculateLeaseACV(nrc, mrc);
        const iruNpv = calculateIRUNPV(iruFee, e.iruTerm || 15, e.iruOamPercent ?? defaultOAM, e.iruOamAnnualIncrement ?? defaultOAMInc, discountRate);
        totalACV += acv;
        totalIRUNPV += iruNpv;
      });

      if (totalACVEl) totalACVEl.textContent = formatCurrency(totalACV, currency) + ` @${tier}`;
      if (totalIRUEl) totalIRUEl.textContent = formatCurrency(totalIRUNPV, currency) + ` @${tier}`;
    } else if (type === 'containers') {
      // Calculate totals for containers
      let totalACV = 0, totalIRUNPV = 0;
      const discountRate = state.financialSettings.npvDiscountRate || 12.5;
      const tier = document.getElementById('dataTableCapacityTier')?.value || '10G';

      state.groups.forEach(g => {
        const nrc = getValueForTier(g.leaseNRC, tier, 0);
        const mrc = getValueForTier(g.leaseMRC, tier, 1);
        const iruFee = getValueForTier(g.iruFee, tier, 1);
        const acv = calculateLeaseACV(nrc, mrc);
        const iruNpv = calculateIRUNPV(iruFee, g.iruTerm || 15, g.iruOamPercent ?? 3, g.iruOamAnnualIncrement ?? 2, discountRate);
        totalACV += acv;
        totalIRUNPV += iruNpv;
      });

      if (totalACVEl) totalACVEl.textContent = formatCurrency(totalACV, currency) + ` @${tier}`;
      if (totalIRUEl) totalIRUEl.textContent = formatCurrency(totalIRUNPV, currency) + ` @${tier}`;
    }
  }

  function renderLinksTable(thead, tbody, showCost, currency) {
    const search = dataTableState.searchQuery.toLowerCase();
    const symbol = getCurrencySymbol(currency);
    const tier = document.getElementById('dataTableCapacityTier')?.value || '10G';

    // Headers - show selected tier
    let headers = `
      <tr>
        <th data-col="code">Code</th>
        <th data-col="linkTag">Link Tag</th>
        <th data-col="tag">Tags</th>
        <th data-col="cableSystem">Cable System</th>
        <th data-col="aEnd">A-End</th>
        <th data-col="bEnd">B-End</th>
        <th data-col="latency">Latency (ms)</th>`;

    if (showCost) {
      headers += `
        <th data-col="nrc">NRC @${tier} (${symbol})</th>
        <th data-col="mrc">MRC @${tier} (${symbol})</th>
        <th data-col="acv">ACV @${tier} (${symbol})</th>
        <th data-col="iruFee">IRU @${tier} (${symbol})</th>
        <th data-col="iruTerm">Term</th>
        <th data-col="oamPct">O&M %</th>
        <th data-col="oamInc">O&M Inc %</th>
        <th data-col="iruNpv">NPV @${tier} (${symbol})</th>`;
    }
    headers += `</tr>`;
    thead.innerHTML = headers;

    // Rows
    const discountRate = state.financialSettings.npvDiscountRate || 12.5;
    const defaultOAM = state.financialSettings.defaultOAM || 3;
    const defaultOAMInc = state.financialSettings.defaultOAMIncrement || 2;
    let rows = '';

    // Build cable system options for dropdown
    let cableSystemOptions = '<option value="">â€” None â€”</option>';
    state.cableSystems.forEach(cs => {
      cableSystemOptions += `<option value="${cs.uuid}">${escapeHtml(cs.name || cs.code || 'Unnamed')}</option>`;
    });

    let filteredEdges = state.edges.filter(e => {
      // Filter by selection first if enabled
      if (dataTableState.filterBySelection && dataTableState.selectedEdgeIds.size > 0) {
        if (!dataTableState.selectedEdgeIds.has(e.id)) return false;
      }

      if (!search) return true;
      const aNode = findNode(e.a);
      const bNode = findNode(e.b);
      const aName = aNode?.name || '';
      const bName = bNode?.name || '';
      // Also search in tags and cable system
      const edgeTags = getElementTags('edge', e.id);
      const tagsStr = Array.from(edgeTags).join(' ').toLowerCase();
      const cableSystem = e.cableSystemId ? findCableSystem(e.cableSystemId) : null;
      const csName = cableSystem ? (cableSystem.name || cableSystem.shortName || '').toLowerCase() : '';
      return (e.code || '').toLowerCase().includes(search) ||
             (e.tag || '').toLowerCase().includes(search) ||
             tagsStr.includes(search) ||
             csName.includes(search) ||
             aName.toLowerCase().includes(search) ||
             bName.toLowerCase().includes(search);
    });

    // Sort if needed
    if (dataTableState.sortColumn) {
      filteredEdges.sort((a, b) => {
        let aVal, bVal;
        const col = dataTableState.sortColumn;

        switch(col) {
          case 'code': aVal = a.code || ''; bVal = b.code || ''; break;
          case 'linkTag': aVal = a.tag || ''; bVal = b.tag || ''; break;
          case 'tag':
            aVal = Array.from(getElementTags('edge', a.id)).join(',');
            bVal = Array.from(getElementTags('edge', b.id)).join(',');
            break;
          case 'cableSystem':
            const csA = a.cableSystemId ? findCableSystem(a.cableSystemId) : null;
            const csB = b.cableSystemId ? findCableSystem(b.cableSystemId) : null;
            aVal = csA ? (csA.name || csA.shortName || '') : '';
            bVal = csB ? (csB.name || csB.shortName || '') : '';
            break;
          case 'latency': aVal = a.latencyMs || 0; bVal = b.latencyMs || 0; break;
          case 'nrc': aVal = getValueForTier(a.leaseNRC, tier, 0); bVal = getValueForTier(b.leaseNRC, tier, 0); break;
          case 'mrc': aVal = getValueForTier(a.leaseMRC, tier, 1); bVal = getValueForTier(b.leaseMRC, tier, 1); break;
          case 'acv':
            aVal = calculateLeaseACV(getValueForTier(a.leaseNRC, tier, 0), getValueForTier(a.leaseMRC, tier, 1));
            bVal = calculateLeaseACV(getValueForTier(b.leaseNRC, tier, 0), getValueForTier(b.leaseMRC, tier, 1));
            break;
          case 'iruFee': aVal = getValueForTier(a.iruFee, tier, 1); bVal = getValueForTier(b.iruFee, tier, 1); break;
          case 'oamPct': aVal = a.iruOamPercent ?? defaultOAM; bVal = b.iruOamPercent ?? defaultOAM; break;
          case 'oamInc': aVal = a.iruOamAnnualIncrement ?? defaultOAMInc; bVal = b.iruOamAnnualIncrement ?? defaultOAMInc; break;
          case 'iruNpv':
            aVal = calculateIRUNPV(getValueForTier(a.iruFee, tier, 1), a.iruTerm||15, a.iruOamPercent??defaultOAM, a.iruOamAnnualIncrement??defaultOAMInc, discountRate);
            bVal = calculateIRUNPV(getValueForTier(b.iruFee, tier, 1), b.iruTerm||15, b.iruOamPercent??defaultOAM, b.iruOamAnnualIncrement??defaultOAMInc, discountRate);
            break;
          default: aVal = 0; bVal = 0;
        }

        if (typeof aVal === 'string') {
          return dataTableState.sortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
        }
        return dataTableState.sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
      });
    }

    filteredEdges.forEach(e => {
      const aNode = findNode(e.a);
      const bNode = findNode(e.b);
      const nrc = getValueForTier(e.leaseNRC, tier, 0);
      const mrc = getValueForTier(e.leaseMRC, tier, 1);
      const iruFee = getValueForTier(e.iruFee, tier, 1);
      const acv = calculateLeaseACV(nrc, mrc);
      const oamPct = e.iruOamPercent ?? defaultOAM;
      const oamInc = e.iruOamAnnualIncrement ?? defaultOAMInc;
      const iruNpv = calculateIRUNPV(iruFee, e.iruTerm || 15, oamPct, oamInc, discountRate);

      // Get tags for this edge
      const edgeTags = getElementTags('edge', e.id);
      const tagsStr = Array.from(edgeTags).join(', ');

      // Get cable system
      const cableSystem = e.cableSystemId ? findCableSystem(e.cableSystemId) : null;

      // Build cable system dropdown with current selection
      let csOptions = '<option value="">â€” None â€”</option>';
      state.cableSystems.forEach(cs => {
        const selected = e.cableSystemId === cs.id ? 'selected' : '';
        csOptions += `<option value="${cs.id}" ${selected}>${escapeHtml(cs.name || cs.shortName || 'Unnamed')}</option>`;
      });

      rows += `<tr data-id="${e.id}" data-type="edge">
        <td><input class="cell-edit" data-field="code" value="${escapeAttr(e.code || '')}" style="width:80px;" /></td>
        <td><input class="cell-edit" data-field="tag" value="${escapeAttr(e.tag || '')}" style="width:80px;" placeholder="Link tag" /></td>
        <td><input class="cell-edit tag-edit" data-field="tags" value="${escapeAttr(tagsStr)}" placeholder="tag1, tag2..." title="Comma-separated tags" /></td>
        <td><select class="cell-edit" data-field="cableSystemId" style="font-size:11px; max-width:120px;">${csOptions}</select></td>
        <td>${aNode?.name || '?'}</td>
        <td>${bNode?.name || '?'}</td>
        <td><input class="cell-edit number" data-field="latencyMs" value="${e.latencyMs ?? ''}" style="width:60px; text-align:right;" /></td>`;

      if (showCost) {
        rows += `
          <td><input class="cell-edit number" data-field="leaseNRC" data-tier="${tier}" value="${nrc}" /></td>
          <td><input class="cell-edit number" data-field="leaseMRC" data-tier="${tier}" value="${mrc}" /></td>
          <td style="text-align:right; font-weight:500; color:#1d4ed8;">${formatCurrency(acv, currency)}</td>
          <td><input class="cell-edit number" data-field="iruFee" data-tier="${tier}" value="${iruFee}" /></td>
          <td><input class="cell-edit number" data-field="iruTerm" value="${e.iruTerm || 15}" style="width:50px;" /></td>
          <td><input class="cell-edit number" data-field="iruOamPercent" value="${oamPct}" style="width:50px;" title="O&M as % of IRU fee" /></td>
          <td><input class="cell-edit number" data-field="iruOamAnnualIncrement" value="${oamInc}" style="width:50px;" title="Yearly O&M increase %" /></td>
          <td style="text-align:right; font-weight:500; color:#7c3aed;">${formatCurrency(iruNpv, currency)}</td>`;
      }
      rows += `</tr>`;
    });

    tbody.innerHTML = rows;

    // Add edit handlers
    tbody.querySelectorAll('.cell-edit').forEach(input => {
      input.addEventListener('change', (ev) => {
        const row = ev.target.closest('tr');
        const edgeId = parseInt(row.dataset.id);
        const field = ev.target.dataset.field;
        const tierAttr = ev.target.dataset.tier;
        const edge = findEdge(edgeId);

        if (edge && field) {
          if (field === 'tags') {
            // Handle tags editing
            const newTagsStr = ev.target.value;
            const newTags = newTagsStr.split(',').map(t => t.trim()).filter(t => t.length > 0);
            setElementTags('edge', edgeId, new Set(newTags));
          } else if (field === 'code' || field === 'tag') {
            // String fields
            edge[field] = ev.target.value.trim();
          } else if (field === 'cableSystemId') {
            // Cable system assignment - use numeric ID
            const newId = ev.target.value ? parseInt(ev.target.value) : null;
            edge.cableSystemId = newId;
            // Also update the cable system navigator list
            updateCableNavigatorList();
          } else if (field === 'latencyMs') {
            const val = ev.target.value.trim();
            edge.latencyMs = val === '' ? null : parseFloat(val);
          } else if ((field === 'leaseNRC' || field === 'leaseMRC' || field === 'iruFee') && tierAttr) {
            // Tier-based fields
            if (typeof edge[field] !== 'object') {
              edge[field] = normalizeTierPricing(edge[field], field === 'leaseNRC' ? 0 : 1);
            }
            edge[field][tierAttr] = parseFloat(ev.target.value) || 0;
          } else {
            edge[field] = parseFloat(ev.target.value) || 0;
          }
          commit();
          render(); // Re-render canvas to show code/tag changes
          renderDataTable(); // Refresh to update calculated fields
        }
      });
    });

    // Escape attribute helper
    function escapeAttr(str) {
      return (str || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }

    // Add sort handlers
    thead.querySelectorAll('th').forEach(th => {
      th.addEventListener('click', () => {
        const col = th.dataset.col;
        if (!col) return;

        if (dataTableState.sortColumn === col) {
          dataTableState.sortDirection = dataTableState.sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          dataTableState.sortColumn = col;
          dataTableState.sortDirection = 'asc';
        }

        // Update visual
        thead.querySelectorAll('th').forEach(h => h.classList.remove('sorted-asc', 'sorted-desc'));
        th.classList.add(dataTableState.sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');

        renderDataTable();
      });
    });
  }

  function renderNodesTable(thead, tbody) {
    const search = dataTableState.searchQuery.toLowerCase();

    thead.innerHTML = `
      <tr>
        <th data-col="code">Code</th>
        <th data-col="name">Name</th>
        <th data-col="tag">Tags</th>
        <th data-col="city">City</th>
        <th data-col="country">Country</th>
        <th data-col="lat">Latitude</th>
        <th data-col="lon">Longitude</th>
        <th data-col="connections">Connections</th>
      </tr>`;

    let filteredNodes = state.nodes.filter(n => {
      // Filter by selection first if enabled
      if (dataTableState.filterBySelection && dataTableState.selectedNodeIds.size > 0) {
        if (!dataTableState.selectedNodeIds.has(n.id)) return false;
      }

      if (!search) return true;
      const nodeTags = getElementTags('node', n.id);
      const tagsStr = Array.from(nodeTags).join(' ').toLowerCase();
      return (n.code || '').toLowerCase().includes(search) ||
             (n.name || '').toLowerCase().includes(search) ||
             (n.city || '').toLowerCase().includes(search) ||
             (n.country || '').toLowerCase().includes(search) ||
             tagsStr.includes(search);
    });

    // Sort if needed
    if (dataTableState.sortColumn) {
      filteredNodes.sort((a, b) => {
        let aVal, bVal;
        const col = dataTableState.sortColumn;

        switch(col) {
          case 'code': aVal = a.code || ''; bVal = b.code || ''; break;
          case 'name': aVal = a.name || ''; bVal = b.name || ''; break;
          case 'tag':
            aVal = Array.from(getElementTags('node', a.id)).join(',');
            bVal = Array.from(getElementTags('node', b.id)).join(',');
            break;
          case 'city': aVal = a.city || ''; bVal = b.city || ''; break;
          case 'country': aVal = a.country || ''; bVal = b.country || ''; break;
          case 'lat': aVal = a.gpsLat || 0; bVal = b.gpsLat || 0; break;
          case 'lon': aVal = a.gpsLon || 0; bVal = b.gpsLon || 0; break;
          case 'connections':
            aVal = state.edges.filter(e => e.a === a.id || e.b === a.id).length;
            bVal = state.edges.filter(e => e.a === b.id || e.b === b.id).length;
            break;
          default: aVal = 0; bVal = 0;
        }

        if (typeof aVal === 'string') {
          return dataTableState.sortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
        }
        return dataTableState.sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
      });
    }

    // Escape attribute helper
    function escapeAttr(str) {
      return (str || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }

    let rows = '';
    filteredNodes.forEach(n => {
      const connections = state.edges.filter(e => e.a === n.id || e.b === n.id).length;
      const nodeTags = getElementTags('node', n.id);
      const tagsStr = Array.from(nodeTags).join(', ');

      rows += `<tr data-id="${n.id}" data-type="node">
        <td><input class="cell-edit" data-field="code" value="${escapeAttr(n.code || '')}" style="width:60px;" /></td>
        <td><input class="cell-edit" data-field="name" value="${escapeAttr(n.name || '')}" style="width:120px;" /></td>
        <td><input class="cell-edit tag-edit" data-field="tags" value="${escapeAttr(tagsStr)}" placeholder="tag1, tag2..." title="Comma-separated tags" /></td>
        <td><input class="cell-edit" data-field="city" value="${escapeAttr(n.city || '')}" style="width:100px;" /></td>
        <td><input class="cell-edit" data-field="country" value="${escapeAttr(n.country || '')}" style="width:100px;" /></td>
        <td><input class="cell-edit number" data-field="gpsLat" value="${n.gpsLat ?? ''}" style="width:90px;" placeholder="Latitude" /></td>
        <td><input class="cell-edit number" data-field="gpsLon" value="${n.gpsLon ?? ''}" style="width:90px;" placeholder="Longitude" /></td>
        <td style="text-align:center;">${connections}</td>
      </tr>`;
    });

    tbody.innerHTML = rows;

    // Add edit handlers for all fields
    tbody.querySelectorAll('.cell-edit').forEach(input => {
      input.addEventListener('change', (ev) => {
        const row = ev.target.closest('tr');
        const nodeId = parseInt(row.dataset.id);
        const field = ev.target.dataset.field;
        const node = findNode(nodeId);

        if (node && field) {
          if (field === 'tags') {
            const newTagsStr = ev.target.value;
            const newTags = newTagsStr.split(',').map(t => t.trim()).filter(t => t.length > 0);
            setElementTags('node', nodeId, new Set(newTags));
          } else if (field === 'code' || field === 'name' || field === 'city' || field === 'country') {
            // String fields
            node[field] = ev.target.value.trim();
          } else if (field === 'gpsLat' || field === 'gpsLon') {
            // GPS coordinates
            const val = ev.target.value.trim();
            node[field] = val === '' ? null : parseFloat(val);
          }
          commit();
          render(); // Re-render canvas to show name/code changes
          renderDataTable();
        }
      });
    });

    // Add sort handlers for nodes table
    thead.querySelectorAll('th').forEach(th => {
      th.addEventListener('click', () => {
        const col = th.dataset.col;
        if (!col) return;

        if (dataTableState.sortColumn === col) {
          dataTableState.sortDirection = dataTableState.sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          dataTableState.sortColumn = col;
          dataTableState.sortDirection = 'asc';
        }

        // Update visual
        thead.querySelectorAll('th').forEach(h => h.classList.remove('sorted-asc', 'sorted-desc'));
        th.classList.add(dataTableState.sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');

        renderDataTable();
      });
    });
  }

  function renderContainersTable(thead, tbody, showCost, currency) {
    const search = dataTableState.searchQuery.toLowerCase();
    const symbol = getCurrencySymbol(currency);
    const tier = document.getElementById('dataTableCapacityTier')?.value || '10G';
    const discountRate = state.financialSettings.npvDiscountRate || 12.5;

    // Headers
    let headers = `
      <tr>
        <th data-col="name">Name</th>
        <th data-col="type">Type</th>
        <th data-col="parent">Parent Region</th>
        <th data-col="nodes">Nodes</th>
        <th data-col="latency">Transit Latency (ms)</th>
        <th data-col="override">Cost Source</th>`;

    if (showCost) {
      headers += `
        <th data-col="nrc">NRC @${tier} (${symbol})</th>
        <th data-col="mrc">MRC @${tier} (${symbol})</th>
        <th data-col="acv">ACV @${tier} (${symbol})</th>
        <th data-col="iruFee">IRU @${tier} (${symbol})</th>
        <th data-col="iruTerm">Term</th>
        <th data-col="iruNpv">NPV @${tier} (${symbol})</th>
        <th data-col="mode">Mode</th>`;
    }
    headers += `</tr>`;
    thead.innerHTML = headers;

    // Filter containers
    let filteredGroups = state.groups.filter(g => {
      if (!search) return true;
      const parent = g.parentId ? findGroup(g.parentId) : null;
      const parentName = parent?.title || '';
      return (g.title || '').toLowerCase().includes(search) ||
             (g.type || '').toLowerCase().includes(search) ||
             parentName.toLowerCase().includes(search);
    });

    // Sort if needed
    if (dataTableState.sortColumn) {
      filteredGroups.sort((a, b) => {
        let aVal, bVal;
        const col = dataTableState.sortColumn;

        switch(col) {
          case 'name': aVal = a.title || ''; bVal = b.title || ''; break;
          case 'type': aVal = a.type || ''; bVal = b.type || ''; break;
          case 'parent':
            const pA = a.parentId ? findGroup(a.parentId) : null;
            const pB = b.parentId ? findGroup(b.parentId) : null;
            aVal = pA?.title || '';
            bVal = pB?.title || '';
            break;
          case 'nodes':
            aVal = state.nodes.filter(n => n.groupId === a.id).length;
            bVal = state.nodes.filter(n => n.groupId === b.id).length;
            break;
          case 'latency':
            aVal = a.transitLatency ?? 999999;
            bVal = b.transitLatency ?? 999999;
            break;
          case 'nrc': aVal = getValueForTier(a.leaseNRC, tier, 0); bVal = getValueForTier(b.leaseNRC, tier, 0); break;
          case 'mrc': aVal = getValueForTier(a.leaseMRC, tier, 1); bVal = getValueForTier(b.leaseMRC, tier, 1); break;
          case 'acv':
            aVal = calculateLeaseACV(getValueForTier(a.leaseNRC, tier, 0), getValueForTier(a.leaseMRC, tier, 1));
            bVal = calculateLeaseACV(getValueForTier(b.leaseNRC, tier, 0), getValueForTier(b.leaseMRC, tier, 1));
            break;
          case 'iruFee': aVal = getValueForTier(a.iruFee, tier, 1); bVal = getValueForTier(b.iruFee, tier, 1); break;
          case 'iruNpv':
            aVal = calculateIRUNPV(getValueForTier(a.iruFee, tier, 1), a.iruTerm || 15, a.iruOamPercent ?? 3, a.iruOamAnnualIncrement ?? 2, discountRate);
            bVal = calculateIRUNPV(getValueForTier(b.iruFee, tier, 1), b.iruTerm || 15, b.iruOamPercent ?? 3, b.iruOamAnnualIncrement ?? 2, discountRate);
            break;
          default: aVal = a.id; bVal = b.id;
        }

        if (typeof aVal === 'string') {
          const result = aVal.localeCompare(bVal);
          return dataTableState.sortDirection === 'asc' ? result : -result;
        }
        return dataTableState.sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
      });
    }

    // Generate rows
    let rows = '';
    filteredGroups.forEach(g => {
      const parent = g.parentId ? findGroup(g.parentId) : null;
      const nodeCount = state.nodes.filter(n => n.groupId === g.id).length;
      const typeLabel = g.type === 'region' ? 'ðŸ“ Region' : 'ðŸ“¦ Container';
      const parentLabel = parent ? parent.title : 'â€”';
      const latencyLabel = g.transitLatency !== undefined && g.transitLatency !== null ? g.transitLatency.toFixed(2) : '(default)';
      const costSource = g.commercialCostOverride ? 'âœï¸ Manual' : 'ðŸ“Š Calculated';

      const nrc = getValueForTier(g.leaseNRC, tier, 0);
      const mrc = getValueForTier(g.leaseMRC, tier, 1);
      const iruFee = getValueForTier(g.iruFee, tier, 1);
      const acv = calculateLeaseACV(nrc, mrc);
      const iruNpv = calculateIRUNPV(iruFee, g.iruTerm || 15, g.iruOamPercent ?? 3, g.iruOamAnnualIncrement ?? 2, discountRate);

      rows += `<tr data-id="${g.id}" data-type="group" style="cursor:pointer;">
        <td style="font-weight:500;">${escapeHtml(g.title || '')}</td>
        <td style="font-size:11px;">${typeLabel}</td>
        <td style="font-size:11px;">${escapeHtml(parentLabel)}</td>
        <td style="text-align:center;">${nodeCount}</td>
        <td style="text-align:right;">${latencyLabel}</td>
        <td style="font-size:10px; color:${g.commercialCostOverride ? '#d97706' : '#059669'};">${costSource}</td>`;

      if (showCost) {
        rows += `
          <td style="text-align:right;">${nrc.toFixed(2)}</td>
          <td style="text-align:right;">${mrc.toFixed(2)}</td>
          <td style="text-align:right; font-weight:500; color:#1d4ed8;">${formatCurrency(acv, currency)}</td>
          <td style="text-align:right;">${iruFee.toFixed(2)}</td>
          <td style="text-align:center;">${g.iruTerm || 15}y</td>
          <td style="text-align:right; font-weight:500; color:#7c3aed;">${formatCurrency(iruNpv, currency)}</td>
          <td style="font-size:10px;">${g.commercialCostMode === 'iru' ? 'IRU' : 'Lease'}</td>`;
      }
      rows += `</tr>`;
    });

    tbody.innerHTML = rows;

    // Add click handler to select container
    tbody.querySelectorAll('tr').forEach(row => {
      row.addEventListener('click', () => {
        const id = parseInt(row.dataset.id);
        const g = findGroup(id);
        if (g) {
          select({ type: 'group', id });
          render();
          updateInspector();
        }
      });
    });

    // Add sort handlers
    thead.querySelectorAll('th[data-col]').forEach(th => {
      th.style.cursor = 'pointer';
      th.addEventListener('click', () => {
        const col = th.dataset.col;
        if (dataTableState.sortColumn === col) {
          dataTableState.sortDirection = dataTableState.sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          dataTableState.sortColumn = col;
          dataTableState.sortDirection = 'asc';
        }

        thead.querySelectorAll('th').forEach(h => h.classList.remove('sorted-asc', 'sorted-desc'));
        th.classList.add(dataTableState.sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');

        renderDataTable();
      });
    });
  }

  function renderMLGTable(thead, tbody, showCost, currency) {
    const symbol = getCurrencySymbol(currency);
    const discountRate = state.financialSettings.npvDiscountRate || 12.5;

    let headers = `
      <tr>
        <th>Name</th>
        <th>Route</th>
        <th>Segments</th>
        <th>Latency (ms)</th>`;

    if (showCost) {
      headers += `
        <th>ACV (${symbol})</th>
        <th>IRU NPV (${symbol})</th>
        <th>Mode</th>`;
    }
    headers += `</tr>`;
    thead.innerHTML = headers;

    let rows = '';
    state.multilinkGroups.forEach(mlg => {
      const origin = findNode(mlg.originNode);
      const dest = findNode(mlg.destinationNode);
      const route = origin && dest ? `${origin.name} â†’ ${dest.name}` : 'â€”';

      // Calculate costs
      const costs = calculateMLGCosts(mlg);

      rows += `<tr data-id="${mlg.id}" data-type="mlg">
        <td style="font-weight:500;">${mlg.name || ''}</td>
        <td style="font-size:11px;">${route}</td>
        <td style="text-align:center;">${mlg.segments?.length || 0}</td>
        <td style="text-align:right;">${mlg.totalLatency?.toFixed(2) || 'â€”'}</td>`;

      if (showCost) {
        rows += `
          <td style="text-align:right; font-weight:500; color:#1d4ed8;">${formatCurrency(costs.acv, currency)}</td>
          <td style="text-align:right; font-weight:500; color:#7c3aed;">${formatCurrency(costs.iruNpv, currency)}</td>
          <td style="font-size:10px;">${mlg.commercialCostMode === 'iru' ? 'IRU' : 'Lease'}</td>`;
      }
      rows += `</tr>`;
    });

    tbody.innerHTML = rows || '<tr><td colspan="7" style="text-align:center; color:#94a3b8; padding:20px;">No multilink groups defined</td></tr>';
  }

  function exportDataTableCSV() {
    const type = dataTableState.type;
    const currency = state.financialSettings.baseCurrency || 'USD';
    const discountRate = state.financialSettings.npvDiscountRate || 12.5;
    const defaultOAM = state.financialSettings.defaultOAM || 3;
    const defaultOAMInc = state.financialSettings.defaultOAMIncrement || 2;
    let csv = '';

    if (type === 'links') {
      csv = 'Code,Link Tag,Tags,Cable System,A-End,B-End,Latency,NRC,MRC,ACV,IRU Fee,IRU Term,O&M %,O&M Inc %,IRU NPV\n';
      state.edges.forEach(e => {
        const aNode = findNode(e.a);
        const bNode = findNode(e.b);
        const acv = calculateLeaseACV(e.leaseNRC || 0, e.leaseMRC || 1);
        const oamPct = e.iruOamPercent ?? defaultOAM;
        const oamInc = e.iruOamAnnualIncrement ?? defaultOAMInc;
        const iruNpv = calculateIRUNPV(e.iruFee || 1, e.iruTerm || 15, oamPct, oamInc, discountRate);
        const edgeTags = Array.from(getElementTags('edge', e.id)).join(';');
        const cableSystem = e.cableSystemId ? findCableSystem(e.cableSystemId) : null;
        const csName = cableSystem ? (cableSystem.name || cableSystem.shortName || '') : '';

        csv += `"${e.code || ''}","${e.tag || ''}","${edgeTags}","${csName}","${aNode?.name || ''}","${bNode?.name || ''}",${e.latencyMs ?? ''},${e.leaseNRC || 0},${e.leaseMRC || 1},${acv.toFixed(2)},${e.iruFee || 1},${e.iruTerm || 15},${oamPct},${oamInc},${iruNpv.toFixed(2)}\n`;
      });
    } else if (type === 'nodes') {
      csv = 'Code,Name,Tags,City,Country,Latitude,Longitude,Connections\n';
      state.nodes.forEach(n => {
        const nodeTags = Array.from(getElementTags('node', n.id)).join(';');
        const connections = state.edges.filter(e => e.a === n.id || e.b === n.id).length;
        csv += `"${n.code || ''}","${n.name || ''}","${nodeTags}","${n.city || ''}","${n.country || ''}",${n.gpsLat ?? ''},${n.gpsLon ?? ''},${connections}\n`;
      });
    }

    // Download
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `neximap_${type}_export.csv`;
    a.click();
    URL.revokeObjectURL(url);
    showToast(`Exported ${type} to CSV`);
  }

  function initDataTable() {
    // Close button
    const btnClose = document.getElementById('btnCloseDataTable');
    if (btnClose) btnClose.addEventListener('click', hideDataTable);

    // Make Data Table draggable
    const dataTableContent = document.getElementById('dataTableContent');
    const dataTableHeader = document.getElementById('dataTableHeader');

    if (dataTableContent && dataTableHeader) {
      let isDragging = false;
      let startX, startY, startLeft, startTop;

      dataTableHeader.addEventListener('mousedown', (e) => {
        // Don't start drag if clicking on buttons or controls
        if (e.target.tagName === 'BUTTON' || e.target.tagName === 'SELECT' || e.target.tagName === 'INPUT') return;

        isDragging = true;
        const rect = dataTableContent.getBoundingClientRect();
        startX = e.clientX;
        startY = e.clientY;
        startLeft = rect.left;
        startTop = rect.top;

        // Set initial position if not already positioned
        if (!dataTableContent.style.left) {
          dataTableContent.style.left = rect.left + 'px';
          dataTableContent.style.top = rect.top + 'px';
        }

        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        let newLeft = startLeft + dx;
        let newTop = startTop + dy;

        // Keep within viewport bounds
        newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - 100));
        newTop = Math.max(0, Math.min(newTop, window.innerHeight - 50));

        dataTableContent.style.left = newLeft + 'px';
        dataTableContent.style.top = newTop + 'px';
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    }

    // Type selector
    const typeSelect = document.getElementById('dataTableType');
    if (typeSelect) {
      typeSelect.addEventListener('change', () => {
        dataTableState.type = typeSelect.value;
        dataTableState.sortColumn = null;
        renderDataTable();
      });
    }

    // Search
    const searchInput = document.getElementById('dataTableSearch');
    if (searchInput) {
      searchInput.addEventListener('input', () => {
        dataTableState.searchQuery = searchInput.value;
        renderDataTable();
      });
    }

    // Capacity tier selector for data table
    const dataTableCapacityTier = document.getElementById('dataTableCapacityTier');
    if (dataTableCapacityTier) {
      dataTableCapacityTier.addEventListener('change', () => {
        renderDataTable();
      });
    }

    // Show cost toggle
    const showCostCheck = document.getElementById('dataTableShowCost');
    if (showCostCheck) {
      showCostCheck.addEventListener('change', () => {
        dataTableState.showCostColumns = showCostCheck.checked;
        renderDataTable();
      });
    }

    // Selection filter toggle
    const selectionFilterCheck = document.getElementById('dataTableSelectionFilter');
    if (selectionFilterCheck) {
      selectionFilterCheck.addEventListener('change', () => {
        dataTableState.filterBySelection = selectionFilterCheck.checked;
        renderDataTable();
      });
    }

    // Export button
    const btnExport = document.getElementById('btnDataTableExport');
    if (btnExport) btnExport.addEventListener('click', exportDataTableCSV);

    // Recalculate button
    const btnRecalc = document.getElementById('btnDataTableRecalc');
    if (btnRecalc) {
      btnRecalc.addEventListener('click', () => {
        recalculateAllMLGCosts();
        recalculateAllContainerCosts();
        renderDataTable();
        showToast('Costs recalculated (MLGs and Containers)');
      });
    }

    // Reset Prices from Tier button
    const btnResetPrices = document.getElementById('btnDataTableResetPrices');
    if (btnResetPrices) {
      btnResetPrices.addEventListener('click', () => {
        const sourceTierSelect = document.getElementById('dataTableSourceTier');
        const sourceTier = sourceTierSelect?.value || '10G';
        resetAllPricesFromTier(sourceTier);
      });
    }

    // Escape to close
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const modal = document.getElementById('dataTableModal');
        if (modal?.classList.contains('show')) {
          hideDataTable();
        }
      }
    });

    // Backdrop click - but NOT when dragging
    const modal = document.getElementById('dataTableModal');
    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) hideDataTable();
      });
    }

    // Menu item
    const miDataTable = document.getElementById('miDataTable');
    if (miDataTable) {
      miDataTable.addEventListener('click', () => {
        closeAllMenus();
        showDataTable();
      });
    }

    // Keyboard shortcut Ctrl+T
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 't') {
        e.preventDefault();
        showDataTable();
      }
    });
  }

  window.showDataTable = showDataTable;
  window.hideDataTable = hideDataTable;

  // ============== BULK EDIT ==============

  let bulkEditState = {
    type: 'links', // 'links' or 'nodes'
    targetItems: []
  };

  function showBulkEditModal(type) {
    bulkEditState.type = type;
    const modal = document.getElementById('bulkEditModal');
    const title = document.getElementById('bulkEditTitle');
    const linksFields = document.getElementById('bulkEditLinksFields');
    const nodesFields = document.getElementById('bulkEditNodesFields');

    if (!modal) return;

    // Update title and show appropriate fields
    if (type === 'links') {
      title.textContent = 'ðŸ“ Bulk Edit Links';
      linksFields.style.display = 'block';
      nodesFields.style.display = 'none';
    } else {
      title.textContent = 'ðŸ“ Bulk Edit Nodes';
      linksFields.style.display = 'none';
      nodesFields.style.display = 'block';
    }

    // Reset all checkboxes
    modal.querySelectorAll('input[type="checkbox"]').forEach(cb => {
      cb.checked = false;
      const input = cb.closest('.bulk-edit-checkbox')?.querySelector('input:not([type="checkbox"]), select');
      if (input) input.disabled = true;
    });

    // Update target count
    updateBulkEditTargetCount();
    updateBulkEditSummary();

    modal.classList.add('show');

    // Close Data menu if open
    closeAllMenus();
  }

  function hideBulkEditModal() {
    const modal = document.getElementById('bulkEditModal');
    if (modal) modal.classList.remove('show');
  }

  function updateBulkEditTargetCount() {
    const target = document.getElementById('bulkEditTarget')?.value || 'all';
    const tagFilter = document.getElementById('bulkEditTagFilter')?.value?.trim().toLowerCase() || '';
    const countEl = document.getElementById('bulkEditTargetCount');
    const tagRow = document.getElementById('bulkEditTagFilterRow');

    // Show/hide tag filter row
    if (tagRow) tagRow.style.display = target === 'tagged' ? 'flex' : 'none';

    let items = [];
    const isLinks = bulkEditState.type === 'links';
    const collection = isLinks ? state.edges : state.nodes;

    switch (target) {
      case 'all':
        items = [...collection];
        break;
      case 'selected':
        if (isLinks) {
          items = collection.filter(e => state.selection.edges.has(e.id));
        } else {
          items = collection.filter(n => state.selection.nodes.has(n.id));
        }
        break;
      case 'filtered':
        const searchQuery = dataTableState.searchQuery.toLowerCase();
        if (isLinks) {
          items = collection.filter(e => {
            if (!searchQuery) return true;
            const aNode = findNode(e.a);
            const bNode = findNode(e.b);
            const edgeTags = getElementTags('edge', e.id);
            const tagsStr = Array.from(edgeTags).join(' ').toLowerCase();
            return (e.code || '').toLowerCase().includes(searchQuery) ||
                   (e.tag || '').toLowerCase().includes(searchQuery) ||
                   tagsStr.includes(searchQuery) ||
                   (aNode?.name || '').toLowerCase().includes(searchQuery) ||
                   (bNode?.name || '').toLowerCase().includes(searchQuery);
          });
        } else {
          items = collection.filter(n => {
            if (!searchQuery) return true;
            const nodeTags = getElementTags('node', n.id);
            const tagsStr = Array.from(nodeTags).join(' ').toLowerCase();
            return (n.code || '').toLowerCase().includes(searchQuery) ||
                   (n.name || '').toLowerCase().includes(searchQuery) ||
                   (n.city || '').toLowerCase().includes(searchQuery) ||
                   (n.country || '').toLowerCase().includes(searchQuery) ||
                   tagsStr.includes(searchQuery);
          });
        }
        break;
      case 'tagged':
        if (tagFilter) {
          items = collection.filter(item => {
            const tags = isLinks ? getElementTags('edge', item.id) : getElementTags('node', item.id);
            return Array.from(tags).some(t => t.toLowerCase().includes(tagFilter));
          });
        }
        break;
    }

    bulkEditState.targetItems = items;

    if (countEl) {
      countEl.textContent = `Will affect: ${items.length} ${isLinks ? 'link' : 'node'}${items.length !== 1 ? 's' : ''}`;
      countEl.style.color = items.length > 0 ? '#6366f1' : '#ef4444';
    }
  }

  function updateBulkEditSummary() {
    const summaryEl = document.getElementById('bulkEditSummary');
    if (!summaryEl) return;

    const modal = document.getElementById('bulkEditModal');
    const checkedCount = modal?.querySelectorAll('.bulk-edit-checkbox input[type="checkbox"]:checked').length || 0;

    if (checkedCount === 0) {
      summaryEl.textContent = 'No changes selected';
    } else {
      summaryEl.textContent = `${checkedCount} field${checkedCount > 1 ? 's' : ''} will be updated`;
    }
  }

  function applyBulkEdit() {
    const items = bulkEditState.targetItems;
    const isLinks = bulkEditState.type === 'links';

    if (items.length === 0) {
      showToast('âš ï¸ No items to update');
      return;
    }

    let changeCount = 0;

    if (isLinks) {
      // Link bulk edits
      const applyNRC = document.getElementById('bulkEditApplyNRC')?.checked;
      const applyMRC = document.getElementById('bulkEditApplyMRC')?.checked;
      const applyIRU = document.getElementById('bulkEditApplyIRU')?.checked;
      const applyTerm = document.getElementById('bulkEditApplyTerm')?.checked;
      const applyOAM = document.getElementById('bulkEditApplyOAM')?.checked;
      const applyOAMInc = document.getElementById('bulkEditApplyOAMInc')?.checked;
      const applyLatency = document.getElementById('bulkEditApplyLatency')?.checked;
      const applyAddTags = document.getElementById('bulkEditApplyAddTags')?.checked;
      const applyRemoveTags = document.getElementById('bulkEditApplyRemoveTags')?.checked;
      const applyReplaceTags = document.getElementById('bulkEditApplyReplaceTags')?.checked;

      const nrcVal = parseFloat(document.getElementById('bulkEditNRC')?.value) || 0;
      const mrcVal = parseFloat(document.getElementById('bulkEditMRC')?.value) || 1;
      const iruVal = parseFloat(document.getElementById('bulkEditIRU')?.value) || 1;
      const termVal = parseInt(document.getElementById('bulkEditTerm')?.value) || 15;
      const oamVal = parseFloat(document.getElementById('bulkEditOAM')?.value) || 3;
      const oamIncVal = parseFloat(document.getElementById('bulkEditOAMInc')?.value) || 2;
      const latencyVal = document.getElementById('bulkEditLatency')?.value?.trim();
      const addTagsVal = (document.getElementById('bulkEditAddTags')?.value || '').split(',').map(t => t.trim()).filter(t => t);
      const removeTagsVal = (document.getElementById('bulkEditRemoveTags')?.value || '').split(',').map(t => t.trim()).filter(t => t);
      const replaceTagsVal = (document.getElementById('bulkEditReplaceTags')?.value || '').split(',').map(t => t.trim()).filter(t => t);

      items.forEach(edge => {
        if (applyNRC) {
          edge.leaseNRC = normalizeTierPricing(nrcVal, nrcVal);
          changeCount++;
        }
        if (applyMRC) {
          edge.leaseMRC = normalizeTierPricing(mrcVal, mrcVal);
          changeCount++;
        }
        if (applyIRU) {
          edge.iruFee = normalizeTierPricing(iruVal, iruVal);
          changeCount++;
        }
        if (applyTerm) {
          edge.iruTerm = termVal;
          changeCount++;
        }
        if (applyOAM) {
          edge.iruOamPercent = oamVal;
          changeCount++;
        }
        if (applyOAMInc) {
          edge.iruOamAnnualIncrement = oamIncVal;
          changeCount++;
        }
        if (applyLatency) {
          edge.latencyMs = latencyVal === '' ? null : parseFloat(latencyVal);
          changeCount++;
        }

        // Tag operations
        if (applyReplaceTags) {
          setElementTags('edge', edge.id, new Set(replaceTagsVal));
          changeCount++;
        } else {
          if (applyAddTags && addTagsVal.length > 0) {
            const current = getElementTags('edge', edge.id);
            addTagsVal.forEach(t => current.add(t));
            setElementTags('edge', edge.id, current);
            changeCount++;
          }
          if (applyRemoveTags && removeTagsVal.length > 0) {
            const current = getElementTags('edge', edge.id);
            removeTagsVal.forEach(t => current.delete(t));
            setElementTags('edge', edge.id, current);
            changeCount++;
          }
        }
      });
    } else {
      // Node bulk edits
      const applyAddTags = document.getElementById('bulkEditNodeAddTags')?.checked;
      const applyRemoveTags = document.getElementById('bulkEditNodeRemoveTags')?.checked;
      const applyReplaceTags = document.getElementById('bulkEditNodeReplaceTags')?.checked;
      const applyCountry = document.getElementById('bulkEditApplyCountry')?.checked;
      const applyCity = document.getElementById('bulkEditApplyCity')?.checked;

      const addTagsVal = (document.getElementById('bulkEditNodeAddTagsInput')?.value || '').split(',').map(t => t.trim()).filter(t => t);
      const removeTagsVal = (document.getElementById('bulkEditNodeRemoveTagsInput')?.value || '').split(',').map(t => t.trim()).filter(t => t);
      const replaceTagsVal = (document.getElementById('bulkEditNodeReplaceTagsInput')?.value || '').split(',').map(t => t.trim()).filter(t => t);
      const countryVal = document.getElementById('bulkEditCountry')?.value?.trim() || '';
      const cityVal = document.getElementById('bulkEditCity')?.value?.trim() || '';

      items.forEach(node => {
        if (applyCountry) {
          node.country = countryVal;
          changeCount++;
        }
        if (applyCity) {
          node.city = cityVal;
          changeCount++;
        }

        // Tag operations
        if (applyReplaceTags) {
          setElementTags('node', node.id, new Set(replaceTagsVal));
          changeCount++;
        } else {
          if (applyAddTags && addTagsVal.length > 0) {
            const current = getElementTags('node', node.id);
            addTagsVal.forEach(t => current.add(t));
            setElementTags('node', node.id, current);
            changeCount++;
          }
          if (applyRemoveTags && removeTagsVal.length > 0) {
            const current = getElementTags('node', node.id);
            removeTagsVal.forEach(t => current.delete(t));
            setElementTags('node', node.id, current);
            changeCount++;
          }
        }
      });
    }

    if (changeCount > 0) {
      commit();
      render();
      renderDataTable();
      hideBulkEditModal();
      showToast(`âœ… Bulk edited ${items.length} ${isLinks ? 'link' : 'node'}${items.length !== 1 ? 's' : ''}`);
    } else {
      showToast('âš ï¸ No changes were made');
    }
  }

  // Initialize bulk edit modal
  function initBulkEdit() {
    const btnClose = document.getElementById('btnCloseBulkEdit');
    const btnCancel = document.getElementById('btnCancelBulkEdit');
    const btnApply = document.getElementById('btnApplyBulkEdit');
    const targetSelect = document.getElementById('bulkEditTarget');
    const tagFilter = document.getElementById('bulkEditTagFilter');
    const modal = document.getElementById('bulkEditModal');

    if (btnClose) btnClose.addEventListener('click', hideBulkEditModal);
    if (btnCancel) btnCancel.addEventListener('click', hideBulkEditModal);
    if (btnApply) btnApply.addEventListener('click', applyBulkEdit);

    if (targetSelect) {
      targetSelect.addEventListener('change', updateBulkEditTargetCount);
    }
    if (tagFilter) {
      tagFilter.addEventListener('input', updateBulkEditTargetCount);
    }

    // Enable/disable inputs when checkboxes are toggled
    if (modal) {
      modal.querySelectorAll('.bulk-edit-checkbox input[type="checkbox"]').forEach(cb => {
        cb.addEventListener('change', () => {
          const input = cb.closest('.bulk-edit-checkbox')?.querySelector('input:not([type="checkbox"]), select');
          if (input) input.disabled = !cb.checked;
          updateBulkEditSummary();
        });
      });
    }

    // Close on escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const bulkModal = document.getElementById('bulkEditModal');
        if (bulkModal?.classList.contains('show')) {
          hideBulkEditModal();
        }
      }
    });

    // Close on backdrop click
    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) hideBulkEditModal();
      });
    }

    // Menu item handlers
    const miBulkEditLinks = document.getElementById('miBulkEditLinks');
    const miBulkEditNodes = document.getElementById('miBulkEditNodes');

    if (miBulkEditLinks) {
      miBulkEditLinks.addEventListener('click', () => {
        showBulkEditModal('links');
      });
    }

    if (miBulkEditNodes) {
      miBulkEditNodes.addEventListener('click', () => {
        showBulkEditModal('nodes');
      });
    }
  }

  // Initialize on load
  setTimeout(() => {
    initBulkEdit();
  }, 250);

  window.showBulkEditModal = showBulkEditModal;
  window.hideBulkEditModal = hideBulkEditModal;

  // ============== END BULK EDIT ==============

  // ============== SETTINGS MODALS ==============

  // ----- Display Preferences -----
  function showDisplayPrefsModal() {
    const modal = document.getElementById('displayPrefsModal');
    if (!modal) return;

    // Load current values
    document.getElementById('dpShowNodeName').checked = state.ui.showNodeName;
    document.getElementById('dpShowNodeCode').checked = state.ui.showNodeCode;
    document.getElementById('dpShowNodeTags').checked = state.ui.showNodeTags;
    document.getElementById('dpShowExtraTags').checked = state.ui.showExtraTags;
    document.getElementById('dpShowLinkTag').checked = state.ui.showLinkTag;
    document.getElementById('dpShowLinkCode').checked = state.ui.showLinkCode;
    document.getElementById('dpShowLatency').checked = state.ui.showLatency;
    document.getElementById('dpShowContainerTitle').checked = state.ui.showContainerTitle;
    document.getElementById('dpCanvasWidth').value = state.canvasWidth;
    document.getElementById('dpCanvasHeight').value = state.canvasHeight;
    document.getElementById('dpShowCanvasBorder').checked = state.showCanvasBorder;
    document.getElementById('dpShowGrid').checked = state.gridEnabled;
    document.getElementById('dpGridSize').value = state.gridSize;

    modal.classList.add('show');
    closeAllMenus();
  }

  function hideDisplayPrefsModal() {
    const modal = document.getElementById('displayPrefsModal');
    if (modal) modal.classList.remove('show');
  }

  function saveDisplayPrefs() {
    // Save UI toggles
    state.ui.showNodeName = document.getElementById('dpShowNodeName').checked;
    state.ui.showNodeCode = document.getElementById('dpShowNodeCode').checked;
    state.ui.showNodeTags = document.getElementById('dpShowNodeTags').checked;
    state.ui.showExtraTags = document.getElementById('dpShowExtraTags').checked;
    state.ui.showLinkTag = document.getElementById('dpShowLinkTag').checked;
    state.ui.showLinkCode = document.getElementById('dpShowLinkCode').checked;
    state.ui.showLatency = document.getElementById('dpShowLatency').checked;
    state.ui.showContainerTitle = document.getElementById('dpShowContainerTitle').checked;

    // Save canvas settings
    state.canvasWidth = parseInt(document.getElementById('dpCanvasWidth').value) || 1600;
    state.canvasHeight = parseInt(document.getElementById('dpCanvasHeight').value) || 900;
    state.showCanvasBorder = document.getElementById('dpShowCanvasBorder').checked;
    state.gridEnabled = document.getElementById('dpShowGrid').checked;
    state.gridSize = parseInt(document.getElementById('dpGridSize').value) || 40;

    // Update canvas size
    const svg = document.getElementById('svg');
    if (svg) {
      svg.setAttribute('viewBox', `0 0 ${state.canvasWidth} ${state.canvasHeight}`);
    }

    // Sync with UI checkboxes if they exist
    const tglNodeName = document.getElementById('tglNodeName');
    const tglNodeCode = document.getElementById('tglNodeCode');
    const tglNodeTags = document.getElementById('tglNodeTags');
    const tglExtraTags = document.getElementById('tglExtraTags');
    const tglLinkTag = document.getElementById('tglLinkTag');
    const tglLinkCode = document.getElementById('tglLinkCode');
    const tglLatency = document.getElementById('tglLatency');
    const tglContainerTitle = document.getElementById('tglContainerTitle');
    const gridEnabled = document.getElementById('gridEnabled');

    if (tglNodeName) tglNodeName.checked = state.ui.showNodeName;
    if (tglNodeCode) tglNodeCode.checked = state.ui.showNodeCode;
    if (tglNodeTags) tglNodeTags.checked = state.ui.showNodeTags;
    if (tglExtraTags) tglExtraTags.checked = state.ui.showExtraTags;
    if (tglLinkTag) tglLinkTag.checked = state.ui.showLinkTag;
    if (tglLinkCode) tglLinkCode.checked = state.ui.showLinkCode;
    if (tglLatency) tglLatency.checked = state.ui.showLatency;
    if (tglContainerTitle) tglContainerTitle.checked = state.ui.showContainerTitle;
    if (gridEnabled) gridEnabled.checked = state.gridEnabled;

    commit();
    render();
    hideDisplayPrefsModal();
    showToast('âœ… Display preferences saved');
  }

  // ----- Default Node Style -----
  function showNodeDefaultsModal() {
    const modal = document.getElementById('nodeDefaultsModal');
    if (!modal) return;

    const ns = state.defaultNodeStyle;
    document.getElementById('ndShape').value = ns.shape;
    document.getElementById('ndSize').value = ns.r;
    document.getElementById('ndFillColor').value = ns.fill;
    document.getElementById('ndFillColorHex').textContent = ns.fill;
    document.getElementById('ndStrokeColor').value = ns.stroke;
    document.getElementById('ndStrokeColorHex').textContent = ns.stroke;
    document.getElementById('ndStrokeWidth').value = ns.strokeWidth;
    document.getElementById('ndLabelFontSize').value = ns.labelFont;
    document.getElementById('ndLabelColor').value = ns.labelColor;
    document.getElementById('ndLabelColorHex').textContent = ns.labelColor;

    updateNodeShapePreview();

    modal.classList.add('show');
    closeAllMenus();
  }

  function hideNodeDefaultsModal() {
    const modal = document.getElementById('nodeDefaultsModal');
    if (modal) modal.classList.remove('show');
  }

  function updateNodeShapePreview() {
    const shape = document.getElementById('ndShape').value;
    const fill = document.getElementById('ndFillColor').value;
    const stroke = document.getElementById('ndStrokeColor').value;
    const preview = document.getElementById('ndShapePreview');

    if (!preview) return;

    let svg = '';
    const sw = 2;

    switch(shape) {
      case 'square':
        svg = `<svg viewBox="0 0 40 40"><rect x="4" y="4" width="32" height="32" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/></svg>`;
        break;
      case 'diamond':
        svg = `<svg viewBox="0 0 40 40"><polygon points="20,4 36,20 20,36 4,20" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/></svg>`;
        break;
      case 'hexagon':
        svg = `<svg viewBox="0 0 40 40"><polygon points="20,4 34,12 34,28 20,36 6,28 6,12" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/></svg>`;
        break;
      case 'triangle':
        svg = `<svg viewBox="0 0 40 40"><polygon points="20,4 36,36 4,36" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/></svg>`;
        break;
      case 'star':
        svg = `<svg viewBox="0 0 40 40"><polygon points="20,4 24,16 36,16 26,24 30,36 20,28 10,36 14,24 4,16 16,16" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/></svg>`;
        break;
      case 'cloud':
        svg = `<svg viewBox="0 0 40 40"><ellipse cx="20" cy="22" rx="14" ry="10" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/><circle cx="12" cy="18" r="6" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/><circle cx="28" cy="18" r="6" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/></svg>`;
        break;
      case 'database':
        svg = `<svg viewBox="0 0 40 40"><ellipse cx="20" cy="10" rx="14" ry="6" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/><path d="M6,10 L6,30 Q6,36 20,36 Q34,36 34,30 L34,10" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/></svg>`;
        break;
      case 'server':
        svg = `<svg viewBox="0 0 40 40"><rect x="6" y="6" width="28" height="28" rx="3" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/><line x1="6" y1="14" x2="34" y2="14" stroke="${stroke}" stroke-width="1"/><line x1="6" y1="22" x2="34" y2="22" stroke="${stroke}" stroke-width="1"/><circle cx="30" cy="10" r="2" fill="${stroke}"/><circle cx="30" cy="18" r="2" fill="${stroke}"/><circle cx="30" cy="26" r="2" fill="${stroke}"/></svg>`;
        break;
      case 'router':
        svg = `<svg viewBox="0 0 40 40"><rect x="6" y="12" width="28" height="16" rx="2" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/><line x1="10" y1="12" x2="10" y2="6" stroke="${stroke}" stroke-width="2"/><line x1="20" y1="12" x2="20" y2="6" stroke="${stroke}" stroke-width="2"/><line x1="30" y1="12" x2="30" y2="6" stroke="${stroke}" stroke-width="2"/><circle cx="10" cy="4" r="2" fill="${stroke}"/><circle cx="20" cy="4" r="2" fill="${stroke}"/><circle cx="30" cy="4" r="2" fill="${stroke}"/></svg>`;
        break;
      default: // circle
        svg = `<svg viewBox="0 0 40 40"><circle cx="20" cy="20" r="16" fill="${fill}" stroke="${stroke}" stroke-width="${sw}"/></svg>`;
    }

    preview.innerHTML = svg;
  }

  function saveNodeDefaults() {
    state.defaultNodeStyle.shape = document.getElementById('ndShape').value;
    state.defaultNodeStyle.r = parseInt(document.getElementById('ndSize').value) || 24;
    state.defaultNodeStyle.fill = document.getElementById('ndFillColor').value;
    state.defaultNodeStyle.stroke = document.getElementById('ndStrokeColor').value;
    state.defaultNodeStyle.strokeWidth = parseFloat(document.getElementById('ndStrokeWidth').value) || 2;
    state.defaultNodeStyle.labelFont = parseInt(document.getElementById('ndLabelFontSize').value) || 12;
    state.defaultNodeStyle.labelColor = document.getElementById('ndLabelColor').value;

    // Update the default node shape state
    state.defaultNodeShape = state.defaultNodeStyle.shape;

    commit();
    hideNodeDefaultsModal();
    showToast('âœ… Default node style saved');
  }

  // ----- Default Link Style -----
  function showLinkDefaultsModal() {
    const modal = document.getElementById('linkDefaultsModal');
    if (!modal) return;

    const ls = state.defaultLinkStyle;
    document.getElementById('ldLineType').value = ls.lineType;
    document.getElementById('ldStrokeWidth').value = ls.strokeWidth;
    document.getElementById('ldDashPattern').value = ls.dashArray;
    document.getElementById('ldCurveArch').value = ls.curveArch;
    document.getElementById('ldStrokeColor').value = ls.stroke;
    document.getElementById('ldStrokeColorHex').textContent = ls.stroke;
    document.getElementById('ldEnableGlow').checked = ls.glow;
    document.getElementById('ldGlowColor').value = ls.glowColor;
    document.getElementById('ldGlowColorHex').textContent = ls.glowColor;
    document.getElementById('ldGlowColorRow').style.display = ls.glow ? 'flex' : 'none';
    document.getElementById('ldLabelFontSize').value = ls.labelFont;
    document.getElementById('ldLabelColor').value = ls.labelColor;
    document.getElementById('ldLabelColorHex').textContent = ls.labelColor;
    document.getElementById('ldArrowStart').checked = ls.arrowStart;
    document.getElementById('ldArrowEnd').checked = ls.arrowEnd;

    modal.classList.add('show');
    closeAllMenus();
  }

  function hideLinkDefaultsModal() {
    const modal = document.getElementById('linkDefaultsModal');
    if (modal) modal.classList.remove('show');
  }

  function saveLinkDefaults() {
    state.defaultLinkStyle.lineType = document.getElementById('ldLineType').value;
    state.defaultLinkStyle.strokeWidth = parseFloat(document.getElementById('ldStrokeWidth').value) || 2;
    state.defaultLinkStyle.dashArray = document.getElementById('ldDashPattern').value;
    state.defaultLinkStyle.curveArch = parseFloat(document.getElementById('ldCurveArch').value) || 0.3;
    state.defaultLinkStyle.stroke = document.getElementById('ldStrokeColor').value;
    state.defaultLinkStyle.glow = document.getElementById('ldEnableGlow').checked;
    state.defaultLinkStyle.glowColor = document.getElementById('ldGlowColor').value;
    state.defaultLinkStyle.labelFont = parseInt(document.getElementById('ldLabelFontSize').value) || 10;
    state.defaultLinkStyle.labelColor = document.getElementById('ldLabelColor').value;
    state.defaultLinkStyle.arrowStart = document.getElementById('ldArrowStart').checked;
    state.defaultLinkStyle.arrowEnd = document.getElementById('ldArrowEnd').checked;

    commit();
    hideLinkDefaultsModal();
    showToast('âœ… Default link style saved');
  }

  // Initialize settings modals
  function initSettingsModals() {
    // Display Preferences
    const miDisplayPrefs = document.getElementById('miDisplayPrefs');
    const btnCloseDisplayPrefs = document.getElementById('btnCloseDisplayPrefs');
    const btnCancelDisplayPrefs = document.getElementById('btnCancelDisplayPrefs');
    const btnSaveDisplayPrefs = document.getElementById('btnSaveDisplayPrefs');
    const displayPrefsModal = document.getElementById('displayPrefsModal');

    if (miDisplayPrefs) miDisplayPrefs.addEventListener('click', showDisplayPrefsModal);
    if (btnCloseDisplayPrefs) btnCloseDisplayPrefs.addEventListener('click', hideDisplayPrefsModal);
    if (btnCancelDisplayPrefs) btnCancelDisplayPrefs.addEventListener('click', hideDisplayPrefsModal);
    if (btnSaveDisplayPrefs) btnSaveDisplayPrefs.addEventListener('click', saveDisplayPrefs);
    if (displayPrefsModal) {
      displayPrefsModal.addEventListener('click', (e) => {
        if (e.target === displayPrefsModal) hideDisplayPrefsModal();
      });
    }

    // Node Defaults
    const miNodeDefaults = document.getElementById('miNodeDefaults');
    const btnCloseNodeDefaults = document.getElementById('btnCloseNodeDefaults');
    const btnCancelNodeDefaults = document.getElementById('btnCancelNodeDefaults');
    const btnSaveNodeDefaults = document.getElementById('btnSaveNodeDefaults');
    const nodeDefaultsModal = document.getElementById('nodeDefaultsModal');
    const ndShape = document.getElementById('ndShape');
    const ndFillColor = document.getElementById('ndFillColor');
    const ndStrokeColor = document.getElementById('ndStrokeColor');
    const ndLabelColor = document.getElementById('ndLabelColor');

    if (miNodeDefaults) miNodeDefaults.addEventListener('click', showNodeDefaultsModal);
    if (btnCloseNodeDefaults) btnCloseNodeDefaults.addEventListener('click', hideNodeDefaultsModal);
    if (btnCancelNodeDefaults) btnCancelNodeDefaults.addEventListener('click', hideNodeDefaultsModal);
    if (btnSaveNodeDefaults) btnSaveNodeDefaults.addEventListener('click', saveNodeDefaults);
    if (nodeDefaultsModal) {
      nodeDefaultsModal.addEventListener('click', (e) => {
        if (e.target === nodeDefaultsModal) hideNodeDefaultsModal();
      });
    }

    // Update shape preview and hex values on change
    if (ndShape) ndShape.addEventListener('change', updateNodeShapePreview);
    if (ndFillColor) {
      ndFillColor.addEventListener('input', () => {
        document.getElementById('ndFillColorHex').textContent = ndFillColor.value;
        updateNodeShapePreview();
      });
    }
    if (ndStrokeColor) {
      ndStrokeColor.addEventListener('input', () => {
        document.getElementById('ndStrokeColorHex').textContent = ndStrokeColor.value;
        updateNodeShapePreview();
      });
    }
    if (ndLabelColor) {
      ndLabelColor.addEventListener('input', () => {
        document.getElementById('ndLabelColorHex').textContent = ndLabelColor.value;
      });
    }

    // Link Defaults
    const miLinkDefaults = document.getElementById('miLinkDefaults');
    const btnCloseLinkDefaults = document.getElementById('btnCloseLinkDefaults');
    const btnCancelLinkDefaults = document.getElementById('btnCancelLinkDefaults');
    const btnSaveLinkDefaults = document.getElementById('btnSaveLinkDefaults');
    const linkDefaultsModal = document.getElementById('linkDefaultsModal');
    const ldEnableGlow = document.getElementById('ldEnableGlow');
    const ldStrokeColor = document.getElementById('ldStrokeColor');
    const ldGlowColor = document.getElementById('ldGlowColor');
    const ldLabelColor = document.getElementById('ldLabelColor');

    if (miLinkDefaults) miLinkDefaults.addEventListener('click', showLinkDefaultsModal);
    if (btnCloseLinkDefaults) btnCloseLinkDefaults.addEventListener('click', hideLinkDefaultsModal);
    if (btnCancelLinkDefaults) btnCancelLinkDefaults.addEventListener('click', hideLinkDefaultsModal);
    if (btnSaveLinkDefaults) btnSaveLinkDefaults.addEventListener('click', saveLinkDefaults);
    if (linkDefaultsModal) {
      linkDefaultsModal.addEventListener('click', (e) => {
        if (e.target === linkDefaultsModal) hideLinkDefaultsModal();
      });
    }

    // Show/hide glow color row
    if (ldEnableGlow) {
      ldEnableGlow.addEventListener('change', () => {
        document.getElementById('ldGlowColorRow').style.display = ldEnableGlow.checked ? 'flex' : 'none';
      });
    }

    // Update hex values on change
    if (ldStrokeColor) {
      ldStrokeColor.addEventListener('input', () => {
        document.getElementById('ldStrokeColorHex').textContent = ldStrokeColor.value;
      });
    }
    if (ldGlowColor) {
      ldGlowColor.addEventListener('input', () => {
        document.getElementById('ldGlowColorHex').textContent = ldGlowColor.value;
      });
    }
    if (ldLabelColor) {
      ldLabelColor.addEventListener('input', () => {
        document.getElementById('ldLabelColorHex').textContent = ldLabelColor.value;
      });
    }

    // Escape key to close modals
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        hideDisplayPrefsModal();
        hideNodeDefaultsModal();
        hideLinkDefaultsModal();
      }
    });
  }

  // Initialize on load
  setTimeout(initSettingsModals, 300);

  window.showDisplayPrefsModal = showDisplayPrefsModal;
  window.showNodeDefaultsModal = showNodeDefaultsModal;
  window.showLinkDefaultsModal = showLinkDefaultsModal;

  // ============== END SETTINGS MODALS ==============

  // ============== END DATA TABLE ==============

  // ============== MLG COMMERCIAL COST ==============

  // Calculate commercial costs for an MLG by summing member link costs
  function calculateMLGCosts(mlg, tier = null) {
    const discountRate = state.financialSettings.npvDiscountRate || 12.5;
    // Use passed tier, or get from UI, or default to 10G
    let selectedTier = tier || '10G';
    if (!tier) {
      const checkedRadio = document.querySelector('input[name="mlgCapacityTier"]:checked');
      if (checkedRadio) selectedTier = checkedRadio.value;
    }

    // Collect all unique link IDs from all segments and paths
    const linkIds = new Set();
    if (mlg.segments) {
      mlg.segments.forEach(seg => {
        if (seg.paths) {
          seg.paths.forEach(path => {
            if (path.links) {
              path.links.forEach(linkId => linkIds.add(linkId));
            }
          });
        }
      });
    }

    // Sum costs from all unique links using the selected tier
    let totalNRC = 0, totalMRC = 0, totalIRUFee = 0;
    let oamSum = 0, oamCount = 0;

    linkIds.forEach(linkId => {
      const edge = findEdge(linkId);
      if (edge) {
        totalNRC += getValueForTier(edge.leaseNRC, selectedTier, 0);
        totalMRC += getValueForTier(edge.leaseMRC, selectedTier, 1);
        totalIRUFee += getValueForTier(edge.iruFee, selectedTier, 1);
        oamSum += edge.iruOamPercent ?? 3;
        oamCount++;
      }
    });

    // Use overrides if set, otherwise use calculated values
    const nrc = mlg.overrideLeaseNRC ?? totalNRC;
    const mrc = mlg.overrideLeaseMRC ?? totalMRC;
    const iruFee = mlg.overrideIRUFee ?? totalIRUFee;
    const iruOam = mlg.overrideIRUOAM ?? (oamCount > 0 ? oamSum / oamCount : 3);
    const iruTerm = mlg.iruTerm || 15;
    const iruIncrement = mlg.iruOamAnnualIncrement ?? 2;

    const acv = calculateLeaseACV(nrc, mrc);
    const iruNpv = calculateIRUNPV(iruFee, iruTerm, iruOam, iruIncrement, discountRate);

    return {
      calcNRC: totalNRC,
      calcMRC: totalMRC,
      calcIRUFee: totalIRUFee,
      calcIRUOAM: oamCount > 0 ? oamSum / oamCount : 5,
      nrc, mrc, iruFee, iruOam, iruTerm, iruIncrement,
      acv, iruNpv,
      linkCount: linkIds.size,
      tier: selectedTier
    };
  }

  // Recalculate costs for all MLGs
  function recalculateAllMLGCosts() {
    state.multilinkGroups.forEach(mlg => {
      const costs = calculateMLGCosts(mlg);
      mlg.calcLeaseNRC = costs.calcNRC;
      mlg.calcLeaseMRC = costs.calcMRC;
      mlg.calcIRUFee = costs.calcIRUFee;
      mlg.calcIRUOAM = costs.calcIRUOAM;
    });
  }

  // ============== CONTAINER COMMERCIAL COST CALCULATIONS ==============

  /**
   * Get links that have both endpoints inside a container
   * @param {Object} group - Container/group object
   * @returns {Array} Array of edge objects
   */
  function getLinksInsideContainer(group) {
    const nodeIdsInContainer = new Set(
      state.nodes.filter(n => n.groupId === group.id).map(n => n.id)
    );
    return state.edges.filter(e =>
      nodeIdsInContainer.has(e.a) && nodeIdsInContainer.has(e.b)
    );
  }

  /**
   * Get links that connect nodes in different child containers of a region
   * @param {Object} region - Region (container of containers) object
   * @returns {Array} Array of edge objects
   */
  function getInterChildLinks(region) {
    // Get all child containers of this region
    const childContainerIds = state.groups
      .filter(g => g.parentId === region.id && g.type === 'country')
      .map(g => g.id);

    if (childContainerIds.length < 2) return [];

    // Build map of node -> container
    const nodeToContainer = new Map();
    state.nodes.forEach(n => {
      if (childContainerIds.includes(n.groupId)) {
        nodeToContainer.set(n.id, n.groupId);
      }
    });

    // Find links where endpoints are in different child containers
    return state.edges.filter(e => {
      const containerA = nodeToContainer.get(e.a);
      const containerB = nodeToContainer.get(e.b);
      return containerA && containerB && containerA !== containerB;
    });
  }

  /**
   * Calculate average cost values from a set of links
   * @param {Array} links - Array of edge objects
   * @returns {Object} Average cost values by tier
   */
  function calculateAverageLinkCosts(links) {
    const tiers = ['1G', '10G', '100G', '400G'];
    const defaults = {
      leaseNRC: {},
      leaseMRC: {},
      iruFee: {},
      iruTerm: state.financialSettings?.containerDefaultIRUTerm || 15,
      iruOamPercent: state.financialSettings?.containerDefaultOAM || 3,
      iruOamAnnualIncrement: state.financialSettings?.containerDefaultOAMIncrement || 2
    };

    tiers.forEach(tier => {
      defaults.leaseNRC[tier] = state.financialSettings?.containerDefaultNRC || 0;
      defaults.leaseMRC[tier] = state.financialSettings?.containerDefaultMRC || 1;
      defaults.iruFee[tier] = state.financialSettings?.containerDefaultIRU || 1;
    });

    if (links.length === 0) return defaults;

    const sums = {
      leaseNRC: {},
      leaseMRC: {},
      iruFee: {},
      iruTerm: 0,
      iruOamPercent: 0,
      iruOamAnnualIncrement: 0
    };

    tiers.forEach(tier => {
      sums.leaseNRC[tier] = 0;
      sums.leaseMRC[tier] = 0;
      sums.iruFee[tier] = 0;
    });

    links.forEach(link => {
      tiers.forEach(tier => {
        sums.leaseNRC[tier] += getValueForTier(link.leaseNRC, tier, 0);
        sums.leaseMRC[tier] += getValueForTier(link.leaseMRC, tier, 1);
        sums.iruFee[tier] += getValueForTier(link.iruFee, tier, 1);
      });
      sums.iruTerm += link.iruTerm || 15;
      sums.iruOamPercent += link.iruOamPercent ?? 3;
      sums.iruOamAnnualIncrement += link.iruOamAnnualIncrement ?? 2;
    });

    const result = {
      leaseNRC: {},
      leaseMRC: {},
      iruFee: {},
      iruTerm: Math.round(sums.iruTerm / links.length),
      iruOamPercent: Math.round((sums.iruOamPercent / links.length) * 10) / 10,
      iruOamAnnualIncrement: Math.round((sums.iruOamAnnualIncrement / links.length) * 10) / 10
    };

    tiers.forEach(tier => {
      result.leaseNRC[tier] = Math.round((sums.leaseNRC[tier] / links.length) * 100) / 100;
      result.leaseMRC[tier] = Math.round((sums.leaseMRC[tier] / links.length) * 100) / 100;
      result.iruFee[tier] = Math.round((sums.iruFee[tier] / links.length) * 100) / 100;
    });

    return result;
  }

  /**
   * Calculate container commercial cost
   * For regular containers: average of internal links
   * For regions: 2 Ã— average(child containers) + average(inter-child links)
   * @param {Object} group - Container/group object
   * @returns {Object} Calculated cost values and source description
   */
  function calculateContainerCost(group) {
    const tiers = ['1G', '10G', '100G', '400G'];

    if (group.type === 'region') {
      // Region: 2 Ã— avg(child costs) + avg(inter-child links)
      const childContainers = state.groups.filter(g => g.parentId === group.id && g.type === 'country');
      const interChildLinks = getInterChildLinks(group);

      if (childContainers.length === 0) {
        // No children - use defaults
        return {
          costs: calculateAverageLinkCosts([]),
          sourceDesc: 'defaults (no child containers)',
          linkCount: 0,
          childCount: 0
        };
      }

      // Calculate average of child container costs
      const childCostSums = {
        leaseNRC: {},
        leaseMRC: {},
        iruFee: {},
        iruTerm: 0,
        iruOamPercent: 0,
        iruOamAnnualIncrement: 0
      };

      tiers.forEach(tier => {
        childCostSums.leaseNRC[tier] = 0;
        childCostSums.leaseMRC[tier] = 0;
        childCostSums.iruFee[tier] = 0;
      });

      childContainers.forEach(child => {
        // Get child's effective costs (calculated or override)
        const childCosts = child.commercialCostOverride ? {
          leaseNRC: child.leaseNRC,
          leaseMRC: child.leaseMRC,
          iruFee: child.iruFee
        } : calculateContainerCost(child).costs;

        tiers.forEach(tier => {
          childCostSums.leaseNRC[tier] += getValueForTier(childCosts.leaseNRC, tier, 0);
          childCostSums.leaseMRC[tier] += getValueForTier(childCosts.leaseMRC, tier, 1);
          childCostSums.iruFee[tier] += getValueForTier(childCosts.iruFee, tier, 1);
        });
        childCostSums.iruTerm += child.iruTerm || 15;
        childCostSums.iruOamPercent += child.iruOamPercent ?? 3;
        childCostSums.iruOamAnnualIncrement += child.iruOamAnnualIncrement ?? 2;
      });

      // Average child costs Ã— 2
      const avgChildCosts = {
        leaseNRC: {},
        leaseMRC: {},
        iruFee: {}
      };
      tiers.forEach(tier => {
        avgChildCosts.leaseNRC[tier] = 2 * (childCostSums.leaseNRC[tier] / childContainers.length);
        avgChildCosts.leaseMRC[tier] = 2 * (childCostSums.leaseMRC[tier] / childContainers.length);
        avgChildCosts.iruFee[tier] = 2 * (childCostSums.iruFee[tier] / childContainers.length);
      });

      // Add inter-child link costs
      const interChildCosts = calculateAverageLinkCosts(interChildLinks);

      const finalCosts = {
        leaseNRC: {},
        leaseMRC: {},
        iruFee: {},
        iruTerm: Math.round(childCostSums.iruTerm / childContainers.length),
        iruOamPercent: Math.round((childCostSums.iruOamPercent / childContainers.length) * 10) / 10,
        iruOamAnnualIncrement: Math.round((childCostSums.iruOamAnnualIncrement / childContainers.length) * 10) / 10
      };

      tiers.forEach(tier => {
        finalCosts.leaseNRC[tier] = Math.round((avgChildCosts.leaseNRC[tier] + getValueForTier(interChildCosts.leaseNRC, tier, 0)) * 100) / 100;
        finalCosts.leaseMRC[tier] = Math.round((avgChildCosts.leaseMRC[tier] + getValueForTier(interChildCosts.leaseMRC, tier, 1)) * 100) / 100;
        finalCosts.iruFee[tier] = Math.round((avgChildCosts.iruFee[tier] + getValueForTier(interChildCosts.iruFee, tier, 1)) * 100) / 100;
      });

      return {
        costs: finalCosts,
        sourceDesc: `2Ã—avg(${childContainers.length} children) + avg(${interChildLinks.length} inter-child links)`,
        linkCount: interChildLinks.length,
        childCount: childContainers.length
      };
    } else {
      // Regular container: average of internal links
      const internalLinks = getLinksInsideContainer(group);
      const costs = calculateAverageLinkCosts(internalLinks);

      return {
        costs,
        sourceDesc: internalLinks.length > 0 ? `avg(${internalLinks.length} internal links)` : 'defaults (no internal links)',
        linkCount: internalLinks.length,
        childCount: 0
      };
    }
  }

  /**
   * Recalculate commercial costs for all containers that don't have user overrides
   */
  function recalculateAllContainerCosts() {
    state.groups.forEach(group => {
      if (!group.commercialCostOverride) {
        const result = calculateContainerCost(group);
        group.leaseNRC = result.costs.leaseNRC;
        group.leaseMRC = result.costs.leaseMRC;
        group.iruFee = result.costs.iruFee;
        group.iruTerm = result.costs.iruTerm;
        group.iruOamPercent = result.costs.iruOamPercent;
        group.iruOamAnnualIncrement = result.costs.iruOamAnnualIncrement;
      }
    });
  }

  /**
   * Reset all link prices from a source tier, applying tier multipliers to other tiers
   * and IRU = MRC Ã— iruFromMRCMultiplier for all tiers.
   * Also recalculates container costs from their internal links.
   * @param {string} sourceTier - The tier to use as the source ('1G', '10G', '100G', '400G')
   */
  function resetAllPricesFromTier(sourceTier) {
    const tierMultipliers = state.financialSettings?.tierMultipliers || { '10G': 2.5, '100G': 6.25, '400G': 15.625 };
    const iruMultiplier = state.financialSettings?.iruFromMRCMultiplier || 36;
    const tiers = ['1G', '10G', '100G', '400G'];

    // Calculate the multiplier from source tier to 1G (inverse)
    // If source is 1G, multiplier to 1G is 1
    // If source is 10G, multiplier to 1G is 1/2.5 = 0.4
    // If source is 100G, multiplier to 1G is 1/6.25 = 0.16
    // If source is 400G, multiplier to 1G is 1/15.625 = 0.064
    let sourceMultiplier = 1;
    if (sourceTier !== '1G') {
      sourceMultiplier = tierMultipliers[sourceTier] || 1;
    }

    let linksUpdated = 0;
    let containersUpdated = 0;

    // Process all links
    state.edges.forEach(edge => {
      // Get the current values at the source tier
      const sourceMRC = getValueForTier(edge.leaseMRC, sourceTier, state.financialSettings?.defaultMRC || 1);
      const sourceNRC = getValueForTier(edge.leaseNRC, sourceTier, state.financialSettings?.defaultNRC || 0);

      // Calculate base (1G) values by dividing by source multiplier
      const baseMRC = sourceMRC / sourceMultiplier;
      const baseNRC = sourceNRC / sourceMultiplier;

      // Initialize tier-based objects if not already
      if (typeof edge.leaseMRC !== 'object') {
        edge.leaseMRC = normalizeTierPricing(edge.leaseMRC, state.financialSettings?.defaultMRC || 1);
      }
      if (typeof edge.leaseNRC !== 'object') {
        edge.leaseNRC = normalizeTierPricing(edge.leaseNRC, 0);
      }
      if (typeof edge.iruFee !== 'object') {
        edge.iruFee = normalizeTierPricing(edge.iruFee, state.financialSettings?.defaultIRU || 1);
      }

      // Calculate all tiers based on the base values
      tiers.forEach(tier => {
        let mult = 1;
        if (tier !== '1G') {
          mult = tierMultipliers[tier] || 1;
        }

        // Calculate MRC and NRC for this tier
        const tierMRC = baseMRC * mult;
        const tierNRC = baseNRC * mult;

        // Set MRC and NRC
        edge.leaseMRC[tier] = Math.round(tierMRC * 100) / 100; // Round to 2 decimal places
        edge.leaseNRC[tier] = Math.round(tierNRC * 100) / 100;

        // Calculate IRU as MRC Ã— iruMultiplier
        edge.iruFee[tier] = Math.round(tierMRC * iruMultiplier * 100) / 100;
      });

      linksUpdated++;
    });

    // Recalculate all container costs (which derive from their internal links)
    state.groups.forEach(group => {
      if (!group.commercialCostOverride) {
        const result = calculateContainerCost(group);
        group.leaseNRC = result.costs.leaseNRC;
        group.leaseMRC = result.costs.leaseMRC;
        group.iruFee = result.costs.iruFee;
        group.iruTerm = result.costs.iruTerm;
        group.iruOamPercent = result.costs.iruOamPercent;
        group.iruOamAnnualIncrement = result.costs.iruOamAnnualIncrement;
        containersUpdated++;
      }
    });

    // Recalculate all MLG costs
    recalculateAllMLGCosts();

    // Commit changes and refresh
    commit();
    renderDataTable();
    render();

    // Show confirmation
    const mult10G = tierMultipliers['10G'] || 2.5;
    const mult100G = tierMultipliers['100G'] || 6.25;
    const mult400G = tierMultipliers['400G'] || 15.625;
    showToast(`Prices reset from ${sourceTier}: ${linksUpdated} links updated, ${containersUpdated} containers recalculated. Multipliers: Ã—${mult10G} (10G), Ã—${mult100G} (100G), Ã—${mult400G} (400G). IRU = MRC Ã— ${iruMultiplier}`);
  }

  // Expose reset function globally
  window.resetAllPricesFromTier = resetAllPricesFromTier;

  /**
   * Get commercial cost for a container for pathfinding
   * @param {Object} group - Container/group object
   * @param {string} tier - Capacity tier ('1G', '10G', '100G', '400G')
   * @returns {number} Commercial cost value
   */
  function getContainerCostForPathfinding(group) {
    if (!group) return 0;

    const metric = routeFinderState.costMetric || state.pathfinderSettings?.costMetric || 'lease';
    const tier = routeFinderState.capacityTier || '10G';
    const discountRate = state.financialSettings?.npvDiscountRate || 12.5;

    if (metric === 'iru') {
      const iruFee = getValueForTier(group.iruFee, tier, 1);
      return calculateIRUNPV(
        iruFee,
        group.iruTerm || 15,
        group.iruOamPercent ?? 3,
        group.iruOamAnnualIncrement ?? 2,
        discountRate
      );
    } else {
      const nrc = getValueForTier(group.leaseNRC, tier, 0);
      const mrc = getValueForTier(group.leaseMRC, tier, 1);
      return calculateLeaseACV(nrc, mrc);
    }
  }

  /**
   * Update container cost display in inspector
   * @param {Object} group - Container/group object
   */
  function updateGroupCostDisplay(group) {
    if (!group) return;

    const currency = state.financialSettings.baseCurrency || 'USD';
    const discountRate = state.financialSettings.npvDiscountRate || 12.5;
    const tiers = ['1G', '10G', '100G', '400G'];

    // Update currency labels
    const groupLeaseCurrency = document.getElementById('groupLeaseCurrency');
    const groupIRUCurrency = document.getElementById('groupIRUCurrency');
    if (groupLeaseCurrency) groupLeaseCurrency.textContent = currency;
    if (groupIRUCurrency) groupIRUCurrency.textContent = currency;

    // Update discount rate
    const groupIRUDiscountRate = document.getElementById('groupIRUDiscountRate');
    if (groupIRUDiscountRate) groupIRUDiscountRate.textContent = discountRate.toFixed(1);

    // Update override status display
    const overrideStatus = document.getElementById('groupCostOverrideStatus');
    const calculatedStatus = document.getElementById('groupCostCalculatedStatus');
    const sourceDesc = document.getElementById('groupCostSourceDesc');

    if (group.commercialCostOverride) {
      if (overrideStatus) overrideStatus.style.display = 'block';
      if (calculatedStatus) calculatedStatus.style.display = 'none';
    } else {
      if (overrideStatus) overrideStatus.style.display = 'none';
      if (calculatedStatus) calculatedStatus.style.display = 'block';
      const calcResult = calculateContainerCost(group);
      if (sourceDesc) sourceDesc.textContent = calcResult.sourceDesc;
    }

    // Update cost mode radios
    const costMode = group.commercialCostMode || 'lease';
    const groupCostModeLease = document.getElementById('groupCostModeLease');
    const groupCostModeIRU = document.getElementById('groupCostModeIRU');
    if (groupCostModeLease) groupCostModeLease.checked = (costMode === 'lease');
    if (groupCostModeIRU) groupCostModeIRU.checked = (costMode === 'iru');

    // Update tier pricing fields
    tiers.forEach(tier => {
      const nrcEl = document.getElementById(`groupLeaseNRC_${tier}`);
      const mrcEl = document.getElementById(`groupLeaseMRC_${tier}`);
      const iruFeeEl = document.getElementById(`groupIRUFee_${tier}`);
      const acvEl = document.getElementById(`groupLeaseACV_${tier}`);
      const npvEl = document.getElementById(`groupIRUNPV_${tier}`);

      const nrc = getValueForTier(group.leaseNRC, tier, 0);
      const mrc = getValueForTier(group.leaseMRC, tier, 1);
      const iruFee = getValueForTier(group.iruFee, tier, 1);

      if (nrcEl) nrcEl.value = nrc;
      if (mrcEl) mrcEl.value = mrc;
      if (iruFeeEl) iruFeeEl.value = iruFee;

      // Calculate and display ACV and NPV
      const acv = calculateLeaseACV(nrc, mrc);
      const npv = calculateIRUNPV(
        iruFee,
        group.iruTerm || 15,
        group.iruOamPercent ?? 3,
        group.iruOamAnnualIncrement ?? 2,
        discountRate
      );

      if (acvEl) acvEl.textContent = formatCurrency(acv, currency);
      if (npvEl) npvEl.textContent = formatCurrency(npv, currency);
    });

    // Update IRU common terms
    const groupIRUTerm = document.getElementById('groupIRUTerm');
    const groupIRUOAM = document.getElementById('groupIRUOAM');
    const groupIRUOAMIncrement = document.getElementById('groupIRUOAMIncrement');

    if (groupIRUTerm) groupIRUTerm.value = group.iruTerm || 15;
    if (groupIRUOAM) groupIRUOAM.value = group.iruOamPercent ?? 3;
    if (groupIRUOAMIncrement) groupIRUOAMIncrement.value = group.iruOamAnnualIncrement ?? 2;
  }

  // Expose functions globally
  window.calculateContainerCost = calculateContainerCost;
  window.recalculateAllContainerCosts = recalculateAllContainerCosts;
  window.getContainerCostForPathfinding = getContainerCostForPathfinding;
  window.updateGroupCostDisplay = updateGroupCostDisplay;

  // ============== END CONTAINER COMMERCIAL COST ==============

  // Update MLG cost display in editor
  function updateMLGCostDisplay(mlg) {
    if (!mlg) return;

    const costs = calculateMLGCosts(mlg);
    const currency = state.financialSettings.baseCurrency || 'USD';
    const discountRate = state.financialSettings.npvDiscountRate || 12.5;
    const tier = costs.tier || '10G';

    // Update currency label with tier info
    const mlgCostCurrency = document.getElementById('mlgCostCurrency');
    if (mlgCostCurrency) mlgCostCurrency.textContent = `${currency} @${tier}`;

    // Update discount rate display
    const mlgIRUDiscountRate = document.getElementById('mlgIRUDiscountRate');
    if (mlgIRUDiscountRate) mlgIRUDiscountRate.textContent = discountRate.toFixed(1);

    // Update calculated sums display with tier
    const mlgLeaseNRCCalc = document.getElementById('mlgLeaseNRCCalc');
    const mlgLeaseMRCCalc = document.getElementById('mlgLeaseMRCCalc');
    const mlgIRUFeeCalc = document.getElementById('mlgIRUFeeCalc');
    const mlgIRUOAMCalc = document.getElementById('mlgIRUOAMCalc');

    if (mlgLeaseNRCCalc) mlgLeaseNRCCalc.textContent = `ÃŽÂ£ ${formatCurrency(costs.calcNRC, currency)} @${tier}`;
    if (mlgLeaseMRCCalc) mlgLeaseMRCCalc.textContent = `ÃŽÂ£ ${formatCurrency(costs.calcMRC, currency)} @${tier}`;
    if (mlgIRUFeeCalc) mlgIRUFeeCalc.textContent = `ÃŽÂ£ ${formatCurrency(costs.calcIRUFee, currency)} @${tier}`;
    if (mlgIRUOAMCalc) mlgIRUOAMCalc.textContent = `Avg ${costs.calcIRUOAM.toFixed(1)}%`;

    // Update input fields (use override if set, else calculated)
    const mlgLeaseNRC = document.getElementById('mlgLeaseNRC');
    const mlgLeaseMRC = document.getElementById('mlgLeaseMRC');
    const mlgIRUFee = document.getElementById('mlgIRUFee');
    const mlgIRUOAM = document.getElementById('mlgIRUOAM');
    const mlgIRUTerm = document.getElementById('mlgIRUTerm');
    const mlgIRUOAMIncrement = document.getElementById('mlgIRUOAMIncrement');

    if (mlgLeaseNRC) mlgLeaseNRC.value = costs.nrc;
    if (mlgLeaseMRC) mlgLeaseMRC.value = costs.mrc;
    if (mlgIRUFee) mlgIRUFee.value = costs.iruFee;
    if (mlgIRUOAM) mlgIRUOAM.value = costs.iruOam;
    if (mlgIRUTerm) mlgIRUTerm.value = costs.iruTerm;
    if (mlgIRUOAMIncrement) mlgIRUOAMIncrement.value = costs.iruIncrement;

    // Update override checkboxes
    const mlgLeaseNRCOverride = document.getElementById('mlgLeaseNRCOverride');
    const mlgLeaseMRCOverride = document.getElementById('mlgLeaseMRCOverride');
    const mlgIRUFeeOverride = document.getElementById('mlgIRUFeeOverride');
    const mlgIRUOAMOverride = document.getElementById('mlgIRUOAMOverride');

    if (mlgLeaseNRCOverride) mlgLeaseNRCOverride.checked = mlg.overrideLeaseNRC !== null;
    if (mlgLeaseMRCOverride) mlgLeaseMRCOverride.checked = mlg.overrideLeaseMRC !== null;
    if (mlgIRUFeeOverride) mlgIRUFeeOverride.checked = mlg.overrideIRUFee !== null;
    if (mlgIRUOAMOverride) mlgIRUOAMOverride.checked = mlg.overrideIRUOAM !== null;

    // Update cost mode radio
    const mlgCostModeLease = document.getElementById('mlgCostModeLease');
    const mlgCostModeIRU = document.getElementById('mlgCostModeIRU');
    const costMode = mlg.commercialCostMode || 'lease';
    if (mlgCostModeLease) mlgCostModeLease.checked = (costMode === 'lease');
    if (mlgCostModeIRU) mlgCostModeIRU.checked = (costMode === 'iru');

    // Update totals
    const mlgLeaseACV = document.getElementById('mlgLeaseACV');
    const mlgIRUNPV = document.getElementById('mlgIRUNPV');
    if (mlgLeaseACV) mlgLeaseACV.textContent = formatCurrency(costs.acv, currency);
    if (mlgIRUNPV) mlgIRUNPV.textContent = formatCurrency(costs.iruNpv, currency);

    // Show the cost section
    const mlgCostSection = document.getElementById('mlgCostSection');
    if (mlgCostSection && costs.linkCount > 0) {
      mlgCostSection.style.display = 'block';
    }
  }

  function setupMLGCostHandlers() {
    // Settings link
    const mlgCostSettingsLink = document.getElementById('mlgCostSettingsLink');
    if (mlgCostSettingsLink) {
      mlgCostSettingsLink.addEventListener('click', (e) => {
        e.preventDefault();
        showFinancialSettingsModal();
      });
    }

    // Capacity tier selector for MLG
    const mlgTierRadios = ['1G', '10G', '100G', '400G'].map(t => document.getElementById(`mlgCapTier${t}`));

    function updateMLGCapacityTierLabels(selectedTier) {
      ['1G', '10G', '100G', '400G'].forEach(tier => {
        const label = document.getElementById(`mlgCapTier${tier}Label`);
        if (label) {
          if (tier === selectedTier) {
            label.style.borderColor = '#059669';
            label.style.background = '#ecfdf5';
            label.style.color = '#047857';
          } else {
            label.style.borderColor = '#e5e7eb';
            label.style.background = 'white';
            label.style.color = '#374151';
          }
        }
      });
    }

    mlgTierRadios.forEach(radio => {
      if (radio) {
        radio.addEventListener('change', () => {
          const mlg = getCurrentMLG();
          if (mlg) {
            updateMLGCostDisplayForTemp(mlg);
          }
          updateMLGCapacityTierLabels(radio.value);
        });
      }
    });

    // Cost mode radios
    const mlgCostModeLease = document.getElementById('mlgCostModeLease');
    const mlgCostModeIRU = document.getElementById('mlgCostModeIRU');

    [mlgCostModeLease, mlgCostModeIRU].forEach(radio => {
      if (radio) {
        radio.addEventListener('change', () => {
          const mlg = getCurrentMLG();
          if (mlg) {
            mlg.commercialCostMode = radio.value;
            updateMLGCostDisplayForTemp(mlg);
          }
        });
      }
    });

    // Override checkboxes and input fields
    const overrideFields = [
      { check: 'mlgLeaseNRCOverride', input: 'mlgLeaseNRC', field: 'overrideLeaseNRC', calcField: 'calcLeaseNRC' },
      { check: 'mlgLeaseMRCOverride', input: 'mlgLeaseMRC', field: 'overrideLeaseMRC', calcField: 'calcLeaseMRC' },
      { check: 'mlgIRUFeeOverride', input: 'mlgIRUFee', field: 'overrideIRUFee', calcField: 'calcIRUFee' },
      { check: 'mlgIRUOAMOverride', input: 'mlgIRUOAM', field: 'overrideIRUOAM', calcField: 'calcIRUOAM' }
    ];

    overrideFields.forEach(({ check, input, field, calcField }) => {
      const checkbox = document.getElementById(check);
      const inputEl = document.getElementById(input);

      if (checkbox) {
        checkbox.addEventListener('change', () => {
          const mlg = getCurrentMLG();
          if (mlg) {
            if (checkbox.checked) {
              // Enable override with current value
              mlg[field] = parseFloat(inputEl?.value) || mlg[calcField] || 0;
            } else {
              // Disable override
              mlg[field] = null;
            }
            updateMLGCostDisplayForTemp(mlg);
          }
        });
      }

      if (inputEl) {
        inputEl.addEventListener('change', () => {
          const mlg = getCurrentMLG();
          const checkbox = document.getElementById(check);
          if (mlg && checkbox?.checked) {
            mlg[field] = parseFloat(inputEl.value) || 0;
            updateMLGCostDisplayForTemp(mlg);
          }
        });

        inputEl.addEventListener('input', () => {
          const mlg = getCurrentMLG();
          if (mlg) {
            // Auto-enable override when user types
            const checkbox = document.getElementById(check);
            if (checkbox && !checkbox.checked) {
              checkbox.checked = true;
              mlg[field] = parseFloat(inputEl.value) || 0;
            }
            updateMLGCostDisplayForTemp(mlg);
          }
        });
      }
    });

    // IRU Term and Increment (not overrideable from links)
    const mlgIRUTerm = document.getElementById('mlgIRUTerm');
    const mlgIRUOAMIncrement = document.getElementById('mlgIRUOAMIncrement');

    [mlgIRUTerm, mlgIRUOAMIncrement].forEach(input => {
      if (input) {
        input.addEventListener('change', () => {
          const mlg = getCurrentMLG();
          if (mlg) {
            if (input.id === 'mlgIRUTerm') mlg.iruTerm = parseInt(input.value) || 15;
            if (input.id === 'mlgIRUOAMIncrement') mlg.iruOamAnnualIncrement = parseFloat(input.value) || 0;
            updateMLGCostDisplayForTemp(mlg);
          }
        });
      }
    });
  }

  // Helper to get current MLG being edited (temp or selected)
  function getCurrentMLG() {
    // First check if we're in edit mode with a temp group
    if (typeof mlgManagerState !== 'undefined' && mlgManagerState.tempGroup) {
      return mlgManagerState.tempGroup;
    }
    // Fallback to selected MLG
    if (state.selectedMultilinkGroup) {
      return state.multilinkGroups.find(mlg => mlg.id === state.selectedMultilinkGroup);
    }
    return null;
  }

  // Update MLG cost display for temp editing group
  function updateMLGCostDisplayForTemp(temp) {
    if (!temp) return;

    const costs = calculateMLGCosts(temp);
    const currency = state.financialSettings.baseCurrency || 'USD';
    const discountRate = state.financialSettings.npvDiscountRate || 12.5;
    const tier = costs.tier || '10G';

    // Update currency label with tier info
    const mlgCostCurrency = document.getElementById('mlgCostCurrency');
    if (mlgCostCurrency) mlgCostCurrency.textContent = `${currency} @${tier}`;

    // Update discount rate display
    const mlgIRUDiscountRate = document.getElementById('mlgIRUDiscountRate');
    if (mlgIRUDiscountRate) mlgIRUDiscountRate.textContent = discountRate.toFixed(1);

    // Update calculated sums display with tier
    const mlgLeaseNRCCalc = document.getElementById('mlgLeaseNRCCalc');
    const mlgLeaseMRCCalc = document.getElementById('mlgLeaseMRCCalc');
    const mlgIRUFeeCalc = document.getElementById('mlgIRUFeeCalc');
    const mlgIRUOAMCalc = document.getElementById('mlgIRUOAMCalc');

    if (mlgLeaseNRCCalc) mlgLeaseNRCCalc.textContent = `ÃŽÂ£ ${formatCurrency(costs.calcNRC, currency)} @${tier}`;
    if (mlgLeaseMRCCalc) mlgLeaseMRCCalc.textContent = `ÃŽÂ£ ${formatCurrency(costs.calcMRC, currency)} @${tier}`;
    if (mlgIRUFeeCalc) mlgIRUFeeCalc.textContent = `ÃŽÂ£ ${formatCurrency(costs.calcIRUFee, currency)} @${tier}`;
    if (mlgIRUOAMCalc) mlgIRUOAMCalc.textContent = `Avg ${costs.calcIRUOAM.toFixed(1)}%`;

    // Update input fields (use override if set, else calculated)
    const mlgLeaseNRC = document.getElementById('mlgLeaseNRC');
    const mlgLeaseMRC = document.getElementById('mlgLeaseMRC');
    const mlgIRUFee = document.getElementById('mlgIRUFee');
    const mlgIRUOAM = document.getElementById('mlgIRUOAM');
    const mlgIRUTerm = document.getElementById('mlgIRUTerm');
    const mlgIRUOAMIncrement = document.getElementById('mlgIRUOAMIncrement');

    if (mlgLeaseNRC) mlgLeaseNRC.value = costs.nrc;
    if (mlgLeaseMRC) mlgLeaseMRC.value = costs.mrc;
    if (mlgIRUFee) mlgIRUFee.value = costs.iruFee;
    if (mlgIRUOAM) mlgIRUOAM.value = costs.iruOam;
    if (mlgIRUTerm) mlgIRUTerm.value = costs.iruTerm;
    if (mlgIRUOAMIncrement) mlgIRUOAMIncrement.value = costs.iruIncrement;

    // Update override checkboxes
    const mlgLeaseNRCOverride = document.getElementById('mlgLeaseNRCOverride');
    const mlgLeaseMRCOverride = document.getElementById('mlgLeaseMRCOverride');
    const mlgIRUFeeOverride = document.getElementById('mlgIRUFeeOverride');
    const mlgIRUOAMOverride = document.getElementById('mlgIRUOAMOverride');

    if (mlgLeaseNRCOverride) mlgLeaseNRCOverride.checked = temp.overrideLeaseNRC !== null && temp.overrideLeaseNRC !== undefined;
    if (mlgLeaseMRCOverride) mlgLeaseMRCOverride.checked = temp.overrideLeaseMRC !== null && temp.overrideLeaseMRC !== undefined;
    if (mlgIRUFeeOverride) mlgIRUFeeOverride.checked = temp.overrideIRUFee !== null && temp.overrideIRUFee !== undefined;
    if (mlgIRUOAMOverride) mlgIRUOAMOverride.checked = temp.overrideIRUOAM !== null && temp.overrideIRUOAM !== undefined;

    // Update cost mode radio
    const mlgCostModeLease = document.getElementById('mlgCostModeLease');
    const mlgCostModeIRU = document.getElementById('mlgCostModeIRU');
    const costMode = temp.commercialCostMode || 'lease';
    if (mlgCostModeLease) mlgCostModeLease.checked = (costMode === 'lease');
    if (mlgCostModeIRU) mlgCostModeIRU.checked = (costMode === 'iru');

    // Update totals
    const mlgLeaseACV = document.getElementById('mlgLeaseACV');
    const mlgIRUNPV = document.getElementById('mlgIRUNPV');
    if (mlgLeaseACV) mlgLeaseACV.textContent = formatCurrency(costs.acv, currency);
    if (mlgIRUNPV) mlgIRUNPV.textContent = formatCurrency(costs.iruNpv, currency);

    // Show the cost section if we have links
    const mlgCostSection = document.getElementById('mlgCostSection');
    if (mlgCostSection) {
      mlgCostSection.style.display = costs.linkCount > 0 ? 'block' : 'none';
    }
  }

  window.calculateMLGCosts = calculateMLGCosts;
  window.recalculateAllMLGCosts = recalculateAllMLGCosts;
  window.updateMLGCostDisplay = updateMLGCostDisplay;
  window.updateMLGCostDisplayForTemp = updateMLGCostDisplayForTemp;

  // ============== END MLG COMMERCIAL COST ==============

  // =============================================
  // KML STUDIO INTEGRATION MODULE
  // =============================================
  (function kmlStudioIntegration() {
    let kmlStudioWindow = null;
    const KML_STUDIO_URL = 'kml-studio.html';
    const MSG_ORIGIN = window.location.protocol === 'file:' ? '*' : window.location.origin;

    // --- Utility: Extract geographic data from entities ---
    function getNodeGeoData(node) {
      if (node.gpsLat != null && node.gpsLon != null &&
          !isNaN(node.gpsLat) && !isNaN(node.gpsLon)) {
        return { entityType: 'node', id: node.id, name: node.name || node.code || ('N-' + node.id),
                 code: node.code, lat: node.gpsLat, lng: node.gpsLon };
      }
      return null;
    }

    function getEdgeGeoData(edge) {
      if (edge.cableGeometry && edge.cableGeometry.coordinates &&
          edge.cableGeometry.coordinates.length > 0) {
        return { entityType: 'link', id: edge.id, name: edge.name || edge.code || ('L-' + edge.id),
                 code: edge.code, geometry: edge.cableGeometry };
      }
      return null;
    }

    function getGroupGeoData(group) {
      if (group.dcLatitude != null && group.dcLongitude != null &&
          !isNaN(parseFloat(group.dcLatitude)) && !isNaN(parseFloat(group.dcLongitude))) {
        return { entityType: 'container', id: group.id, name: group.title || ('G-' + group.id),
                 lat: parseFloat(group.dcLatitude), lng: parseFloat(group.dcLongitude) };
      }
      return null;
    }

    function getMLGGeoData(mlg) {
      const links = [];
      if (mlg.segments) {
        mlg.segments.forEach(seg => {
          seg.paths.forEach(path => {
            path.links.forEach(linkId => {
              const edge = state.edges.find(e => e.id === linkId);
              if (edge) {
                const geo = getEdgeGeoData(edge);
                if (geo) links.push(geo);
              }
            });
          });
        });
      }
      if (links.length === 0) return null;
      return { entityType: 'mlg', id: mlg.id, name: mlg.name || ('MLG-' + mlg.id), links };
    }

    // --- Collect selected entities with geo data + track warnings ---
    function getSelectedGeoEntities(collectWarnings) {
      const entities = [];
      const warnings = collectWarnings ? [] : null;

      function checkAndAdd(type, obj) {
        if (type === 'node') {
          const g = getNodeGeoData(obj);
          if (g) { entities.push(g); return; }
          if (warnings) warnings.push({ type: 'node', name: obj.name || obj.code || ('N-' + obj.id), reason: 'No GPS coordinates â€” cannot move to KML editor' });
        } else if (type === 'edge') {
          const g = getEdgeGeoData(obj);
          if (g) { entities.push(g); return; }
          if (warnings) warnings.push({ type: 'link', name: obj.name || obj.code || ('L-' + obj.id), reason: 'No geo geometry exists â€” cannot move to KML editor' });
        } else if (type === 'group') {
          const g = getGroupGeoData(obj);
          if (g) { entities.push(g); return; }
          if (warnings) warnings.push({ type: 'container', name: obj.title || ('G-' + obj.id), reason: 'No geo geometry exists â€” cannot move to KML editor' });
        }
      }

      // Single selection
      if (state.selected) {
        if (state.selected.type === 'node') {
          const n = state.nodes.find(x => x.id === state.selected.id);
          if (n) checkAndAdd('node', n);
        } else if (state.selected.type === 'edge') {
          const e = state.edges.find(x => x.id === state.selected.id);
          if (e) checkAndAdd('edge', e);
        } else if (state.selected.type === 'group') {
          const gr = state.groups.find(x => x.id === state.selected.id);
          if (gr) checkAndAdd('group', gr);
        }
      }
      // Multi-selection
      const addedIds = new Set(entities.map(e => e.entityType + '-' + e.id));
      if (state.selection) {
        state.selection.nodes.forEach(id => {
          if (addedIds.has('node-' + id)) return;
          const n = state.nodes.find(x => x.id === id);
          if (n) { checkAndAdd('node', n); addedIds.add('node-' + id); }
        });
        state.selection.edges.forEach(id => {
          if (addedIds.has('link-' + id)) return;
          const e = state.edges.find(x => x.id === id);
          if (e) { checkAndAdd('edge', e); addedIds.add('link-' + id); }
        });
        state.selection.groups.forEach(id => {
          if (addedIds.has('container-' + id)) return;
          const gr = state.groups.find(x => x.id === id);
          if (gr) { checkAndAdd('group', gr); addedIds.add('container-' + id); }
        });
      }
      if (collectWarnings) return { entities, warnings };
      return entities;
    }

    // --- Show geo-data warnings for entities that cannot be sent to KML Studio ---
    function showKMLGeoWarnings(warnings) {
      if (!warnings || warnings.length === 0) return;
      const lines = warnings.map(w => {
        const icon = w.type === 'node' ? 'Node' : w.type === 'link' ? 'Link' : 'Container';
        return icon + ' "' + w.name + '": ' + w.reason;
      });
      showToast(lines.join('\n'));
    }

    // --- Open KML Studio popup ---
    function openKMLStudio(entities) {
      if (kmlStudioWindow && !kmlStudioWindow.closed) {
        kmlStudioWindow.focus();
        if (entities && entities.length > 0) {
          kmlStudioWindow.postMessage({ type: 'neximap-import', entities }, MSG_ORIGIN);
          showToast('Sent ' + entities.length + ' entity(s) to KML Studio');
        }
        return;
      }
      const w = Math.min(1200, screen.availWidth * 0.7);
      const h = Math.min(800, screen.availHeight * 0.8);
      const left = screen.availLeft + (screen.availWidth - w) / 2;
      const top = screen.availTop + (screen.availHeight - h) / 2;
      kmlStudioWindow = window.open(KML_STUDIO_URL, 'NeximapKMLStudio',
        `width=${w},height=${h},left=${left},top=${top},menubar=no,toolbar=no,status=no,resizable=yes`);
      if (!kmlStudioWindow) {
        showToast('Popup blocked â€” please allow popups for this site');
        return;
      }
      // Send entities after the window loads
      if (entities && entities.length > 0) {
        const checkReady = setInterval(() => {
          try {
            if (kmlStudioWindow.closed) { clearInterval(checkReady); return; }
            kmlStudioWindow.postMessage({ type: 'neximap-ping' }, MSG_ORIGIN);
          } catch (e) { /* cross-origin before load */ }
        }, 300);
        kmlStudioWindow._pendingEntities = entities;
        kmlStudioWindow._readyCheckInterval = checkReady;
      }
    }

    // --- Receive messages from KML Studio ---
    window.addEventListener('message', (event) => {
      if (!event.data || typeof event.data !== 'object') return;
      if (MSG_ORIGIN !== '*' && event.origin !== window.location.origin) return;

      if (event.data.type === 'kml-studio-ready' || event.data.type === 'kml-studio-pong') {
        if (kmlStudioWindow && kmlStudioWindow._pendingEntities) {
          kmlStudioWindow.postMessage({
            type: 'neximap-import',
            entities: kmlStudioWindow._pendingEntities
          }, MSG_ORIGIN);
          showToast('Sent ' + kmlStudioWindow._pendingEntities.length + ' entity(s) to KML Studio');
          delete kmlStudioWindow._pendingEntities;
          if (kmlStudioWindow._readyCheckInterval) {
            clearInterval(kmlStudioWindow._readyCheckInterval);
            delete kmlStudioWindow._readyCheckInterval;
          }
        }
      }

      if (event.data.type === 'kml-export-to-neximap') {
        showKMLImportConfirmDialog(event.data.entities);
      }

      // KML Studio requests the list of available Neximap objects for its right panel
      if (event.data.type === 'kml-request-neximap-objects') {
        const objects = {
          nodes: state.nodes.map(n => ({
            id: n.id, name: n.name || n.code || ('N-' + n.id),
            code: n.code, hasGeo: (n.gpsLat != null && n.gpsLon != null && !isNaN(n.gpsLat) && !isNaN(n.gpsLon)),
            lat: n.gpsLat, lon: n.gpsLon
          })),
          links: state.edges.map(e => ({
            id: e.id, name: e.name || e.code || ('L-' + e.id),
            code: e.code,
            hasGeo: !!(e.cableGeometry && e.cableGeometry.coordinates && e.cableGeometry.coordinates.length > 0),
            aNodeName: (function() { const an = state.nodes.find(x => x.id === e.a); return an ? (an.name || an.code || 'N-'+an.id) : '?'; })(),
            bNodeName: (function() { const bn = state.nodes.find(x => x.id === e.b); return bn ? (bn.name || bn.code || 'N-'+bn.id) : '?'; })()
          })),
          containers: state.groups.map(g => ({
            id: g.id, name: g.title || ('G-' + g.id),
            type: g.type,
            hasGeo: (g.dcLatitude != null && g.dcLongitude != null && !isNaN(parseFloat(g.dcLatitude)) && !isNaN(parseFloat(g.dcLongitude))),
            lat: g.dcLatitude, lon: g.dcLongitude
          }))
        };
        if (event.source) {
          event.source.postMessage({ type: 'neximap-objects-response', objects }, MSG_ORIGIN);
        }
      }

      // KML Studio sends assignments (drag from KML to Neximap panel)
      if (event.data.type === 'kml-assign-to-neximap') {
        applyKMLAssignments(event.data.assignments);
      }

      // KML Studio requests geo data for specific Neximap entities (drag from right panel to KML map)
      if (event.data.type === 'kml-request-entity-geo') {
        const requests = event.data.items || [];
        const entities = [];
        requests.forEach(req => {
          if (req.type === 'node') {
            const n = state.nodes.find(x => x.id === req.id);
            if (n) { const g = getNodeGeoData(n); if (g) entities.push(g); }
          } else if (req.type === 'link') {
            const e = state.edges.find(x => x.id === req.id);
            if (e) { const g = getEdgeGeoData(e); if (g) entities.push(g); }
          } else if (req.type === 'container') {
            const gr = state.groups.find(x => x.id === req.id);
            if (gr) { const g = getGroupGeoData(gr); if (g) entities.push(g); }
          }
        });
        if (event.source && entities.length > 0) {
          event.source.postMessage({ type: 'neximap-import', entities }, MSG_ORIGIN);
        }
      }
    });

    // --- Apply assignments from KML Studio drag-and-drop ---
    function applyKMLAssignments(assignments) {
      if (!assignments || assignments.length === 0) return;
      let applied = 0;
      assignments.forEach(a => {
        if (a.targetType === 'node' && a.entityType === 'pin') {
          const node = state.nodes.find(n => n.id === a.targetId);
          if (node) { node.gpsLat = a.lat; node.gpsLon = a.lng; applied++; }
        } else if (a.targetType === 'container' && a.entityType === 'pin') {
          const group = state.groups.find(g => g.id === a.targetId);
          if (group) { group.dcLatitude = a.lat; group.dcLongitude = a.lng; applied++; }
        } else if (a.targetType === 'link' && (a.entityType === 'folder' || a.entityType === 'line')) {
          const edge = state.edges.find(e => e.id === a.targetId);
          if (!edge) return;
          if (a.geometry) {
            edge.cableGeometry = a.geometry;
            edge.pathSource = 'kml-import';
            applied++;
          } else if (a.layers) {
            // Folder with line layers -> merge into geometry
            const lines = a.layers.filter(l => l.type === 'line' && l.coords && l.coords.length > 0);
            if (lines.length === 1) {
              edge.cableGeometry = { type: 'LineString', coordinates: lines[0].coords.map(c => [c[1], c[0]]) };
            } else if (lines.length > 1) {
              edge.cableGeometry = { type: 'MultiLineString', coordinates: lines.map(line => line.coords.map(c => [c[1], c[0]])) };
            }
            if (lines.length > 0) { edge.pathSource = 'kml-import'; applied++; }
          }
        }
      });
      if (applied > 0) {
        showToast('Applied ' + applied + ' assignment(s) from KML Studio');
        render();
        updateInspector();
      }
    }

    // --- KML Import Confirmation Dialog ---
    function showKMLImportConfirmDialog(entities) {
      if (!entities || entities.length === 0) {
        showToast('No entities received from KML Studio');
        return;
      }

      const overlay = document.createElement('div');
      overlay.id = 'kmlStudioConfirmDialog';

      const folders = entities.filter(e => e.entityType === 'folder');
      const pins = entities.filter(e => e.entityType === 'pin');

      const linkOptions = state.edges.map(e =>
        `<option value="${e.id}">${e.name || e.code || 'L-' + e.id}</option>`
      ).join('');
      const nodeOptions = state.nodes.map(n =>
        `<option value="${n.id}">${n.name || n.code || 'N-' + n.id}</option>`
      ).join('');
      const groupOptions = state.groups.map(g =>
        `<option value="${g.id}">${g.title || 'G-' + g.id}</option>`
      ).join('');

      let bodyHTML = '';

      if (folders.length > 0) {
        bodyHTML += `<div style="margin-bottom:12px;">
          <div style="font-weight:600; margin-bottom:6px;">Folders (assign geometry to links):</div>
          <table><tr><th>Folder</th><th>Lines</th><th>Assign to Link</th></tr>`;
        folders.forEach((f, i) => {
          const lineCount = f.layers ? f.layers.filter(l => l.type === 'line').length : 0;
          bodyHTML += `<tr>
            <td>${f.name}</td>
            <td>${lineCount} line(s)</td>
            <td><select class="kml-folder-target" data-idx="${i}">
              <option value="">â€” Select link â€”</option>${linkOptions}
            </select></td>
          </tr>`;
        });
        bodyHTML += '</table></div>';
      }

      if (pins.length > 0) {
        bodyHTML += `<div style="margin-bottom:12px;">
          <div style="font-weight:600; margin-bottom:6px;">Pins (assign position to nodes/containers):</div>
          <table><tr><th>Pin</th><th>Coordinates</th><th>Assign to</th><th>Target</th></tr>`;
        pins.forEach((p, i) => {
          bodyHTML += `<tr>
            <td>${p.name}</td>
            <td style="font-family:monospace; font-size:11px;">${p.lat.toFixed(4)}, ${p.lng.toFixed(4)}</td>
            <td><select class="kml-pin-type" data-idx="${i}">
              <option value="node">Node</option>
              <option value="container">Container</option>
            </select></td>
            <td><select class="kml-pin-target" data-idx="${i}">
              <option value="">â€” Select â€”</option>${nodeOptions}
            </select></td>
          </tr>`;
        });
        bodyHTML += '</table></div>';
      }

      overlay.innerHTML = `<div class="kml-confirm-box">
        <div class="kml-confirm-header">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#0096D6" stroke-width="2"><path d="M8 12L16 8L24 12L16 16Z" transform="scale(0.75) translate(4,4)" fill="#0096D6" opacity="0.2"/></svg>
          Import from KML Studio
        </div>
        <div class="kml-confirm-body">
          <div style="margin-bottom:8px; color:#6b7280;">The following items were sent from KML Studio. Select which Neximap entities to assign them to:</div>
          ${bodyHTML}
          ${(folders.length === 0 && pins.length === 0) ? '<div style="color:#9ca3af;">No compatible items to import.</div>' : ''}
        </div>
        <div class="kml-confirm-footer">
          <button class="kml-cancel-btn">Cancel</button>
          <button class="kml-apply-btn primary">Apply</button>
        </div>
      </div>`;

      document.body.appendChild(overlay);

      // Toggle node/container options when pin type changes
      overlay.querySelectorAll('.kml-pin-type').forEach(sel => {
        sel.addEventListener('change', () => {
          const idx = sel.dataset.idx;
          const targetSel = overlay.querySelector(`.kml-pin-target[data-idx="${idx}"]`);
          if (sel.value === 'container') {
            targetSel.innerHTML = '<option value="">â€” Select â€”</option>' + groupOptions;
          } else {
            targetSel.innerHTML = '<option value="">â€” Select â€”</option>' + nodeOptions;
          }
        });
      });

      // Cancel
      overlay.querySelector('.kml-cancel-btn').addEventListener('click', () => overlay.remove());
      overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.remove(); });

      // Apply
      overlay.querySelector('.kml-apply-btn').addEventListener('click', () => {
        let applied = 0;

        // Apply folders to links
        overlay.querySelectorAll('.kml-folder-target').forEach(sel => {
          const idx = parseInt(sel.dataset.idx);
          const linkId = parseInt(sel.value);
          if (!linkId || isNaN(linkId)) return;
          const folder = folders[idx];
          if (!folder || !folder.layers) return;
          const lines = folder.layers.filter(l => l.type === 'line' && l.coords && l.coords.length > 0);
          if (lines.length === 0) return;

          const edge = state.edges.find(e => e.id === linkId);
          if (!edge) return;

          // Convert KML Studio coords [lat,lng] to GeoJSON [lng,lat]
          if (lines.length === 1) {
            edge.cableGeometry = { type: 'LineString', coordinates: lines[0].coords.map(c => [c[1], c[0]]) };
          } else {
            edge.cableGeometry = { type: 'MultiLineString', coordinates: lines.map(line => line.coords.map(c => [c[1], c[0]])) };
          }
          edge.pathSource = 'kml-import';
          applied++;
        });

        // Apply pins to nodes/containers
        overlay.querySelectorAll('.kml-pin-target').forEach(sel => {
          const idx = parseInt(sel.dataset.idx);
          const targetId = parseInt(sel.value);
          if (!targetId || isNaN(targetId)) return;
          const pin = pins[idx];
          if (!pin) return;

          const typeEl = overlay.querySelector(`.kml-pin-type[data-idx="${idx}"]`);
          if (typeEl && typeEl.value === 'container') {
            const group = state.groups.find(g => g.id === targetId);
            if (group) { group.dcLatitude = pin.lat; group.dcLongitude = pin.lng; applied++; }
          } else {
            const node = state.nodes.find(n => n.id === targetId);
            if (node) { node.gpsLat = pin.lat; node.gpsLon = pin.lng; applied++; }
          }
        });

        overlay.remove();
        if (applied > 0) {
          showToast('Applied ' + applied + ' assignment(s) from KML Studio');
          render();
          updateInspector();
        } else {
          showToast('No assignments were made');
        }
      });
    }

    // --- Toolbar button: click to open, drag to send selection ---
    const kmlBtn = document.getElementById('btnKMLStudio');
    if (kmlBtn) {
      kmlBtn.addEventListener('click', () => {
        const result = getSelectedGeoEntities(true);
        showKMLGeoWarnings(result.warnings);
        openKMLStudio(result.entities.length > 0 ? result.entities : null);
      });

      // Drop zone for dragging canvas items, cable systems, or datacenters onto the button
      kmlBtn.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
        kmlBtn.classList.add('kml-drop-active');
      });
      kmlBtn.addEventListener('dragleave', () => kmlBtn.classList.remove('kml-drop-active'));
      kmlBtn.addEventListener('drop', (e) => {
        e.preventDefault();
        kmlBtn.classList.remove('kml-drop-active');

        // Handle application/neximap-entity (canvas drag)
        const data = e.dataTransfer.getData('application/neximap-entity');
        if (data) {
          try { openKMLStudio([JSON.parse(data)]); return; } catch (ex) { /* ignore */ }
        }

        // Handle cable-system drag from Cable System List
        const textData = e.dataTransfer.getData('text/plain');
        if (textData && textData.startsWith('cable-system:')) {
          const csId = parseInt(textData.split(':')[1]);
          const cs = state.cableSystems.find(c => c.id === csId);
          if (cs) {
            const entities = [];
            // Add cable geometry as a link entity
            if (cs.geometry && cs.geometry.coordinates) {
              entities.push({ entityType: 'link', id: cs.id, name: cs.shortName || cs.name, code: cs.name, geometry: cs.geometry });
            }
            // Add landing points as node entities
            if (cs.landingPoints && cs.landingPoints.length > 0) {
              cs.landingPoints.forEach((lp, idx) => {
                if (lp.latitude && lp.longitude) {
                  entities.push({ entityType: 'node', id: 'cls-' + cs.id + '-' + idx, name: lp.name || lp.city || ('Station ' + (idx + 1)), lat: lp.latitude, lng: lp.longitude });
                }
              });
            }
            if (entities.length > 0) { openKMLStudio(entities); return; }
            showToast('Cable system "' + (cs.shortName || cs.name) + '" has no geographic data');
            return;
          }
        }

        // Handle datacenter drag from DC Navigator
        if (textData && textData.startsWith('datacenter:')) {
          const dcId = parseInt(textData.split(':')[1]);
          const fac = window._dcDatabase && window._dcDatabase.facilities.find(f => f.id === dcId);
          if (fac && fac.latitude && fac.longitude) {
            openKMLStudio([{ entityType: 'node', id: 'dc-' + fac.id, name: fac.name, lat: parseFloat(fac.latitude), lng: parseFloat(fac.longitude) }]);
            return;
          }
          if (fac) { showToast('Datacenter "' + fac.name + '" has no coordinates'); return; }
        }

        // Fallback: use canvas selection
        const result = getSelectedGeoEntities(true);
        showKMLGeoWarnings(result.warnings);
        if (result.entities.length > 0) openKMLStudio(result.entities);
        else if (!result.warnings || result.warnings.length === 0) showToast('No entities with geographic data in selection');
      });
    }

    // --- Data menu: KML Studio items ---
    const miKML = document.getElementById('miKMLStudio');
    if (miKML) miKML.addEventListener('click', () => { closeAllMenus(); openKMLStudio(null); });
    const miKMLSel = document.getElementById('miKMLStudioSelection');
    if (miKMLSel) miKMLSel.addEventListener('click', () => {
      closeAllMenus();
      const result = getSelectedGeoEntities(true);
      showKMLGeoWarnings(result.warnings);
      if (result.entities.length === 0 && (!result.warnings || result.warnings.length === 0)) {
        showToast('No selected entities with geographic data'); return;
      }
      if (result.entities.length > 0) openKMLStudio(result.entities);
    });

    // --- Keyboard shortcut: Ctrl+G to open KML Studio ---
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && !e.shiftKey && !e.altKey && e.key === 'g') {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;
        e.preventDefault();
        const result = getSelectedGeoEntities(true);
        showKMLGeoWarnings(result.warnings);
        openKMLStudio(result.entities.length > 0 ? result.entities : null);
      }
    });

    // --- Make canvas items draggable to KML Studio button ---
    const canvasSvg = document.getElementById('svgCanvas');
    if (canvasSvg) {
      canvasSvg.addEventListener('dragstart', (e) => {
        const entities = getSelectedGeoEntities();
        if (entities.length > 0) {
          e.dataTransfer.setData('application/neximap-entity', JSON.stringify(entities[0]));
          e.dataTransfer.effectAllowed = 'copy';
        }
      });
    }

    // Expose globally
    window.openKMLStudio = openKMLStudio;
    window.getSelectedGeoEntities = getSelectedGeoEntities;
    window.getMLGGeoData = getMLGGeoData;

    console.log('[NexiMap] KML Studio integration loaded');
  })();

  showToast('Welcome to NexiMap Studio â€” double-click to create a node.');
})();
</script>

<!-- Financial Settings Modal -->
<div id="financialSettingsModal">
  <div id="financialSettingsContent">
    <div id="financialSettingsHeader">
      <h3>ðŸ’° Financial Settings</h3>
      <button class="close-btn" id="btnCloseFinancialSettings">âœ•</button>
    </div>
    <div id="financialSettingsBody">
      <!-- Currency Section -->
      <div class="fin-section">
        <div class="fin-section-title">ðŸ’± Base Currency</div>
        <div class="fin-row">
          <label>Currency</label>
          <select id="finBaseCurrency">
            <option value="USD">USD - US Dollar</option>
            <option value="EUR">EUR - Euro</option>
            <option value="GBP">GBP - British Pound</option>
            <option value="JPY">JPY - Japanese Yen</option>
            <option value="CNY">CNY - Chinese Yuan</option>
            <option value="SGD">SGD - Singapore Dollar</option>
            <option value="HKD">HKD - Hong Kong Dollar</option>
            <option value="AUD">AUD - Australian Dollar</option>
            <option value="CHF">CHF - Swiss Franc</option>
            <option value="CAD">CAD - Canadian Dollar</option>
            <option value="INR">INR - Indian Rupee</option>
            <option value="KRW">KRW - South Korean Won</option>
            <option value="BRL">BRL - Brazilian Real</option>
            <option value="MXN">MXN - Mexican Peso</option>
            <option value="AED">AED - UAE Dirham</option>
            <option value="SAR">SAR - Saudi Riyal</option>
          </select>
        </div>
        <div class="fin-hint">All costs will be displayed and calculated in this currency</div>

        <div class="currency-rates-box">
          <div class="currency-rates-header">
            <span>Exchange Rates (vs USD)</span>
            <button id="btnFetchRates" title="Fetch latest rates from ECB">
              <span id="fetchRatesIcon">ðŸ”„</span> Update
            </button>
          </div>
          <div class="currency-rates-grid" id="currencyRatesGrid">
            <div class="currency-rate-item"><span class="code">EUR</span><span class="rate">â€”</span></div>
            <div class="currency-rate-item"><span class="code">GBP</span><span class="rate">â€”</span></div>
            <div class="currency-rate-item"><span class="code">JPY</span><span class="rate">â€”</span></div>
            <div class="currency-rate-item"><span class="code">SGD</span><span class="rate">â€”</span></div>
            <div class="currency-rate-item"><span class="code">HKD</span><span class="rate">â€”</span></div>
            <div class="currency-rate-item"><span class="code">AUD</span><span class="rate">â€”</span></div>
            <div class="currency-rate-item"><span class="code">CHF</span><span class="rate">â€”</span></div>
            <div class="currency-rate-item"><span class="code">CNY</span><span class="rate">â€”</span></div>
          </div>
          <div class="rates-updated" id="ratesUpdatedTime">Exchange rates not yet loaded</div>
        </div>
      </div>

      <!-- NPV Calculation Section -->
      <div class="fin-section">
        <div class="fin-section-title">ðŸ“ˆ NPV Calculation</div>
        <div class="fin-row">
          <label>Discount Rate</label>
          <input type="number" id="finDiscountRate" value="12.5" min="0" max="100" step="0.1" />
          <span class="unit">%</span>
        </div>
        <div class="fin-hint">Used for IRU Net Present Value calculations (default: 12.5%)</div>
      </div>

      <!-- Default Values Section - Tier Based -->
      <div class="fin-section">
        <div class="fin-section-title">ðŸ“‹ Default Values for New Links (1G Base Tier)</div>
        <div class="fin-hint" style="margin-bottom:10px;">These are the base values at 1G tier. Higher tiers are calculated using the multipliers below.</div>

        <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
          <!-- Lease Defaults -->
          <div style="padding:10px; background:#eff6ff; border:1px solid #bfdbfe; border-radius:6px;">
            <div style="font-size:10px; font-weight:600; color:#1e40af; margin-bottom:8px;">ðŸ“„ Lease Defaults (1G)</div>
            <div class="fin-row" style="margin-bottom:6px;">
              <label style="width:80px;">NRC</label>
              <input type="number" id="finDefaultNRC" value="0" min="0" step="0.01" style="width:80px;" />
              <span class="unit" id="finDefaultNRCUnit">USD</span>
            </div>
            <div class="fin-row">
              <label style="width:80px;">MRC</label>
              <input type="number" id="finDefaultMRC" value="1" min="0" step="0.01" style="width:80px;" />
              <span class="unit" id="finDefaultMRCUnit">USD</span>
            </div>
          </div>

          <!-- IRU Defaults -->
          <div style="padding:10px; background:#faf5ff; border:1px solid #e9d5ff; border-radius:6px;">
            <div style="font-size:10px; font-weight:600; color:#6b21a8; margin-bottom:8px;">ðŸ“œ IRU Defaults (1G)</div>
            <div class="fin-row" style="margin-bottom:6px;">
              <label style="width:80px;">IRU Fee</label>
              <input type="number" id="finDefaultIRU" value="1" min="0" step="0.01" style="width:80px;" />
              <span class="unit" id="finDefaultIRUUnit">USD</span>
            </div>
            <div class="fin-row" style="margin-bottom:6px;">
              <label style="width:80px;">Term</label>
              <input type="number" id="finDefaultIRUTerm" value="15" min="1" max="30" step="1" style="width:60px;" />
              <span class="unit">years</span>
            </div>
            <div class="fin-row">
              <label style="width:80px;">O&M %</label>
              <input type="number" id="finDefaultOAM" value="5" min="0" max="100" step="0.1" style="width:60px;" />
              <span class="unit">%</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Tier Multipliers Section -->
      <div class="fin-section">
        <div class="fin-section-title">ðŸ“Š Capacity Tier Multipliers</div>
        <div class="fin-hint" style="margin-bottom:10px;">Set the multiplier for each tier relative to 1G base pricing. Used by "Auto-fill from 1G" button.</div>

        <div style="display:grid; grid-template-columns:repeat(3, 1fr); gap:10px;">
          <div style="padding:8px; background:#f8fafc; border:1px solid #e2e8f0; border-radius:6px; text-align:center;">
            <div style="font-size:11px; font-weight:700; color:#0891b2; margin-bottom:6px;">10G Multiplier</div>
            <div style="display:flex; align-items:center; justify-content:center; gap:4px;">
              <span style="font-size:12px; color:#64748b;">Ã—</span>
              <input type="number" id="finTierMult10G" value="2.5" min="1" max="100" step="0.1" style="width:60px; text-align:center; padding:4px; border:1px solid #cbd5e1; border-radius:4px;" />
            </div>
            <div style="font-size:9px; color:#94a3b8; margin-top:4px;">from 1G</div>
          </div>
          <div style="padding:8px; background:#f8fafc; border:1px solid #e2e8f0; border-radius:6px; text-align:center;">
            <div style="font-size:11px; font-weight:700; color:#0891b2; margin-bottom:6px;">100G Multiplier</div>
            <div style="display:flex; align-items:center; justify-content:center; gap:4px;">
              <span style="font-size:12px; color:#64748b;">Ã—</span>
              <input type="number" id="finTierMult100G" value="6.25" min="1" max="1000" step="0.1" style="width:60px; text-align:center; padding:4px; border:1px solid #cbd5e1; border-radius:4px;" />
            </div>
            <div style="font-size:9px; color:#94a3b8; margin-top:4px;">from 1G</div>
          </div>
          <div style="padding:8px; background:#f8fafc; border:1px solid #e2e8f0; border-radius:6px; text-align:center;">
            <div style="font-size:11px; font-weight:700; color:#0891b2; margin-bottom:6px;">400G Multiplier</div>
            <div style="display:flex; align-items:center; justify-content:center; gap:4px;">
              <span style="font-size:12px; color:#64748b;">Ã—</span>
              <input type="number" id="finTierMult400G" value="15.625" min="1" max="10000" step="0.1" style="width:60px; text-align:center; padding:4px; border:1px solid #cbd5e1; border-radius:4px;" />
            </div>
            <div style="font-size:9px; color:#94a3b8; margin-top:4px;">from 1G</div>
          </div>
        </div>

        <div style="margin-top:10px; padding:8px; background:#ecfdf5; border:1px solid #a7f3d0; border-radius:6px;">
          <div style="display:flex; align-items:center; gap:8px;">
            <button id="btnResetMultipliers" style="padding:4px 10px; font-size:10px; background:#f0fdf4; border:1px solid #86efac; border-radius:4px; cursor:pointer;">ðŸ”„ Reset to 2.5Ã— progression</button>
            <span style="font-size:10px; color:#059669;">Sets: 10G=2.5Ã—, 100G=6.25Ã—, 400G=15.625Ã—</span>
          </div>
        </div>
      </div>

      <!-- IRU from MRC Multiplier Section -->
      <div class="fin-section">
        <div class="fin-section-title">ðŸ“œ IRU Fee Calculation from MRC</div>
        <div class="fin-hint" style="margin-bottom:10px;">When resetting prices, the IRU fee for each tier is calculated as: MRC Ã— IRU Multiplier. This provides a standard conversion from monthly lease pricing to one-time IRU fees.</div>

        <div style="display:flex; align-items:center; gap:12px; padding:12px; background:#faf5ff; border:1px solid #e9d5ff; border-radius:6px;">
          <div style="flex:1;">
            <div style="font-size:11px; font-weight:700; color:#7c3aed; margin-bottom:6px;">IRU Fee = MRC Ã— Multiplier</div>
            <div style="display:flex; align-items:center; gap:8px;">
              <label style="font-size:11px; color:#6b7280;">Multiplier:</label>
              <input type="number" id="finIRUFromMRCMultiplier" value="36" min="1" max="1000" step="1" style="width:70px; text-align:center; padding:6px; border:1px solid #c4b5fd; border-radius:4px; font-weight:600; color:#7c3aed;" />
              <span style="font-size:11px; color:#6b7280;">Ã— MRC</span>
            </div>
            <div style="font-size:10px; color:#8b5cf6; margin-top:6px;">Default: 36 (equivalent to 3 years of MRC)</div>
          </div>
          <div style="padding:10px; background:#ede9fe; border-radius:6px; text-align:center;">
            <div style="font-size:9px; color:#6b21a8; text-transform:uppercase; font-weight:600; margin-bottom:4px;">Example</div>
            <div style="font-size:12px; color:#7c3aed; font-weight:600;">MRC $1,000 â†’ IRU $<span id="finIRUExampleResult">36,000</span></div>
          </div>
        </div>
      </div>

      <!-- Container Defaults Section -->
      <div class="fin-section">
        <div class="fin-section-title">ðŸ“¦ Container Transit Defaults (1G Base Tier)</div>
        <div class="fin-hint" style="margin-bottom:10px;">Default commercial cost values for container transit when no internal links exist. Values are calculated automatically from average of internal links when available.</div>

        <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
          <!-- Container Lease Defaults -->
          <div style="padding:10px; background:#ecfdf5; border:1px solid #a7f3d0; border-radius:6px;">
            <div style="font-size:10px; font-weight:600; color:#065f46; margin-bottom:8px;">ðŸ“„ Lease Defaults (1G)</div>
            <div class="fin-row" style="margin-bottom:6px;">
              <label style="width:80px;">NRC</label>
              <input type="number" id="finContainerDefaultNRC" value="0" min="0" step="0.01" style="width:80px;" />
              <span class="unit" id="finContainerDefaultNRCUnit">USD</span>
            </div>
            <div class="fin-row">
              <label style="width:80px;">MRC</label>
              <input type="number" id="finContainerDefaultMRC" value="1" min="0" step="0.01" style="width:80px;" />
              <span class="unit" id="finContainerDefaultMRCUnit">USD</span>
            </div>
          </div>

          <!-- Container IRU Defaults -->
          <div style="padding:10px; background:#fdf4ff; border:1px solid #f0abfc; border-radius:6px;">
            <div style="font-size:10px; font-weight:600; color:#86198f; margin-bottom:8px;">ðŸ“œ IRU Defaults (1G)</div>
            <div class="fin-row" style="margin-bottom:6px;">
              <label style="width:80px;">IRU Fee</label>
              <input type="number" id="finContainerDefaultIRU" value="1" min="0" step="0.01" style="width:80px;" />
              <span class="unit" id="finContainerDefaultIRUUnit">USD</span>
            </div>
            <div class="fin-row" style="margin-bottom:6px;">
              <label style="width:80px;">Term</label>
              <input type="number" id="finContainerDefaultIRUTerm" value="15" min="1" max="30" step="1" style="width:60px;" />
              <span class="unit">years</span>
            </div>
            <div class="fin-row">
              <label style="width:80px;">O&M %</label>
              <input type="number" id="finContainerDefaultOAM" value="3" min="0" max="100" step="0.1" style="width:60px;" />
              <span class="unit">%</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Pathfinder Cost Settings Section -->
      <div class="fin-section">
        <div class="fin-section-title">ðŸ§­ Pathfinder Cost Settings</div>
        <div class="fin-row">
          <label>Default Cost Metric</label>
          <select id="finDefaultCostMetric">
            <option value="lease">Lease (ACV - Annual Contract Value)</option>
            <option value="iru">IRU (Net Present Value)</option>
          </select>
        </div>
        <div class="fin-row">
          <label>Cost Scale</label>
          <select id="finCostScale">
            <option value="linear">Linear</option>
            <option value="logarithmic">Logarithmic</option>
          </select>
        </div>
        <div class="fin-hint">Logarithmic scale helps when costs vary dramatically between links</div>
      </div>
    </div>
    <div id="financialSettingsFooter">
      <button class="btn-cancel" id="btnCancelFinancialSettings">Cancel</button>
      <button class="btn-save" id="btnSaveFinancialSettings">Save Settings</button>
    </div>
  </div>
</div>

<!-- Data Table Modal -->
<div id="dataTableModal">
  <div id="dataTableContent">
    <div id="dataTableHeader">
      <h3>ðŸ“Š Data Table</h3>
      <div id="dataTableControls">
        <select id="dataTableType">
          <option value="links">Links</option>
          <option value="nodes">Nodes</option>
          <option value="containers">Containers</option>
          <option value="mlg">Multilink Groups</option>
        </select>
        <button class="close-btn" id="btnCloseDataTable">âœ•</button>
      </div>
    </div>
    <div id="dataTableToolbar">
      <input type="text" id="dataTableSearch" placeholder="ðŸ” Search..." />
      <div style="display:flex; gap:8px; align-items:center;">
        <label id="dataTableSelectionFilterLabel" style="font-size:11px; color:#6366f1; display:flex; align-items:center; gap:4px; padding:4px 8px; background:#eef2ff; border:1px solid #c7d2fe; border-radius:4px; cursor:pointer;">
          <input type="checkbox" id="dataTableSelectionFilter" style="width:14px; height:14px; accent-color:#6366f1;" />
          <span>ðŸ“ Selection only</span>
          <span id="dataTableSelectionCount" style="font-weight:600; color:#4f46e5;">(0)</span>
        </label>
        <label style="font-size:11px; color:#64748b; display:flex; align-items:center; gap:4px;">
          View Tier:
          <select id="dataTableCapacityTier" style="padding:4px 6px; font-size:11px; border:1px solid #d1d5db; border-radius:4px; background:white;">
            <option value="1G">1G</option>
            <option value="10G" selected>10G</option>
            <option value="100G">100G</option>
            <option value="400G">400G</option>
          </select>
        </label>
        <label style="font-size:11px; color:#64748b; display:flex; align-items:center; gap:4px;">
          <input type="checkbox" id="dataTableShowCost" checked style="width:14px; height:14px;" />
          Show Cost Columns
        </label>
      </div>
      <div style="flex:1;"></div>
      <div id="dataTableResetPricesGroup" style="display:flex; align-items:center; gap:4px; padding:4px 8px; background:#fef3c7; border:1px solid #fcd34d; border-radius:6px;">
        <span style="font-size:10px; color:#92400e; font-weight:600;">â›¡ Reset Prices from:</span>
        <select id="dataTableSourceTier" style="padding:3px 6px; font-size:11px; border:1px solid #fbbf24; border-radius:4px; background:white; font-weight:600; color:#92400e;">
          <option value="1G">1G</option>
          <option value="10G">10G</option>
          <option value="100G">100G</option>
          <option value="400G">400G</option>
        </select>
        <button class="toolbar-btn" id="btnDataTableResetPrices" style="background:#f59e0b; color:white; border-color:#d97706; font-weight:600;" title="Recalculate all tier prices and IRU fees based on the selected source tier using the configured multipliers">
          ðŸ”„ Apply to All
        </button>
      </div>
      <button class="toolbar-btn" id="btnDataTableExport">ðŸ“¤ Export CSV</button>
      <button class="toolbar-btn" id="btnDataTableRecalc">ðŸ”„ Recalculate</button>
    </div>
    <div id="dataTableBody">
      <table id="dataTableContainer">
        <thead id="dataTableHead">
          <!-- Dynamic headers -->
        </thead>
        <tbody id="dataTableRows">
          <!-- Dynamic rows -->
        </tbody>
      </table>
    </div>
    <div id="dataTableFooter">
      <div class="info">
        <span id="dataTableRowCount">0 items</span>
        <span id="dataTableSelectedCount" style="margin-left:12px; color:#6366f1; display:none;">0 selected</span>
      </div>
      <div class="totals">
        <div class="total-item">
          <span class="label">Total ACV:</span>
          <span class="value" id="dataTableTotalACV">$0</span>
        </div>
        <div class="total-item">
          <span class="label">Total IRU NPV:</span>
          <span class="value" id="dataTableTotalIRU">$0</span>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Capacity Editor Modal -->
<div id="capacityEditorModal" style="
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.3);
  z-index: 10000;
  justify-content: center;
  align-items: center;
  pointer-events: none;
">
  <div id="capacityEditorContent" style="
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    width: 900px;
    max-width: 95vw;
    height: 70vh;
    min-height: 400px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    resize: both;
    position: absolute;
    pointer-events: auto;
  ">
    <div id="capacityEditorHeader" style="
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 20px;
      background: linear-gradient(135deg, #059669 0%, #10b981 100%);
      color: white;
      cursor: move;
      user-select: none;
    ">
      <h3 style="margin:0; font-size:16px; font-weight:600; display:flex; align-items:center; gap:8px;">
        <span>ðŸ“Š</span> Capacity Editor
      </h3>
      <div style="display:flex; align-items:center; gap:12px;">
        <span id="capacityEditorCount" style="font-size:12px; opacity:0.9;">0 links</span>
        <button id="btnCloseCapacityEditor" style="
          background: rgba(255,255,255,0.2);
          border: none;
          color: white;
          width: 28px;
          height: 28px;
          border-radius: 6px;
          cursor: pointer;
          font-size: 16px;
          display: flex;
          align-items: center;
          justify-content: center;
        ">âœ•</button>
      </div>
    </div>

    <div id="capacityEditorToolbar" style="
      padding: 10px 16px;
      background: #f8fafc;
      border-bottom: 1px solid #e2e8f0;
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    ">
      <input type="text" id="capacityEditorSearch" placeholder="ðŸ” Search links..." style="
        padding: 8px 12px;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        font-size: 12px;
        width: 200px;
      " />

      <label id="capacityEditorSelectionFilterLabel" style="
        font-size: 11px;
        color: #059669;
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 6px 10px;
        background: #ecfdf5;
        border: 1px solid #a7f3d0;
        border-radius: 6px;
        cursor: pointer;
      ">
        <input type="checkbox" id="capacityEditorSelectionFilter" style="width:14px; height:14px; accent-color:#059669;" />
        <span>ðŸ“ Selection only</span>
        <span id="capacityEditorSelectionCount" style="font-weight:600; color:#047857;">(0)</span>
      </label>

      <div style="flex:1;"></div>

      <div style="display:flex; align-items:center; gap:6px; font-size:11px; color:#64748b;">
        <span>Total Capacity:</span>
        <span id="capacityEditorTotalGbps" style="font-weight:600; color:#059669;">0 Gbps</span>
      </div>

      <button id="btnCapacityEditorExport" style="
        padding: 6px 12px;
        background: white;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        font-size: 11px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 4px;
      ">ðŸ“¤ Export CSV</button>
    </div>

    <div id="capacityEditorBody" style="
      flex: 1;
      overflow: auto;
      background: #fff;
    ">
      <table id="capacityEditorTable" style="
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      ">
        <thead id="capacityEditorHead" style="
          position: sticky;
          top: 0;
          background: #f1f5f9;
          z-index: 10;
        ">
          <tr>
            <th style="padding:10px 12px; text-align:left; font-weight:600; color:#475569; border-bottom:2px solid #e2e8f0; min-width:80px;">Code</th>
            <th style="padding:10px 12px; text-align:left; font-weight:600; color:#475569; border-bottom:2px solid #e2e8f0; min-width:100px;">Link Tag</th>
            <th style="padding:10px 12px; text-align:left; font-weight:600; color:#475569; border-bottom:2px solid #e2e8f0; min-width:100px;">A-End</th>
            <th style="padding:10px 12px; text-align:left; font-weight:600; color:#475569; border-bottom:2px solid #e2e8f0; min-width:100px;">B-End</th>
            <th style="padding:10px 8px; text-align:center; font-weight:600; color:#475569; border-bottom:2px solid #e2e8f0; background:#ecfdf5; min-width:70px;">1G</th>
            <th style="padding:10px 8px; text-align:center; font-weight:600; color:#475569; border-bottom:2px solid #e2e8f0; background:#ecfdf5; min-width:70px;">10G</th>
            <th style="padding:10px 8px; text-align:center; font-weight:600; color:#475569; border-bottom:2px solid #e2e8f0; background:#ecfdf5; min-width:70px;">100G</th>
            <th style="padding:10px 8px; text-align:center; font-weight:600; color:#475569; border-bottom:2px solid #e2e8f0; background:#ecfdf5; min-width:70px;">400G</th>
            <th style="padding:10px 8px; text-align:center; font-weight:600; color:#475569; border-bottom:2px solid #e2e8f0; background:#ecfdf5; min-width:70px;">Tbps</th>
            <th style="padding:10px 12px; text-align:right; font-weight:600; color:#047857; border-bottom:2px solid #e2e8f0; background:#d1fae5; min-width:100px;">Total (Gbps)</th>
            <th style="padding:10px 12px; text-align:left; font-weight:600; color:#475569; border-bottom:2px solid #e2e8f0; min-width:120px;">Capacity Bar</th>
          </tr>
        </thead>
        <tbody id="capacityEditorRows">
          <!-- Dynamic rows -->
        </tbody>
      </table>
    </div>

    <div id="capacityEditorFooter" style="
      padding: 10px 16px;
      background: #f8fafc;
      border-top: 1px solid #e2e8f0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      color: #64748b;
    ">
      <div>
        <span id="capacityEditorRowCount">0 links</span>
        <span style="margin-left:12px; color:#059669;" id="capacityEditorFilteredInfo"></span>
      </div>
      <div style="display:flex; gap:16px;">
        <span>ðŸ’¡ Click cells to edit â€¢ Tab to navigate â€¢ Enter to save</span>
      </div>
    </div>
  </div>
</div>

<!-- Bulk Edit Modal -->
<div id="bulkEditModal">
  <div id="bulkEditContent">
    <div id="bulkEditHeader">
      <h3 id="bulkEditTitle">ðŸ“ Bulk Edit</h3>
      <button class="close-btn" id="btnCloseBulkEdit">âœ•</button>
    </div>
    <div id="bulkEditBody">
      <!-- Target Selection -->
      <div class="bulk-edit-section">
        <h4>ðŸŽ¯ Target Selection</h4>
        <div class="bulk-edit-row">
          <label>Apply to:</label>
          <select id="bulkEditTarget">
            <option value="all">All items</option>
            <option value="selected">Selected items only</option>
            <option value="filtered">Current filter results</option>
            <option value="tagged">Items with specific tag</option>
          </select>
        </div>
        <div class="bulk-edit-row" id="bulkEditTagFilterRow" style="display:none;">
          <label>Tag filter:</label>
          <input type="text" id="bulkEditTagFilter" placeholder="Enter tag name..." />
        </div>
        <div id="bulkEditTargetCount" style="font-size:11px; color:#6366f1; margin-top:8px;">
          Will affect: 0 items
        </div>
      </div>

      <!-- Links-specific fields -->
      <div id="bulkEditLinksFields">
        <div class="bulk-edit-section">
          <h4>ðŸ’° Commercial Settings</h4>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditApplyNRC" />
            <label style="width:auto;">Set NRC (all tiers)</label>
            <input type="number" id="bulkEditNRC" value="0" min="0" style="width:100px;" disabled />
          </div>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditApplyMRC" />
            <label style="width:auto;">Set MRC (all tiers)</label>
            <input type="number" id="bulkEditMRC" value="1" min="0" step="0.01" style="width:100px;" disabled />
          </div>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditApplyIRU" />
            <label style="width:auto;">Set IRU Fee (all tiers)</label>
            <input type="number" id="bulkEditIRU" value="1" min="0" step="0.01" style="width:100px;" disabled />
          </div>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditApplyTerm" />
            <label style="width:auto;">Set IRU Term (years)</label>
            <input type="number" id="bulkEditTerm" value="15" min="1" max="99" style="width:80px;" disabled />
          </div>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditApplyOAM" />
            <label style="width:auto;">Set O&M %</label>
            <input type="number" id="bulkEditOAM" value="3" min="0" max="100" step="0.1" style="width:80px;" disabled />
          </div>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditApplyOAMInc" />
            <label style="width:auto;">Set O&M Inc %</label>
            <input type="number" id="bulkEditOAMInc" value="2" min="0" max="50" step="0.1" style="width:80px;" disabled />
          </div>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditApplyLatency" />
            <label style="width:auto;">Set Latency (ms)</label>
            <input type="number" id="bulkEditLatency" value="" min="0" step="0.01" style="width:100px;" disabled />
          </div>
        </div>

        <div class="bulk-edit-section">
          <h4>ðŸ·ï¸ Tags</h4>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditApplyAddTags" />
            <label style="width:auto;">Add tags:</label>
            <input type="text" id="bulkEditAddTags" placeholder="tag1, tag2..." style="flex:1;" disabled />
          </div>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditApplyRemoveTags" />
            <label style="width:auto;">Remove tags:</label>
            <input type="text" id="bulkEditRemoveTags" placeholder="tag1, tag2..." style="flex:1;" disabled />
          </div>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditApplyReplaceTags" />
            <label style="width:auto;">Replace all tags:</label>
            <input type="text" id="bulkEditReplaceTags" placeholder="tag1, tag2..." style="flex:1;" disabled />
          </div>
        </div>
      </div>

      <!-- Nodes-specific fields -->
      <div id="bulkEditNodesFields" style="display:none;">
        <div class="bulk-edit-section">
          <h4>ðŸ·ï¸ Tags</h4>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditNodeAddTags" />
            <label style="width:auto;">Add tags:</label>
            <input type="text" id="bulkEditNodeAddTagsInput" placeholder="tag1, tag2..." style="flex:1;" disabled />
          </div>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditNodeRemoveTags" />
            <label style="width:auto;">Remove tags:</label>
            <input type="text" id="bulkEditNodeRemoveTagsInput" placeholder="tag1, tag2..." style="flex:1;" disabled />
          </div>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditNodeReplaceTags" />
            <label style="width:auto;">Replace all tags:</label>
            <input type="text" id="bulkEditNodeReplaceTagsInput" placeholder="tag1, tag2..." style="flex:1;" disabled />
          </div>
        </div>

        <div class="bulk-edit-section">
          <h4>ðŸŒ Location</h4>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditApplyCountry" />
            <label style="width:auto;">Set Country:</label>
            <input type="text" id="bulkEditCountry" placeholder="Country name..." style="flex:1;" disabled />
          </div>
          <div class="bulk-edit-row bulk-edit-checkbox">
            <input type="checkbox" id="bulkEditApplyCity" />
            <label style="width:auto;">Set City:</label>
            <input type="text" id="bulkEditCity" placeholder="City name..." style="flex:1;" disabled />
          </div>
        </div>
      </div>
    </div>
    <div id="bulkEditFooter">
      <div class="target-info" id="bulkEditSummary">No changes selected</div>
      <div class="btn-group">
        <button class="btn-cancel" id="btnCancelBulkEdit">Cancel</button>
        <button class="btn-apply" id="btnApplyBulkEdit">Apply Changes</button>
      </div>
    </div>
  </div>
</div>

<!-- Display Preferences Modal -->
<div id="displayPrefsModal" class="settings-modal">
  <div class="settings-modal-content">
    <div class="settings-modal-header display-prefs">
      <h3>ðŸŽ¨ Display Preferences</h3>
      <button class="close-btn" id="btnCloseDisplayPrefs">âœ•</button>
    </div>
    <div class="settings-modal-body">
      <div class="settings-section">
        <h4>ðŸ“ Node Labels</h4>
        <div class="settings-row">
          <label>Show Node Name</label>
          <input type="checkbox" id="dpShowNodeName" checked />
        </div>
        <div class="settings-row">
          <label>Show Node Code</label>
          <input type="checkbox" id="dpShowNodeCode" checked />
        </div>
        <div class="settings-row">
          <label>Show Node Tags</label>
          <input type="checkbox" id="dpShowNodeTags" />
        </div>
        <div class="settings-row">
          <label>Show Extra Tags</label>
          <input type="checkbox" id="dpShowExtraTags" />
        </div>
      </div>

      <div class="settings-section">
        <h4>ðŸ”— Link Labels</h4>
        <div class="settings-row">
          <label>Show Link Tag</label>
          <input type="checkbox" id="dpShowLinkTag" checked />
        </div>
        <div class="settings-row">
          <label>Show Link Code</label>
          <input type="checkbox" id="dpShowLinkCode" checked />
        </div>
        <div class="settings-row">
          <label>Show Latency</label>
          <input type="checkbox" id="dpShowLatency" checked />
        </div>
      </div>

      <div class="settings-section">
        <h4>ðŸ“¦ Containers</h4>
        <div class="settings-row">
          <label>Show Container Titles</label>
          <input type="checkbox" id="dpShowContainerTitle" checked />
        </div>
      </div>

      <div class="settings-section">
        <h4>ðŸ–¼ï¸ Canvas</h4>
        <div class="settings-row">
          <label>Canvas Width</label>
          <input type="number" id="dpCanvasWidth" value="1600" min="800" max="10000" step="100" style="width:100px;" />
          <span class="hint">px</span>
        </div>
        <div class="settings-row">
          <label>Canvas Height</label>
          <input type="number" id="dpCanvasHeight" value="900" min="600" max="10000" step="100" style="width:100px;" />
          <span class="hint">px</span>
        </div>
        <div class="settings-row">
          <label>Show Canvas Border</label>
          <input type="checkbox" id="dpShowCanvasBorder" checked />
        </div>
        <div class="settings-row">
          <label>Show Grid</label>
          <input type="checkbox" id="dpShowGrid" checked />
        </div>
        <div class="settings-row">
          <label>Grid Size</label>
          <select id="dpGridSize" style="width:120px;">
            <option value="10">Fine (10px)</option>
            <option value="20">Small (20px)</option>
            <option value="40" selected>Medium (40px)</option>
            <option value="60">Large (60px)</option>
            <option value="100">Extra Large (100px)</option>
          </select>
        </div>
      </div>
    </div>
    <div class="settings-modal-footer">
      <button class="btn-cancel" id="btnCancelDisplayPrefs">Cancel</button>
      <button class="btn-save" id="btnSaveDisplayPrefs">Save Preferences</button>
    </div>
  </div>
</div>

<!-- Default Node Style Modal -->
<div id="nodeDefaultsModal" class="settings-modal">
  <div class="settings-modal-content">
    <div class="settings-modal-header node-defaults">
      <h3>ðŸ“ Default Node Style</h3>
      <button class="close-btn" id="btnCloseNodeDefaults">âœ•</button>
    </div>
    <div class="settings-modal-body">
      <div class="settings-section">
        <h4>ðŸ”· Shape & Size</h4>
        <div class="settings-row">
          <label>Default Shape</label>
          <select id="ndShape">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="diamond">Diamond</option>
            <option value="hexagon">Hexagon</option>
            <option value="triangle">Triangle</option>
            <option value="star">Star</option>
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
            <option value="server">Server</option>
            <option value="router">Router</option>
          </select>
          <div class="shape-preview" id="ndShapePreview">
            <svg viewBox="0 0 40 40"><circle cx="20" cy="20" r="16" fill="#dae8fc" stroke="#6c8ebf" stroke-width="2"/></svg>
          </div>
        </div>
        <div class="settings-row">
          <label>Default Size</label>
          <input type="number" id="ndSize" value="24" min="10" max="100" step="2" style="width:80px;" />
          <span class="hint">px radius</span>
        </div>
      </div>

      <div class="settings-section">
        <h4>ðŸŽ¨ Colors</h4>
        <div class="settings-row">
          <label>Fill Color</label>
          <input type="color" id="ndFillColor" value="#dae8fc" />
          <span id="ndFillColorHex" style="font-family:monospace; font-size:11px; color:#64748b;">#dae8fc</span>
        </div>
        <div class="settings-row">
          <label>Stroke Color</label>
          <input type="color" id="ndStrokeColor" value="#6c8ebf" />
          <span id="ndStrokeColorHex" style="font-family:monospace; font-size:11px; color:#64748b;">#6c8ebf</span>
        </div>
        <div class="settings-row">
          <label>Stroke Width</label>
          <input type="number" id="ndStrokeWidth" value="2" min="0" max="10" step="0.5" style="width:80px;" />
          <span class="hint">px</span>
        </div>
      </div>

      <div class="settings-section">
        <h4>ðŸ·ï¸ Label Style</h4>
        <div class="settings-row">
          <label>Label Font Size</label>
          <input type="number" id="ndLabelFontSize" value="12" min="8" max="24" step="1" style="width:80px;" />
          <span class="hint">px</span>
        </div>
        <div class="settings-row">
          <label>Label Color</label>
          <input type="color" id="ndLabelColor" value="#333333" />
          <span id="ndLabelColorHex" style="font-family:monospace; font-size:11px; color:#64748b;">#333333</span>
        </div>
      </div>
    </div>
    <div class="settings-modal-footer">
      <button class="btn-cancel" id="btnCancelNodeDefaults">Cancel</button>
      <button class="btn-save" id="btnSaveNodeDefaults">Save Defaults</button>
    </div>
  </div>
</div>

<!-- Default Link Style Modal -->
<div id="linkDefaultsModal" class="settings-modal">
  <div class="settings-modal-content">
    <div class="settings-modal-header link-defaults">
      <h3>ðŸ”— Default Link Style</h3>
      <button class="close-btn" id="btnCloseLinkDefaults">âœ•</button>
    </div>
    <div class="settings-modal-body">
      <div class="settings-section">
        <h4>ðŸ“ Line Style</h4>
        <div class="settings-row">
          <label>Line Type</label>
          <select id="ldLineType">
            <option value="straight">Straight</option>
            <option value="curved">Curved</option>
          </select>
        </div>
        <div class="settings-row">
          <label>Stroke Width</label>
          <input type="number" id="ldStrokeWidth" value="2" min="1" max="20" step="0.5" style="width:80px;" />
          <span class="hint">px</span>
        </div>
        <div class="settings-row">
          <label>Dash Pattern</label>
          <select id="ldDashPattern">
            <option value="">Solid</option>
            <option value="5,5">Dashed</option>
            <option value="2,4">Dotted</option>
            <option value="10,5,2,5">Dash-Dot</option>
          </select>
        </div>
        <div class="settings-row">
          <label>Curve Arch</label>
          <input type="number" id="ldCurveArch" value="0.3" min="0" max="1" step="0.1" style="width:80px;" />
          <span class="hint">0=straight, 1=max curve</span>
        </div>
      </div>

      <div class="settings-section">
        <h4>ðŸŽ¨ Colors</h4>
        <div class="settings-row">
          <label>Stroke Color</label>
          <input type="color" id="ldStrokeColor" value="#666666" />
          <span id="ldStrokeColorHex" style="font-family:monospace; font-size:11px; color:#64748b;">#666666</span>
        </div>
        <div class="settings-row">
          <label>Enable Glow</label>
          <input type="checkbox" id="ldEnableGlow" />
        </div>
        <div class="settings-row" id="ldGlowColorRow" style="display:none;">
          <label>Glow Color</label>
          <input type="color" id="ldGlowColor" value="#0096D6" />
          <span id="ldGlowColorHex" style="font-family:monospace; font-size:11px; color:#64748b;">#0096D6</span>
        </div>
      </div>

      <div class="settings-section">
        <h4>ðŸ·ï¸ Label Style</h4>
        <div class="settings-row">
          <label>Label Font Size</label>
          <input type="number" id="ldLabelFontSize" value="10" min="8" max="24" step="1" style="width:80px;" />
          <span class="hint">px</span>
        </div>
        <div class="settings-row">
          <label>Label Color</label>
          <input type="color" id="ldLabelColor" value="#666666" />
          <span id="ldLabelColorHex" style="font-family:monospace; font-size:11px; color:#64748b;">#666666</span>
        </div>
      </div>

      <div class="settings-section">
        <h4>âž¡ï¸ Arrows</h4>
        <div class="settings-row">
          <label>Arrow at Start</label>
          <input type="checkbox" id="ldArrowStart" />
        </div>
        <div class="settings-row">
          <label>Arrow at End</label>
          <input type="checkbox" id="ldArrowEnd" />
        </div>
      </div>
    </div>
    <div class="settings-modal-footer">
      <button class="btn-cancel" id="btnCancelLinkDefaults">Cancel</button>
      <button class="btn-save" id="btnSaveLinkDefaults">Save Defaults</button>
    </div>
  </div>
</div>

<!-- Print Preview Modal -->
<div id="printPreviewModal">
  <div id="printPreviewContent">
    <div id="printPreviewHeader">
      <h3>Print Preview</h3>
      <div id="printPreviewControls">
        <label style="font-size:13px;">
          Page Size:
          <select id="printPageSize" style="margin-left:4px; padding:4px;">
            <option value="a4">A4</option>
            <option value="letter">Letter</option>
            <option value="a3">A3</option>
            <option value="fit">Fit Content</option>
          </select>
        </label>
        <label style="font-size:13px;">
          Orientation:
          <select id="printOrientation" style="margin-left:4px; padding:4px;">
            <option value="landscape">Landscape</option>
            <option value="portrait">Portrait</option>
          </select>
        </label>
        <label style="font-size:13px;">
          <input type="checkbox" id="printShowGrid" style="margin-right:4px;" />
          Show Grid
        </label>
        <button class="btn primary" id="btnDoPrint">Print</button>
        <button class="btn" id="btnClosePrintPreview">Close</button>
      </div>
    </div>
    <div id="printPreviewBody">
      <div id="printPreviewPage">
        <!-- SVG preview will be inserted here -->
      </div>
    </div>
  </div>
</div>

<script>
(function() {
  const printPreviewModal = document.getElementById('printPreviewModal');
  const printPreviewPage = document.getElementById('printPreviewPage');
  const printPageSize = document.getElementById('printPageSize');
  const printOrientation = document.getElementById('printOrientation');
  const printShowGrid = document.getElementById('printShowGrid');
  const btnDoPrint = document.getElementById('btnDoPrint');
  const btnClosePrintPreview = document.getElementById('btnClosePrintPreview');
  const miPrintPreview = document.getElementById('miPrintPreview');
  const miPrint = document.getElementById('miPrint');

  // Page sizes in mm (width x height for portrait)
  const pageSizes = {
    a4: { w: 297, h: 210 },      // landscape by default
    letter: { w: 279, h: 216 },  // landscape by default
    a3: { w: 420, h: 297 },      // landscape by default
    fit: { w: 0, h: 0 }          // will be calculated
  };

  function generatePrintSVG(showGrid = false) {
    const svg = document.getElementById('svg');
    const clone = svg.cloneNode(true);

    // Remove grid if not wanted
    if (!showGrid) {
      const gridElements = clone.querySelectorAll('.grid');
      gridElements.forEach(el => el.remove());
    }

    // Remove selection highlights
    clone.querySelectorAll('.node-selected, .edge.selected, .group-selected').forEach(el => {
      el.classList.remove('node-selected', 'selected', 'group-selected');
    });

    // Remove resize handles - they are editing aids, not part of the printed output
    clone.querySelectorAll('.group-handle').forEach(el => el.remove());
    clone.querySelectorAll('.node-resize-handle').forEach(el => el.remove());

    // Remove marquee if any
    const marquee = clone.querySelector('.marquee');
    if (marquee) marquee.remove();

    return clone;
  }

  function updatePrintPreview() {
    const size = printPageSize.value;
    const orientation = printOrientation.value;
    const showGrid = printShowGrid.checked;

    let pageW, pageH;

    if (size === 'fit') {
      // Calculate bounding box of content
      const svg = document.getElementById('svg');
      const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
      pageW = viewBox[2];
      pageH = viewBox[3];
    } else {
      const dims = pageSizes[size];
      if (orientation === 'landscape') {
        pageW = Math.max(dims.w, dims.h);
        pageH = Math.min(dims.w, dims.h);
      } else {
        pageW = Math.min(dims.w, dims.h);
        pageH = Math.max(dims.w, dims.h);
      }
    }

    // Scale for preview (mm to pixels, roughly)
    const scale = size === 'fit' ? 0.5 : 2;
    const previewW = pageW * scale;
    const previewH = pageH * scale;

    const printSVG = generatePrintSVG(showGrid);
    printSVG.setAttribute('width', previewW);
    printSVG.setAttribute('height', previewH);
    printSVG.style.background = '#fff';

    printPreviewPage.innerHTML = '';
    printPreviewPage.style.width = previewW + 'px';
    printPreviewPage.style.height = previewH + 'px';
    printPreviewPage.appendChild(printSVG);
  }

  function showPrintPreview() {
    printPreviewModal.classList.add('show');
    updatePrintPreview();
  }

  function closePrintPreview() {
    printPreviewModal.classList.remove('show');
  }

  function doPrint() {
    closePrintPreview();
    setTimeout(() => {
      window.print();
    }, 100);
  }

  // Event listeners
  if (miPrintPreview) {
    miPrintPreview.addEventListener('click', () => {
      showPrintPreview();
      // Close file menu
      const fileMenu = document.getElementById('fileMenu');
      if (fileMenu) fileMenu.hidden = true;
    });
  }

  if (miPrint) {
    miPrint.addEventListener('click', () => {
      // Close file menu
      const fileMenu = document.getElementById('fileMenu');
      if (fileMenu) fileMenu.hidden = true;
      window.print();
    });
  }

  if (btnDoPrint) btnDoPrint.addEventListener('click', doPrint);
  if (btnClosePrintPreview) btnClosePrintPreview.addEventListener('click', closePrintPreview);

  if (printPageSize) printPageSize.addEventListener('change', updatePrintPreview);
  if (printOrientation) printOrientation.addEventListener('change', updatePrintPreview);
  if (printShowGrid) printShowGrid.addEventListener('change', updatePrintPreview);

  // Close on escape
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && printPreviewModal.classList.contains('show')) {
      closePrintPreview();
    }
  });

  // Close on background click
  printPreviewModal.addEventListener('click', (e) => {
    if (e.target === printPreviewModal) {
      closePrintPreview();
    }
  });

  // Ctrl+P shortcut
  document.addEventListener('keydown', (e) => {
    if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
      e.preventDefault();
      window.print();
    }
  });
})();
</script>

<!-- Cable Visor Panel (Submarine Cable Map Viewer) -->
<aside id="cableVisorPanel">
  <div id="cableVisorHeader">
    <h3>ðŸŒ Submarine Cable Visor</h3>
    <div id="cableVisorControls">
      <button id="btnCableVisorPresentation" title="Presentation Mode (Fullscreen)"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg></button>
      <button id="btnCableVisorMaximize" title="Maximize/Restore">â¬œ</button>
      <button id="btnCableVisorClose" title="Close Visor">âœ•</button>
    </div>
  </div>
  <div id="cableVisorToolbar">
    <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
      <span style="font-size:11px; font-weight:600; color:#495057;">Source:</span>
      <label style="display:flex; align-items:center; gap:4px; cursor:pointer; font-size:11px;">
        <input type="radio" name="visorSource" id="visorSrcList" value="list" checked style="margin:0;" />
        ðŸ“‹ Cable List
      </label>
      <label style="display:flex; align-items:center; gap:4px; cursor:pointer; font-size:11px;">
        <input type="radio" name="visorSource" id="visorSrcAPI" value="api" style="margin:0;" />
        ðŸŒ Public Cable System DB
      </label>
      <button id="btnVisorRefreshAPI" class="btn" style="padding:3px 8px; font-size:10px; margin-left:auto;" title="Fetch fresh data from Public Cable System DB API (slow, ~500 requests)">ðŸ”„ Refresh from API</button>
    </div>
    <div style="display:flex; gap:8px; align-items:center;">
      <input type="text" id="cableVisorSearch" placeholder="Search cables..." style="flex:1;" />
      <select id="cableVisorRegionFilter">
        <option value="">All Corridors</option>
      </select>
      <button class="btn" id="btnVisorSelectAll" style="padding:4px 8px; font-size:11px;" title="Select all visible">âœ“ All</button>
      <button class="btn" id="btnVisorClearAll" style="padding:4px 8px; font-size:11px;" title="Clear selection">âœ— Clear</button>
    </div>
    <div style="display:flex; gap:6px; align-items:center; margin-top:4px;">
      <span style="font-size:10px; font-weight:600; color:#64748b;">Display:</span>
      <button class="visor-toggle-btn" id="btnVisorShowNames" title="Show/hide cable names on map">Names</button>
      <button class="visor-toggle-btn" id="btnVisorShowStations" title="Show/hide cable landing stations on map">Stations</button>
      <button class="visor-toggle-btn" id="btnVisorFixNames" title="Pin cable names permanently on map" style="display:none;">Pin Names</button>
      <button class="visor-toggle-btn" id="btnVisorFixStationNames" title="Pin station names permanently on map" style="display:none;">Pin Stations</button>
      <div style="flex:1;"></div>
      <div style="position:relative;">
        <button class="btn" id="btnCableVisorActions" style="padding:3px 8px;font-size:10px;" title="Image actions">&#x1F5BC;&#xFE0F; Image &#x25BC;</button>
        <div class="visor-action-menu" id="cableVisorActionMenu">
          <button id="btnCableVisorCopyImage">&#x1F4CB; Copy to Clipboard</button>
          <button id="btnCableVisorSavePNG">&#x1F5BC;&#xFE0F; Save as PNG</button>
          <button id="btnCableVisorSaveJPG">&#x1F5BC;&#xFE0F; Save as JPG</button>
          <div class="menu-sep"></div>
          <button id="btnCableVisorPrint">&#x1F5A8;&#xFE0F; Print</button>
        </div>
      </div>
    </div>
    <div style="display:flex; gap:6px; align-items:center; margin-top:5px; padding-top:5px; border-top:1px solid #e9ecef;">
      <span style="font-size:10px; font-weight:600; color:#64748b;">Map Style:</span>
      <select id="cableVisorMapStyle" style="padding:3px 6px; font-size:10px; border:1px solid #d0d0d0; border-radius:4px; background:white; max-width:160px;">
        <option value="osm">OpenStreetMap</option>
        <option value="satellite">Satellite (ESRI)</option>
        <option value="topo">Topo (ESRI)</option>
        <option value="openTopo">OpenTopoMap</option>
        <option value="cartoLight">Carto Light</option>
        <option value="cartoDark">Carto Dark</option>
      </select>
    </div>
    <div style="display:flex; gap:6px; align-items:center; margin-top:5px; padding-top:5px; border-top:1px solid #e9ecef;">
      <span style="font-size:10px; font-weight:600; color:#64748b;">CLS Filter:</span>
      <select id="cableVisorCLSMode" style="padding:3px 6px; font-size:10px; border:1px solid #d0d0d0; border-radius:4px; background:white;">
        <option value="">Off</option>
        <option value="station">By Station</option>
        <option value="city">By City</option>
        <option value="country">By Country</option>
      </select>
      <div class="cls-filter-wrap" id="cableVisorCLSWrap" style="display:none;">
        <input type="text" id="cableVisorCLSInput" placeholder="Type to search..." autocomplete="off" />
        <span class="cls-search-icon">&#x1F50D;</span>
        <div class="cls-filter-dropdown" id="cableVisorCLSDropdown"></div>
      </div>
      <span id="cableVisorCLSTag" style="display:none;"></span>
    </div>
  </div>
  <div id="cableVisorMap">
    <div id="cableVisorMapContainer" style="width:100%; height:100%;"></div>
    <div id="cableVisorMapLoading" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); text-align:center; color:#666;">
      <div style="font-size:24px; margin-bottom:8px;">ðŸŒ</div>
      <div>Loading map...</div>
    </div>
  </div>
  <div id="cableVisorMapResizeHandle" title="Drag to resize map">
    <div class="resize-grip"></div>
  </div>
  <div id="cableVisorDetailPanel">
    <div class="visor-detail-header" id="visorDetailHeaderToggle" title="Click to expand/collapse details">
      <span class="visor-detail-toggle" id="visorDetailChevron">â–¼</span>
      <h4 id="visorDetailName">Cable Name</h4>
      <span id="visorDetailStatusBadge" class="visor-detail-status unknown">
        <span class="cs-status-badge live-unknown" style="width:8px;height:8px;"></span> Unknown
      </span>
      <button class="visor-detail-close" id="btnCloseVisorDetail" title="Close details">âœ•</button>
    </div>
    <div class="visor-detail-body" id="visorDetailBody">
      <div class="visor-detail-grid" id="visorDetailGrid"></div>
      <div class="visor-landing-points" id="visorLandingPoints" style="display:none;">
        <h5>ðŸ“ Landing Stations</h5>
        <div class="visor-lp-list" id="visorLpList"></div>
      </div>
    </div>
  </div>
  <div id="cableVisorList">
    <div style="padding:8px 12px; background:#f8f9fa; border-bottom:1px solid #e0e0e0; font-size:11px; font-weight:600; color:#495057; position:sticky; top:0; z-index:5;">
      <span id="cableVisorListTitle">Cables from Database</span>
      <span id="cableVisorSelectedCount" style="float:right; color:#0077b6;">0 selected</span>
    </div>
    <div id="cableVisorCableList">
      <!-- Dynamic list -->
    </div>
  </div>
  <div id="cableVisorFooter">
    <span id="cableVisorCableCount">0 cables</span>
    <span>Click cables to show on map â€¢ Double-click to zoom</span>
  </div>
</aside>

<!-- Datacenter Visor Panel -->
<aside id="dcVisorPanel">
  <div id="dcVisorHeader">
    <h3>&#x1F3E2; Datacenter Visor</h3>
    <div id="dcVisorControls">
      <button id="btnDCVisorPresentation" title="Presentation Mode (Fullscreen)"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></svg></button>
      <button id="btnDCVisorMaximize" title="Maximize/Restore">&#x2B1C;</button>
      <button id="btnDCVisorClose" title="Close Visor">&#x2715;</button>
    </div>
  </div>
  <div id="dcVisorToolbar">
    <div style="display:flex; gap:8px; align-items:center;">
      <input type="text" id="dcVisorSearch" placeholder="Search facilities..." style="flex:1; padding:6px 10px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px;" />
      <select id="dcVisorTypeFilter" style="padding:6px 10px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px; background:white; max-width:120px;">
        <option value="">All Types</option>
        <option value="datacenter">Datacenters</option>
        <option value="cable_station">Cable Stations</option>
      </select>
      <select id="dcVisorRegionFilter" style="padding:6px 10px; border:1px solid #d0d0d0; border-radius:4px; font-size:12px; background:white; max-width:140px;">
        <option value="">All Corridors</option>
      </select>
    </div>
    <div style="display:flex; gap:6px; align-items:center; margin-top:4px;">
      <button class="btn" id="btnDCVisorSelectAll" style="padding:4px 8px; font-size:11px;" title="Select all visible">&#x2713; All</button>
      <button class="btn" id="btnDCVisorClearAll" style="padding:4px 8px; font-size:11px;" title="Clear selection">&#x2717; Clear</button>
      <span style="font-size:10px; font-weight:600; color:#64748b; margin-left:8px;">Display:</span>
      <button class="visor-toggle-btn" id="btnDCVisorShowNames" title="Show/hide datacenter names on map">Names</button>
      <div style="flex:1;"></div>
      <div style="position:relative;">
        <button class="btn" id="btnDCVisorActions" style="padding:3px 8px;font-size:10px;" title="Image actions">&#x1F5BC;&#xFE0F; Image &#x25BC;</button>
        <div class="visor-action-menu" id="dcVisorActionMenu">
          <button id="btnDCVisorCopyImage">&#x1F4CB; Copy to Clipboard</button>
          <button id="btnDCVisorSavePNG">&#x1F5BC;&#xFE0F; Save as PNG</button>
          <button id="btnDCVisorSaveJPG">&#x1F5BC;&#xFE0F; Save as JPG</button>
          <div class="menu-sep"></div>
          <button id="btnDCVisorPrint">&#x1F5A8;&#xFE0F; Print</button>
        </div>
      </div>
    </div>
  </div>
  <div id="dcVisorMap">
    <div id="dcVisorMapContainer" style="width:100%; height:100%;"></div>
    <div id="dcVisorMapLoading" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); text-align:center; color:#666;">
      <div style="font-size:24px; margin-bottom:8px;">&#x1F3E2;</div>
      <div>Loading map...</div>
    </div>
  </div>
  <div id="dcVisorMapResizeHandle" title="Drag to resize map">
    <div class="resize-grip"></div>
  </div>
  <div id="dcVisorList">
    <div style="padding:8px 12px; background:#f8f9fa; border-bottom:1px solid #e0e0e0; font-size:11px; font-weight:600; color:#495057; position:sticky; top:0; z-index:5;">
      <span id="dcVisorListTitle">Datacenters from PeeringDB</span>
      <span id="dcVisorSelectedCount" style="float:right; color:#9333ea;">0 selected</span>
    </div>
    <div id="dcVisorDCList">
      <!-- Dynamic list -->
    </div>
  </div>
  <div id="dcVisorFooter">
    <span id="dcVisorDCCount">0 datacenters</span>
    <span>Click to show on map &#x2022; Double-click to zoom</span>
  </div>
</aside>

<!-- Help Center Modal -->
<div id="helpCenterModal">
  <div id="helpCenterContent">
    <div id="helpCenterHeader">
      <h2>
        <span style="font-size: 22px;">â“</span>
        Help Center
      </h2>
      <div style="display:flex; align-items:center; gap:12px;">
        <button id="btnOpenOnlineDocs" style="padding:8px 16px; background:linear-gradient(135deg, #10b981, #059669); color:white; border:none; border-radius:6px; cursor:pointer; font-size:13px; font-weight:600; display:flex; align-items:center; gap:6px;" title="Open full documentation in new tab">
          ðŸŒ Full Guide
        </button>
        <button class="close-btn" id="btnCloseHelpCenter" title="Close (Esc)">Ã—</button>
      </div>
    </div>

    <div id="helpCenterSearch">
      <input type="text" id="helpSearchInput" placeholder="Search help topics, shortcuts, features..." autocomplete="off" />
    </div>

    <div id="helpCenterBody">
      <nav id="helpCenterNav">
        <div class="help-nav-item active" data-section="getting-started">
          <span class="nav-icon">ðŸ›€</span>
          <span>Getting Started</span>
        </div>
        <div class="help-nav-item" data-section="shortcuts">
          <span class="nav-icon">âŒ¨ï¸</span>
          <span>Keyboard Shortcuts</span>
        </div>
        <div class="help-nav-item" data-section="features">
          <span class="nav-icon">ðŸŽ¯</span>
          <span>Features Guide</span>
        </div>
        <div class="help-nav-item" data-section="tips">
          <span class="nav-icon">ðŸ’¡</span>
          <span>Tips & Tricks</span>
        </div>
        <div class="help-nav-item" data-section="faq">
          <span class="nav-icon">â“</span>
          <span>FAQ</span>
        </div>
        <div class="help-nav-item" data-section="changelog">
          <span class="nav-icon">ðŸ“‹</span>
          <span>What's New</span>
          <span class="nav-badge">v60</span>
        </div>
      </nav>

      <div id="helpCenterPanel">
        <!-- Getting Started Section -->
        <div class="help-section active" id="help-getting-started">
          <h3><span class="section-icon">ðŸ›€</span> Getting Started</h3>
          <p>Welcome to NexiMap Studio! Click any card below to learn more in the full documentation.</p>

          <div class="quick-start-grid">
            <div class="quick-start-card" data-guide-section="nodes" title="Click to learn more about nodes">
              <div class="qs-icon">ðŸ“</div>
              <div class="qs-title">Create Nodes</div>
              <div class="qs-desc">Double-click on canvas</div>
              <div class="qs-link">Learn more â†’</div>
            </div>
            <div class="quick-start-card" data-guide-section="links" title="Click to learn more about links">
              <div class="qs-icon">ðŸ”—</div>
              <div class="qs-title">Connect Nodes</div>
              <div class="qs-desc">Drag from node to node</div>
              <div class="qs-link">Learn more â†’</div>
            </div>
            <div class="quick-start-card" data-guide-section="quick-start" title="Click to learn more about selection">
              <div class="qs-icon">ðŸŽ¯</div>
              <div class="qs-title">Select Items</div>
              <div class="qs-desc">Click or Alt+drag</div>
              <div class="qs-link">Learn more â†’</div>
            </div>
            <div class="quick-start-card" data-guide-section="containers" title="Click to learn more about containers">
              <div class="qs-icon">ðŸ“¦</div>
              <div class="qs-title">Containers</div>
              <div class="qs-desc">Group and organize</div>
              <div class="qs-link">Learn more â†’</div>
            </div>
            <div class="quick-start-card" data-guide-section="tags" title="Click to learn more about tags">
              <div class="qs-icon">ðŸ·ï¸</div>
              <div class="qs-title">Tags & Labels</div>
              <div class="qs-desc">Categorize elements</div>
              <div class="qs-link">Learn more â†’</div>
            </div>
            <div class="quick-start-card" data-guide-section="route-finder" title="Click to learn more about route finding">
              <div class="qs-icon">ðŸ›¤ï¸</div>
              <div class="qs-title">Find Routes</div>
              <div class="qs-desc">Optimal path calculation</div>
              <div class="qs-link">Learn more â†’</div>
            </div>
          </div>

          <h4 style="margin: 24px 0 12px; font-size: 15px; color: #333;">ðŸ“– Quick Actions</h4>
          <div class="help-action-buttons">
            <button class="help-action-btn" data-guide-section="canvas-view">
              <span>ðŸŽ¨</span> Canvas View Guide
            </button>
            <button class="help-action-btn" data-guide-section="dynamic-map">
              <span>ðŸŒ</span> Map View Guide
            </button>
            <button class="help-action-btn" data-guide-section="data-table">
              <span>ðŸ“Š</span> Data Table Guide
            </button>
            <button class="help-action-btn" data-guide-section="cost-model">
              <span>ðŸ’°</span> Cost Model Guide
            </button>
          </div>

          <h4 style="margin: 24px 0 12px; font-size: 15px; color: #333;">Basic Workflow</h4>
          <ol style="padding-left: 20px; color: #555; line-height: 1.8;">
            <li><strong>Create nodes</strong> by double-clicking on the canvas or selecting a shape from the toolbar</li>
            <li><strong>Connect nodes</strong> by clicking and dragging from one node to another</li>
            <li><strong>Edit properties</strong> using the Inspector panel on the right (press I to toggle)</li>
            <li><strong>Organize</strong> your diagram with containers and groups</li>
            <li><strong>Save</strong> your work with Ctrl+S or File â†’ Save</li>
          </ol>

          <h4 style="margin: 20px 0 12px; font-size: 15px; color: #333;">Canvas Navigation</h4>
          <ul style="padding-left: 20px; color: #555; line-height: 1.8;">
            <li><strong>Pan:</strong> Click and drag on empty canvas space</li>
            <li><strong>Zoom:</strong> Ctrl + mouse wheel, or use the zoom controls in the toolbar</li>
            <li><strong>Fit to view:</strong> Press Enter or click the Fit button</li>
          </ul>
        </div>

        <!-- Keyboard Shortcuts Section -->
        <div class="help-section" id="help-shortcuts">
          <h3><span class="section-icon">âŒ¨ï¸</span> Keyboard Shortcuts</h3>
          <p>Master these shortcuts to work faster with NexiMap Studio.</p>

          <!-- Canvas Navigation -->
          <div class="help-accordion expanded">
            <div class="help-accordion-header">
              <span>ðŸ§­ Canvas Navigation</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="help-accordion-content">
              <div class="help-accordion-inner">
                <div class="shortcut-row">
                  <span class="shortcut-desc">Pan canvas</span>
                  <span class="shortcut-keys"><kbd>Drag</kbd><span class="plus">on empty space</span></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Zoom in/out</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>Wheel</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Reset zoom to 100%</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>0</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Fit to view</span>
                  <span class="shortcut-keys"><kbd>Enter</kbd></span>
                </div>
              </div>
            </div>
          </div>

          <!-- Selection & Editing -->
          <div class="help-accordion">
            <div class="help-accordion-header">
              <span>ðŸŽ¯ Selection & Editing</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="help-accordion-content">
              <div class="help-accordion-inner">
                <div class="shortcut-row">
                  <span class="shortcut-desc">Create new node</span>
                  <span class="shortcut-keys"><kbd>Double-click</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Selection box</span>
                  <span class="shortcut-keys"><kbd>Alt</kbd><span class="plus">+</span><kbd>Drag</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Add to selection</span>
                  <span class="shortcut-keys"><kbd>Shift</kbd><span class="plus">+</span><kbd>Click</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Delete selected</span>
                  <span class="shortcut-keys"><kbd>Del</kbd><span class="plus">/</span><kbd>Backspace</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Move text labels</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>Drag</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Select all</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>A</kbd></span>
                </div>
              </div>
            </div>
          </div>

          <!-- Edit Operations -->
          <div class="help-accordion">
            <div class="help-accordion-header">
              <span>âœ‚ï¸ Edit Operations</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="help-accordion-content">
              <div class="help-accordion-inner">
                <div class="shortcut-row">
                  <span class="shortcut-desc">Copy</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>C</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Cut</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>X</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Paste</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>V</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Undo</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>Z</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Redo</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>Shift</kbd><span class="plus">+</span><kbd>Z</kbd></span>
                </div>
              </div>
            </div>
          </div>

          <!-- File Operations -->
          <div class="help-accordion">
            <div class="help-accordion-header">
              <span>ðŸ“ File Operations</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="help-accordion-content">
              <div class="help-accordion-inner">
                <div class="shortcut-row">
                  <span class="shortcut-desc">New diagram</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>N</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Open file</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>O</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Save</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>S</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Print</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>P</kbd></span>
                </div>
              </div>
            </div>
          </div>

          <!-- View Controls -->
          <div class="help-accordion">
            <div class="help-accordion-header">
              <span>ðŸ‘ï¸ View Controls</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="help-accordion-content">
              <div class="help-accordion-inner">
                <div class="shortcut-row">
                  <span class="shortcut-desc">Toggle Inspector</span>
                  <span class="shortcut-keys"><kbd>I</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Toggle Tag filter</span>
                  <span class="shortcut-keys"><kbd>F</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Open Data Table</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>T</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Open Help Center</span>
                  <span class="shortcut-keys"><kbd>F1</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Close modals</span>
                  <span class="shortcut-keys"><kbd>Esc</kbd></span>
                </div>
              </div>
            </div>
          </div>

          <!-- Data & Filters -->
          <div class="help-accordion">
            <div class="help-accordion-header">
              <span>ðŸ“Š Data & Filters</span>
              <span class="accordion-icon">â–¼</span>
            </div>
            <div class="help-accordion-content">
              <div class="help-accordion-inner">
                <div class="shortcut-row">
                  <span class="shortcut-desc">Open Data Table</span>
                  <span class="shortcut-keys"><kbd>Ctrl</kbd><span class="plus">+</span><kbd>T</kbd></span>
                </div>
                <div class="shortcut-row">
                  <span class="shortcut-desc">Toggle Tag filter</span>
                  <span class="shortcut-keys"><kbd>F</kbd></span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Features Guide Section -->
        <div class="help-section" id="help-features">
          <h3><span class="section-icon">ðŸŽ¯</span> Features Guide</h3>
          <p>Explore the powerful features of NexiMap Studio. Click any card to open the detailed guide.</p>

          <div class="feature-grid">
            <div class="feature-card" data-guide-section="nodes">
              <h4><span class="feature-icon">ðŸ“</span> Nodes</h4>
              <p>Create network nodes with customizable shapes, colors, sizes, and labels. Nodes support GPS coordinates for geo-mapping.</p>
              <span class="feature-link">View full guide â†’</span>
            </div>
            <div class="feature-card" data-guide-section="links">
              <h4><span class="feature-icon">ðŸ”—</span> Links</h4>
              <p>Connect nodes with links that can display labels, costs, capacity, and latency. Support for curved and straight lines.</p>
              <span class="feature-link">View full guide â†’</span>
            </div>
            <div class="feature-card" data-guide-section="containers">
              <h4><span class="feature-icon">ðŸ“¦</span> Containers</h4>
              <p>Group related nodes into containers. Containers can represent locations, regions, or logical groupings.</p>
              <span class="feature-link">View full guide â†’</span>
            </div>
            <div class="feature-card" data-guide-section="tags">
              <h4><span class="feature-icon">ðŸ·ï¸</span> Tags & Labels</h4>
              <p>Add tags to nodes, links, and containers for easy filtering and organization. Use the Label Manager for bulk operations.</p>
              <span class="feature-link">View full guide â†’</span>
            </div>
            <div class="feature-card" data-guide-section="static-geo">
              <h4><span class="feature-icon">ðŸ—ºï¸</span> Static Geo View</h4>
              <p>Visualize your network on a static geographic map using GPS coordinates. Works offline with custom backgrounds.</p>
              <span class="feature-link">View full guide â†’</span>
            </div>
            <div class="feature-card" data-guide-section="dynamic-map">
              <h4><span class="feature-icon">ðŸŒ</span> Interactive Map</h4>
              <p>Use the dynamic MapLibre-powered map for zoomable, pannable geographic visualization with OpenStreetMap tiles.</p>
              <span class="feature-link">View full guide â†’</span>
            </div>
            <div class="feature-card" data-guide-section="data-table">
              <h4><span class="feature-icon">ðŸ“Š</span> Data Table</h4>
              <p>View and edit all your data in a spreadsheet-like interface. Sort, filter, and bulk edit nodes and links.</p>
              <span class="feature-link">View full guide â†’</span>
            </div>
            <div class="feature-card" data-guide-section="route-finder">
              <h4><span class="feature-icon">ðŸ›¤ï¸</span> Route Finder</h4>
              <p>Find optimal paths between nodes based on cost, latency, or other metrics. Highlight and compare routes.</p>
              <span class="feature-link">View full guide â†’</span>
            </div>
            <div class="feature-card" data-guide-section="cable-systems">
              <h4><span class="feature-icon">ðŸ“</span> Cable Systems</h4>
              <p>Define cable systems to group related links. Filter views by cable system and track system-wide metrics.</p>
              <span class="feature-link">View full guide â†’</span>
            </div>
            <div class="feature-card" data-guide-section="cost-model">
              <h4><span class="feature-icon">ðŸ’°</span> Cost Analysis</h4>
              <p>Calculate costs based on distance, capacity tiers, and commercial models (Lease/IRU). Configure in Financial Settings.</p>
              <span class="feature-link">View full guide â†’</span>
            </div>
            <div class="feature-card" data-guide-section="library">
              <h4><span class="feature-icon">ðŸŽ¨</span> Style Library</h4>
              <p>Save and reuse node styles. Import custom SVG shapes. Format painter for quick style application.</p>
              <span class="feature-link">View full guide â†’</span>
            </div>
            <div class="feature-card" data-guide-section="import-export">
              <h4><span class="feature-icon">ðŸ“¤</span> Export Options</h4>
              <p>Export to SVG, PNG, JPG images or CSV data. Print directly or use Print Preview for fine-tuning.</p>
              <span class="feature-link">View full guide â†’</span>
            </div>
          </div>
        </div>

        <!-- Tips & Tricks Section -->
        <div class="help-section" id="help-tips">
          <h3><span class="section-icon">ðŸ’¡</span> Tips & Tricks</h3>
          <p>Pro tips to boost your productivity with NexiMap Studio.</p>

          <ul class="tips-list">
            <li>
              <span class="tip-icon">â›¡</span>
              <div class="tip-content">
                <div class="tip-title">Quick Node Creation</div>
                <div class="tip-desc">Double-click anywhere on the canvas to create a new node instantly. The node will use your currently selected shape tool.</div>
              </div>
            </li>
            <li>
              <span class="tip-icon">ðŸŽ¨</span>
              <div class="tip-content">
                <div class="tip-title">Format Painter</div>
                <div class="tip-desc">Use the brush tool to copy formatting from one node and apply it to others. Great for consistent styling.</div>
              </div>
            </li>
            <li>
              <span class="tip-icon">ðŸ“</span>
              <div class="tip-content">
                <div class="tip-title">Snap to Grid</div>
                <div class="tip-desc">Enable the grid for precise alignment. The grid size can be customized from Fine (10px) to Extra Large (100px).</div>
              </div>
            </li>
            <li>
              <span class="tip-icon">ðŸ”</span>
              <div class="tip-content">
                <div class="tip-title">Multi-Select with Alt+Drag</div>
                <div class="tip-desc">Hold Alt and drag to create a selection box. All items within the box will be selected for bulk operations.</div>
              </div>
            </li>
            <li>
              <span class="tip-icon">ðŸ·ï¸</span>
              <div class="tip-content">
                <div class="tip-title">Power of Tags</div>
                <div class="tip-desc">Tag items consistently to enable powerful filtering. Use the Label Manager to batch-add or remove tags across multiple items.</div>
              </div>
            </li>
            <li>
              <span class="tip-icon">ðŸ’¾</span>
              <div class="tip-content">
                <div class="tip-title">Auto-Save Recovery</div>
                <div class="tip-desc">NexiMap Studio automatically saves your work. If something goes wrong, use File â†’ Recovery â†’ Recover Autosave.</div>
              </div>
            </li>
            <li>
              <span class="tip-icon">ðŸ—ºï¸</span>
              <div class="tip-content">
                <div class="tip-title">GPS Coordinates</div>
                <div class="tip-desc">Add latitude and longitude to nodes to enable geographic visualization. Click the ðŸŒ button on the map to sync schematic positions from GPS.</div>
              </div>
            </li>
            <li>
              <span class="tip-icon">ðŸ“Š</span>
              <div class="tip-content">
                <div class="tip-title">Data Table Power</div>
                <div class="tip-desc">Open the Data Table (Ctrl+T) for spreadsheet-like editing. Click column headers to sort, use the search to filter, and double-click cells to edit.</div>
              </div>
            </li>
          </ul>
        </div>

        <!-- FAQ Section -->
        <div class="help-section" id="help-faq">
          <h3><span class="section-icon">â“</span> Frequently Asked Questions</h3>

          <div class="faq-item">
            <div class="faq-question">
              <span>How do I connect two nodes?</span>
              <span class="faq-icon">+</span>
            </div>
            <div class="faq-answer">
              <div class="faq-answer-inner">
                Click on the source node and drag towards the target node. A link will be created automatically when you release the mouse over another node.
              </div>
            </div>
          </div>

          <div class="faq-item">
            <div class="faq-question">
              <span>How do I delete items?</span>
              <span class="faq-icon">+</span>
            </div>
            <div class="faq-answer">
              <div class="faq-answer-inner">
                Select the item(s) you want to delete and press the Delete or Backspace key. You can also click the trash icon in the toolbar. Use Ctrl+Z to undo if needed.
              </div>
            </div>
          </div>

          <div class="faq-item">
            <div class="faq-question">
              <span>Can I import data from Excel?</span>
              <span class="faq-icon">+</span>
            </div>
            <div class="faq-answer">
              <div class="faq-answer-inner">
                Yes! Go to File â†’ Import/Export â†’ Download Import Template to get the Excel template. Fill in your data and use Import from Spreadsheet to load it.
              </div>
            </div>
          </div>

          <div class="faq-item">
            <div class="faq-question">
              <span>How do I show my network on a map?</span>
              <span class="faq-icon">+</span>
            </div>
            <div class="faq-answer">
              <div class="faq-answer-inner">
                First, add GPS coordinates (latitude/longitude) to your nodes in the Inspector panel. Then click the "Geo" button for a static map or the "Map" button for an interactive map.
              </div>
            </div>
          </div>

          <div class="faq-item">
            <div class="faq-question">
              <span>How do I export my diagram as an image?</span>
              <span class="faq-icon">+</span>
            </div>
            <div class="faq-answer">
              <div class="faq-answer-inner">
                Go to File â†’ Import/Export and choose Export as SVG, PNG, or JPG. SVG is best for scaling, while PNG/JPG are better for sharing.
              </div>
            </div>
          </div>

          <div class="faq-item">
            <div class="faq-question">
              <span>How do I find the shortest path between nodes?</span>
              <span class="faq-icon">+</span>
            </div>
            <div class="faq-answer">
              <div class="faq-answer-inner">
                Click the "Routes" button in the toolbar to open the Route Finder. Select your start and end nodes, choose your optimization criteria (cost, latency, hops), and click Find Routes.
              </div>
            </div>
          </div>

          <div class="faq-item">
            <div class="faq-question">
              <span>How do I save my file format preferences?</span>
              <span class="faq-icon">+</span>
            </div>
            <div class="faq-answer">
              <div class="faq-answer-inner">
                NexiMap Studio saves your preferences automatically, including grid settings, zoom level, and panel positions. Your financial settings and default styles are also preserved.
              </div>
            </div>
          </div>
        </div>

        <!-- What's New / Changelog Section -->
        <div class="help-section" id="help-changelog">
          <h3><span class="section-icon">ðŸ“‹</span> What's New</h3>

          <div class="changelog-version">
            <div class="changelog-header">
              <span class="changelog-badge latest">v60</span>
              <span class="changelog-date">Latest Release</span>
            </div>
            <ul class="changelog-list">
              <li><span class="change-type new">New</span> Online User Guide - comprehensive documentation hosted on GitHub Pages</li>
              <li><span class="change-type new">New</span> "Full Guide" button in Help Center links to online documentation</li>
              <li><span class="change-type new">New</span> Bulk Price Reset from any capacity tier with configurable multipliers</li>
              <li><span class="change-type new">New</span> IRU from MRC Multiplier setting for automated IRU fee calculation</li>
              <li><span class="change-type improved">Improved</span> Selection Filter in Data Table - always visible and clickable</li>
              <li><span class="change-type fixed">Fixed</span> Help Center layout and search functionality</li>
            </ul>
          </div>

          <div class="changelog-version">
            <div class="changelog-header">
              <span class="changelog-badge">v59</span>
              <span class="changelog-date">Previous Release</span>
            </div>
            <ul class="changelog-list">
              <li><span class="change-type new">New</span> Physical Routing Diversity system for route protection</li>
              <li><span class="change-type new">New</span> Build Your Own Protected Path (BYOPP) wizard</li>
              <li><span class="change-type new">New</span> Save routes to existing Multilink Groups</li>
              <li><span class="change-type improved">Improved</span> Route Finder with diversity enforcement options</li>
            </ul>
          </div>

          <div class="changelog-version">
            <div class="changelog-header">
              <span class="changelog-badge">v58</span>
              <span class="changelog-date">Previous Release</span>
            </div>
            <ul class="changelog-list">
              <li><span class="change-type new">New</span> Capacity Tier Pricing with configurable multipliers</li>
              <li><span class="change-type new">New</span> NPV calculations for IRU cost analysis</li>
              <li><span class="change-type new">New</span> Financial Settings dialog with currency and discount rate</li>
              <li><span class="change-type improved">Improved</span> Cost optimization in Route Finder (Latency/Cost/Balanced)</li>
            </ul>
          </div>

          <div class="changelog-version">
            <div class="changelog-header">
              <span class="changelog-badge">v57</span>
              <span class="changelog-date">Previous Release</span>
            </div>
            <ul class="changelog-list">
              <li><span class="change-type new">New</span> Help Center with searchable content</li>
              <li><span class="change-type new">New</span> Data Table with inline editing and bulk operations</li>
              <li><span class="change-type new">New</span> MapLibre integration for dynamic geographic maps</li>
            </ul>
          </div>
        </div>

        <!-- Search Results Section (hidden by default) -->
        <div class="help-section" id="help-search-results">
          <h3><span class="section-icon">ðŸ”</span> Search Results</h3>
          <div id="searchResultsContent"></div>
        </div>
      </div>
    </div>

    <div id="helpCenterFooter">
      <div class="footer-left">
        <span>Press</span>
        <kbd style="padding:2px 6px; background:#e8e8e8; border:1px solid #ccc; border-radius:3px; font-size:11px;">F1</kbd>
        <span>anytime to open Help</span>
      </div>
      <button class="footer-btn" id="btnPrintShortcuts">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/>
        </svg>
        Print Shortcuts
      </button>
    </div>
    <!-- Resize handles -->
    <div class="help-center-resize-handle right" data-resize="right"></div>
    <div class="help-center-resize-handle bottom" data-resize="bottom"></div>
    <div class="help-center-resize-handle corner" data-resize="corner"></div>
  </div>
</div>

<!-- Path Edit Mode Banner -->
<div id="pathEditModeBanner">
  <div class="banner-content">
    <div class="banner-info">
      <span class="banner-icon">ðŸ›¤ï¸</span>
      <div>
        <div class="banner-title">PATH EDITING MODE</div>
        <div class="banner-subtitle" id="pathEditLinkName">Editing: Link L-15 (Node A â†’ Node B)</div>
      </div>
    </div>
    <div class="banner-status" id="pathEditStatus">
      <span id="pathEditStatusIcon">â—</span>
      <span id="pathEditStatusText">No changes</span>
    </div>
    <div class="banner-actions">
      <button class="banner-btn save" id="btnPathSaveExit" title="Save path and exit edit mode">ðŸ’¾ Save & Exit</button>
      <button class="banner-btn exit" id="btnPathCancelExit" title="Discard changes and exit">âœ• Cancel</button>
    </div>
  </div>
</div>

<!-- Path Edit Mode Overlay (dims other content) -->
<div id="pathEditModeOverlay"></div>

<!-- Path Edit Control Panel -->
<div id="pathEditControlPanel">
  <div class="control-header" id="pathEditPanelHeader">
    <span class="control-title">ðŸ›¤ï¸ Path Editor</span>
    <div style="display:flex; align-items:center; gap:8px;">
      <span class="waypoint-count" id="pathWaypointCount">0 waypoints</span>
      <div class="control-header-btns">
        <button class="control-header-btn" id="btnMinimizePathPanel" title="Minimize">âˆ’</button>
      </div>
    </div>
  </div>

  <div class="control-body">
    <div class="edit-methods">
      <button class="method-btn" id="btnMethodManual" data-method="manual" title="Draw path manually on map">
        <span class="method-icon">âœï¸</span>
        <span class="method-label">Manual</span>
      </button>
      <button class="method-btn" id="btnMethodCableDb" data-method="telegeography" title="Import from Cable Database">
        <span class="method-icon">ðŸŒ</span>
        <span class="method-label">Cable Database</span>
      </button>
      <button class="method-btn" id="btnMethodKML" data-method="kml-import" title="Import KML/GeoJSON">
        <span class="method-icon">ðŸ“¥</span>
        <span class="method-label">Import</span>
      </button>
    </div>

    <div id="pathEditInstructions" style="padding: 10px; background: #f0f9ff; border-radius: 6px; font-size: 11px; color: #0369a1; border: 1px solid #bae6fd;">
      ðŸ‘† Select a method above, then click on the map to add waypoints.
    </div>

    <div class="control-actions" style="flex-wrap: wrap; gap: 6px;">
      <button class="control-btn danger" id="btnPathClear" title="Clear all waypoints">ðŸ—‘ï¸ Clear</button>
      <button class="control-btn secondary" id="btnPathUndo" title="Remove last waypoint">â†©ï¸ Undo</button>
      <button class="control-btn primary" id="btnPathSavePanel" title="Save path and exit" style="margin-left:auto;">ðŸ’¾ Save</button>
    </div>

    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e5e7eb; font-size: 10px; color: #6b7280; line-height: 1.5;">
      <strong>Tips:</strong> Click to add â€¢ Click waypoint to delete â€¢ Scroll to zoom â€¢ Drag map to pan
    </div>
  </div>
</div>

<!-- About Modal -->
<div id="aboutModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.4); z-index:20000; justify-content:center; align-items:center;">
  <div style="background:#fff; border-radius:16px; box-shadow:0 20px 60px rgba(0,0,0,0.3); width:400px; max-width:90vw; overflow:hidden;">
    <div style="padding:24px; text-align:center;">
      <svg width="64" height="64" viewBox="0 0 32 32" style="margin-bottom:16px;">
        <defs>
          <linearGradient id="aboutLogoGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#667eea"/>
            <stop offset="100%" style="stop-color:#764ba2"/>
          </linearGradient>
        </defs>
        <rect x="2" y="2" width="28" height="28" rx="4" fill="url(#aboutLogoGradient)"/>
        <path d="M8 8H24M8 16H24M8 24H24M8 8V24M16 8V24M24 8V24" stroke="white" stroke-width="0.8" opacity="0.2"/>
        <path d="M8 8L16 16L24 8M16 16L8 24M16 16L24 24" stroke="white" stroke-width="1.8" stroke-linecap="round"/>
        <circle cx="8" cy="8" r="2.5" fill="white"/>
        <circle cx="24" cy="8" r="2.5" fill="white"/>
        <circle cx="16" cy="16" r="3" fill="white"/>
        <circle cx="8" cy="24" r="2.5" fill="white"/>
        <circle cx="24" cy="24" r="2.5" fill="white"/>
      </svg>
      <h2 style="margin:0 0 4px; font-size:20px; color:#333;">NexiMap Studio</h2>
      <p style="margin:0 0 16px; color:#888; font-size:13px;" id="aboutVersionText">Version 62.1 <span style="color:#b0b0b0; font-size:11px;">â€¢ Build 2026-02-24</span></p>
      <p style="margin:0 0 20px; color:#555; font-size:13px; line-height:1.6;">
        Professional network topology and diagram design tool with geographic mapping, cost analysis, and route optimization.
      </p>
      <button onclick="this.closest('#aboutModal').style.display='none'" style="padding:10px 24px; background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; border:none; border-radius:8px; font-size:14px; cursor:pointer;">Close</button>
    </div>
  </div>
</div>


<script>
// Help Center JavaScript
(function() {
  const helpCenterModal = document.getElementById('helpCenterModal');
  const btnCloseHelpCenter = document.getElementById('btnCloseHelpCenter');
  const helpSearchInput = document.getElementById('helpSearchInput');
  const helpNavItems = document.querySelectorAll('.help-nav-item');
  const helpSections = document.querySelectorAll('.help-section');
  const accordionHeaders = document.querySelectorAll('.help-accordion-header');
  const faqQuestions = document.querySelectorAll('.faq-question');

  // Menu items
  const miHelpCenter = document.getElementById('miHelpCenter');
  const miOnlineGuide = document.getElementById('miOnlineGuide');
  const miQuickShortcuts = document.getElementById('miQuickShortcuts');
  const miAbout = document.getElementById('miAbout');
  const helpMenu = document.getElementById('helpMenu');

  // Online documentation URL
  const ONLINE_DOCS_URL = 'https://javierroyserrano.github.io/Neximap/';

  // Open Help Center
  function openHelpCenter(section = 'getting-started') {
    helpCenterModal.classList.add('show');
    showSection(section);
    helpSearchInput.value = '';
    helpSearchInput.focus();
    // Close help menu if open
    if (helpMenu) helpMenu.hidden = true;
  }

  // Close Help Center
  function closeHelpCenter() {
    helpCenterModal.classList.remove('show');
  }

  // Show specific section
  function showSection(sectionId) {
    // Update nav
    helpNavItems.forEach(item => {
      item.classList.toggle('active', item.dataset.section === sectionId);
    });
    // Update sections
    helpSections.forEach(section => {
      section.classList.toggle('active', section.id === `help-${sectionId}`);
    });
  }

  // Navigation click handlers
  helpNavItems.forEach(item => {
    item.addEventListener('click', () => {
      showSection(item.dataset.section);
    });
  });

  // Accordion toggle
  accordionHeaders.forEach(header => {
    header.addEventListener('click', () => {
      header.parentElement.classList.toggle('expanded');
    });
  });

  // FAQ toggle
  faqQuestions.forEach(question => {
    question.addEventListener('click', () => {
      question.parentElement.classList.toggle('expanded');
    });
  });

  // Search functionality - comprehensive searchable index
  const searchableContent = [
    // Nodes
    { title: 'Creating Nodes', desc: 'Double-click on canvas to create nodes with customizable shapes, colors, and labels', section: 'nodes', keywords: ['node', 'create', 'double-click', 'shape', 'circle', 'square', 'point', 'location'], icon: 'ðŸ“', category: 'Elements' },
    { title: 'Node Properties', desc: 'Edit node name, code, tags, GPS coordinates, and appearance in the Inspector', section: 'nodes', keywords: ['node', 'property', 'inspector', 'name', 'code', 'gps', 'coordinate', 'latitude', 'longitude'], icon: 'ðŸ“', category: 'Elements' },

    // Links
    { title: 'Creating Links', desc: 'Click and drag from one node to another to create connections', section: 'links', keywords: ['link', 'connect', 'drag', 'connection', 'edge', 'line', 'cable'], icon: 'ðŸ”—', category: 'Elements' },
    { title: 'Link Properties', desc: 'Set latency, capacity, costs (NRC/MRC/IRU), and appearance for links', section: 'links', keywords: ['link', 'property', 'latency', 'capacity', 'cost', 'nrc', 'mrc', 'iru', 'price'], icon: 'ðŸ”—', category: 'Elements' },

    // Containers
    { title: 'Containers', desc: 'Group nodes together with containers for organization and transit costs', section: 'containers', keywords: ['container', 'group', 'box', 'region', 'area', 'transit'], icon: 'ðŸ“¦', category: 'Elements' },

    // Tags
    { title: 'Tags & Labels', desc: 'Add tags to elements for filtering and organization', section: 'tags', keywords: ['tag', 'label', 'filter', 'organize', 'category', 'group'], icon: 'ðŸ·ï¸', category: 'Elements' },

    // Views
    { title: 'Canvas View', desc: 'Schematic/diagrammatic view with free positioning and custom backgrounds', section: 'canvas-view', keywords: ['canvas', 'schematic', 'diagram', 'view', 'background', 'image'], icon: 'ðŸŽ¨', category: 'Views' },
    { title: 'Static Geo View', desc: 'Geographic view with GPS positioning on static map background', section: 'static-geo', keywords: ['geo', 'geographic', 'static', 'gps', 'map', 'position', 'coordinate'], icon: 'ðŸ—ºï¸', category: 'Views' },
    { title: 'Dynamic Map', desc: 'Interactive OpenStreetMap with zoom, pan, and real-time navigation', section: 'dynamic-map', keywords: ['map', 'dynamic', 'interactive', 'openstreetmap', 'maplibre', 'zoom', 'pan'], icon: 'ðŸŒ', category: 'Views' },

    // Data
    { title: 'Data Table', desc: 'Spreadsheet view for bulk editing nodes, links, and costs', section: 'data-table', keywords: ['data', 'table', 'spreadsheet', 'bulk', 'edit', 'csv', 'export'], icon: 'ðŸ“Š', category: 'Data' },
    { title: 'Selection Filter', desc: 'Filter Data Table to show only selected items from canvas', section: 'data-table', keywords: ['selection', 'filter', 'selected', 'table'], icon: 'ðŸ“Š', category: 'Data' },
    { title: 'Heat Map', desc: 'Visualize capacity or price with color-coded links', section: 'heat-map', keywords: ['heat', 'heatmap', 'capacity', 'price', 'color', 'visualize'], icon: 'ðŸŒ¡ï¸', category: 'Data' },

    // Cable Systems & MLG
    { title: 'Cable Systems', desc: 'Group links by physical infrastructure for diversity checking', section: 'cable-systems', keywords: ['cable', 'system', 'infrastructure', 'submarine', 'fiber', 'physical'], icon: 'ðŸ“', category: 'Network' },
    { title: 'Multilink Groups', desc: 'Create protected paths with working and protection routes', section: 'multilink', keywords: ['multilink', 'mlg', 'group', 'protected', 'path', 'working', 'protection'], icon: 'ðŸ”€', category: 'Network' },

    // Routing
    { title: 'Route Finder', desc: 'Find optimal paths by latency, cost, or balanced optimization', section: 'route-finder', keywords: ['route', 'path', 'find', 'optimal', 'latency', 'cost', 'dijkstra'], icon: 'ðŸ›¤ï¸', category: 'Routing' },
    { title: 'Path Diversity', desc: 'Ensure routes dont share physical infrastructure for resilience', section: 'diversity', keywords: ['diversity', 'diverse', 'separate', 'resilience', 'protection', 'redundant'], icon: 'ðŸ¡ï¸', category: 'Routing' },

    // Costs
    { title: 'Cost Model', desc: 'Lease (NRC/MRC/ACV) and IRU pricing with NPV calculations', section: 'cost-model', keywords: ['cost', 'price', 'lease', 'nrc', 'mrc', 'acv', 'iru', 'npv', 'commercial'], icon: 'ðŸ’°', category: 'Commercial' },
    { title: 'Financial Settings', desc: 'Configure currency, discount rate, and tier multipliers', section: 'financial-settings', keywords: ['financial', 'setting', 'currency', 'discount', 'rate', 'multiplier', 'tier'], icon: 'â›™ï¸', category: 'Commercial' },
    { title: 'Bulk Price Reset', desc: 'Calculate all tier prices from a single source tier', section: 'price-reset', keywords: ['bulk', 'price', 'reset', 'tier', 'multiplier', 'calculate'], icon: 'ðŸ”„', category: 'Commercial' },

    // Library
    { title: 'Style Library', desc: 'Save and reuse node styles, import custom SVG icons', section: 'library', keywords: ['library', 'style', 'save', 'reuse', 'svg', 'icon', 'custom', 'format'], icon: 'ðŸ“›', category: 'Styling' },

    // Import/Export
    { title: 'Import & Export', desc: 'Save projects, export images (PNG/SVG/JPG), and CSV data', section: 'import-export', keywords: ['import', 'export', 'save', 'png', 'svg', 'jpg', 'csv', 'print'], icon: 'ðŸ“¤', category: 'Files' },

    // Shortcuts
    { title: 'Keyboard Shortcuts', desc: 'Master shortcuts for faster workflow', section: 'shortcuts', keywords: ['keyboard', 'shortcut', 'key', 'ctrl', 'hotkey', 'accelerator'], icon: 'âŒ¨ï¸', category: 'Reference' },

    // Interface
    { title: 'Toolbar Buttons', desc: 'Overview of all toolbar buttons and panel toggles', section: 'toolbar', keywords: ['toolbar', 'button', 'panel', 'toggle', 'interface'], icon: 'ðŸ”§', category: 'Interface' },
    { title: 'Inspector Panel', desc: 'Edit properties of selected elements', section: 'interface', keywords: ['inspector', 'panel', 'property', 'edit', 'right'], icon: 'ðŸ“', category: 'Interface' }
  ];

  helpSearchInput.addEventListener('input', () => {
    const query = helpSearchInput.value.toLowerCase().trim();

    if (query.length < 2) {
      // Show last active section or getting started
      const activeNav = document.querySelector('.help-nav-item.active');
      if (activeNav && activeNav.dataset.section !== 'search-results') {
        showSection(activeNav.dataset.section);
      } else {
        showSection('getting-started');
      }
      return;
    }

    // Find matching items
    const matches = searchableContent.filter(item =>
      item.keywords.some(keyword => keyword.includes(query) || query.includes(keyword)) ||
      item.title.toLowerCase().includes(query) ||
      item.desc.toLowerCase().includes(query)
    );

    // Always show search results section
    const resultsSection = document.getElementById('help-search-results');
    const resultsContent = document.getElementById('searchResultsContent');

    if (matches.length > 0) {
      // Group by category
      const grouped = {};
      matches.forEach(match => {
        if (!grouped[match.category]) grouped[match.category] = [];
        grouped[match.category].push(match);
      });

      let html = `
        <div class="search-results-header">
          <span class="results-count">${matches.length} result${matches.length > 1 ? 's' : ''}</span> for "<strong>${query}</strong>"
        </div>
        <div class="search-results-list">
      `;

      for (const [category, items] of Object.entries(grouped)) {
        html += `<div class="search-category">${category}</div>`;
        items.forEach(item => {
          html += `
            <div class="search-result-item" data-section="${item.section}" onclick="window.open('${ONLINE_DOCS_URL}#${item.section}', '_blank')">
              <div class="result-icon">${item.icon}</div>
              <div class="result-content">
                <div class="result-title">${item.title}</div>
                <div class="result-desc">${item.desc}</div>
              </div>
              <div class="result-arrow">â†’</div>
            </div>
          `;
        });
      }

      html += `
        </div>
        <div class="search-results-footer">
          <button onclick="window.open('${ONLINE_DOCS_URL}', '_blank')" class="search-full-guide-btn">
            ðŸŒ Browse Full Documentation
          </button>
        </div>
      `;

      resultsContent.innerHTML = html;
    } else {
      // No results found
      resultsContent.innerHTML = `
        <div class="help-no-results">
          <div class="no-results-icon">ðŸ”</div>
          <p>No results found for "<strong>${query}</strong>"</p>
          <p style="color:#888; font-size:12px; margin-top:8px;">Try different keywords or search the full documentation.</p>
          <button onclick="window.open('${ONLINE_DOCS_URL}', '_blank')" class="search-full-guide-btn" style="margin-top:16px;">
            ðŸŒ Search Online Documentation
          </button>
        </div>
      `;
    }

    // Show search results section
    helpSections.forEach(section => section.classList.remove('active'));
    resultsSection.classList.add('active');
    helpNavItems.forEach(item => item.classList.remove('active'));
  });

  // Menu item handlers
  if (miHelpCenter) {
    miHelpCenter.addEventListener('click', () => {
      openHelpCenter('getting-started');
    });
  }

  // Open Online User Guide
  if (miOnlineGuide) {
    miOnlineGuide.addEventListener('click', () => {
      if (helpMenu) helpMenu.hidden = true;
      window.open(ONLINE_DOCS_URL, '_blank');
    });
  }

  if (miQuickShortcuts) {
    miQuickShortcuts.addEventListener('click', () => {
      openHelpCenter('shortcuts');
    });
  }

  if (miAbout) {
    miAbout.addEventListener('click', () => {
      if (helpMenu) helpMenu.hidden = true;
      document.getElementById('aboutModal').style.display = 'flex';
    });
  }

  // Version badge in header â€” click to open About
  document.getElementById('appVersionBadge')?.addEventListener('click', () => {
    document.getElementById('aboutModal').style.display = 'flex';
  });

  // Close button
  if (btnCloseHelpCenter) {
    btnCloseHelpCenter.addEventListener('click', closeHelpCenter);
  }

  // Full Guide button - opens online documentation
  const btnOpenOnlineDocs = document.getElementById('btnOpenOnlineDocs');
  if (btnOpenOnlineDocs) {
    btnOpenOnlineDocs.addEventListener('click', () => {
      window.open(ONLINE_DOCS_URL, '_blank');
    });
  }

  // Close on background click
  helpCenterModal.addEventListener('click', (e) => {
    if (e.target === helpCenterModal) {
      closeHelpCenter();
    }
  });

  // ============== HELP CENTER DRAG & RESIZE ==============

  const helpCenterContent = document.getElementById('helpCenterContent');
  const helpCenterHeader = document.getElementById('helpCenterHeader');

  // Drag functionality
  let isDragging = false;
  let dragStartX, dragStartY, dragStartLeft, dragStartTop;

  helpCenterHeader.addEventListener('mousedown', (e) => {
    // Don't drag if clicking on buttons
    if (e.target.closest('button')) return;

    isDragging = true;
    helpCenterContent.classList.add('dragging');

    const rect = helpCenterContent.getBoundingClientRect();
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    dragStartLeft = rect.left;
    dragStartTop = rect.top;

    // If not already positioned, set initial position
    if (!helpCenterContent.classList.contains('positioned')) {
      helpCenterContent.classList.add('positioned');
      helpCenterContent.style.left = dragStartLeft + 'px';
      helpCenterContent.style.top = dragStartTop + 'px';
    }

    e.preventDefault();
  });

  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;

    const dx = e.clientX - dragStartX;
    const dy = e.clientY - dragStartY;

    let newLeft = dragStartLeft + dx;
    let newTop = dragStartTop + dy;

    // Keep within viewport bounds
    const maxLeft = window.innerWidth - helpCenterContent.offsetWidth;
    const maxTop = window.innerHeight - helpCenterContent.offsetHeight;

    newLeft = Math.max(0, Math.min(newLeft, maxLeft));
    newTop = Math.max(0, Math.min(newTop, maxTop));

    helpCenterContent.style.left = newLeft + 'px';
    helpCenterContent.style.top = newTop + 'px';
  });

  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      helpCenterContent.classList.remove('dragging');
    }
  });

  // Resize functionality
  let isResizing = false;
  let resizeType = null;
  let resizeStartX, resizeStartY, resizeStartWidth, resizeStartHeight, resizeStartLeft, resizeStartTop;

  document.querySelectorAll('.help-center-resize-handle').forEach(handle => {
    handle.addEventListener('mousedown', (e) => {
      isResizing = true;
      resizeType = handle.dataset.resize;

      const rect = helpCenterContent.getBoundingClientRect();
      resizeStartX = e.clientX;
      resizeStartY = e.clientY;
      resizeStartWidth = rect.width;
      resizeStartHeight = rect.height;
      resizeStartLeft = rect.left;
      resizeStartTop = rect.top;

      // If not already positioned, set initial position
      if (!helpCenterContent.classList.contains('positioned')) {
        helpCenterContent.classList.add('positioned');
        helpCenterContent.style.left = resizeStartLeft + 'px';
        helpCenterContent.style.top = resizeStartTop + 'px';
      }

      helpCenterContent.classList.add('dragging');
      e.preventDefault();
      e.stopPropagation();
    });
  });

  document.addEventListener('mousemove', (e) => {
    if (!isResizing) return;

    const dx = e.clientX - resizeStartX;
    const dy = e.clientY - resizeStartY;

    const minWidth = 400;
    const minHeight = 300;
    const maxWidth = window.innerWidth - 40;
    const maxHeight = window.innerHeight - 40;

    if (resizeType === 'right' || resizeType === 'corner') {
      const newWidth = Math.max(minWidth, Math.min(resizeStartWidth + dx, maxWidth));
      helpCenterContent.style.width = newWidth + 'px';
      helpCenterContent.style.maxWidth = 'none';
    }

    if (resizeType === 'bottom' || resizeType === 'corner') {
      const newHeight = Math.max(minHeight, Math.min(resizeStartHeight + dy, maxHeight));
      helpCenterContent.style.height = newHeight + 'px';
      helpCenterContent.style.maxHeight = 'none';
    }
  });

  document.addEventListener('mouseup', () => {
    if (isResizing) {
      isResizing = false;
      resizeType = null;
      helpCenterContent.classList.remove('dragging');
    }
  });

  // Reset position when closing
  const originalCloseHelpCenter = closeHelpCenter;
  closeHelpCenter = function() {
    helpCenterContent.classList.remove('positioned', 'dragging');
    helpCenterContent.style.left = '';
    helpCenterContent.style.top = '';
    helpCenterContent.style.width = '';
    helpCenterContent.style.height = '';
    helpCenterContent.style.maxWidth = '';
    helpCenterContent.style.maxHeight = '';
    originalCloseHelpCenter();
  };

  // ============== END HELP CENTER DRAG & RESIZE ==============

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // F1 to open Help Center
    if (e.key === 'F1') {
      e.preventDefault();
      if (helpCenterModal.classList.contains('show')) {
        closeHelpCenter();
      } else {
        openHelpCenter('getting-started');
      }
    }
    // Escape to close
    if (e.key === 'Escape' && helpCenterModal.classList.contains('show')) {
      closeHelpCenter();
    }
  });

  // Print shortcuts button
  const btnPrintShortcuts = document.getElementById('btnPrintShortcuts');
  if (btnPrintShortcuts) {
    btnPrintShortcuts.addEventListener('click', () => {
      const printContent = `
        <html>
        <head>
          <title>NexiMap Studio - Keyboard Shortcuts</title>
          <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 40px; max-width: 800px; margin: 0 auto; }
            h1 { font-size: 24px; margin-bottom: 8px; }
            h2 { font-size: 16px; margin-top: 24px; margin-bottom: 12px; color: #555; border-bottom: 1px solid #e0e0e0; padding-bottom: 4px; }
            .subtitle { color: #888; font-size: 14px; margin-bottom: 32px; }
            table { width: 100%; border-collapse: collapse; margin-bottom: 16px; }
            td { padding: 6px 0; font-size: 13px; }
            td:first-child { width: 60%; }
            td:last-child { text-align: right; font-family: monospace; color: #666; }
            kbd { background: #f0f0f0; border: 1px solid #ccc; padding: 2px 6px; border-radius: 3px; font-size: 11px; }
            @media print { body { padding: 20px; } }
          </style>
        </head>
        <body>
          <h1>NexiMap Studio</h1>
          <p class="subtitle">Keyboard Shortcuts Reference</p>

          <h2>Canvas Navigation</h2>
          <table>
            <tr><td>Pan canvas</td><td><kbd>Drag</kbd> on empty space</td></tr>
            <tr><td>Zoom in/out</td><td><kbd>Ctrl</kbd> + <kbd>Wheel</kbd></td></tr>
            <tr><td>Reset zoom to 100%</td><td><kbd>Ctrl</kbd> + <kbd>0</kbd></td></tr>
            <tr><td>Fit to view</td><td><kbd>Enter</kbd></td></tr>
          </table>

          <h2>Selection & Editing</h2>
          <table>
            <tr><td>Create new node</td><td><kbd>Double-click</kbd></td></tr>
            <tr><td>Selection box</td><td><kbd>Alt</kbd> + <kbd>Drag</kbd></td></tr>
            <tr><td>Add to selection</td><td><kbd>Shift</kbd> + <kbd>Click</kbd></td></tr>
            <tr><td>Delete selected</td><td><kbd>Del</kbd> / <kbd>Backspace</kbd></td></tr>
            <tr><td>Move text labels</td><td><kbd>Ctrl</kbd> + <kbd>Drag</kbd></td></tr>
            <tr><td>Select all</td><td><kbd>Ctrl</kbd> + <kbd>A</kbd></td></tr>
          </table>

          <h2>Edit Operations</h2>
          <table>
            <tr><td>Copy</td><td><kbd>Ctrl</kbd> + <kbd>C</kbd></td></tr>
            <tr><td>Cut</td><td><kbd>Ctrl</kbd> + <kbd>X</kbd></td></tr>
            <tr><td>Paste</td><td><kbd>Ctrl</kbd> + <kbd>V</kbd></td></tr>
            <tr><td>Undo</td><td><kbd>Ctrl</kbd> + <kbd>Z</kbd></td></tr>
            <tr><td>Redo</td><td><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Z</kbd></td></tr>
          </table>

          <h2>File Operations</h2>
          <table>
            <tr><td>New diagram</td><td><kbd>Ctrl</kbd> + <kbd>N</kbd></td></tr>
            <tr><td>Open file</td><td><kbd>Ctrl</kbd> + <kbd>O</kbd></td></tr>
            <tr><td>Save</td><td><kbd>Ctrl</kbd> + <kbd>S</kbd></td></tr>
            <tr><td>Print</td><td><kbd>Ctrl</kbd> + <kbd>P</kbd></td></tr>
          </table>

          <h2>View Controls</h2>
          <table>
            <tr><td>Toggle Inspector</td><td><kbd>I</kbd></td></tr>
            <tr><td>Toggle Tag filter</td><td><kbd>F</kbd></td></tr>
            <tr><td>Open Data Table</td><td><kbd>Ctrl</kbd> + <kbd>T</kbd></td></tr>
            <tr><td>Open Help Center</td><td><kbd>F1</kbd></td></tr>
            <tr><td>Close modals</td><td><kbd>Esc</kbd></td></tr>
          </table>
        </body>
        </html>
      `;

      const printWindow = window.open('', '_blank');
      printWindow.document.write(printContent);
      printWindow.document.close();
      printWindow.print();
    });
  }

  // Quick start card actions - open online documentation
  document.querySelectorAll('.quick-start-card[data-guide-section]').forEach(card => {
    card.addEventListener('click', () => {
      const section = card.dataset.guideSection;
      if (section) {
        window.open(ONLINE_DOCS_URL + '#' + section, '_blank');
      }
    });
  });

  // Help action buttons - open online documentation
  document.querySelectorAll('.help-action-btn[data-guide-section]').forEach(btn => {
    btn.addEventListener('click', () => {
      const section = btn.dataset.guideSection;
      if (section) {
        window.open(ONLINE_DOCS_URL + '#' + section, '_blank');
      }
    });
  });

  // Feature cards - open online documentation
  document.querySelectorAll('.feature-card[data-guide-section]').forEach(card => {
    card.addEventListener('click', () => {
      const section = card.dataset.guideSection;
      if (section) {
        window.open(ONLINE_DOCS_URL + '#' + section, '_blank');
      }
    });
  });

  // About modal close on background click
  const aboutModal = document.getElementById('aboutModal');
  if (aboutModal) {
    aboutModal.addEventListener('click', (e) => {
      if (e.target === aboutModal) {
        aboutModal.style.display = 'none';
      }
    });
  }

  // ============== PATH EDIT MODE EVENT LISTENERS ==============

  // Edit Path Geometry button in inspector
  document.getElementById('btnEditPathGeometry')?.addEventListener('click', () => {
    // Access main script state via window
    if (window.state?.selected?.type === 'edge') {
      window.enterPathEditMode(window.state.selected.id);
    } else {
    }
  });

  // Edit existing path button
  document.getElementById('btnEditExistingPath')?.addEventListener('click', () => {
    if (window.state?.selected?.type === 'edge') {
      window.enterPathEditMode(window.state.selected.id);
    }
  });

  // Remove path button
  document.getElementById('btnRemovePath')?.addEventListener('click', () => {
    if (window.state?.selected?.type === 'edge') {
      if (confirm('Remove the path geometry from this link? The link will be shown as a straight line.')) {
        window.removePathFromLink(window.state.selected.id);
      }
    }
  });

  // Path Edit Mode Banner buttons
  document.getElementById('btnPathSaveExit')?.addEventListener('click', () => {
    window.exitPathEditMode(true);
  });

  document.getElementById('btnPathCancelExit')?.addEventListener('click', () => {
    if (window.state?.pathEditMode?.hasUnsavedChanges) {
      if (confirm('Discard unsaved changes to the path?')) {
        window.exitPathEditMode(false);
      }
    } else {
      window.exitPathEditMode(false);
    }
  });

  // Path Edit Control Panel method buttons
  document.querySelectorAll('#pathEditControlPanel .method-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const method = btn.dataset.method;

      // Update active state
      document.querySelectorAll('#pathEditControlPanel .method-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      if (window.state?.pathEditMode) {
        window.state.pathEditMode.editMethod = method;
      }

      // Update instructions
      const instructions = document.getElementById('pathEditInstructions');
      if (instructions) {
        switch (method) {
          case 'manual':
            instructions.innerHTML = '<strong>Manual Draw Mode:</strong> Click on the map to add waypoints. Click existing waypoints to remove them. Drag waypoints to reposition.';
            // Enable map click for manual mode
            if (window.mapLibreState?.map && window.enableManualPathDrawing) {
              window.enableManualPathDrawing();
            }
            break;
          case 'telegeography':
            instructions.innerHTML = '<strong>Cable Database Import:</strong> Enter cable name to search...';
            // Show Cable Database search interface
            if (window.showCableDbSearch) {
              window.showCableDbSearch();
            }
            break;
          case 'kml-import':
            instructions.innerHTML = '<strong>KML/GeoJSON Import:</strong> Select a .kml, .geojson, or .json file...';
            // Create a hidden file input, attach listener, and click it immediately
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.kml,.geojson,.json';
            fileInput.style.display = 'none';
            fileInput.addEventListener('change', (e) => {
              if (window.handlePathKmlImport) {
                window.handlePathKmlImport(e);
              }
              fileInput.remove();
            });
            document.body.appendChild(fileInput);
            fileInput.click();
            break;
        }
      }
    });
  });

  // Clear path button
  document.getElementById('btnPathClear')?.addEventListener('click', () => {
    if (window.state?.pathEditMode?.currentPath?.length > 0) {
      if (confirm('Clear all waypoints from this path?')) {
        window.state.pathEditMode.currentPath = [];
        window.state.pathEditMode.currentSegments = null;
        window.state.pathEditMode.hasUnsavedChanges = true;
        if (window.updatePathEditStatus) window.updatePathEditStatus();
        if (window.updateWaypointCount) window.updateWaypointCount();
        if (window.renderPathEditingView) window.renderPathEditingView();
      }
    }
  });

  // Undo last waypoint
  document.getElementById('btnPathUndo')?.addEventListener('click', () => {
    if (window.state?.pathEditMode?.currentPath?.length > 0) {
      window.state.pathEditMode.currentPath.pop();
      window.state.pathEditMode.currentSegments = null; // Manual edit breaks segments
      window.state.pathEditMode.hasUnsavedChanges = true;
      if (window.updatePathEditStatus) window.updatePathEditStatus();
      if (window.updateWaypointCount) window.updateWaypointCount();
      if (window.renderPathEditingView) window.renderPathEditingView();
    }
  });

  // Save button in panel (same as Save & Exit in banner)
  document.getElementById('btnPathSavePanel')?.addEventListener('click', () => {
    window.exitPathEditMode(true);
  });

  // Minimize path edit panel
  document.getElementById('btnMinimizePathPanel')?.addEventListener('click', () => {
    const panel = document.getElementById('pathEditControlPanel');
    const btn = document.getElementById('btnMinimizePathPanel');
    if (panel) {
      panel.classList.toggle('minimized');
      if (btn) {
        btn.textContent = panel.classList.contains('minimized') ? '+' : 'âˆ’';
        btn.title = panel.classList.contains('minimized') ? 'Expand' : 'Minimize';
      }
    }
  });

  // Make path edit panel draggable
  (function() {
    const panel = document.getElementById('pathEditControlPanel');
    const header = document.getElementById('pathEditPanelHeader');
    if (!panel || !header) return;

    let isDragging = false;
    let startX, startY, startLeft, startBottom;

    header.addEventListener('mousedown', (e) => {
      if (e.target.closest('.control-header-btn')) return; // Don't drag when clicking buttons
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      const rect = panel.getBoundingClientRect();
      startLeft = rect.left;
      startBottom = window.innerHeight - rect.bottom;
      panel.style.transition = 'none';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      panel.style.left = Math.max(0, startLeft + dx) + 'px';
      panel.style.bottom = Math.max(0, startBottom - dy) + 'px';
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        panel.style.transition = '';
      }
    });
  })();

  // ============== DATACENTER NAVIGATOR ==============

  // Helper to escape HTML (local to this scope)
  function escapeHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  // DC database state
  window._dcDatabase = { facilities: [], meta: {}, loaded: false };
  window._dcExpandedId = null;  // Currently expanded detail panel
  window._dcSelectedId = null;

  // Load PeeringDB facilities database + cable stations from separate file
  async function loadDCDatabase() {
    try {
      const resp = await fetch('data/peeringdb_facilities.json');
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const data = await resp.json();
      window._dcDatabase = { facilities: data.facilities || [], meta: data.meta || {}, loaded: true };
      console.log(`[DC] Loaded ${window._dcDatabase.facilities.length} facilities from PeeringDB`);

      // Load cable stations from separate file and merge
      await mergeCableStationsDatabase();
      renderDCList();
      populateDCCountryFilter();
    } catch (err) {
      console.error('[DC] Failed to load database:', err);
      document.getElementById('dcList').innerHTML = '<div class="muted" style="padding:12px; text-align:center; color:#b91c1c;">Failed to load datacenter database.</div>';
    }
  }

  // Load cable stations from dedicated file and merge into _dcDatabase
  async function mergeCableStationsDatabase() {
    try {
      // Try cable_stations_db.json first (comprehensive), fall back to cable_stations.json
      let resp = await fetch('data/cable_stations_db.json');
      if (!resp.ok) {
        resp = await fetch('data/cable_stations.json');
      }
      if (!resp.ok) {
        console.warn(`[DC] No cable stations file found (HTTP ${resp.status}), skipping.`);
        return;
      }
      const csData = await resp.json();
      const csFacilities = csData.facilities || [];
      if (csFacilities.length === 0) return;

      // Avoid duplicates: collect existing IDs
      const existingIds = new Set(window._dcDatabase.facilities.map(f => f.id));
      let merged = 0;
      for (const cs of csFacilities) {
        if (!existingIds.has(cs.id)) {
          window._dcDatabase.facilities.push(cs);
          existingIds.add(cs.id);
          merged++;
        }
      }

      // Update meta counts
      const totalCS = window._dcDatabase.facilities.filter(f => (f.facility_type || 'datacenter') === 'cable_station').length;
      window._dcDatabase.meta.total_cable_stations = totalCS;
      window._dcDatabase.meta.total_facilities = window._dcDatabase.facilities.length;

      console.log(`[DC] Merged ${merged} cable stations (${totalCS} total cable stations)`);
    } catch (err) {
      console.warn('[DC] Could not load cable stations, continuing without them:', err.message);
    }
  }

  // Carrier density class
  function getDCDensityClass(fac) {
    const c = (fac.carrier_count || 0) + (fac.ix_count || 0);
    if (c >= 50) return 'density-critical';
    if (c >= 20) return 'density-high';
    if (c >= 5) return 'density-medium';
    if (c >= 1) return 'density-low';
    return 'density-minimal';
  }

  // Populate country filter dropdown
  function populateDCCountryFilter() {
    const sel = document.getElementById('dcNavCountryFilter');
    if (!sel) return;
    const countries = [...new Set(window._dcDatabase.facilities.map(f => f.country).filter(Boolean))].sort();
    countries.forEach(c => {
      const opt = document.createElement('option');
      opt.value = c; opt.textContent = c;
      sel.appendChild(opt);
    });
  }

  // Render DC list
  function renderDCList() {
    const listEl = document.getElementById('dcList');
    if (!listEl || !window._dcDatabase.loaded) return;

    const searchTerm = (document.getElementById('dcNavSearch')?.value || '').toLowerCase().trim();
    const countryFilter = document.getElementById('dcNavCountryFilter')?.value || '';
    const typeFilter = document.getElementById('dcNavTypeFilter')?.value || '';
    const groupByRegion = document.getElementById('dcNavGroupByRegion')?.checked ?? true;

    let facilities = window._dcDatabase.facilities;

    // Filter by type
    if (typeFilter) {
      facilities = facilities.filter(f => (f.facility_type || 'datacenter') === typeFilter);
    }
    // Filter by search
    if (searchTerm) {
      facilities = facilities.filter(f =>
        (f.name || '').toLowerCase().includes(searchTerm) ||
        (f.org_name || '').toLowerCase().includes(searchTerm) ||
        (f.city || '').toLowerCase().includes(searchTerm) ||
        (f.cable_systems || []).some(cs => cs.toLowerCase().includes(searchTerm))
      );
    }
    if (countryFilter) {
      facilities = facilities.filter(f => f.country === countryFilter);
    }

    if (facilities.length === 0) {
      listEl.innerHTML = '<div class="muted" style="padding:12px; text-align:center;">No matching facilities.</div>';
      document.getElementById('dcNavCount').textContent = '0 facilities';
      return;
    }

    // Count label
    const dcCount = facilities.filter(f => (f.facility_type || 'datacenter') !== 'cable_station').length;
    const csCount = facilities.filter(f => (f.facility_type || 'datacenter') === 'cable_station').length;
    const countParts = [];
    if (dcCount > 0) countParts.push(`${dcCount} DC`);
    if (csCount > 0) countParts.push(`${csCount} CLS`);
    document.getElementById('dcNavCount').textContent = countParts.length ? countParts.join(' / ') : `${facilities.length} facilities`;

    let html = '';

    // Preserve which regions are currently expanded before re-render
    const expandedRegions = new Set();
    if (listEl) {
      listEl.querySelectorAll('.dc-region-items').forEach(div => {
        if (!div.classList.contains('collapsed')) {
          expandedRegions.add(div.id);
        }
      });
    }

    if (groupByRegion) {
      // Group by region_continent
      const groups = {};
      facilities.forEach(f => {
        const region = f.region_continent || 'Other';
        if (!groups[region]) groups[region] = [];
        groups[region].push(f);
      });
      const regionOrder = ['North America', 'Europe', 'Asia Pacific', 'South America', 'Africa', 'Middle East', 'Other'];
      regionOrder.forEach(region => {
        const facs = groups[region];
        if (!facs || facs.length === 0) return;
        const regionId = region.replace(/[^a-zA-Z0-9]/g, '_');
        const isExpanded = expandedRegions.has('dc_region_' + regionId);
        html += `<div class="dc-region-group" data-region="${escapeHtml(region)}">
          <div class="dc-region-header" data-dc-toggle-region="${regionId}">
            <span>${escapeHtml(region)} (${facs.length})</span>
            <span class="region-toggle">${isExpanded ? 'â–¼' : 'â–¶'}</span>
          </div>
          <div class="dc-region-items${isExpanded ? '' : ' collapsed'}" id="dc_region_${regionId}">
            ${facs.map(f => renderDCItem(f)).join('')}
          </div>
        </div>`;
      });
    } else {
      facilities.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
      html = facilities.map(f => renderDCItem(f)).join('');
    }

    const scrollTop = listEl.scrollTop;
    listEl.innerHTML = html;
    listEl.scrollTop = scrollTop;

    // Region toggle handlers
    listEl.querySelectorAll('.dc-region-header').forEach(header => {
      header.addEventListener('click', () => {
        const regionId = header.dataset.dcToggleRegion;
        const itemsDiv = document.getElementById('dc_region_' + regionId);
        const toggle = header.querySelector('.region-toggle');
        if (itemsDiv) {
          itemsDiv.classList.toggle('collapsed');
          toggle.textContent = itemsDiv.classList.contains('collapsed') ? 'â–¶' : 'â–¼';
        }
      });
    });
  }

  // Render single DC item
  function renderDCItem(fac) {
    const densityClass = getDCDensityClass(fac);
    const netCount = (fac.networks || []).length;
    const isSelected = window._dcSelectedId === fac.id;
    const isExpanded = window._dcExpandedId === fac.id;
    const facType = fac.facility_type || 'datacenter';
    const isCLS = facType === 'cable_station';
    const typeBadge = isCLS ? '<span style="font-size:8px;padding:1px 4px;border-radius:3px;background:#dbeafe;color:#1d4ed8;font-weight:600;white-space:nowrap;">CLS</span>'
      : '';
    const borderColor = isCLS ? '#93c5fd' : '#f9a8d4';
    const cableCount = (fac.cable_systems || []).length;
    const metaLabel = isCLS ? (cableCount > 0 ? `${cableCount}C` : '') : `${netCount}N`;

    return `<div class="dc-item ${isSelected ? 'selected' : ''}" data-dc-id="${fac.id}" draggable="true" style="border-left-color:${borderColor};">
      <span class="dc-density-badge ${densityClass}" title="Carriers: ${fac.carrier_count || 0}, IXs: ${fac.ix_count || 0}, Networks: ${netCount}"></span>
      <div style="min-width:0; flex:1;">
        <div class="dc-name">${typeBadge} ${escapeHtml(fac.name)}</div>
        <div class="dc-org">${escapeHtml(fac.org_name || '')} \u{2014} ${escapeHtml(fac.city || '')}, ${escapeHtml(fac.country || '')}</div>
      </div>
      <div style="display:flex; align-items:center; gap:3px;">
        ${metaLabel ? `<div class="dc-meta">${metaLabel}</div>` : ''}
        <button class="dc-expand-btn" data-dc-id="${fac.id}" title="Show details" style="background:none; border:1px solid ${borderColor}; border-radius:3px; width:20px; height:20px; cursor:pointer; font-size:11px; color:${isCLS ? '#2563eb' : '#ec4899'}; display:flex; align-items:center; justify-content:center;">${isExpanded ? '\u{2212}' : '+'}</button>
      </div>
    </div>${isExpanded ? renderDCDetailPanel(fac) : ''}`;
  }

  // Render expanded detail panel for a DC
  function renderDCDetailPanel(fac) {
    const nets = fac.networks || [];
    const topNets = nets.slice(0, 30);
    const hasMore = nets.length > 30;
    const facType = fac.facility_type || 'datacenter';
    const isCLS = facType === 'cable_station';
    const cables = fac.cable_systems || [];
    const typeLabel = isCLS ? 'Cable Station' : 'Datacenter';
    return `<div class="dc-detail-panel show">
      <div class="dc-detail-grid">
        <div class="dc-field"><div class="dc-field-label">Type</div><div class="dc-field-value" style="font-weight:600;color:${isCLS ? '#1d4ed8' : '#831843'};">${typeLabel}</div></div>
        <div class="dc-field full-width"><div class="dc-field-label">Address</div><div class="dc-field-value">${escapeHtml(fac.address1 || '')}${fac.address2 ? ', ' + escapeHtml(fac.address2) : ''}</div></div>
        <div class="dc-field"><div class="dc-field-label">City</div><div class="dc-field-value">${escapeHtml(fac.city || '')}</div></div>
        <div class="dc-field"><div class="dc-field-label">Country</div><div class="dc-field-value">${escapeHtml(fac.country || '')}${fac.state ? ' / ' + escapeHtml(fac.state) : ''}</div></div>
        <div class="dc-field"><div class="dc-field-label">Zipcode</div><div class="dc-field-value">${escapeHtml(fac.zipcode || '\u{2014}')}</div></div>
        <div class="dc-field"><div class="dc-field-label">Region</div><div class="dc-field-value">${escapeHtml(fac.region_continent || '\u{2014}')}</div></div>
        <div class="dc-field"><div class="dc-field-label">Latitude</div><div class="dc-field-value">${fac.latitude != null ? fac.latitude : '\u{2014}'}</div></div>
        <div class="dc-field"><div class="dc-field-label">Longitude</div><div class="dc-field-value">${fac.longitude != null ? fac.longitude : '\u{2014}'}</div></div>
        <div class="dc-field"><div class="dc-field-label">Networks</div><div class="dc-field-value">${nets.length}</div></div>
        <div class="dc-field"><div class="dc-field-label">Carriers</div><div class="dc-field-value">${fac.carrier_count || 0}</div></div>
        <div class="dc-field"><div class="dc-field-label">IXPs</div><div class="dc-field-value">${fac.ix_count || 0}</div></div>
        ${fac.website ? `<div class="dc-field full-width"><div class="dc-field-label">Website</div><div class="dc-field-value" style="font-size:10px;">${escapeHtml(fac.website)}</div></div>` : ''}
      </div>
      ${cables.length > 0 ? `<div class="dc-networks-list" style="border-top:1px solid #dbeafe; padding-top:4px; margin-top:4px;">
        <div style="font-size:9px; font-weight:600; color:#1d4ed8; margin-bottom:3px;">\u{1F4E1} Cable Systems (${cables.length}):</div>
        ${cables.map(c => `<span class="dc-net-tag" style="background:#dbeafe; border-color:#93c5fd; color:#1d4ed8;">${escapeHtml(c)}</span>`).join('')}
      </div>` : ''}
      ${nets.length > 0 ? `<div class="dc-networks-list">
        <div style="font-size:9px; font-weight:600; color:#92400e; margin-bottom:3px;">Networks (${nets.length}):</div>
        ${topNets.map(n => `<span class="dc-net-tag" title="${escapeHtml(n.type || '')} / ${escapeHtml(n.traffic || '')}">AS${n.asn} ${escapeHtml(n.name)}</span>`).join('')}
        ${hasMore ? `<span class="dc-net-tag" style="background:#fef3c7; border-color:#fcd34d; color:#92400e;">+${nets.length - 30} more</span>` : ''}
      </div>` : ''}
    </div>`;
  }

  // DC Navigator event delegation
  document.getElementById('dcList')?.addEventListener('click', (e) => {
    // Expand/collapse detail
    const expandBtn = e.target.closest('.dc-expand-btn');
    if (expandBtn) {
      e.stopPropagation();
      const dcId = parseInt(expandBtn.dataset.dcId);
      window._dcExpandedId = (window._dcExpandedId === dcId) ? null : dcId;
      renderDCList();
      return;
    }
    // Select item
    const item = e.target.closest('.dc-item');
    if (item) {
      const dcId = parseInt(item.dataset.dcId);
      window._dcSelectedId = dcId;
      renderDCList();
    }
  });

  // DC search and filter
  document.getElementById('dcNavSearch')?.addEventListener('input', () => renderDCList());
  document.getElementById('dcNavTypeFilter')?.addEventListener('change', () => renderDCList());
  document.getElementById('dcNavCountryFilter')?.addEventListener('change', () => renderDCList());
  document.getElementById('dcNavGroupByRegion')?.addEventListener('change', () => renderDCList());

  // DC Navigator toggle button
  document.getElementById('btnToggleDCNavigator')?.addEventListener('click', () => {
    const nav = document.getElementById('dcNavigator');
    if (!nav) return;
    if (nav.style.display === 'none' || !nav.style.display) {
      nav.style.display = 'flex';
      document.getElementById('btnToggleDCNavigator').classList.add('active');
      if (!window._dcDatabase.loaded) loadDCDatabase();
    } else {
      nav.style.display = 'none';
      document.getElementById('btnToggleDCNavigator').classList.remove('active');
    }
  });

  // DC Navigator minimize/close
  document.getElementById('btnMinimizeDCNav')?.addEventListener('click', () => {
    const nav = document.getElementById('dcNavigator');
    if (!nav) return;
    nav.classList.toggle('minimized');
    document.getElementById('btnMinimizeDCNav').textContent = nav.classList.contains('minimized') ? '+' : 'âˆ’';
  });
  document.getElementById('btnCloseDCNav')?.addEventListener('click', () => {
    document.getElementById('dcNavigator').style.display = 'none';
    document.getElementById('btnToggleDCNavigator')?.classList.remove('active');
  });

  // Make DC Navigator draggable
  (function() {
    const nav = document.getElementById('dcNavigator');
    const header = document.getElementById('dcNavigatorHeader');
    if (!nav || !header) return;
    let isDragging = false, offsetX, offsetY;
    header.addEventListener('mousedown', (e) => {
      if (e.target.closest('#dcNavigatorControls')) return;
      isDragging = true;
      offsetX = e.clientX - nav.offsetLeft;
      offsetY = e.clientY - nav.offsetTop;
      nav.style.cursor = 'move';
      e.preventDefault();
    });
    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      nav.style.left = (e.clientX - offsetX) + 'px';
      nav.style.top = (e.clientY - offsetY) + 'px';
      nav.style.right = 'auto';
    });
    document.addEventListener('mouseup', () => {
      if (isDragging) { isDragging = false; nav.style.cursor = ''; }
    });
  })();

  console.log('[NexiMap] Main script fully loaded');
})();
</script>
</body>
</html>
